{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>iris<ul> <li>calibration<ul> <li>calibration_generator</li> <li>test_calibrator_wavelength</li> </ul> </li> <li>controllers<ul> <li>camera_controller_dummy</li> <li>camera_controller_thorlabs_color</li> <li>camera_controller_thorlabs_mono</li> <li>camera_controller_webcam</li> <li>class_camera_controller</li> <li>class_spectrometer_controller</li> <li>class_xy_stage_controller</li> <li>class_z_stage_controller</li> <li>mcm301_wrapper</li> <li>oceandirect_wrapper</li> <li>raman_spectrometer_controller_Andor_dll</li> <li>raman_spectrometer_controller_Andor_pylablib</li> <li>raman_spectrometer_controller_PI_dll</li> <li>raman_spectrometer_controller_PI_pylablib</li> <li>raman_spectrometer_controller_PI_trial</li> <li>raman_spectrometer_controller_QEPro</li> <li>raman_spectrometer_controller_WasatchEnlighten</li> <li>raman_spectrometer_controller_dummy</li> <li>xy_stage_controller_PI</li> <li>xy_stage_controller_PI_dll</li> <li>xy_stage_controller_dummy</li> <li>xy_stage_controller_m30xy</li> <li>xy_stage_controller_zaber</li> <li>z_stage_controller_dummy</li> <li>z_stage_controller_mcm301</li> <li>z_stage_controller_pfm450</li> <li>z_stage_controller_z825b</li> </ul> </li> <li>data<ul> <li>calibration_objective</li> <li>measurement_Raman</li> <li>measurement_RamanMap</li> <li>measurement_coordinates</li> <li>measurement_image</li> </ul> </li> <li>gui<ul> <li>dataHub_MeaImg</li> <li>dataHub_MeaRMap</li> <li>hilvl_Brightfield</li> <li>hilvl_Raman</li> <li>hilvl_coorGen</li> <li>image_calibration<ul> <li>Canvas_ROIdefinition</li> <li>objective_calibration</li> <li>plotter_heatmap_overlay</li> </ul> </li> <li>motion_video</li> <li>raman</li> <li>shortcut_handler</li> <li>submodules<ul> <li>heatmap_plotter_MeaRMap</li> <li>image_tiling</li> <li>meaCoor_generator<ul> <li>line_zScan</li> <li>points_image</li> <li>rectangle_aroundCentre</li> <li>rectangle_endToEnd</li> <li>rectangle_image</li> <li>rectangle_video</li> <li>singlePoint_zScan</li> <li>ssfrm_tilemthd1_rect_around</li> </ul> </li> <li>meaCoor_modifier<ul> <li>every_z</li> <li>gridify</li> <li>topology_visualiser</li> <li>translateXYZ</li> <li>zInterpolate</li> </ul> </li> <li>peakfinder_plotter_MeaRaman</li> </ul> </li> <li>timestamp_coorshift</li> </ul> </li> <li>main_analyser</li> <li>multiprocessing<ul> <li>basemanager</li> <li>dataStreamer_Raman</li> <li>dataStreamer_StageCam</li> </ul> </li> <li>resources<ul> <li>coordinate_generators<ul> <li>convert_2Dto3D_ui</li> <li>point_image_ui</li> <li>point_zScanLinear_ui</li> <li>rect_aroundcentre_ui</li> <li>rect_image_ui</li> <li>rect_startend_ui</li> <li>rect_video_ui</li> </ul> </li> <li>coordinate_modifiers<ul> <li>every_z_ui</li> <li>gridify_setup_finetuning_ui</li> <li>gridify_setup_naming_ui</li> <li>gridify_setup_ui</li> <li>topology_visuliser_ui</li> <li>translator_xyz_ui</li> <li>zInterpolate_ui</li> </ul> </li> <li>dataHubPlus_Raman_ui</li> <li>dataHub_Raman_ui</li> <li>dataHub_coor_ui</li> <li>dataHub_image_ui</li> <li>heatmap_plotter_overlay_ui</li> <li>heatmap_plotter_ui</li> <li>hilvl_Raman_ui</li> <li>hilvl_brightfield_ui</li> <li>hilvl_coorGen_coorMod_ui</li> <li>hilvl_coorGen_ui</li> <li>main_analyser_ui</li> <li>main_controller_ui</li> <li>motion_video<ul> <li>brightfieldcontrol_ui</li> <li>stagecontrol_ui</li> </ul> </li> <li>objective_calibration_controls_ui</li> <li>objective_calibration_main_ui</li> <li>objectives_ui</li> <li>raman_ui</li> <li>spectra_peak_finder_ui</li> <li>spectrometer_calibration_ui</li> <li>tiling_method_control_ui</li> <li>tiling_method_ui</li> </ul> </li> <li>utils<ul> <li>general</li> <li>gridify</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/iris/main_analyser/","title":"main_analyser","text":""},{"location":"reference/iris/calibration/calibration_generator/","title":"calibration_generator","text":"<p>This class generates the calibration for the spectrometer to map pixels to wavelengths, and the intensity calibration of a Raman spectrometer</p>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.MainWindow_SpectrometerCalibrationGenerator","title":"<code>MainWindow_SpectrometerCalibrationGenerator</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>Main window for the spectrometer calibration generator</p> Source code in <code>iris/calibration/calibration_generator.py</code> <pre><code>class MainWindow_SpectrometerCalibrationGenerator(qw.QMainWindow):\n    \"\"\"\n    Main window for the spectrometer calibration generator\n    \"\"\"\n    def __init__(self, pipe_update: Connection):\n        super().__init__()\n        self.setWindowTitle('Spectrometer Calibration Generator')\n        self._wdg = Wdg_SpectrometerCalibrationGenerator(self, pipe_update)\n        self.setCentralWidget(self._wdg)\n\n    def get_WdgCalibrator(self) -&gt; Wdg_SpectrometerCalibrationGenerator:\n        \"\"\"\n        Gets the calibrator widget\n\n        Returns:\n            Wdg_SpectrometerCalibrationGenerator: The calibrator widget\n        \"\"\"\n        return self._wdg\n\n    @Slot()\n    def closeEvent(self, event):\n        \"\"\"\n        Overrides the close event to hide the window instead of closing it\n        \"\"\"\n        self.hide()\n        event.ignore()\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.MainWindow_SpectrometerCalibrationGenerator.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Overrides the close event to hide the window instead of closing it</p> Source code in <code>iris/calibration/calibration_generator.py</code> <pre><code>@Slot()\ndef closeEvent(self, event):\n    \"\"\"\n    Overrides the close event to hide the window instead of closing it\n    \"\"\"\n    self.hide()\n    event.ignore()\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.MainWindow_SpectrometerCalibrationGenerator.get_WdgCalibrator","title":"<code>get_WdgCalibrator()</code>","text":"<p>Gets the calibrator widget</p> <p>Returns:</p> Name Type Description <code>Wdg_SpectrometerCalibrationGenerator</code> <code>Wdg_SpectrometerCalibrationGenerator</code> <p>The calibrator widget</p> Source code in <code>iris/calibration/calibration_generator.py</code> <pre><code>def get_WdgCalibrator(self) -&gt; Wdg_SpectrometerCalibrationGenerator:\n    \"\"\"\n    Gets the calibrator widget\n\n    Returns:\n        Wdg_SpectrometerCalibrationGenerator: The calibrator widget\n    \"\"\"\n    return self._wdg\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.SpectrometerCalibrator","title":"<code>SpectrometerCalibrator</code>","text":"<p>The backend for the wavelength calibration to be used in the RamanMeasurementHub</p> Source code in <code>iris/calibration/calibration_generator.py</code> <pre><code>class SpectrometerCalibrator():\n    \"\"\"\n    The backend for the wavelength calibration to be used in the RamanMeasurementHub\n    \"\"\"\n    def __init__(self, pipe_update: Connection, pipe_measurement: Connection):\n        self._cal_params = CalibrationParams()\n\n        # The table to map the measured wavelengths to the reference wavelengths\n        self._transTable_wv = {}\n        self._transTable_int = {}\n\n        # Pipe to receive the path to update the calibration parameters\n        self._pipe_update = pipe_update\n        self._pipe_mea = pipe_measurement\n        self._flg_isrunning = mp.Event()\n        self._thd_update = threading.Thread(target=self._auto_update)\n        self._thd_update.start()\n        self._thd_calibrate = threading.Thread(target=self._auto_calibrate)\n        self._thd_calibrate.start()\n\n    def terminate(self):\n        \"\"\"\n        Terminates the backend\n        \"\"\"\n        self._flg_isrunning.clear()\n        self._thd_update.join()\n        self._pipe_update.close()\n\n    def calibrate_measurement(self, measurement:pd.DataFrame):\n        \"\"\"\n        Calibrates the spectrometer measurement based on the calibration parameters\n\n        Args:\n            measurement (pd.DataFrame): The measurement data to be calibrated\n        \"\"\"\n        list_wavelength_raw = measurement[DataAnalysisConfigEnum.WAVELENGTH_LABEL.value].values\n        list_intensity_raw = measurement[DataAnalysisConfigEnum.INTENSITY_LABEL.value].values\n        list_wavelength_cal = [self.get_wavelength(wavelength_raw)\\\n            for wavelength_raw in list_wavelength_raw]\n        list_intensity_cal = [self.get_intensity(wavelength_raw,intensity_raw)\\\n            for wavelength_raw,intensity_raw in zip(list_wavelength_raw,list_intensity_raw)]\n\n        # Reconstruct the dataframe with the calibrated values\n        cal_spectrum = measurement.copy()\n        cal_spectrum[DataAnalysisConfigEnum.WAVELENGTH_LABEL.value] = list_wavelength_cal\n        cal_spectrum[DataAnalysisConfigEnum.INTENSITY_LABEL.value] = list_intensity_cal\n\n        return cal_spectrum\n\n    def _auto_calibrate(self):\n        \"\"\"\n        Automatically calibrates the spectrometer measurement\n        \"\"\"\n        self._flg_isrunning.set()\n        while self._flg_isrunning.is_set():\n            if self._pipe_mea.poll(timeout=1):\n                measurement = self._pipe_mea.recv()\n                ret = None\n                try: ret = self.calibrate_measurement(measurement)\n                except Exception as e: print('ERROR SpectrometerCalibrator._auto_calibrate: ',e)\n                finally: self._pipe_mea.send(ret)\n\n    def _auto_update(self):\n        \"\"\"\n        Automatically updates the calibration parameters\n        \"\"\"\n        self._flg_isrunning.set()\n        while self._flg_isrunning.is_set():\n            if self._pipe_update.poll(timeout=1):\n                recv = self._pipe_update.recv()\n                self._cal_params = recv\n                self._transTable_wv.clear()\n                self._transTable_int.clear()\n            time.sleep(0.5)\n\n    def get_wavelength(self,pixel_idx:float) -&gt; float:\n        \"\"\"\n        Gets the wavelength based on the pixel index\n\n        Args:\n            pixel_idx (float): The pixel index\n\n        Returns:\n            float: The wavelength\n        \"\"\"\n        assert isinstance(pixel_idx,(int,float)), 'ERROR SpectrometerCalibrator.get_wavelength: The pixel index must be a number'\n        pixel_req = '{:.3f}'.format(pixel_idx)\n        if pixel_req in self._transTable_wv.keys():\n            wavelength_cal = self._transTable_wv[pixel_req]\n        else:\n            wavelength_cal = np.polyval(self._cal_params['wavelen_poly_coeffs'],pixel_idx)\n            self._transTable_wv[pixel_req] = wavelength_cal\n        return wavelength_cal\n\n    def get_intensity(self,pixel_idx:float,intensity:float) -&gt; float:\n        \"\"\"\n        Gets the intensity based on the pixel index and the measured intensity\n\n        Args:\n            pixel_idx (float): The pixel index\n            intensity (float): The measured intensity\n\n        Returns:\n            float: The calibrated intensity\n        \"\"\"\n        assert isinstance(pixel_idx,(int,float)), 'ERROR SpectrometerCalibrator.get_intensity: The pixel index must be a number'\n        assert isinstance(intensity,(int,float)), 'ERROR SpectrometerCalibrator.get_intensity: The intensity must be a number'\n        pixel_req = '{:.3f}'.format(pixel_idx)\n\n        if pixel_req in self._transTable_int.keys():\n            cal_ratio = self._transTable_int[pixel_req]\n        else:\n            cal_ratio = np.polyval(self._cal_params['intensity_poly_coeffs'],pixel_idx)\n            self._transTable_int[pixel_req] = cal_ratio\n\n        intensity_cal = cal_ratio*intensity\n        return intensity_cal\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.SpectrometerCalibrator.calibrate_measurement","title":"<code>calibrate_measurement(measurement)</code>","text":"<p>Calibrates the spectrometer measurement based on the calibration parameters</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>DataFrame</code> <p>The measurement data to be calibrated</p> required Source code in <code>iris/calibration/calibration_generator.py</code> <pre><code>def calibrate_measurement(self, measurement:pd.DataFrame):\n    \"\"\"\n    Calibrates the spectrometer measurement based on the calibration parameters\n\n    Args:\n        measurement (pd.DataFrame): The measurement data to be calibrated\n    \"\"\"\n    list_wavelength_raw = measurement[DataAnalysisConfigEnum.WAVELENGTH_LABEL.value].values\n    list_intensity_raw = measurement[DataAnalysisConfigEnum.INTENSITY_LABEL.value].values\n    list_wavelength_cal = [self.get_wavelength(wavelength_raw)\\\n        for wavelength_raw in list_wavelength_raw]\n    list_intensity_cal = [self.get_intensity(wavelength_raw,intensity_raw)\\\n        for wavelength_raw,intensity_raw in zip(list_wavelength_raw,list_intensity_raw)]\n\n    # Reconstruct the dataframe with the calibrated values\n    cal_spectrum = measurement.copy()\n    cal_spectrum[DataAnalysisConfigEnum.WAVELENGTH_LABEL.value] = list_wavelength_cal\n    cal_spectrum[DataAnalysisConfigEnum.INTENSITY_LABEL.value] = list_intensity_cal\n\n    return cal_spectrum\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.SpectrometerCalibrator.get_intensity","title":"<code>get_intensity(pixel_idx, intensity)</code>","text":"<p>Gets the intensity based on the pixel index and the measured intensity</p> <p>Parameters:</p> Name Type Description Default <code>pixel_idx</code> <code>float</code> <p>The pixel index</p> required <code>intensity</code> <code>float</code> <p>The measured intensity</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calibrated intensity</p> Source code in <code>iris/calibration/calibration_generator.py</code> <pre><code>def get_intensity(self,pixel_idx:float,intensity:float) -&gt; float:\n    \"\"\"\n    Gets the intensity based on the pixel index and the measured intensity\n\n    Args:\n        pixel_idx (float): The pixel index\n        intensity (float): The measured intensity\n\n    Returns:\n        float: The calibrated intensity\n    \"\"\"\n    assert isinstance(pixel_idx,(int,float)), 'ERROR SpectrometerCalibrator.get_intensity: The pixel index must be a number'\n    assert isinstance(intensity,(int,float)), 'ERROR SpectrometerCalibrator.get_intensity: The intensity must be a number'\n    pixel_req = '{:.3f}'.format(pixel_idx)\n\n    if pixel_req in self._transTable_int.keys():\n        cal_ratio = self._transTable_int[pixel_req]\n    else:\n        cal_ratio = np.polyval(self._cal_params['intensity_poly_coeffs'],pixel_idx)\n        self._transTable_int[pixel_req] = cal_ratio\n\n    intensity_cal = cal_ratio*intensity\n    return intensity_cal\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.SpectrometerCalibrator.get_wavelength","title":"<code>get_wavelength(pixel_idx)</code>","text":"<p>Gets the wavelength based on the pixel index</p> <p>Parameters:</p> Name Type Description Default <code>pixel_idx</code> <code>float</code> <p>The pixel index</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The wavelength</p> Source code in <code>iris/calibration/calibration_generator.py</code> <pre><code>def get_wavelength(self,pixel_idx:float) -&gt; float:\n    \"\"\"\n    Gets the wavelength based on the pixel index\n\n    Args:\n        pixel_idx (float): The pixel index\n\n    Returns:\n        float: The wavelength\n    \"\"\"\n    assert isinstance(pixel_idx,(int,float)), 'ERROR SpectrometerCalibrator.get_wavelength: The pixel index must be a number'\n    pixel_req = '{:.3f}'.format(pixel_idx)\n    if pixel_req in self._transTable_wv.keys():\n        wavelength_cal = self._transTable_wv[pixel_req]\n    else:\n        wavelength_cal = np.polyval(self._cal_params['wavelen_poly_coeffs'],pixel_idx)\n        self._transTable_wv[pixel_req] = wavelength_cal\n    return wavelength_cal\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.SpectrometerCalibrator.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the backend</p> Source code in <code>iris/calibration/calibration_generator.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminates the backend\n    \"\"\"\n    self._flg_isrunning.clear()\n    self._thd_update.join()\n    self._pipe_update.close()\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.Wdg_SpectrometerCalibrationGenerator","title":"<code>Wdg_SpectrometerCalibrationGenerator</code>","text":"<p>               Bases: <code>Ui_spectrometerCalibrator</code>, <code>QWidget</code></p> <p>GUI for the spectrometer calibration generator</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Tk</code> <p>The root window</p> required <code>pipe_update</code> <code>Connection</code> <p>The pipe to update the calibration parameters in the backend</p> required <code>dict_cal</code> <code>DictCalibration</code> <p>The calibration parameters dictionary</p> required Source code in <code>iris/calibration/calibration_generator.py</code> <pre><code>class Wdg_SpectrometerCalibrationGenerator(Ui_spectrometerCalibrator, qw.QWidget):\n    \"\"\"\n    GUI for the spectrometer calibration generator\n\n    Args:\n        master (tk.Tk): The root window\n        pipe_update (Connection): The pipe to update the calibration parameters in the backend\n        dict_cal (DictCalibration): The calibration parameters dictionary\n    \"\"\"\n    def __init__(self, parent:qw.QWidget, pipe_update: Connection):\n        super().__init__(parent)\n        self.setupUi(self)\n\n    # &gt;&gt; General parameters &lt;&lt;\n        figsize_in = (3.5,3.5)\n\n    # &gt;&gt; Backend functions &lt;&lt;\n        # Pipe to update the calibration parameters in the backend\n        self._pipe_update = pipe_update\n\n    # &gt;&gt; Global calibration parameters and widgets &lt;&lt;\n        # Frontend params to temporarily store the calibration parameters\n        self._cal_params = CalibrationParams()\n\n        # Buttons to load, save, and calculate the calibration params\n        self.btnLoad.clicked.connect(self._load_calibration)\n        self.btnSave.clicked.connect(self._save_calibration)\n\n    # &gt;&gt; Wavelength calibration parameters and widgets &lt;&lt;\n        # Canvas to show the wavelength calibration transfer function\n        self._fig_wv, self._ax_wv = plt.subplots(1,1,figsize=figsize_in)\n        self._canvas_wv = FigureCanvas(figure=self._fig_wv)\n        self.lytPixelmapCanvas.addWidget(self._canvas_wv)\n        self._canvas_wv.draw_idle()\n\n        # Treeview to show the measured and reference wavelengths\n        self._tree = self.treePixelmap\n        self._tree.setColumnCount(2)\n        self._tree.setHeaderLabels(['Measured peak loc [pixel OR nm]','Reference peak loc [nm]'])\n\n        # Button to load the measured and reference wavelengths\n        self.btnLoadPixelmap.clicked.connect(self._load_wavelength)\n\n    # &gt;&gt; Intensity calibration parameters and widgets&lt;&lt;\n        # Canvas to show the intensity calibration transfer function\n        figsize_in_int = (figsize_in[0]*2,figsize_in[1])\n        self._fig_int, axes = plt.subplots(1,2,figsize=figsize_in_int)\n        self._ax_int_raw, self._ax_int_cal = axes\n        self._canvas_int = FigureCanvas(figure=self._fig_int)\n        self.lytIntensityCanvas.addWidget(self._canvas_int)\n        self._canvas_int.draw_idle()\n\n        # Button to load the measured and reference intensities\n        self.btnLoadIntensity.clicked.connect(self._load_intensity)\n\n    # &gt;&gt; Auto-load the calibration file from the last session &lt;&lt;\n        cal_filepath = LibraryConfigEnum.SPECTROMETER_CALIBRATION_PATH.value\n        if os.path.isfile(cal_filepath) and cal_filepath.endswith('.json'):\n            self._load_calibration(cal_filepath)\n\n    def _load_calibration(self,loadpath:str|None=None) -&gt; None:\n        \"\"\"\n        Loads the calibration file\n\n        Args:\n            loadpath (str|None): The path to the calibration file. If None, a file dialog will be opened\n\n        Returns:\n            bool: True if the calibration file is loaded successfully, False otherwise\n        \"\"\"\n        if loadpath is None or not os.path.exists(loadpath) or not os.path.isfile(loadpath) or not loadpath.endswith('.json'):\n            init_file = LibraryConfigEnum.SPECTROMETER_CALIBRATION_PATH.value\n            init_dir = os.path.dirname(init_file) if os.path.exists(init_file) else ''\n            loadpath = qw.QFileDialog.getOpenFileName(\n                self,\n                'Load calibration file',\n                init_dir,\n                'JSON files (*.json)',\n            )[0]\n        if loadpath == '': return\n\n        with open(loadpath,'r') as f: dict_params = json.load(f)\n        try:\n            for key in dict_params:\n                val = dict_params[key]\n                if isinstance(val,list): self._cal_params[key] = [float(v) for v in val]\n                elif isinstance(val,tuple): self._cal_params[key] = tuple([float(v) for v in val])\n                else: self._cal_params[key] = float(val)\n        except Exception as e: print('ERROR _load_calibration file read: ',e); return\n\n        try:self._analyse_intensity_calibration_params(calculate_transfunc=False)\n        except Exception as e: qw.QMessageBox.warning(self,'Load calibration error','Error in loading intensity calibration parameters:\\n{}'.format(e))\n\n        try:self._analyse_wavelength_calibration_params(calculate_transfunc=False)\n        except Exception as e: qw.QMessageBox.warning(self,'Load calibration error','Error in loading wavelength calibration parameters:\\n{}'.format(e))\n\n        # Send the loadpath to the backend\n        self._pipe_update.send(self._cal_params)\n\n    def _save_calibration(self):\n        \"\"\"\n        Saves the calibration file as a json file\n        \"\"\"\n        filepath = qw.QFileDialog.getSaveFileName(\n            self,\n            'Save calibration file',\n            LibraryConfigEnum.SPECTROMETER_CALIBRATION_DIR_DEFAULT.value,\n            'JSON files (*.json)',\n        )[0]\n        if filepath == '': return\n        with open(filepath,'w') as f: json.dump(self._cal_params,f)\n\n    def _calculate_transferFunc_int_cubic(self,list_pixel_idx:list[float],list_int_mea:list[float],list_int_ref:list[float])\\\n        -&gt; tuple[tuple[float,float,float,float],list[tuple[float,float]]]:\n        \"\"\"\n        Generates the transfer function from the measured and reference/expected values\n\n        Args:\n            list_pixel_idx (list[float]): List of the pixel indices\n            list_int_mea (list[float]): List of the measured intensities\n            list_int_ref (list[float]): List of the reference intensities\n\n        Returns:\n            tuple[tuple[float,float,float,float],list[tuple[float,float]]]: The coefficients of\n                the transfer function (a,b,c,d) for the cubic function of a*x**3 + b*x**2 + c*x + d\n                and the list of coordinates of the intensity ratio [ref/mea]\n        \"\"\"\n        def cubic(x,a,b,c,d): return a*x**3 + b*x**2 + c*x + d\n\n        # Calculate the intensity ratio (reference/measured)\n        list_int_ratio = [int_ref/int_mea for int_mea,int_ref in zip(list_int_mea,list_int_ref)]\n\n        list_ratio_coors = list(zip(list_pixel_idx,list_int_ratio))\n\n        # Fit the transfer function\n        popt,_ = curve_fit(cubic,xdata=list_pixel_idx,ydata=list_int_ratio)\n        popt = tuple(popt) # Convert the array to tuple for json serialisation during saving\n        return popt, list_ratio_coors\n\n    def _calculate_pxlMappingFunc_wv_cubic(self,list_mea:list[float],list_ref:list[float])\\\n        -&gt; tuple[float,float,float,float]:\n        \"\"\"\n        Generates the pixel mapping function from the measured and reference/expected values\n\n        Args:\n            list_mea (list[float]): List of the measured values\n            list_ref (list[float]): List of the reference/expected values\n\n        Returns:\n            tuple[float,float,float,float]: The coefficients of the mapping function (a,b,c,d) for the cubic function of a*x**3 + b*x**2 + c*x + d\n        \"\"\"\n        def cubic(x,a,b,c,d): return a*x**3 + b*x**2 + c*x + d\n\n        # Fit the transfer function\n        popt,_ = curve_fit(cubic,xdata=list_mea,ydata=list_ref)\n        popt = tuple(popt) # Convert the array to tuple for json serialisation during saving\n        return popt\n\n    def _load_intensity(self):\n        \"\"\"\n        Loads the measured and reference intensities\n        \"\"\"\n        qw.QMessageBox.information(\n            self,\n            'Load intensity calibration points','Please select the csv file containing the measured'\n            ' and reference intensities\\nThe csv file should have 3 columns: Pixel index (or raw wavelength),'\n            ' Measured intensity [a.u.], Reference intensity [a.u.].\\nThe first line (header) will be skipped')\n\n        filepath = qw.QFileDialog.getOpenFileName(\n            self,\n            'Load intensity calibration points',\n            '',\n            'CSV files (*.csv)',\n        )[0]\n        if filepath == '': return\n\n        df = pd.read_csv(filepath,header=None,skiprows=1)\n\n        self._cal_params['intensity_list_pixel_idx'] = df.iloc[:,0].tolist()\n        self._cal_params['intensity_list_measured'] = df.iloc[:,1].tolist()\n        self._cal_params['intensity_list_reference'] = df.iloc[:,2].tolist()\n\n        # Calculate the transfer function and plot it\n        self._analyse_intensity_calibration_params()\n        self._pipe_update.send(self._cal_params)\n\n    def _analyse_intensity_calibration_params(self,calculate_transfunc:bool=True):\n        \"\"\"\n        Analyse the intensity calibration based on the values stored in the\n        calibration parameters dictionary. Also assigns the calculatedtransfer function\n        coefficients into the dictionary if requested.\n\n        Args:\n            calculate_transfunc (bool): If True, the transfer function will be calculated and stored\n        \"\"\"\n        list_pixel_idx = self._cal_params['intensity_list_pixel_idx']\n        list_int_mea = self._cal_params['intensity_list_measured']\n        list_int_ref = self._cal_params['intensity_list_reference']\n        transfer_func_coeff, list_ratio_coors = self._calculate_transferFunc_int_cubic(list_pixel_idx,list_int_mea,list_int_ref)\n\n        # Store the transfer function coefficients\n        if calculate_transfunc:self._cal_params['intensity_poly_coeffs'] = transfer_func_coeff\n\n        # Plot the transfer function\n        self._plot_int_transfer_func(self._cal_params['intensity_list_pixel_idx'],self._cal_params['intensity_list_measured'],\n                                    self._cal_params['intensity_list_reference'],list_ratio_coors)\n\n    def _plot_int_transfer_func(self,list_pixel_idx:list[float],list_int_mea:list[float],list_int_ref:list[float],\n                                list_ratio_coors:list[tuple[float,float]]):\n        \"\"\"\n        Plots the raw values and the transfer function for the intensity calibration based on given values\n\n        Args:\n            list_pixel_idx (list[float]): List of the pixel indices\n            list_int_mea (list[float]): List of the measured intensities\n            list_int_ref (list[float]): List of the reference intensities\n            list_ratio_coors (list[tuple[float,float]]): List of the coordinates of the intensity ratio [ref/mea]\n        \"\"\"\n    # &gt; Raw values &lt;\n        # Generate the plot for the raw values\n        fig,ax = self._fig_int, self._ax_int_raw\n        ax.cla()\n        ax.scatter(list_pixel_idx,list_int_mea,c='r',label='Measured intensity',marker='x',s=1)\n        ax.scatter(list_pixel_idx,list_int_ref,c='b',label='Reference intensity',marker='x',s=1)\n        ax.set_xlabel('Pixel index')\n        ax.set_ylabel('Intensity [a.u.]')\n        ax.set_title('Intensity calibration')\n        ax.legend()\n\n    # &gt; Transfer function &lt;\n        # Grab the transfer function\n        transfer_func_coeff = self._cal_params['intensity_poly_coeffs']\n\n        # Generate the points for the plot\n        x_min = min(list_pixel_idx)\n        x_max = max(list_pixel_idx)\n        x = np.linspace(x_min,x_max,100)\n        y = np.polyval(transfer_func_coeff,x)\n\n        x2 = [coor[0] for coor in list_ratio_coors]\n        y2 = [coor[1] for coor in list_ratio_coors]\n        y2_min = min(y2)\n        y2_max = max(y2)\n        if y2_min &gt; 0 and y2_max &gt; 0: y2_min = 0\n        if y2_min &lt; 0 and y2_max &lt; 0: y2_max = 0\n\n        # Generate the plot\n        fig,ax = self._fig_int, self._ax_int_cal\n        ax:Axes\n        ax.cla()\n        ax.plot(x,y,c='r',label='Transfer function')\n        ax.scatter(x2,y2,c='b',label='Intensity ratio [ref/mea]',marker='x',s=1)\n        ax.set_ylim(y2_min-abs(y2_min)*0.1,y2_max+abs(y2_max)*0.1)\n        ax.set_xlabel('Pixel index [pixel] OR Wavelength [nm]')\n        ax.set_ylabel('Intensity [a.u.]')\n        ax.set_title('Intensity calibration transfer function')\n        ax.legend()\n\n        # Show the plot and redraw the canvas\n        self._canvas_int.draw()\n\n    def _load_wavelength(self):\n        \"\"\"\n        Loads the measured and reference wavelengths\n        \"\"\"\n        qw.QMessageBox.information(\n            self,\n            'Load wavelength calibration points','Please select the csv file containing the measured'\n            ' and reference wavelengths\\nThe csv file should have 2 columns: Measured peak loc [pixel OR nm],'\n            ' Reference peak loc [nm].\\nThe first line (header) will be skipped')\n\n        filepath = qw.QFileDialog.getOpenFileName(\n            self,\n            'Load wavelength calibration points',\n            '',\n            'CSV files (*.csv)',\n        )[0]\n        if filepath == '': return\n\n        df = pd.read_csv(filepath,header=None,skiprows=1)\n\n        self._cal_params['wavelen_list_measured'] = df.iloc[:,0].tolist()\n        self._cal_params['wavelen_list_reference'] = df.iloc[:,1].tolist()\n\n        # Calculate the transfer function\n        self._analyse_wavelength_calibration_params()\n        self._pipe_update.send(self._cal_params)\n\n    def _analyse_wavelength_calibration_params(self,calculate_transfunc:bool=True):\n        \"\"\"\n        Analyse the wavelength calibration based on the values stored in the\n        calibration parameters dictionary. Also assigns the calculated transfer function\n        coefficients into the dictionary.\n\n        Args:\n            calculate_transfunc (bool): If True, the transfer function will be calculated\n        \"\"\"\n        if calculate_transfunc:\n            list_peakRS_mea = self._cal_params['wavelen_list_measured']\n            list_peakRS_ref = self._cal_params['wavelen_list_reference']\n            transfer_func_coeff = self._calculate_pxlMappingFunc_wv_cubic(list_peakRS_mea,list_peakRS_ref)\n            self._cal_params['wavelen_poly_coeffs'] = transfer_func_coeff\n\n        # Update the treeview\n        self._update_treeview_wv()\n\n        # Plot the transfer function\n        self._plot_wv_pxlMapping_func(self._cal_params['wavelen_list_measured'],self._cal_params['wavelen_list_reference'])\n\n    def _plot_wv_pxlMapping_func(self,list_peakRS_mea:list[float],list_peakRS_ref:list[float]):\n        \"\"\"\n        Plots the pixel mapping function for the wavelength calibration\n\n        Args:\n            list_peakRS_mea (list[float]): List of the Raman shift peaks of the sample representative\n            list_peakRS_ref (list[float]): List of the Raman shift peaks of the reference\n        \"\"\"\n    # &gt; Grab the transfer function &lt;\n        transfer_func_coeff = self._cal_params['wavelen_poly_coeffs']\n\n        # Generate the x and y values from the transfer function\n        x_min = min(list_peakRS_mea)\n        x_max = max(list_peakRS_mea)\n        x = np.linspace(x_min,x_max,100)\n        y = np.polyval(transfer_func_coeff,x)\n\n        # Generate the plot\n        fig,ax = self._fig_wv, self._ax_wv\n        ax.cla()\n        ax.plot(x,y,c='b',label='Pixel mapping func')\n        ax.scatter(list_peakRS_mea,list_peakRS_ref,c='r',label='Peaks')\n        ax.set_xlabel('Measurement Raman peaks [nm OR pixel]')\n        ax.set_ylabel('Reference Raman peaks [nm]')\n        ax.set_title('Spectrometer pixel mapping')\n        ax.legend()\n\n        # Add a label to each scatter points\n        for i,peakRS in enumerate(list_peakRS_mea):\n            ax.annotate(str(peakRS),(list_peakRS_mea[i],list_peakRS_ref[i]))\n\n        # Show the plot and redraw the canvas\n        self._canvas_wv.draw()\n\n    def _update_treeview_wv(self):\n        \"\"\"\n        Updates the treeview for the wavelength calibration\n        \"\"\"\n        self._tree.clear()\n        for (mea,ref) in zip(self._cal_params['wavelen_list_measured'],self._cal_params['wavelen_list_reference']):\n            item = qw.QTreeWidgetItem()\n            item.setText(0,str(mea))\n            item.setText(1,str(ref))\n\n            self._tree.addTopLevelItem(item)        \n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/calibration/calibration_generator/#iris.calibration.calibration_generator.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/calibration/test_calibrator_wavelength/","title":"test_calibrator_wavelength","text":"<p>This class handles the calibration to map spectrometer pixels to wavelengths using  reference peaks</p>"},{"location":"reference/iris/controllers/camera_controller_dummy/","title":"camera_controller_dummy","text":"<p>A controller to take in a video feed and display </p> <p>Made on: 04 March 2024</p>"},{"location":"reference/iris/controllers/camera_controller_dummy/#iris.controllers.camera_controller_dummy.CameraController_Dummy","title":"<code>CameraController_Dummy</code>","text":"<p>               Bases: <code>Class_CameraController</code></p> <p>A class that operates the camera, takes and stores the current frame for a webcam.</p> Source code in <code>iris/controllers/camera_controller_dummy.py</code> <pre><code>class CameraController_Dummy(Class_CameraController):\n    \"\"\"\n    A class that operates the camera, takes and stores the current frame for a webcam.\n    \"\"\"\n    def __init__(self,**kwargs) -&gt; None:\n        self._size = (640,480)  # Size of the video feed in pixels\n        self._frame = np.ones((self._size[1],self._size[0],3),dtype=np.uint8)*255  # Initial frame\n        # Convert to a yellow image\n        self._frame[:,:,:] = [0,255,255]\n\n        self.flg_initialised = True\n\n        print('\\n&gt;&gt;&gt;&gt;&gt; DUMMY camera controller is used &lt;&lt;&lt;&lt;&lt;')\n\n    def get_identifier(self) -&gt; str:\n        return \"Dummy camera controller\"\n\n    def camera_intialisation(self):\n        self.flg_initialised = True\n\n    def camera_termination(self):\n        print('Terminating the camera')\n        self.flg_initialised = False\n\n    def get_initialisation_status(self) -&gt; bool:\n        return self.flg_initialised\n\n    def frame_capture(self) -&gt; (np.ndarray|None):\n        return self._frame\n\n    def img_capture(self) -&gt; Image.Image:\n        frame = self.frame_capture()\n        self.img = Image.fromarray(frame)\n        return self.img\n\n    def vidcapture_show(self):\n        self.status = \"video capture on-going\"\n        self.vidcap_flag = True\n        self.win_name = 'preview'\n\n        while self.vidcap_flag:\n            self.vidshow(self.win_name,self._frame)\n            self.frame_capture()\n            key = cv2.waitKey(20)\n            if key == 27: # exit on ESC\n                self.vidcap_flag = False\n                time.sleep(0.5)\n        self.status = \"video capture stopped\"\n        self.quit()\n\n    def vidshow(self,win_name,frame):\n        cv2.imshow(win_name, frame)\n\n    def quit(self):\n        print('video stopped')\n        cv2.destroyWindow(self.win_name)\n        self.camera_termination()\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_color/","title":"camera_controller_thorlabs_color","text":"<p>A controller to take in a video feed and display</p>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_color/#iris.controllers.camera_controller_thorlabs_color.CameraController_ThorlabsColor","title":"<code>CameraController_ThorlabsColor</code>","text":"<p>               Bases: <code>Class_CameraController</code></p> <p>A class that operates the camera, takes and stores the current frame for Thorlabs colour camera.</p> Source code in <code>iris/controllers/camera_controller_thorlabs_color.py</code> <pre><code>class CameraController_ThorlabsColor(Class_CameraController):\n    \"\"\"\n    A class that operates the camera, takes and stores the current frame for Thorlabs colour camera.\n    \"\"\"\n    def __init__(self,show:bool=False) -&gt; None:\n        self.controller:TLCameraSDK = None\n\n        self._lock = mp.Lock()\n\n        self.camera_index = 0           # Takes the 1st capture device as the source\n                                        # it is possible that the desired device is NOT the 1st one\n                                        # in this case, a different index should be chosen by trial and error\n                                        # index = 0,1,2,3,... etc.\n\n        self._colour_processor:TL_MTC = None\n        self._clrprc_monoToColour:MonoToColorProcessor = None        \n\n        self._frame_width:int = None\n        self._frame_height:int = None\n\n        self._flg_show_preview = show\n        self.win_name = 'preview'\n\n        # Post processing parameters\n        self._mirrorx:bool = None\n        self._mirrory:bool = None\n\n        self.flg_initialised = False\n\n        self._identifier = None\n        try: self._initialisation()\n        except Exception as e: print('CameraController_ThorlabsColor initialisation error:\\n{}'.format(e))\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the camera.\n\n        Returns:\n            str: The identifier of the camera\n        \"\"\"\n        if self._identifier is None:\n            self._identifier = f\"Thorlabs_{self.camera.model}, S/N:{self.camera.serial_number}\"\n        return self._identifier\n\n    def reinitialise_connection(self) -&gt; None:\n        \"\"\"\n        Reinitialise the camera connection\n        \"\"\"\n        try: self.camera_termination()\n        except Exception as e: print('CameraController_ThorlabsColor reinitialise_connection error:\\n{}'.format(e))\n\n        try: self._initialisation()\n        except Exception as e: print('CameraController_ThorlabsColor reinitialise_connection error:\\n{}'.format(e))\n\n    def _initialisation(self) -&gt; bool:\n        \"\"\"\n        Initialise the camera connection\n\n        Returns:\n            bool: True if the camera is initialised\n        \"\"\"\n        try: self.controller = TLCameraSDK()\n        except Exception as e: print('CameraController_ThorlabsColor initialisation error:\\n{}'.format(e))\n\n        self._lock = mp.Lock()\n\n        self._lock.acquire()\n\n        available_cameras = self.controller.discover_available_cameras()\n\n        if len(available_cameras) &lt; 1:\n            print(\"no cameras detected\")\n            return False\n\n        self.camera = self.controller.open_camera(available_cameras[self.camera_index])\n        self.camera.exposure_time_us = ControllerSpecificConfigEnum.THORLABS_CAMERA_EXPOSURE_TIME.value # exposure time in [us]. Default: 10000 (10ms)\n        self.camera.frames_per_trigger_zero_for_unlimited = ControllerSpecificConfigEnum.THORLABS_CAMERA_FRAMEPERTRIGGER.value  # number of frames obtained per trigger, 0 for continuous acquisition mode\n        self.camera.image_poll_timeout_ms = ControllerSpecificConfigEnum.THORLABS_CAMERA_IMAGEPOLL_TIMEOUT.value    # set image polling timeout in [ms]\n        self.camera.gain = int(0)\n\n        self._colour_processor = TL_MTC()\n        self._clrprc_monoToColour = self._colour_processor.create_mono_to_color_processor(\n            self.camera.camera_sensor_type,\n            self.camera.color_filter_array_phase,\n            self.camera.get_color_correction_matrix(),\n            self.camera.get_default_white_balance_matrix(),\n            self.camera.bit_depth)\n        self._clrprc_monoToColour.color_space = TL_ClrSpc.SRGB  # sRGB color space\n        self._clrprc_monoToColour.output_format = TL_Fmt.RGB_PIXEL  # data is returned as sequential RGB values\n\n        self._frame_width = self.camera.image_width_pixels\n        self._frame_height = self.camera.image_height_pixels\n\n        self.camera.arm(2)\n        self.camera.issue_software_trigger()\n\n        self.status = \"video capture initialisation\"  # Status message of the class\n\n        if self._flg_show_preview == True:\n            self.win_name = 'preview'\n            cv2.namedWindow(self.win_name)\n\n        # Post processing parameters\n        self._mirrorx = ControllerConfigEnum.CAMERA_MIRRORX.value\n        self._mirrory = ControllerConfigEnum.CAMERA_MIRRORY.value\n\n        self.flg_initialised = True\n\n        # Set the identifier\n        self._identifier = f\"Thorlabs_{self.camera.model}, S/N:{self.camera.serial_number}\"\n\n        self._lock.release()\n        print('&gt;&gt;&gt;&gt;&gt; Thorlabs color camera initialised &lt;&lt;&lt;&lt;&lt;')\n\n    def camera_termination(self):\n\n        print('Terminating the Thorlabs color camera')\n        try:\n            with self._lock: self.camera.disarm()\n        except Exception as e: print('camera_termiation error:\\n{}'.format(e))\n\n        try:\n            with self._lock: self._clrprc_monoToColour.dispose()\n        except Exception as e: print('camera_termiation error:\\n{}'.format(e))\n\n        try:\n            with self._lock: self._colour_processor.dispose()\n        except Exception as e: print('camera_termiation error:\\n{}'.format(e))\n\n        try:\n            with self._lock: self.camera.dispose()\n        except Exception as e: print('camera_termiation error:\\n{}'.format(e))\n\n        try:\n            with self._lock: self.controller.dispose()\n        except Exception as e: print('camera_termiation error:\\n{}'.format(e))\n\n        self.controller = None\n        self.camera = None\n        self._colour_processor = None\n\n        time.sleep(3)   # Wait for all terminations to complete\n\n        self.flg_initialised = False\n\n        print('&gt;&gt;&gt;&gt;&gt; Thorlabs color camera terminated &lt;&lt;&lt;&lt;&lt;')\n\n    def set_exposure_time(self, exposure_time_us:int|float) -&gt; None:\n        \"\"\"\n        Set the exposure time of the camera\n\n        Args:\n            exposure_time_us (int | float): Exposure time in microseconds\n        \"\"\"\n        with self._lock:\n            try: self.camera.exposure_time_us = exposure_time_us\n            except Exception as e: print('set_exposure_time error:\\n{}'.format(e))\n\n    def get_exposure_time(self) -&gt; int|float|None:\n        \"\"\"\n        Get the exposure time of the camera\n\n        Returns:\n            int | float: Exposure time in microseconds\n        \"\"\"\n        with self._lock:\n            try: exposure_time = self.camera.exposure_time_us\n            except Exception as e: print('get_exposure_time error:\\n{}'.format(e)); exposure_time = None\n            return exposure_time\n\n    def get_initialisation_status(self) -&gt; bool:\n        return self.flg_initialised\n\n    def frame_capture(self) -&gt; (np.ndarray|None):\n        with self._lock: frame = self.camera.get_pending_frame_or_null()\n        if frame is not None:\n            image_1d:np.ndarray = self._clrprc_monoToColour.transform_to_24(\n                frame.image_buffer, self._frame_width, self._frame_height)\n\n            with self._lock:\n                image_array = image_1d.reshape(self.camera.image_height_pixels, self.camera.image_width_pixels, 3)\n\n            if self._mirrorx: image_array = cv2.flip(image_array, 0)\n            if self._mirrory: image_array = cv2.flip(image_array, 1)\n\n            self.img = image_array\n            return self.img\n        else:\n            return None\n\n    def img_capture(self) -&gt; Image.Image:\n        frm = self.frame_capture()\n        if frm is None:\n            return None\n        self.img = Image.fromarray(frm)\n        return self.img\n\n    def vidcapture_show(self):\n        self.status = \"video capture on-going\"\n        self.vidcap_flag = True\n\n        while self.vidcap_flag:\n            key = cv2.waitKey(20)\n            if key == 27: # exit on ESC\n                self.vidcap_flag = False\n                time.sleep(0.1)\n\n            img = self.frame_capture()\n\n            if img is None:\n                time.sleep(0.01)\n                continue\n            frame = cv2.cvtColor(img, cv2.COLOR_BGR2RGBA)\n            self.vidshow(self.win_name,frame)\n\n        self.status = \"video capture stopped\"\n        self.quit()\n\n    def vidshow(self,win_name,frame):\n        cv2.imshow(win_name, frame)\n\n    def quit(self):\n        print('video stopped')\n        self.camera_termination()\n        cv2.destroyWindow(self.win_name)\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_color/#iris.controllers.camera_controller_thorlabs_color.CameraController_ThorlabsColor.get_exposure_time","title":"<code>get_exposure_time()</code>","text":"<p>Get the exposure time of the camera</p> <p>Returns:</p> Type Description <code>int | float | None</code> <p>int | float: Exposure time in microseconds</p> Source code in <code>iris/controllers/camera_controller_thorlabs_color.py</code> <pre><code>def get_exposure_time(self) -&gt; int|float|None:\n    \"\"\"\n    Get the exposure time of the camera\n\n    Returns:\n        int | float: Exposure time in microseconds\n    \"\"\"\n    with self._lock:\n        try: exposure_time = self.camera.exposure_time_us\n        except Exception as e: print('get_exposure_time error:\\n{}'.format(e)); exposure_time = None\n        return exposure_time\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_color/#iris.controllers.camera_controller_thorlabs_color.CameraController_ThorlabsColor.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the camera.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the camera</p> Source code in <code>iris/controllers/camera_controller_thorlabs_color.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the camera.\n\n    Returns:\n        str: The identifier of the camera\n    \"\"\"\n    if self._identifier is None:\n        self._identifier = f\"Thorlabs_{self.camera.model}, S/N:{self.camera.serial_number}\"\n    return self._identifier\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_color/#iris.controllers.camera_controller_thorlabs_color.CameraController_ThorlabsColor.reinitialise_connection","title":"<code>reinitialise_connection()</code>","text":"<p>Reinitialise the camera connection</p> Source code in <code>iris/controllers/camera_controller_thorlabs_color.py</code> <pre><code>def reinitialise_connection(self) -&gt; None:\n    \"\"\"\n    Reinitialise the camera connection\n    \"\"\"\n    try: self.camera_termination()\n    except Exception as e: print('CameraController_ThorlabsColor reinitialise_connection error:\\n{}'.format(e))\n\n    try: self._initialisation()\n    except Exception as e: print('CameraController_ThorlabsColor reinitialise_connection error:\\n{}'.format(e))\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_color/#iris.controllers.camera_controller_thorlabs_color.CameraController_ThorlabsColor.set_exposure_time","title":"<code>set_exposure_time(exposure_time_us)</code>","text":"<p>Set the exposure time of the camera</p> <p>Parameters:</p> Name Type Description Default <code>exposure_time_us</code> <code>int | float</code> <p>Exposure time in microseconds</p> required Source code in <code>iris/controllers/camera_controller_thorlabs_color.py</code> <pre><code>def set_exposure_time(self, exposure_time_us:int|float) -&gt; None:\n    \"\"\"\n    Set the exposure time of the camera\n\n    Args:\n        exposure_time_us (int | float): Exposure time in microseconds\n    \"\"\"\n    with self._lock:\n        try: self.camera.exposure_time_us = exposure_time_us\n        except Exception as e: print('set_exposure_time error:\\n{}'.format(e))\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_mono/","title":"camera_controller_thorlabs_mono","text":"<p>A controller to take in a video feed and display</p>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_mono/#iris.controllers.camera_controller_thorlabs_mono.CameraController_ThorlabsMono","title":"<code>CameraController_ThorlabsMono</code>","text":"<p>               Bases: <code>Class_CameraController</code></p> <p>A class that operates the camera, takes and stores the current frame for Thorlabs monochrome camera.</p> Source code in <code>iris/controllers/camera_controller_thorlabs_mono.py</code> <pre><code>class CameraController_ThorlabsMono(Class_CameraController):\n    \"\"\"\n    A class that operates the camera, takes and stores the current frame for Thorlabs monochrome camera.\n    \"\"\"\n    def __init__(self,show=False) -&gt; None:\n\n        # Check if the SDK is open\n        self.controller:TLCameraSDK = None\n\n        self._lock = Lock()\n\n        self.camera_index = 0           # Takes the 1st capture device as the source\n                                        # it is possible that the desired device is NOT the 1st one\n                                        # in this case, a different index should be chosen by trial and error\n                                        # index = 0,1,2,3,... etc.\n\n        self.camera:TLCamera = None\n        self._intensity_mod = 1/100\n\n        self._frame_width:int = None\n        self._frame_height:int = None\n\n        self._flg_show_preview = show\n\n        self.win_name = 'preview'\n\n        # Post processing parameters\n        self._mirrorx:bool = None\n        self._mirrory:bool = None\n\n        self.flg_initialised = False\n\n        self._identifier = None\n        try: self._initialisation()\n        except Exception as e: print('camera_initialisation error:\\n{}'.format(e))\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the camera.\n\n        Returns:\n            str: The identifier of the camera\n        \"\"\"\n        if self._identifier is None:\n            self._identifier = f\"Thorlabs_{self.camera.model}, S/N:{self.camera.serial_number}\"\n        return self._identifier\n\n    def reinitialise_connection(self) -&gt; None:\n        \"\"\"\n        Reinitialise the camera connection\n        \"\"\"\n        try: self.camera_termination()\n        except Exception as e: print('camera_reinitialisation error:\\n{}'.format(e))\n\n        try: self._initialisation()\n        except Exception as e: print('camera_reinitialisation error:\\n{}'.format(e))\n\n    def _initialisation(self) -&gt; bool:\n        \"\"\"\n        Check if the camera is initialised\n        \"\"\"\n        self._lock.acquire()\n\n        try: self.controller = TLCameraSDK()\n        except Exception as e: print('camera_initialisation error:\\n{}'.format(e))\n\n        available_cameras = self.controller.discover_available_cameras()\n\n        if len(available_cameras) &lt; 1:\n            print(\"no cameras detected\")\n\n        self.camera = self.controller.open_camera(available_cameras[self.camera_index])\n        self.camera.exposure_time_us = ControllerSpecificConfigEnum.THORLABS_CAMERA_EXPOSURE_TIME.value # exposure time in [us]. Default: 10000 (10ms)\n        self.camera.frames_per_trigger_zero_for_unlimited = ControllerSpecificConfigEnum.THORLABS_CAMERA_FRAMEPERTRIGGER.value  # number of frames obtained per trigger, 0 for continuous acquisition mode\n        self.camera.image_poll_timeout_ms = ControllerSpecificConfigEnum.THORLABS_CAMERA_IMAGEPOLL_TIMEOUT.value    # set image polling timeout in [ms]\n\n        self._frame_width = self.camera.image_width_pixels\n        self._frame_height = self.camera.image_height_pixels\n\n        self.camera.arm(2)\n        self.camera.issue_software_trigger()\n\n        self.status = \"video capture initialisation\"  # Status message of the class\n\n        if self._flg_show_preview == True:\n            self.win_name = 'preview'\n            cv2.namedWindow(self.win_name)\n\n        # Post processing parameters\n        self._mirrorx = ControllerConfigEnum.CAMERA_MIRRORX.value\n        self._mirrory = ControllerConfigEnum.CAMERA_MIRRORY.value\n\n        self.flg_initialised = True\n\n        # Set the identifier\n        self._identifier = f\"Thorlabs_{self.camera.model}, S/N:{self.camera.serial_number}\"\n\n        self._lock.release()\n\n    def camera_termination(self):\n        self._lock.acquire()\n\n        try: self.camera.disarm()\n        except Exception as e: print('camera_disarm error:\\n{}'.format(e))\n\n        try: self.camera.dispose()\n        except Exception as e: print('camera_termiation error:\\n{}'.format(e))\n\n        try: self.controller.dispose()\n        except Exception as e: print('controller_dispose error:\\n{}'.format(e))\n\n        self.camera = None\n        self.controller = None\n\n        time.sleep(3)   # Wait for all terminations to complete\n\n        self.flg_initialised = False\n\n        self._lock.release()\n\n    def get_initialisation_status(self) -&gt; bool:\n        return self.flg_initialised\n\n    def set_exposure_time(self, exposure_time_us:int|float) -&gt; None:\n        \"\"\"\n        Set the exposure time of the camera\n\n        Args:\n            exposure_time_us (int | float): Exposure time in microseconds\n        \"\"\"\n        with self._lock:\n            if not isinstance(exposure_time_us, (int, float)):\n                raise ValueError(\"Exposure time must be an integer or float\")\n            exposure_time_us = int(exposure_time_us)\n            self.camera.exposure_time_us = exposure_time_us\n\n    def get_exposure_time(self) -&gt; int|float|None:\n        \"\"\"\n        Get the exposure time of the camera\n\n        Returns:\n            int | float: Exposure time in microseconds\n        \"\"\"\n        with self._lock:\n            return self.camera.exposure_time_us\n\n    def frame_capture(self) -&gt; (np.ndarray|None):\n        with self._lock: frame = self.camera.get_pending_frame_or_null()\n\n        if frame is not None:\n            image_1d:np.ndarray=frame.image_buffer\n            image_array = image_1d.reshape(self.camera.image_height_pixels, self.camera.image_width_pixels)\n\n            if self._mirrorx: image_array = cv2.flip(image_array, 0)\n            if self._mirrory: image_array = cv2.flip(image_array, 1)\n\n            self.img = image_array\n            return self.img\n        else:\n            return None\n\n    def img_capture(self) -&gt; Image.Image:\n        frm = self.frame_capture()\n        if frm is None: return None\n        # frm_normalised = cv2.normalize(frm, None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8U) \n        frm_normalised = frm*self._intensity_mod\n        self.img = Image.fromarray(frm_normalised)\n        self.img = self.img.convert('RGB')\n        return self.img\n\n    def vidcapture_show(self):\n        self.status = \"video capture on-going\"\n        self.vidcap_flag = True\n\n        while self.vidcap_flag:\n            key = cv2.waitKey(20)\n            if key == 27: # exit on ESC\n                self.vidcap_flag = False\n                time.sleep(0.1)\n\n\n            # Adjust exposure time dynamically (example)\n            if key == ord('i'):  # Increase exposure\n                try: self.camera.exposure_time_us += 100\n                except Exception as e: print(f\"Error: {e}\")\n                print(f\"Exposure increased to: {self.camera.exposure_time_us}\")\n            elif key == ord('d'):  # Decrease exposure\n                try: self.camera.exposure_time_us -= 100\n                except Exception as e: print(f\"Error: {e}\")\n                print(f\"Exposure decreased to: {self.camera.exposure_time_us}\")\n\n            # img = self.frame_capture()\n            # frame = cv2.cvtColor(np.array(img), cv2.COLOR_BGR2RGBA)\n\n            img = self.img_capture() # RGB Image object\n            frame = img\n            frame = cv2.cvtColor(np.array(frame), cv2.COLOR_BGR2RGBA)\n\n            if img is None:\n                time.sleep(0.01)\n                continue\n\n            self.vidshow(self.win_name,frame)\n\n        self.status = \"video capture stopped\"\n        self.quit()\n\n    def vidshow(self,win_name,frame):\n        cv2.imshow(win_name, frame)\n\n    def quit(self):\n        print('video stopped')\n        self.camera_termination()\n        cv2.destroyWindow(self.win_name)\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_mono/#iris.controllers.camera_controller_thorlabs_mono.CameraController_ThorlabsMono.get_exposure_time","title":"<code>get_exposure_time()</code>","text":"<p>Get the exposure time of the camera</p> <p>Returns:</p> Type Description <code>int | float | None</code> <p>int | float: Exposure time in microseconds</p> Source code in <code>iris/controllers/camera_controller_thorlabs_mono.py</code> <pre><code>def get_exposure_time(self) -&gt; int|float|None:\n    \"\"\"\n    Get the exposure time of the camera\n\n    Returns:\n        int | float: Exposure time in microseconds\n    \"\"\"\n    with self._lock:\n        return self.camera.exposure_time_us\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_mono/#iris.controllers.camera_controller_thorlabs_mono.CameraController_ThorlabsMono.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the camera.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the camera</p> Source code in <code>iris/controllers/camera_controller_thorlabs_mono.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the camera.\n\n    Returns:\n        str: The identifier of the camera\n    \"\"\"\n    if self._identifier is None:\n        self._identifier = f\"Thorlabs_{self.camera.model}, S/N:{self.camera.serial_number}\"\n    return self._identifier\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_mono/#iris.controllers.camera_controller_thorlabs_mono.CameraController_ThorlabsMono.reinitialise_connection","title":"<code>reinitialise_connection()</code>","text":"<p>Reinitialise the camera connection</p> Source code in <code>iris/controllers/camera_controller_thorlabs_mono.py</code> <pre><code>def reinitialise_connection(self) -&gt; None:\n    \"\"\"\n    Reinitialise the camera connection\n    \"\"\"\n    try: self.camera_termination()\n    except Exception as e: print('camera_reinitialisation error:\\n{}'.format(e))\n\n    try: self._initialisation()\n    except Exception as e: print('camera_reinitialisation error:\\n{}'.format(e))\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_thorlabs_mono/#iris.controllers.camera_controller_thorlabs_mono.CameraController_ThorlabsMono.set_exposure_time","title":"<code>set_exposure_time(exposure_time_us)</code>","text":"<p>Set the exposure time of the camera</p> <p>Parameters:</p> Name Type Description Default <code>exposure_time_us</code> <code>int | float</code> <p>Exposure time in microseconds</p> required Source code in <code>iris/controllers/camera_controller_thorlabs_mono.py</code> <pre><code>def set_exposure_time(self, exposure_time_us:int|float) -&gt; None:\n    \"\"\"\n    Set the exposure time of the camera\n\n    Args:\n        exposure_time_us (int | float): Exposure time in microseconds\n    \"\"\"\n    with self._lock:\n        if not isinstance(exposure_time_us, (int, float)):\n            raise ValueError(\"Exposure time must be an integer or float\")\n        exposure_time_us = int(exposure_time_us)\n        self.camera.exposure_time_us = exposure_time_us\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_webcam/","title":"camera_controller_webcam","text":"<p>A controller to take in a video feed and display</p>"},{"location":"reference/iris/controllers/camera_controller_webcam/#iris.controllers.camera_controller_webcam.CameraController_Webcam","title":"<code>CameraController_Webcam</code>","text":"<p>               Bases: <code>Class_CameraController</code></p> <p>A class that operates the camera, takes and stores the current frame for a webcam.</p> Source code in <code>iris/controllers/camera_controller_webcam.py</code> <pre><code>class CameraController_Webcam(Class_CameraController):\n    \"\"\"\n    A class that operates the camera, takes and stores the current frame for a webcam.\n    \"\"\"\n    def __init__(self,show=False) -&gt; None:\n        self.camera_index = ControllerConfigEnum.CAMERA_INDEX.value    # Takes the 1st capture device as the source\n                                            # it is possible that the desired device is NOT the 1st one\n                                            # in this case, a different index should be chosen by trial and error\n                                            # index = 0,1,2,3,... etc.\n        self.camera_intialisation()\n        self.status = \"video capture initialisation\"  # Status message of the class\n\n        if show == True:\n            self.win_name = 'preview'\n            cv2.namedWindow(self.win_name)\n\n        # try to get the first frame\n        self.frame_flag = False # An indicator if there's a frame stored\n        if self.vc.isOpened():\n            self.frame_flag, self.frame = self.vc.read()\n            self.img = Image.fromarray(self.frame)\n\n        # Post-processing parameters\n        self._mirrorx = ControllerConfigEnum.CAMERA_MIRRORX.value\n        self._mirrory = ControllerConfigEnum.CAMERA_MIRRORY.value\n\n        self.flg_initialised = True\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the camera.\n\n        Returns:\n            str: The identifier of the camera\n        \"\"\"\n        return f\"Webcam, index {self.camera_index}\"\n\n    def camera_intialisation(self):\n        self.vc = cv2.VideoCapture(0)\n        self.flg_initialised = True\n\n    def camera_termination(self):\n        self.vc.release()\n        self.flg_initialised = False\n\n    def get_initialisation_status(self) -&gt; bool:\n        return self.flg_initialised\n\n    def frame_capture(self) -&gt; (np.ndarray|None):\n        self.frame_flag, self.frame = self.vc.read()\n\n        if self._mirrorx: self.frame = cv2.flip(self.frame, 0)\n        if self._mirrory: self.frame = cv2.flip(self.frame, 1)\n\n        return self.frame\n\n    def img_capture(self) -&gt; Image.Image:\n        # self.frame_flag, self.frame = self.vc.read()\n        img = Image.fromarray(cv2.cvtColor(self.vc.read()[1], cv2.COLOR_BGR2RGBA))\n\n        if self._mirrorx: img = img.transpose(Image.FLIP_LEFT_RIGHT)\n        if self._mirrory: img = img.transpose(Image.FLIP_TOP_BOTTOM)\n\n        self.img = img\n        return self.img\n\n    def vidcapture_show(self):\n        self.status = \"video capture on-going\"\n        self.vidcap_flag = True\n\n        while self.vidcap_flag:\n            self.vidshow(self.win_name,self.frame)\n            self.frame_capture()\n            key = cv2.waitKey(20)\n            if key == 27: # exit on ESC\n                self.vidcap_flag = False\n                time.sleep(0.5)\n        self.status = \"video capture stopped\"\n        self.quit()\n\n    def vidshow(self,win_name,frame):\n        cv2.imshow(win_name, frame)\n\n    def quit(self):\n        print('video stopped')\n        cv2.destroyWindow(self.win_name)\n        self.camera_termination()\n</code></pre>"},{"location":"reference/iris/controllers/camera_controller_webcam/#iris.controllers.camera_controller_webcam.CameraController_Webcam.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the camera.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the camera</p> Source code in <code>iris/controllers/camera_controller_webcam.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the camera.\n\n    Returns:\n        str: The identifier of the camera\n    \"\"\"\n    return f\"Webcam, index {self.camera_index}\"\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/","title":"class_camera_controller","text":"<p>Class definition for the Thorlabs colour camera controller and a guide to writing one for the IRIS app.</p>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController","title":"<code>Class_CameraController</code>","text":"<p>A class that operates the camera, takes and stores the current frame for Thorlabs colour camera.</p> Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>class Class_CameraController:\n    \"\"\"\n    A class that operates the camera, takes and stores the current frame for Thorlabs colour camera.\n    \"\"\"\n    def __init__(self,show=False) -&gt; None:\n        # &lt;&lt;&lt;&lt;&lt; Insert the device initialisation commands here (connection, parameters, etc.)\n        pass\n\n        self.status = \"video capture initialisation\"  # Status message of the class\n\n        # Post processing parameters\n        self._mirrorx = ControllerConfigEnum.CAMERA_MIRRORX.value\n        self._mirrory = ControllerConfigEnum.CAMERA_MIRRORY.value\n\n        self.flg_initialised = True\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the camera.\n\n        Returns:\n            str: The identifier of the camera\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the command to get the camera identifier here\n        identifier = \"CameraController_ID: Not set\"\n        return identifier\n\n    def camera_termination(self) -&gt; None:\n        \"\"\"\n        To terminate the connections to the camera prior exit\n        \"\"\"\n        try:\n            # &lt;&lt;&lt;&lt;&lt; Insert the termination commands here\n            pass\n        except Exception as e:\n            print('camera_termiation error:\\n{}'.format(e))\n\n        self.flg_initialised = False\n\n    def get_initialisation_status(self) -&gt; bool:\n        \"\"\"\n        Returns the initialisation status of the camera.\n\n        Returns:\n            bool: The initialisation status of the camera\n        \"\"\"\n        return self.flg_initialised\n\n\n    def set_exposure_time(self, exposure_time_us:int|float) -&gt; None:\n        \"\"\"\n        Set the exposure time of the camera\n\n        Args:\n            exposure_time_us (int | float): Exposure time in microseconds\n        \"\"\"\n        raise NotImplementedError(\"set_exposure_time() does not exist in this controller\")\n\n    def get_exposure_time(self) -&gt; int|float|None:\n        \"\"\"\n        Get the exposure time of the camera\n\n        Returns:\n            int | float: Exposure time in microseconds\n        \"\"\"\n        raise NotImplementedError(\"get_exposure_time() does not exist in this controller\")\n\n    def frame_capture(self) -&gt; (np.ndarray|None):\n        \"\"\"\n        Captures the frame from the camera and returns it as a numpy array.\n\n        Returns:\n            np.ndarray|None: The frame as a numpy array or None if no frame is captured\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the command to capture the frame here\n        frame = np.ndarray((100,100,3)) # dummy frame\n        pass\n\n        if frame is not None:\n            if self._mirrorx:\n                # &lt;&lt;&lt;&lt;&lt; Insert the command to flip the image in the x-axis here\n                pass\n            if self._mirrory:\n                # &lt;&lt;&lt;&lt;&lt; Insert the command to flip the image in the y-axis here\n                pass\n            # &lt;&lt;&lt;&lt;&lt; Insert the command to convert the frame to a numpy array here\n            img = frame # dummy img\n            pass\n\n            return img\n        else:\n            return None\n\n    def img_capture(self) -&gt; Image.Image|None:\n        \"\"\"\n        Captures the frame from the camera and returns it as a PIL Image.\n\n        Returns:\n            Image.Image|None: The frame as a PIL Image or None if no frame is captured\n        \"\"\"\n        frm = self.frame_capture()\n        if frm is None:\n            return None\n        self.img = Image.fromarray(frm)\n        return self.img\n\n    def vidcapture_show(self) -&gt; None:\n        \"\"\"\n        Tests the video capture and shows the video feed.\n        \"\"\"\n        self.vidcap_flag = True\n        win_name = 'preview'\n        cv2.namedWindow(win_name)\n\n        while self.vidcap_flag:\n            key = cv2.waitKey(20)\n            if key == 27: # exit on ESC\n                self.vidcap_flag = False\n                time.sleep(0.1)\n\n            img = self.frame_capture()\n\n            if img is None:\n                time.sleep(0.01)\n                continue\n            frame = cv2.cvtColor(img, cv2.COLOR_BGR2RGBA)\n            self.vidshow(win_name,frame)\n\n        self.status = \"video capture stopped\"\n        self.quit(win_name=win_name)\n\n    def vidshow(self,win_name,frame) -&gt; None:\n        \"\"\"\n        Shows the video feed in a window.\n\n        Args:\n            win_name (str): The name of the window\n            frame (np.ndarray): The frame to be displayed\n        \"\"\"\n        cv2.imshow(win_name, frame)\n\n    def quit(self,win_name:str=None) -&gt; None:\n        print('video stopped')\n        self.camera_termination()\n        if win_name: cv2.destroyWindow(win_name)\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController.camera_termination","title":"<code>camera_termination()</code>","text":"<p>To terminate the connections to the camera prior exit</p> Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>def camera_termination(self) -&gt; None:\n    \"\"\"\n    To terminate the connections to the camera prior exit\n    \"\"\"\n    try:\n        # &lt;&lt;&lt;&lt;&lt; Insert the termination commands here\n        pass\n    except Exception as e:\n        print('camera_termiation error:\\n{}'.format(e))\n\n    self.flg_initialised = False\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController.frame_capture","title":"<code>frame_capture()</code>","text":"<p>Captures the frame from the camera and returns it as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray | None</code> <p>np.ndarray|None: The frame as a numpy array or None if no frame is captured</p> Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>def frame_capture(self) -&gt; (np.ndarray|None):\n    \"\"\"\n    Captures the frame from the camera and returns it as a numpy array.\n\n    Returns:\n        np.ndarray|None: The frame as a numpy array or None if no frame is captured\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the command to capture the frame here\n    frame = np.ndarray((100,100,3)) # dummy frame\n    pass\n\n    if frame is not None:\n        if self._mirrorx:\n            # &lt;&lt;&lt;&lt;&lt; Insert the command to flip the image in the x-axis here\n            pass\n        if self._mirrory:\n            # &lt;&lt;&lt;&lt;&lt; Insert the command to flip the image in the y-axis here\n            pass\n        # &lt;&lt;&lt;&lt;&lt; Insert the command to convert the frame to a numpy array here\n        img = frame # dummy img\n        pass\n\n        return img\n    else:\n        return None\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController.get_exposure_time","title":"<code>get_exposure_time()</code>","text":"<p>Get the exposure time of the camera</p> <p>Returns:</p> Type Description <code>int | float | None</code> <p>int | float: Exposure time in microseconds</p> Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>def get_exposure_time(self) -&gt; int|float|None:\n    \"\"\"\n    Get the exposure time of the camera\n\n    Returns:\n        int | float: Exposure time in microseconds\n    \"\"\"\n    raise NotImplementedError(\"get_exposure_time() does not exist in this controller\")\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the camera.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the camera</p> Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the camera.\n\n    Returns:\n        str: The identifier of the camera\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the command to get the camera identifier here\n    identifier = \"CameraController_ID: Not set\"\n    return identifier\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController.get_initialisation_status","title":"<code>get_initialisation_status()</code>","text":"<p>Returns the initialisation status of the camera.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>The initialisation status of the camera</p> Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>def get_initialisation_status(self) -&gt; bool:\n    \"\"\"\n    Returns the initialisation status of the camera.\n\n    Returns:\n        bool: The initialisation status of the camera\n    \"\"\"\n    return self.flg_initialised\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController.img_capture","title":"<code>img_capture()</code>","text":"<p>Captures the frame from the camera and returns it as a PIL Image.</p> <p>Returns:</p> Type Description <code>Image | None</code> <p>Image.Image|None: The frame as a PIL Image or None if no frame is captured</p> Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>def img_capture(self) -&gt; Image.Image|None:\n    \"\"\"\n    Captures the frame from the camera and returns it as a PIL Image.\n\n    Returns:\n        Image.Image|None: The frame as a PIL Image or None if no frame is captured\n    \"\"\"\n    frm = self.frame_capture()\n    if frm is None:\n        return None\n    self.img = Image.fromarray(frm)\n    return self.img\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController.set_exposure_time","title":"<code>set_exposure_time(exposure_time_us)</code>","text":"<p>Set the exposure time of the camera</p> <p>Parameters:</p> Name Type Description Default <code>exposure_time_us</code> <code>int | float</code> <p>Exposure time in microseconds</p> required Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>def set_exposure_time(self, exposure_time_us:int|float) -&gt; None:\n    \"\"\"\n    Set the exposure time of the camera\n\n    Args:\n        exposure_time_us (int | float): Exposure time in microseconds\n    \"\"\"\n    raise NotImplementedError(\"set_exposure_time() does not exist in this controller\")\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController.vidcapture_show","title":"<code>vidcapture_show()</code>","text":"<p>Tests the video capture and shows the video feed.</p> Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>def vidcapture_show(self) -&gt; None:\n    \"\"\"\n    Tests the video capture and shows the video feed.\n    \"\"\"\n    self.vidcap_flag = True\n    win_name = 'preview'\n    cv2.namedWindow(win_name)\n\n    while self.vidcap_flag:\n        key = cv2.waitKey(20)\n        if key == 27: # exit on ESC\n            self.vidcap_flag = False\n            time.sleep(0.1)\n\n        img = self.frame_capture()\n\n        if img is None:\n            time.sleep(0.01)\n            continue\n        frame = cv2.cvtColor(img, cv2.COLOR_BGR2RGBA)\n        self.vidshow(win_name,frame)\n\n    self.status = \"video capture stopped\"\n    self.quit(win_name=win_name)\n</code></pre>"},{"location":"reference/iris/controllers/class_camera_controller/#iris.controllers.class_camera_controller.Class_CameraController.vidshow","title":"<code>vidshow(win_name, frame)</code>","text":"<p>Shows the video feed in a window.</p> <p>Parameters:</p> Name Type Description Default <code>win_name</code> <code>str</code> <p>The name of the window</p> required <code>frame</code> <code>ndarray</code> <p>The frame to be displayed</p> required Source code in <code>iris/controllers/class_camera_controller.py</code> <pre><code>def vidshow(self,win_name,frame) -&gt; None:\n    \"\"\"\n    Shows the video feed in a window.\n\n    Args:\n        win_name (str): The name of the window\n        frame (np.ndarray): The frame to be displayed\n    \"\"\"\n    cv2.imshow(win_name, frame)\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/","title":"class_spectrometer_controller","text":"<p>Class definition for the Raman spectrometer controller and a guide to writing one for the IRIS</p>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.Class_SpectrometerController","title":"<code>Class_SpectrometerController</code>","text":"Source code in <code>iris/controllers/class_spectrometer_controller.py</code> <pre><code>class Class_SpectrometerController():\n    def __init__(self) -&gt; None:\n        # &lt;&lt;&lt;&lt;&lt; Insert the device initialisation commands here (connection, parameters, etc.)\n\n        self._lock = Lock()     # Lock for the acquisition process\n\n        # Start the initialisation process\n        self.initialisation()\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the camera.\n\n        Returns:\n            str: The identifier of the camera\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the command to get the camera identifier here\n        identifier = \"SpectrometerController_ID: Not set\"\n        return identifier\n\n# Core functionalities (initialisation, termination)\n    def initialisation(self) -&gt; None:\n        \"\"\"\n        Initializes the Raman spectrometer controller.\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the initialisation commands here\n        pass\n\n\n    def terminate(self) -&gt; None:\n        \"\"\"\n        To terminate the connections to the Raman spectrometers\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the termination commands here\n        pass\n\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n\n    def get_integration_time_us(self) -&gt; int:\n        \"\"\"\n        Get the integration time of the device\n\n        Returns:\n            int: Integration time in [device unit] (microseconds for the QE Pro)\n        \"\"\"\n        with self._lock:\n            # &lt;&lt;&lt;&lt;&lt; Insert the command to get the integration time here\n            int_time = 100\n            pass\n\n        return int_time\n\n    def set_integration_time_us(self,integration_time:int) -&gt; int:\n        \"\"\"Sets the integration time of the device\n\n        Args:\n            integration_time (int): Integration time in [device unit] \n            (microseconds for the QE Pro)\n\n        Returns:\n            int: Device integrationt time after set up in microseconds\n        \"\"\"\n\n        print('work here (raman spectrometer controller file)')\n\n        if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n            raise ValueError(\"Integration time must be an integer\")\n        integration_time = int(integration_time)\n\n        with self._lock:\n            # &lt;&lt;&lt;&lt;&lt; Insert the command to set the integration time here\n            pass\n            int_time = self.get_integration_time_us()\n\n        return int_time\n\n    def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n        \"\"\" \n        A function to measure the spectrum of the Raman spectrometer.\n\n        Returns:\n            tuple[pd.DataFrame, int, int]: A tuple containing the following:\n                - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                    intensity columns, from the config file. (as a global constant)\n                - int: The timestamp of the measurement in integer format (microseconds).\n                - int: The integration time used for the measurement in microseconds.\n        \"\"\"\n        with self._lock:\n            # &lt;&lt;&lt;&lt;&lt; Insert the command to measure the spectrum here\n            intensity = []\n            wavelength = []\n            pass\n\n            timestamp = get_timestamp_us_int()\n            integration_time = self.get_integration_time_us()\n\n        spectra = pd.DataFrame({\n            DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: wavelength,\n            DataAnalysisConfigEnum.INTENSITY_LABEL.value: intensity,\n        })\n        return (spectra, timestamp, integration_time)\n\n# Set of commands for testing/automation\n    def self_test(self):\n        # &lt;&lt;&lt;&lt;&lt; Insert the self-test commands here\n        pass\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.Class_SpectrometerController.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the camera.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the camera</p> Source code in <code>iris/controllers/class_spectrometer_controller.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the camera.\n\n    Returns:\n        str: The identifier of the camera\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the command to get the camera identifier here\n    identifier = \"SpectrometerController_ID: Not set\"\n    return identifier\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.Class_SpectrometerController.get_integration_time_us","title":"<code>get_integration_time_us()</code>","text":"<p>Get the integration time of the device</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Integration time in [device unit] (microseconds for the QE Pro)</p> Source code in <code>iris/controllers/class_spectrometer_controller.py</code> <pre><code>def get_integration_time_us(self) -&gt; int:\n    \"\"\"\n    Get the integration time of the device\n\n    Returns:\n        int: Integration time in [device unit] (microseconds for the QE Pro)\n    \"\"\"\n    with self._lock:\n        # &lt;&lt;&lt;&lt;&lt; Insert the command to get the integration time here\n        int_time = 100\n        pass\n\n    return int_time\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.Class_SpectrometerController.initialisation","title":"<code>initialisation()</code>","text":"<p>Initializes the Raman spectrometer controller.</p> Source code in <code>iris/controllers/class_spectrometer_controller.py</code> <pre><code>def initialisation(self) -&gt; None:\n    \"\"\"\n    Initializes the Raman spectrometer controller.\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the initialisation commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.Class_SpectrometerController.measure_spectrum","title":"<code>measure_spectrum()</code>","text":"<p>A function to measure the spectrum of the Raman spectrometer.</p> <p>Returns:</p> Type Description <code>tuple[DataFrame, int, int]</code> <p>tuple[pd.DataFrame, int, int]: A tuple containing the following: - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and     intensity columns, from the config file. (as a global constant) - int: The timestamp of the measurement in integer format (microseconds). - int: The integration time used for the measurement in microseconds.</p> Source code in <code>iris/controllers/class_spectrometer_controller.py</code> <pre><code>def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n    \"\"\" \n    A function to measure the spectrum of the Raman spectrometer.\n\n    Returns:\n        tuple[pd.DataFrame, int, int]: A tuple containing the following:\n            - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                intensity columns, from the config file. (as a global constant)\n            - int: The timestamp of the measurement in integer format (microseconds).\n            - int: The integration time used for the measurement in microseconds.\n    \"\"\"\n    with self._lock:\n        # &lt;&lt;&lt;&lt;&lt; Insert the command to measure the spectrum here\n        intensity = []\n        wavelength = []\n        pass\n\n        timestamp = get_timestamp_us_int()\n        integration_time = self.get_integration_time_us()\n\n    spectra = pd.DataFrame({\n        DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: wavelength,\n        DataAnalysisConfigEnum.INTENSITY_LABEL.value: intensity,\n    })\n    return (spectra, timestamp, integration_time)\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.Class_SpectrometerController.set_integration_time_us","title":"<code>set_integration_time_us(integration_time)</code>","text":"<p>Sets the integration time of the device</p> <p>Parameters:</p> Name Type Description Default <code>integration_time</code> <code>int</code> <p>Integration time in [device unit] </p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Device integrationt time after set up in microseconds</p> Source code in <code>iris/controllers/class_spectrometer_controller.py</code> <pre><code>def set_integration_time_us(self,integration_time:int) -&gt; int:\n    \"\"\"Sets the integration time of the device\n\n    Args:\n        integration_time (int): Integration time in [device unit] \n        (microseconds for the QE Pro)\n\n    Returns:\n        int: Device integrationt time after set up in microseconds\n    \"\"\"\n\n    print('work here (raman spectrometer controller file)')\n\n    if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n        raise ValueError(\"Integration time must be an integer\")\n    integration_time = int(integration_time)\n\n    with self._lock:\n        # &lt;&lt;&lt;&lt;&lt; Insert the command to set the integration time here\n        pass\n        int_time = self.get_integration_time_us()\n\n    return int_time\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.Class_SpectrometerController.terminate","title":"<code>terminate()</code>","text":"<p>To terminate the connections to the Raman spectrometers</p> Source code in <code>iris/controllers/class_spectrometer_controller.py</code> <pre><code>def terminate(self) -&gt; None:\n    \"\"\"\n    To terminate the connections to the Raman spectrometers\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the termination commands here\n    pass\n\n    print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/class_spectrometer_controller/#iris.controllers.class_spectrometer_controller.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/","title":"class_xy_stage_controller","text":"<p>Class definition for the XY stage controller and a guide to write one Open Raman Microscopy (ORM) app.</p>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController","title":"<code>Class_XYController</code>","text":"Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>class Class_XYController():\n    def __init__(self,**kwargs) -&gt; None:\n        # Remapping of the controls\n        self.dict_ctrl_remap = {\n            'xfwd':ControllerDirectionEnum.XFWD.value,\n            'xrev':ControllerDirectionEnum.XREV.value,\n            'yfwd':ControllerDirectionEnum.YFWD.value,\n            'yrev':ControllerDirectionEnum.YREV.value,\n        }   # Dictionary to remap the controls (only for the continuous and jog movements)\n\n        self._max_vel_mmS = 100.0    # Maximum velocity of the motor in mm/s\n        self._min_vel_mmS = 0.1      # Minimum velocity of the motor in mm/s\n\n        self._flipxy = ControllerConfigEnum.STAGE_FLIPXY.value      # Flag to indicate if the x and y axes are flipped in referece to the image capture\n        self._invertx = ControllerConfigEnum.STAGE_INVERTX.value    # Flag to indicate if the x axis is flipped (inverted)\n        self._inverty = ControllerConfigEnum.STAGE_INVERTY.value    # Flag to indicate if the y axis is flipped (inverted)\n\n        # Motor parameters\n        ## &lt;&lt;&lt; Here, you can insert the parameters required for the operations:\n        ## such as, the maximum velocity, acceleration, etc.\n        ## coordinate retrieval parameters, etc.\n\n        # Start by initializing the connection, device, motors, and their parameters\n        try:\n            self.initialisation()\n        except Exception as e:\n            print('Run ABORTED due to error in intialization:')\n            print(e)\n            self.terminate()\n\n        # Continue by setting up the motors and initializing (calibrating) the coordinate system of the motors\n        try:\n            if True: # &lt;&lt;&lt;&lt;&lt; Insert homing conditions here if possible\n                self.homing_n_coor_calibration()\n        except Exception as e:\n            print('Coordinate calibration has failed:')\n            print(e)\n            self.terminate()\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the camera.\n\n        Returns:\n            str: The identifier of the camera\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the command to get the camera identifier here\n        identifier = \"XYStageController_ID: Not set\"\n        return identifier\n\n    def reinitialise_connection(self) -&gt; None:\n        \"\"\"\n        Reinitialise the connection to the device\n        \"\"\"\n        try:self.terminate()\n        except Exception as e: print('Reinitialisation error:\\n{}'.format(e))\n\n        try:self.initialisation()\n        except Exception as e: print('Reinitialisation error:\\n{}'.format(e))\n\n    def _remap_coordinates_flip_get(self,coor:tuple[float,float]) -&gt; tuple[float,float]:\n        \"\"\"\n        Remaps the coordinates based on the flip flags for getting the coordinates\n        This is because matrix operations are not commutative.\n\n        Args:\n            coor (tuple[float,float]): The coordinate to be remapped\n\n        Returns:\n            tuple[float,float]: the remapped coordinate\n        \"\"\"\n        x,y = coor\n        if self._flipxy:\n            x,y = y,x\n        if self._invertx:\n            x = -1*x\n        if self._inverty:\n            y = -1*y\n        return (x,y)\n\n    def _remap_coordinates_flip_set(self,coor:tuple[float,float]) -&gt; tuple[float,float]:\n        \"\"\"\n        Remaps the coordinates based on the flip flags for setting the coordinates (moving the motors).\n        This is because matrix operations are not commutative.\n\n        Args:\n            coor (tuple[float,float]): The coordinate to be remapped\n\n        Returns:\n            tuple[float,float]: the remapped coordinate\n        \"\"\"\n        x,y = coor\n        if self._invertx:\n            x = -1*x\n        if self._inverty:\n            y = -1*y\n        if self._flipxy:\n            x,y = y,x\n        return (x,y)\n\n    def initialisation(self) -&gt; None:\n        \"\"\"\n        Initialises the device, setup the connection, channels, motors and their parameters, etc.\n        \"\"\"\n        # Device parameters\n        ## &lt;&lt;&lt;&lt;&lt; Here, you can insert the device parameters and connection initialisation commands\n        pass\n\n        print('\\n&gt;&gt;&gt;&gt;&gt; Device and motor initialisation complete &lt;&lt;&lt;&lt;&lt;')\n\n    def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100) -&gt; None:\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): Legacy parameter. Is ignored.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if vel_move &lt; 0:\n            raise ValueError(\"Velocity and acceleration parameters must be larger than 0%\")\n        if vel_move &gt; 100:\n            raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor velocity and acceleration setting commands here\n        pass\n\n\n    def get_vel_acc_relative(self) -&gt; tuple[float,float,float]:\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor velocity and acceleration retrieval commands here\n        relvel = float(100)\n        pass\n        return (relvel,relvel,float(100))\n\n    def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n        \"\"\"\n        Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n        Args:\n            speed_mm_s (float): The speed to be converted in mm/s\n\n        Returns:\n            float: The relative velocity parameter in percentage\n        \"\"\"\n        # Adjust the speed to the limits if it is out of bounds\n        if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n            speed_mm_s = self._min_vel_mmS\n        if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n            speed_mm_s = self._max_vel_mmS\n\n        # Calculate the relative speed\n        speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n        return speed_rel\n\n    def report_attributes(self) -&gt; None:\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Device and motor attributes &lt;&lt;&lt;&lt;&lt;\")\n        for attr, value in vars(self).items():\n            print(f\"{attr}: {value}\")\n\n    def get_coordinates(self) -&gt; tuple[float,float]:\n        \"\"\"\n        Returns the current motor coordinates\n\n        Returns:\n            tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor coordinate retrieval commands here\n        coor_x = float(0)\n        coor_y = float(0)\n        pass\n        return (coor_x,coor_y)\n\n    def homing_n_coor_calibration(self) -&gt; None:\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        - Also called as 'homing'\n        \"\"\"\n        if self.motorx_state != 0 or self.motory_state != 0:\n                print(\"!!!!! Motor is running, homing request BLOCKED !!!!!\")\n                return\n\n        print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n        # Home the device, use multithreading to operate both motors at once\n        # &lt;&lt;&lt;&lt;&lt; Insert the homing commands here\n        pass\n\n        print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n\n    def move_direct(self,coor_abs:tuple[float,float]) -&gt; None:\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor movement commands here\n        pass\n\n    def move_continuous(self,dir:str) -&gt; None:\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n        \"\"\"\n        # Check if the motor is running, prevents command overlap\n        if False: # &lt;&lt;&lt;&lt;&lt; Insert the motor running condition check here if required\n            print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n            return\n\n        dir = self.dict_ctrl_remap[dir] # Remap the control\n\n        if dir == 'xfwd':\n            # &lt;&lt;&lt;&lt;&lt; Insert the motor continuous movement commands here\n            pass\n        elif dir == 'xrev':\n            # &lt;&lt;&lt;&lt;&lt; Insert the motor continuous movement commands here\n            pass\n        elif dir == 'yfwd':\n            # &lt;&lt;&lt;&lt;&lt; Insert the motor continuous movement commands here\n            pass\n        elif dir == 'yrev':\n            # &lt;&lt;&lt;&lt;&lt; Insert the motor continuous movement commands here\n            pass\n\n    def stop_move(self) -&gt; None:\n        \"\"\"\n        Stops the continuous movement of the motors\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor stop command here\n        pass\n\n    def get_jog(self) -&gt; tuple[float,float,float,float,float,float]:\n        \"\"\"\n        Returns the current jog step in [mm]:\n\n        Returns:\n            tuple of floats: 6 elements:\n            (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the jog step retrieval commands here\n        jog_step_x = 0.1\n        jog_step_y = 0.1\n        jog_vel_x = 100\n        jog_vel_y = 100\n        jog_acc_x = 100\n\n        pass\n\n        return (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100) -&gt; None:\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): Legacy parameter. Is ignored.\n            acc_rel (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n            raise ValueError(\"Distance must be a float\")\n\n        if False: # &lt;&lt;&lt;&lt;&lt; Insert the jog step size check here if required\n            raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min_um))\n\n        # &lt;&lt;&lt;&lt;&lt; Insert the jog step setting commands here\n        pass\n\n    def move_jog(self,direction:str) -&gt; None:\n        \"\"\"\n        Moves the motor with a single jogging motion.\n\n        Args:\n            direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n        \"\"\"\n\n        if not isinstance(direction, str):\n            raise ValueError(\"Direction must be a string\")\n\n        if direction not in ['xfwd','xrev','yfwd','yrev']:\n            raise ValueError(\"Direction must be 'xfwd', 'xrev', 'yfwd', 'yrev'\")\n\n        if False: # &lt;&lt;&lt;&lt;&lt; Insert the motor running condition check here if required\n            print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n            return\n\n        direction = self.dict_ctrl_remap[direction] # Remap the control\n\n        if direction == 'xfwd':\n            # &lt;&lt;&lt;&lt;&lt; Insert the motor jog movement commands here\n            pass\n        elif direction == 'xrev':\n            # &lt;&lt;&lt;&lt;&lt; Insert the motor jog movement commands here\n            pass\n        elif direction == 'yfwd':\n            # &lt;&lt;&lt;&lt;&lt; Insert the motor jog movement commands here\n            pass\n        elif direction == 'yrev':\n            # &lt;&lt;&lt;&lt;&lt; Insert the motor jog movement commands here\n            pass\n\n    def terminate(self) -&gt; None:\n        \"\"\"\n        Terminates the operation and closes the connection to the device\n        \"\"\"\n        try:\n            # &lt;&lt;&lt;&lt;&lt; Insert the termination commands here\n            pass\n            print('xy_stage_controller: Connection closed')\n        except Exception as e:\n            print('xy_stage_controller: Error in closing the connection:\\n{}'.format(e))\n\n    def movementtest(self) -&gt; None:\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; MOTOR TEST: CIRCULAR MOTION &lt;&lt;&lt;&lt;&lt;\")\n        # Create circle coordinates\n        angles = np.arange(0, 2 * np.pi, 0.25)\n        radius = 10.0    # mm\n        xs = radius * np.cos(angles)+radius\n        ys = radius * np.sin(angles)+radius\n\n        for i in range(len(angles)):\n            print(i, float(xs[i]))\n            coor = [float(xs[i]), float(ys[i])]\n            self.move_direct(coor)\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.calculate_vel_relative","title":"<code>calculate_vel_relative(speed_mm_s)</code>","text":"<p>Calculates the relative velocity parameter for the motor given the speed in mm/s</p> <p>Parameters:</p> Name Type Description Default <code>speed_mm_s</code> <code>float</code> <p>The speed to be converted in mm/s</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The relative velocity parameter in percentage</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n    \"\"\"\n    Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n    Args:\n        speed_mm_s (float): The speed to be converted in mm/s\n\n    Returns:\n        float: The relative velocity parameter in percentage\n    \"\"\"\n    # Adjust the speed to the limits if it is out of bounds\n    if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n        speed_mm_s = self._min_vel_mmS\n    if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n        speed_mm_s = self._max_vel_mmS\n\n    # Calculate the relative speed\n    speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n    return speed_rel\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Returns the current motor coordinates</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def get_coordinates(self) -&gt; tuple[float,float]:\n    \"\"\"\n    Returns the current motor coordinates\n\n    Returns:\n        tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the motor coordinate retrieval commands here\n    coor_x = float(0)\n    coor_y = float(0)\n    pass\n    return (coor_x,coor_y)\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the camera.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the camera</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the camera.\n\n    Returns:\n        str: The identifier of the camera\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the command to get the camera identifier here\n    identifier = \"XYStageController_ID: Not set\"\n    return identifier\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.get_jog","title":"<code>get_jog()</code>","text":"<p>Returns the current jog step in [mm]:</p> <p>Returns:</p> Type Description <code>float</code> <p>tuple of floats: 6 elements:</p> <code>float</code> <p>(jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def get_jog(self) -&gt; tuple[float,float,float,float,float,float]:\n    \"\"\"\n    Returns the current jog step in [mm]:\n\n    Returns:\n        tuple of floats: 6 elements:\n        (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the jog step retrieval commands here\n    jog_step_x = 0.1\n    jog_step_y = 0.1\n    jog_vel_x = 100\n    jog_vel_y = 100\n    jog_acc_x = 100\n\n    pass\n\n    return (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def get_vel_acc_relative(self) -&gt; tuple[float,float,float]:\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the motor velocity and acceleration retrieval commands here\n    relvel = float(100)\n    pass\n    return (relvel,relvel,float(100))\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. - Also called as 'homing'</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def homing_n_coor_calibration(self) -&gt; None:\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    - Also called as 'homing'\n    \"\"\"\n    if self.motorx_state != 0 or self.motory_state != 0:\n            print(\"!!!!! Motor is running, homing request BLOCKED !!!!!\")\n            return\n\n    print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n    # Home the device, use multithreading to operate both motors at once\n    # &lt;&lt;&lt;&lt;&lt; Insert the homing commands here\n    pass\n\n    print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.initialisation","title":"<code>initialisation()</code>","text":"<p>Initialises the device, setup the connection, channels, motors and their parameters, etc.</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def initialisation(self) -&gt; None:\n    \"\"\"\n    Initialises the device, setup the connection, channels, motors and their parameters, etc.\n    \"\"\"\n    # Device parameters\n    ## &lt;&lt;&lt;&lt;&lt; Here, you can insert the device parameters and connection initialisation commands\n    pass\n\n    print('\\n&gt;&gt;&gt;&gt;&gt; Device and motor initialisation complete &lt;&lt;&lt;&lt;&lt;')\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement</p> required Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def move_continuous(self,dir:str) -&gt; None:\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n    \"\"\"\n    # Check if the motor is running, prevents command overlap\n    if False: # &lt;&lt;&lt;&lt;&lt; Insert the motor running condition check here if required\n        print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n        return\n\n    dir = self.dict_ctrl_remap[dir] # Remap the control\n\n    if dir == 'xfwd':\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor continuous movement commands here\n        pass\n    elif dir == 'xrev':\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor continuous movement commands here\n        pass\n    elif dir == 'yfwd':\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor continuous movement commands here\n        pass\n    elif dir == 'yrev':\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor continuous movement commands here\n        pass\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.move_direct","title":"<code>move_direct(coor_abs)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>tuple[float, float]</code> <p>the absolute coordinate to move to in [mm]</p> required Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def move_direct(self,coor_abs:tuple[float,float]) -&gt; None:\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the motor movement commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single jogging motion.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.</p> required Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def move_jog(self,direction:str) -&gt; None:\n    \"\"\"\n    Moves the motor with a single jogging motion.\n\n    Args:\n        direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n    \"\"\"\n\n    if not isinstance(direction, str):\n        raise ValueError(\"Direction must be a string\")\n\n    if direction not in ['xfwd','xrev','yfwd','yrev']:\n        raise ValueError(\"Direction must be 'xfwd', 'xrev', 'yfwd', 'yrev'\")\n\n    if False: # &lt;&lt;&lt;&lt;&lt; Insert the motor running condition check here if required\n        print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n        return\n\n    direction = self.dict_ctrl_remap[direction] # Remap the control\n\n    if direction == 'xfwd':\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor jog movement commands here\n        pass\n    elif direction == 'xrev':\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor jog movement commands here\n        pass\n    elif direction == 'yfwd':\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor jog movement commands here\n        pass\n    elif direction == 'yrev':\n        # &lt;&lt;&lt;&lt;&lt; Insert the motor jog movement commands here\n        pass\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.reinitialise_connection","title":"<code>reinitialise_connection()</code>","text":"<p>Reinitialise the connection to the device</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def reinitialise_connection(self) -&gt; None:\n    \"\"\"\n    Reinitialise the connection to the device\n    \"\"\"\n    try:self.terminate()\n    except Exception as e: print('Reinitialisation error:\\n{}'.format(e))\n\n    try:self.initialisation()\n    except Exception as e: print('Reinitialisation error:\\n{}'.format(e))\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100) -&gt; None:\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): Legacy parameter. Is ignored.\n        acc_rel (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n        raise ValueError(\"Distance must be a float\")\n\n    if False: # &lt;&lt;&lt;&lt;&lt; Insert the jog step size check here if required\n        raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min_um))\n\n    # &lt;&lt;&lt;&lt;&lt; Insert the jog step setting commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100) -&gt; None:\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): Legacy parameter. Is ignored.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if vel_move &lt; 0:\n        raise ValueError(\"Velocity and acceleration parameters must be larger than 0%\")\n    if vel_move &gt; 100:\n        raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n    # &lt;&lt;&lt;&lt;&lt; Insert the motor velocity and acceleration setting commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops the continuous movement of the motors</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def stop_move(self) -&gt; None:\n    \"\"\"\n    Stops the continuous movement of the motors\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the motor stop command here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.Class_XYController.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the operation and closes the connection to the device</p> Source code in <code>iris/controllers/class_xy_stage_controller.py</code> <pre><code>def terminate(self) -&gt; None:\n    \"\"\"\n    Terminates the operation and closes the connection to the device\n    \"\"\"\n    try:\n        # &lt;&lt;&lt;&lt;&lt; Insert the termination commands here\n        pass\n        print('xy_stage_controller: Connection closed')\n    except Exception as e:\n        print('xy_stage_controller: Error in closing the connection:\\n{}'.format(e))\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/class_xy_stage_controller/#iris.controllers.class_xy_stage_controller.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/","title":"class_z_stage_controller","text":"<p>Class definition for the z-stage controller and a guide to writing one for the Open Raman Microscopy (ORM) app.</p>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController","title":"<code>Class_ZController</code>","text":"Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>class Class_ZController():\n    def __init__(self,**kwargs) -&gt; None:\n\n        self._dict_ctrl_remap = {\n            'zfwd':ControllerDirectionEnum.ZFWD.value,\n            'zrev':ControllerDirectionEnum.ZREV.value\n        }   # Dictionary to remap the controls\n\n        # &lt;&lt;&lt;&lt;&lt; Insert the device parameters here\n\n        # Start by initializing the connection, device, motors, and their parameters\n        try:\n            self.initialisation()\n        except Exception as e:\n            print('Run ABORTED due to error in intialization:')\n            print(e)\n            self.terminate()\n\n        # Continue by setting up the motors and initializing (calibrating) the coordinate system of the motors\n        try:\n            if True: # &lt;&lt;&lt;&lt;&lt; Insert homing check condition here if required\n                self.set_vel_acc_relative()\n                self.homing_n_coor_calibration()\n        except Exception as e:\n            print('Coordinate calibration has failed:')\n            print(e)\n            self.terminate()\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the camera.\n\n        Returns:\n            str: The identifier of the camera\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the command to get the camera identifier here\n        identifier = \"ZStageController_ID: Not set\"\n        return identifier\n\n    def initialisation(self) -&gt; None:\n        \"\"\"\n        Initialises the parameters\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the initialisation commands here\n        pass\n\n    def get_vel_acc_relative(self) -&gt; tuple[float,float,float]:\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the velocity and acceleration retrieval commands here\n        vel = 100\n        pass\n        return (vel,vel,float(100))\n\n    def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100) -&gt; None:\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): Legacy parameter. Is ignored.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if vel_move &lt; 1 or vel_move &gt; 100:\n            raise ValueError(\"Velocity and acceleration parameters must be larger than 1% and smaller than 100%\")\n\n        if not isinstance(vel_move, int) and not isinstance(vel_move, float):\n            raise ValueError(\"Velocity must be an integer\")\n\n        # &lt;&lt;&lt;&lt;&lt; Insert the velocity and acceleration setting commands here\n        pass\n\n    def homing_n_coor_calibration(self) -&gt; None:\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        Also called as 'homing'\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the homing and coordinate calibration commands here\n        pass\n\n    def terminate(self) -&gt; None:\n        \"\"\"\n        Terminate the operation. Returns the stage to home and disconnects the device.\n        \"\"\"\n        try:\n            # &lt;&lt;&lt;&lt;&lt; Insert the termination commands here\n            pass\n        except Exception as e:\n            print('Error in closing the device:')\n            print(e)\n\n    def move_direct(self,coor_abs) -&gt; None:\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (float): coordinate of the destination [mm]\n        \"\"\"\n        if not isinstance(coor_abs, float) and not isinstance(coor_abs, int):\n            raise ValueError(\"Coordinate must be a float\")\n\n        # &lt;&lt;&lt;&lt;&lt; Insert the direct movement commands here\n        pass\n\n    def move_continuous(self,dir) -&gt; None:\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n        if False: # &lt;&lt;&lt;&lt;&lt; Insert the motor running check condition here\n            print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n            return\n\n        dir = self._dict_ctrl_remap[dir] # Remap the controls\n\n        if dir == 'zfwd':\n            # &lt;&lt;&lt;&lt;&lt; Insert the forward movement command here\n            pass\n        elif dir == 'zrev':\n            # &lt;&lt;&lt;&lt;&lt; Insert the forward movement command here\n            pass\n        else:\n            raise ValueError(\"Direction must be 'fwd' or 'rev'\")\n\n    def get_jog(self) -&gt; tuple[float,float,float]:\n        \"\"\"\n        Get the jog parameters for the motor\n\n        Returns:\n            tuple of floats: 3 elements: (jog_step [mm], jog_vel, jog_acc)\n\n        Note:\n            - jog_vel and jog_acc are not available in the MCM301 library\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the jog parameter retrieval commands here\n        jog_step_mm = 0.01\n\n        return (jog_step_mm, None, None)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100) -&gt; None:\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): Legacy parameter. Is ignored.\n            acc_rel (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n            raise ValueError(\"Distance must be a float\")\n\n        if False: # &lt;&lt;&lt;&lt;&lt; Insert the jog step size check condition here if required\n            raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n        # &lt;&lt;&lt;&lt;&lt; Insert the jog parameter setting commands here\n        pass\n\n    def move_jog(self,direction:str) -&gt; None:\n        \"\"\"\n        Moves the motor with a single/continuous jogging motion until a stop command.\n\n        Args:\n            direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n        if False: # &lt;&lt;&lt;&lt;&lt; Insert the motor running check condition here if required\n            print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n            return\n\n        direction = self._dict_ctrl_remap[direction] # Remap the controls\n\n        if direction == 'zfwd':\n            # &lt;&lt;&lt;&lt;&lt; Insert the forward jog movement command here\n            pass\n        elif direction == 'zrev':\n            # &lt;&lt;&lt;&lt;&lt; Insert the reverse jog movement command here\n            pass\n        else:\n            raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n    def stop_move(self) -&gt; None:\n        \"\"\"\n        Stops all motor movement. Will try 5 times before giving up.\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the stop movement commands here\n        pass\n\n    def _MoveTestAbsolute(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        distances = np.arange(0, 25, 2)\n        for i,distance in enumerate(distances):\n            print(i, distance)\n            self.move_direct(float(distance))\n\n    def _MoveTestJog(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        jog_step = 2 # [mm]\n        self.set_jog(jog_step)\n        for i in range(5):\n            print(self.get_coordinates())\n            self.move_jog('fwd')\n\n        jog_step = 1 # [mm]\n        self.set_jog(jog_step)\n        for i in range(10):\n            print(self.get_coordinates())\n            self.move_jog('rev')\n\n    def get_coordinates(self) -&gt; float:\n        \"\"\"\n        Get the coordinates of the motor [mm]\n        \"\"\"\n        # &lt;&lt;&lt;&lt;&lt; Insert the coordinate retrieval commands here\n        position_mm = float(0)\n        pass\n\n        return position_mm\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Get the coordinates of the motor [mm]</p> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def get_coordinates(self) -&gt; float:\n    \"\"\"\n    Get the coordinates of the motor [mm]\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the coordinate retrieval commands here\n    position_mm = float(0)\n    pass\n\n    return position_mm\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the camera.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the camera</p> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the camera.\n\n    Returns:\n        str: The identifier of the camera\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the command to get the camera identifier here\n    identifier = \"ZStageController_ID: Not set\"\n    return identifier\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.get_jog","title":"<code>get_jog()</code>","text":"<p>Get the jog parameters for the motor</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple of floats: 3 elements: (jog_step [mm], jog_vel, jog_acc)</p> Note <ul> <li>jog_vel and jog_acc are not available in the MCM301 library</li> </ul> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def get_jog(self) -&gt; tuple[float,float,float]:\n    \"\"\"\n    Get the jog parameters for the motor\n\n    Returns:\n        tuple of floats: 3 elements: (jog_step [mm], jog_vel, jog_acc)\n\n    Note:\n        - jog_vel and jog_acc are not available in the MCM301 library\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the jog parameter retrieval commands here\n    jog_step_mm = 0.01\n\n    return (jog_step_mm, None, None)\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def get_vel_acc_relative(self) -&gt; tuple[float,float,float]:\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the velocity and acceleration retrieval commands here\n    vel = 100\n    pass\n    return (vel,vel,float(100))\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. Also called as 'homing'</p> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def homing_n_coor_calibration(self) -&gt; None:\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    Also called as 'homing'\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the homing and coordinate calibration commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.initialisation","title":"<code>initialisation()</code>","text":"<p>Initialises the parameters</p> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def initialisation(self) -&gt; None:\n    \"\"\"\n    Initialises the parameters\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the initialisation commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def move_continuous(self,dir) -&gt; None:\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n    if False: # &lt;&lt;&lt;&lt;&lt; Insert the motor running check condition here\n        print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n        return\n\n    dir = self._dict_ctrl_remap[dir] # Remap the controls\n\n    if dir == 'zfwd':\n        # &lt;&lt;&lt;&lt;&lt; Insert the forward movement command here\n        pass\n    elif dir == 'zrev':\n        # &lt;&lt;&lt;&lt;&lt; Insert the forward movement command here\n        pass\n    else:\n        raise ValueError(\"Direction must be 'fwd' or 'rev'\")\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.move_direct","title":"<code>move_direct(coor_abs)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>float</code> <p>coordinate of the destination [mm]</p> required Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def move_direct(self,coor_abs) -&gt; None:\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (float): coordinate of the destination [mm]\n    \"\"\"\n    if not isinstance(coor_abs, float) and not isinstance(coor_abs, int):\n        raise ValueError(\"Coordinate must be a float\")\n\n    # &lt;&lt;&lt;&lt;&lt; Insert the direct movement commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single/continuous jogging motion until a stop command.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def move_jog(self,direction:str) -&gt; None:\n    \"\"\"\n    Moves the motor with a single/continuous jogging motion until a stop command.\n\n    Args:\n        direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n    if False: # &lt;&lt;&lt;&lt;&lt; Insert the motor running check condition here if required\n        print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n        return\n\n    direction = self._dict_ctrl_remap[direction] # Remap the controls\n\n    if direction == 'zfwd':\n        # &lt;&lt;&lt;&lt;&lt; Insert the forward jog movement command here\n        pass\n    elif direction == 'zrev':\n        # &lt;&lt;&lt;&lt;&lt; Insert the reverse jog movement command here\n        pass\n    else:\n        raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100) -&gt; None:\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): Legacy parameter. Is ignored.\n        acc_rel (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n        raise ValueError(\"Distance must be a float\")\n\n    if False: # &lt;&lt;&lt;&lt;&lt; Insert the jog step size check condition here if required\n        raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n    # &lt;&lt;&lt;&lt;&lt; Insert the jog parameter setting commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100) -&gt; None:\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): Legacy parameter. Is ignored.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if vel_move &lt; 1 or vel_move &gt; 100:\n        raise ValueError(\"Velocity and acceleration parameters must be larger than 1% and smaller than 100%\")\n\n    if not isinstance(vel_move, int) and not isinstance(vel_move, float):\n        raise ValueError(\"Velocity must be an integer\")\n\n    # &lt;&lt;&lt;&lt;&lt; Insert the velocity and acceleration setting commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops all motor movement. Will try 5 times before giving up.</p> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def stop_move(self) -&gt; None:\n    \"\"\"\n    Stops all motor movement. Will try 5 times before giving up.\n    \"\"\"\n    # &lt;&lt;&lt;&lt;&lt; Insert the stop movement commands here\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/class_z_stage_controller/#iris.controllers.class_z_stage_controller.Class_ZController.terminate","title":"<code>terminate()</code>","text":"<p>Terminate the operation. Returns the stage to home and disconnects the device.</p> Source code in <code>iris/controllers/class_z_stage_controller.py</code> <pre><code>def terminate(self) -&gt; None:\n    \"\"\"\n    Terminate the operation. Returns the stage to home and disconnects the device.\n    \"\"\"\n    try:\n        # &lt;&lt;&lt;&lt;&lt; Insert the termination commands here\n        pass\n    except Exception as e:\n        print('Error in closing the device:')\n        print(e)\n</code></pre>"},{"location":"reference/iris/controllers/mcm301_wrapper/","title":"mcm301_wrapper","text":"<p>Wrapper module for MCM301 SDK to handle import issues. This module properly imports the MCM301 SDK components and provides a clean interface.</p>"},{"location":"reference/iris/controllers/mcm301_wrapper/#iris.controllers.mcm301_wrapper.get_mcm301_class","title":"<code>get_mcm301_class()</code>","text":"<p>Get the MCM301 class, importing it if necessary.</p> <p>Returns:</p> Name Type Description <code>MCM301</code> <p>The MCM301 class from the SDK</p> Source code in <code>iris/controllers/mcm301_wrapper.py</code> <pre><code>def get_mcm301_class():\n    \"\"\"\n    Get the MCM301 class, importing it if necessary.\n\n    Returns:\n        MCM301: The MCM301 class from the SDK\n    \"\"\"\n    global _mcm301_class\n\n    if _mcm301_class is None:\n        _mcm301_class = setup_mcm301_imports()\n\n    return _mcm301_class\n</code></pre>"},{"location":"reference/iris/controllers/mcm301_wrapper/#iris.controllers.mcm301_wrapper.setup_mcm301_imports","title":"<code>setup_mcm301_imports()</code>","text":"<p>Set up the MCM301 SDK imports properly. This handles the path management and import order issues.</p> Source code in <code>iris/controllers/mcm301_wrapper.py</code> <pre><code>def setup_mcm301_imports():\n    \"\"\"\n    Set up the MCM301 SDK imports properly.\n    This handles the path management and import order issues.\n    \"\"\"\n    # Get the SDK directory path\n    sdk_path = os.path.abspath(ControllerSpecificConfigEnum.MCM301_SDK_DIRPATH.value)\n\n    # Add to path if not already there\n    if sdk_path not in sys.path:\n        sys.path.insert(0, sdk_path)\n\n    # Change to SDK directory temporarily to handle relative imports and DLL loading\n    original_cwd = os.getcwd()\n    try:\n        os.chdir(sdk_path)\n\n        # Import the modules in the correct order\n        # First import the type definitions\n        import MCM301_Type_Define\n\n        # Then import the command library\n        import MCM301_COMMAND_LIB\n\n        # Get the MCM301 class\n        MCM301 = MCM301_COMMAND_LIB.MCM301\n\n        # Update the library path to use the full path to the SDK directory\n        # This fixes the DLL loading issue\n        import platform\n        if platform.architecture()[0] == '64bit':\n            dll_name = \"MCM301Lib_x64.dll\"\n        else:\n            dll_name = \"MCM301Lib_Win32.dll\"\n\n        full_dll_path = os.path.join(sdk_path, dll_name)\n\n        # Create a wrapper class that sets the correct DLL path\n        class MCM301_Wrapper(MCM301):\n            def __init__(self):\n                # Override the library path before calling parent constructor\n                if not MCM301.isLoad:\n                    MCM301.load_library(full_dll_path)\n                super().__init__()\n\n        return MCM301_Wrapper\n\n    finally:\n        # Always restore the original working directory\n        os.chdir(original_cwd)\n</code></pre>"},{"location":"reference/iris/controllers/oceandirect_wrapper/","title":"oceandirect_wrapper","text":"<p>Wrapper module for Ocean Insight SDK to handle import and DLL loading issues. This module properly imports the Ocean Insight SDK components and provides a clean interface.</p>"},{"location":"reference/iris/controllers/oceandirect_wrapper/#iris.controllers.oceandirect_wrapper.create_oceandirect_api","title":"<code>create_oceandirect_api()</code>","text":"<p>Create an OceanDirectAPI instance with proper path handling. This function handles the DLL path issues during instantiation.</p> <p>Returns:</p> Name Type Description <code>OceanDirectAPI</code> <p>Properly instantiated API object</p> Source code in <code>iris/controllers/oceandirect_wrapper.py</code> <pre><code>def create_oceandirect_api():\n    \"\"\"\n    Create an OceanDirectAPI instance with proper path handling.\n    This function handles the DLL path issues during instantiation.\n\n    Returns:\n        OceanDirectAPI: Properly instantiated API object\n    \"\"\"\n    # Get the SDK directory path\n    sdk_path = os.path.abspath(ControllerSpecificConfigEnum.OCEANINSIGHT_API_DIRPATH.value)\n    sdk_parent_path = os.path.dirname(sdk_path)\n\n    # Change to SDK directory temporarily for DLL loading\n    original_cwd = os.getcwd()\n    try:\n        os.chdir(sdk_parent_path)\n\n        # Get the original classes\n        OceanDirectAPI, _, _ = get_oceandirect_classes()\n\n        # Create and return the API instance\n        return OceanDirectAPI()\n\n    finally:\n        # Always restore the original working directory\n        os.chdir(original_cwd)\n</code></pre>"},{"location":"reference/iris/controllers/oceandirect_wrapper/#iris.controllers.oceandirect_wrapper.get_oceandirect_classes","title":"<code>get_oceandirect_classes()</code>","text":"<p>Get the Ocean Direct classes, importing them if necessary.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(OceanDirectAPI, OceanDirectError, FeatureID) classes from the SDK</p> Source code in <code>iris/controllers/oceandirect_wrapper.py</code> <pre><code>def get_oceandirect_classes():\n    \"\"\"\n    Get the Ocean Direct classes, importing them if necessary.\n\n    Returns:\n        tuple: (OceanDirectAPI, OceanDirectError, FeatureID) classes from the SDK\n    \"\"\"\n    global _oceandirect_classes\n\n    if _oceandirect_classes is None:\n        # Import the base classes directly without wrapping\n        _oceandirect_classes = setup_oceandirect_imports()\n\n    return _oceandirect_classes\n</code></pre>"},{"location":"reference/iris/controllers/oceandirect_wrapper/#iris.controllers.oceandirect_wrapper.setup_oceandirect_imports","title":"<code>setup_oceandirect_imports()</code>","text":"<p>Set up the Ocean Insight SDK imports properly. This handles the path management and DLL loading issues.</p> Source code in <code>iris/controllers/oceandirect_wrapper.py</code> <pre><code>def setup_oceandirect_imports():\n    \"\"\"\n    Set up the Ocean Insight SDK imports properly.\n    This handles the path management and DLL loading issues.\n    \"\"\"\n    # Get the SDK directory path\n    sdk_path = os.path.abspath(ControllerSpecificConfigEnum.OCEANINSIGHT_API_DIRPATH.value)\n\n    # Add to path if not already there\n    if sdk_path not in sys.path:\n        sys.path.insert(0, sdk_path)\n\n    # Change to SDK directory temporarily to handle relative imports and DLL loading\n    # The Ocean Insight SDK uses relative paths for DLL loading, so we need to be in the right directory\n    original_cwd = os.getcwd()\n    try:\n        # Change to the parent directory of the oceandirect package\n        # This is because sdk_properties.py uses \"./oceandirect\" as the relative path\n        sdk_parent_path = os.path.dirname(sdk_path)\n        os.chdir(sdk_parent_path)\n\n        # Import the Ocean Direct modules\n        from oceandirect.OceanDirectAPI import OceanDirectAPI, OceanDirectError, FeatureID\n\n        return OceanDirectAPI, OceanDirectError, FeatureID\n\n    finally:\n        # Always restore the original working directory\n        os.chdir(original_cwd)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/","title":"raman_spectrometer_controller_Andor_dll","text":"<p>A class that allows the control of the Andor spectrometers.</p> <p>Self notes: This script is based on the Andor CCD iVac 416 though, the it should  be applicable to most of Andor's other spectrometers with minimal to no adjustments (aside from the advance features).</p> <p>Acknowledgement: pylablib as a learning material for the development of this controller, though no code from it has been reused in this controller.</p>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.SpectrometerController_Andor","title":"<code>SpectrometerController_Andor</code>","text":"<p>               Bases: <code>Class_SpectrometerController</code></p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>class SpectrometerController_Andor(Class_SpectrometerController):\n    def __init__(self):\n        self._lock = Lock()\n\n    # &gt;&gt;&gt; Device initialisation &lt;&lt;&lt;\n        init_dir = os.path.split(path_dll_andor)[0]\n        initialize(init_dir)\n\n        # Parameter intialisation\n        self._x_pixel, self._y_pixel = getDetector()\n        self._total_pixel = self._x_pixel * self._y_pixel\n\n        # Detector initialisation\n        self._set_ROI_parameters()\n\n        # Acquisition initialisation\n        setReadMode(mode='4. Image')\n        setAcquisitionMode(mode='5. RunTillAbort')\n        setKineticCycleTime(0.0)\n        setTriggerMode('10. Software Trigger')\n\n        if not isTriggerModeAvailable(mode='10. Software Trigger'):\n            raise SyntaxError('Trigger mode not available either due to hardware limitations or incorrect settings.'\\\n                '(e.g., Read mode has to be set to 4. Image, and Acquisition mode to 5. RunTillAbort)')\n\n        # Acquisition parameters\n        self._flg_isacquiring = threading.Event()\n        self._integration_time_us:int = 0\n        self._theoretical_wait_time_sec:float = 0.0\n\n        # Initialise the device for acquisition\n        self._identifier = None\n        self.initialisation()\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the unique identifier of the spectrometer controller.\n\n        Returns:\n            str: The unique identifier of the spectrometer controller.\n        \"\"\"\n        if self._identifier is None:\n            self._identifier = f\"Andor_{getCameraSerialNumber()}\"\n        return self._identifier\n\n    def initialisation(self):\n        \"\"\"\n        Initialises the spectrometer controller\n        \"\"\"\n        self._identifier = f\"Andor_{getCameraSerialNumber()}\"\n\n        self._initialise_cooler()\n        self._integration_time_us = self.get_integration_time_us()\n        self._start_acquisition()\n\n    def terminate(self):\n        \"\"\"\n        Terminates the spectrometer controller according to the manufacturer's protocol\n        \"\"\"\n        self._cooler_shutdown_protocol()\n        self._stop_acquisition()\n\n    def _initialise_cooler(self):\n        self._lock.acquire()\n        coolerON()\n        try: temp = int(ANDOR_OPE_TEMP)\n        except ValueError: temp = getTemperature()\n\n        try: setTemperature(temp)\n        except RuntimeError as e:\n            print(f\"Failed to set temperature: {e}\")\n            self._lock.release()\n            return\n\n        i=0\n        while getTemperature() &gt; temp + ANDOR_TEMP_INIT_MARGIN:\n            time.sleep(1)\n            i+=1\n            if i % 5 == 1:\n                print(f\"Cooling... Current: {getTemperature()} degC. Target: {ANDOR_OPE_TEMP} degC\")\n\n        try: checkCoolingStatus()\n        except RuntimeError as e:\n            temp = getTemperature()\n            print(f\"Cooling failed: {e}. Current: {temp} degC. Target: {ANDOR_OPE_TEMP} degC\")\n\n        self._lock.release()\n\n    def _cooler_shutdown_protocol(self):\n        \"\"\"\n        Shutdown protocol for the cooler.\n        \"\"\"\n        self._lock.acquire()\n        coolerOFF()\n        i=0\n        while getTemperature() &lt; SAFE_SHUTDOWN_TEMP:\n            time.sleep(1)\n            i+=1\n            if i % 5 == 1:\n                print(f\"Shutting down... Current: {getTemperature()} degC. Target: {SAFE_SHUTDOWN_TEMP} degC\")\n\n        self._lock.release()\n\n    def _set_ROI_parameters(self):\n        \"\"\"\n        Set the Region of Interest (ROI) parameters for the detector according to\n        the user-defined settings in the config.ini file.\n        \"\"\"\n        xmin_dev = 1\n        xmax_dev = self._x_pixel\n        ymin_dev = 1\n        ymax_dev = self._y_pixel\n\n        xmin_user = ControllerSpecificConfigEnum.ANDOR_ROI_COL_MIN.value\n        xmax_user = ControllerSpecificConfigEnum.ANDOR_ROI_COL_MAX.value\n        xbin_user = ControllerSpecificConfigEnum.ANDOR_ROI_BIN_COL.value\n\n        ymin_user = ControllerSpecificConfigEnum.ANDOR_ROI_ROW_MIN.value\n        ymax_user = ControllerSpecificConfigEnum.ANDOR_ROI_ROW_MAX.value\n        ybin_user = ControllerSpecificConfigEnum.ANDOR_ROI_BIN_ROW.value\n\n        xstart = max(xmin_dev, xmin_user)\n        xend = min(xmax_dev, xmax_user)\n        xbin = min(xbin_user, (xend-xstart+1))\n        assert (xend-xstart+1) % xbin == 0, f\"Invalid X ROI parameters: {xstart}, {xend}, {xbin}.\"\\\n            \"The bin must divide the range evenly. Either change the bin or the COL MIN/MAX values.\"\n\n        ystart = max(ymin_dev, ymin_user)\n        yend = min(ymax_dev, ymax_user)\n        ybin = min(ybin_user, (yend-ystart+1))\n\n        assert (yend-ystart+1) % ybin == 0, f\"Invalid Y ROI parameters: {ystart}, {yend}, {ybin}.\"\\\n            \"The bin must divide the range evenly. Either change the bin or the ROW MIN/MAX values.\"\n\n        setImage(hbin=xbin, vbin=ybin, hstart=xstart, hend=xend, vstart=ystart, vend=yend)\n\n        self._x_pixel = int((xend - xstart + 1)/xbin)\n        self._y_pixel = int((yend - ystart + 1)/ybin)\n        self._total_pixel = int(self._x_pixel * self._y_pixel)\n\n        print(f\"Binning parameters: xstart={xstart}, xend={xend}, xbin={xbin}, ystart={ystart}, yend={yend}, ybin={ybin}\")\n\n    def _start_acquisition(self):\n        with self._lock:\n            startAcquisition()\n            self._flg_isacquiring.set()\n\n    def _stop_acquisition(self):\n        with self._lock:\n            abortAcquisition()\n            self._flg_isacquiring.clear()\n\n    def get_integration_time_us(self) -&gt; int:\n        \"\"\"\n        Returns the integration time of the device\n\n        Returns:\n            int: Integration time in microseconds\n        \"\"\"\n        with self._lock:\n            exposure_sec,_,kineticCycle_sec = getAcquisitionTimings_sec()\n        self._integration_time_us = int(exposure_sec * 1e6)  # Convert seconds to microseconds\n        self._theoretical_wait_time_sec = kineticCycle_sec\n        return self._integration_time_us\n\n    def get_integration_time_limits_us(self):\n        \"\"\"\n        Get the integration time limits of the device\n\n        Returns:\n            tuple: A tuple containing the minimum, maximum, and increment of the integration time in [us]\n        \"\"\"\n        return (10, 1e9, 1)\n\n    def set_integration_time_us(self, integration_time:int) -&gt; int:\n        \"\"\"Sets the integration time of the device\n\n        Args:\n            integration_time (int): Integration time in [device unit] \n            (microseconds for the QE Pro)\n\n        Returns:\n            int: Device integrationt time after set up in microseconds\n        \"\"\"\n        if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n            raise ValueError(\"Integration time must be an integer\")\n        integration_time = int(integration_time)\n\n        with self._lock: setExposureTime(integration_time * 1e-6)\n\n        self._integration_time_us = self.get_integration_time_us()\n        return self._integration_time_us\n\n    def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n        \"\"\" \n        A function to measure the spectrum of the Raman spectrometer.\n\n        Returns:\n            tuple[pd.DataFrame, int, int]: A tuple containing the following:\n                - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                    intensity columns, from the config file. (as a global constant)\n                - int: The timestamp of the measurement in integer format (microseconds).\n                - int: The integration time used for the measurement in microseconds.\n        \"\"\"\n        with self._lock:\n            timestamp = get_timestamp_us_int()\n            sendSoftwareTrigger()\n            waitForAcquisitionTimeOut(self._theoretical_wait_time_sec * 1e3 * 1.5)\n            intensity = getMostRecentImage(self._x_pixel,self._y_pixel,self._total_pixel)\n\n        intensity = np.sum(intensity, axis=0).reshape(-1).tolist()\n        wavelength = np.arange(1,self._x_pixel+1).tolist()\n\n        intensity = [float(i) for i in intensity]\n        wavelength = [float(i) for i in wavelength]\n\n        spectra = pd.DataFrame({\n            DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: wavelength,\n            DataAnalysisConfigEnum.INTENSITY_LABEL.value: intensity,\n        })\n        return (spectra, timestamp, self._integration_time_us)\n\n    def _test_save_last_measurement_as_sif(self, path: str) -&gt; None:\n        \"\"\"\n        Test function to save the last measurement as a .sif file.\n\n        Args:\n            path (str): The full file path where the data should be saved.\n        \"\"\"\n        with self._lock:\n            saveAsSif(path)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.SpectrometerController_Andor.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the unique identifier of the spectrometer controller.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier of the spectrometer controller.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the unique identifier of the spectrometer controller.\n\n    Returns:\n        str: The unique identifier of the spectrometer controller.\n    \"\"\"\n    if self._identifier is None:\n        self._identifier = f\"Andor_{getCameraSerialNumber()}\"\n    return self._identifier\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.SpectrometerController_Andor.get_integration_time_limits_us","title":"<code>get_integration_time_limits_us()</code>","text":"<p>Get the integration time limits of the device</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the minimum, maximum, and increment of the integration time in [us]</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def get_integration_time_limits_us(self):\n    \"\"\"\n    Get the integration time limits of the device\n\n    Returns:\n        tuple: A tuple containing the minimum, maximum, and increment of the integration time in [us]\n    \"\"\"\n    return (10, 1e9, 1)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.SpectrometerController_Andor.get_integration_time_us","title":"<code>get_integration_time_us()</code>","text":"<p>Returns the integration time of the device</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Integration time in microseconds</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def get_integration_time_us(self) -&gt; int:\n    \"\"\"\n    Returns the integration time of the device\n\n    Returns:\n        int: Integration time in microseconds\n    \"\"\"\n    with self._lock:\n        exposure_sec,_,kineticCycle_sec = getAcquisitionTimings_sec()\n    self._integration_time_us = int(exposure_sec * 1e6)  # Convert seconds to microseconds\n    self._theoretical_wait_time_sec = kineticCycle_sec\n    return self._integration_time_us\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.SpectrometerController_Andor.initialisation","title":"<code>initialisation()</code>","text":"<p>Initialises the spectrometer controller</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def initialisation(self):\n    \"\"\"\n    Initialises the spectrometer controller\n    \"\"\"\n    self._identifier = f\"Andor_{getCameraSerialNumber()}\"\n\n    self._initialise_cooler()\n    self._integration_time_us = self.get_integration_time_us()\n    self._start_acquisition()\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.SpectrometerController_Andor.measure_spectrum","title":"<code>measure_spectrum()</code>","text":"<p>A function to measure the spectrum of the Raman spectrometer.</p> <p>Returns:</p> Type Description <code>tuple[DataFrame, int, int]</code> <p>tuple[pd.DataFrame, int, int]: A tuple containing the following: - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and     intensity columns, from the config file. (as a global constant) - int: The timestamp of the measurement in integer format (microseconds). - int: The integration time used for the measurement in microseconds.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n    \"\"\" \n    A function to measure the spectrum of the Raman spectrometer.\n\n    Returns:\n        tuple[pd.DataFrame, int, int]: A tuple containing the following:\n            - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                intensity columns, from the config file. (as a global constant)\n            - int: The timestamp of the measurement in integer format (microseconds).\n            - int: The integration time used for the measurement in microseconds.\n    \"\"\"\n    with self._lock:\n        timestamp = get_timestamp_us_int()\n        sendSoftwareTrigger()\n        waitForAcquisitionTimeOut(self._theoretical_wait_time_sec * 1e3 * 1.5)\n        intensity = getMostRecentImage(self._x_pixel,self._y_pixel,self._total_pixel)\n\n    intensity = np.sum(intensity, axis=0).reshape(-1).tolist()\n    wavelength = np.arange(1,self._x_pixel+1).tolist()\n\n    intensity = [float(i) for i in intensity]\n    wavelength = [float(i) for i in wavelength]\n\n    spectra = pd.DataFrame({\n        DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: wavelength,\n        DataAnalysisConfigEnum.INTENSITY_LABEL.value: intensity,\n    })\n    return (spectra, timestamp, self._integration_time_us)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.SpectrometerController_Andor.set_integration_time_us","title":"<code>set_integration_time_us(integration_time)</code>","text":"<p>Sets the integration time of the device</p> <p>Parameters:</p> Name Type Description Default <code>integration_time</code> <code>int</code> <p>Integration time in [device unit] </p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Device integrationt time after set up in microseconds</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def set_integration_time_us(self, integration_time:int) -&gt; int:\n    \"\"\"Sets the integration time of the device\n\n    Args:\n        integration_time (int): Integration time in [device unit] \n        (microseconds for the QE Pro)\n\n    Returns:\n        int: Device integrationt time after set up in microseconds\n    \"\"\"\n    if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n        raise ValueError(\"Integration time must be an integer\")\n    integration_time = int(integration_time)\n\n    with self._lock: setExposureTime(integration_time * 1e-6)\n\n    self._integration_time_us = self.get_integration_time_us()\n    return self._integration_time_us\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.SpectrometerController_Andor.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the spectrometer controller according to the manufacturer's protocol</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminates the spectrometer controller according to the manufacturer's protocol\n    \"\"\"\n    self._cooler_shutdown_protocol()\n    self._stop_acquisition()\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.abortAcquisition","title":"<code>abortAcquisition()</code>","text":"<p>Abort the current acquisition on the Andor SDK.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def abortAcquisition() -&gt; None:\n    \"\"\"\n    Abort the current acquisition on the Andor SDK.\n    \"\"\"\n    ret = AbortAcquisition()\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to abort acquisition: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.acquisition_test_img","title":"<code>acquisition_test_img(integration_time_ms=100.0)</code>","text":"<p>Run an image acquisition test with the specified integration time.</p> <p>Parameters:</p> Name Type Description Default <code>integration_time_ms</code> <code>float</code> <p>The integration time for the acquisition in milliseconds. Default is 100.0 ms.</p> <code>100.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The acquired image data.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def acquisition_test_img(integration_time_ms:float=100.0) -&gt; np.ndarray:\n    \"\"\"\n    Run an image acquisition test with the specified integration time.\n\n    Args:\n        integration_time_ms (float): The integration time for the acquisition in milliseconds. Default is 100.0 ms.\n\n    Returns:\n        np.ndarray: The acquired image data.\n    \"\"\"\n    print(\"&gt;&gt;&gt;&gt;&gt; Running image acquisition test... &lt;&lt;&lt;&lt;&lt;\")\n\n    setAcquisitionMode(mode='1. Single')\n    setReadMode(mode='4. Image')\n\n    pixelx,pixely = getDetector()\n    print(f\"Detector size (X, Y): {pixelx}, {pixely}\")\n\n    setExposureTime(integration_time_ms * 1e-3)\n    setTriggerMode('10. Software Trigger')\n    setNumberAccumulations(1)\n    setKineticCycleTime(0)\n    setImage(1, 1, 1, pixelx, 1, pixely)\n    print(f'Acquisition timings: {getAcquisitionTimings_sec()}')\n\n    kinetic_cycle_time_sec = getAcquisitionTimings_sec()[2]\n\n    t1 = time.time()\n    print('Acquiring image')\n    startAcquisition()\n\n    waitForAcquisitionTimeOut(kinetic_cycle_time_sec*1e3*1.5)\n    print(f'Image acquisition complete. Time taken: {time.time()-t1} sec')\n\n    img = getMostRecentImage(pixelx,pixely,pixelx*pixely)\n    return img\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.cancelWait","title":"<code>cancelWait()</code>","text":"<p>Cancel the wait for acquisition timeout.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def cancelWait() -&gt; None:\n    \"\"\"\n    Cancel the wait for acquisition timeout.\n    \"\"\"\n    ret = CancelWait()\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to cancel wait: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.checkCoolingStatus","title":"<code>checkCoolingStatus()</code>","text":"<p>Checks if the target temperature has been achieved.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the return value is not DRV_TEMPERATURE_STABILIZED. (either not reached, not stabilised, or error occurred)</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def checkCoolingStatus() -&gt; None:\n    \"\"\"\n    Checks if the target temperature has been achieved.\n\n    Raises:\n        RuntimeError: If the return value is not DRV_TEMPERATURE_STABILIZED.\n            (either not reached, not stabilised, or error occurred)\n    \"\"\"\n    current_temp = ctypes.c_int()\n    ret = GetTemperature(ctypes.byref(current_temp))\n    if ret != ErrorCodes.DRV_TEMPERATURE_STABILIZED.value:\n        raise RuntimeError(f\"Failed to get cooling status: {read_return_message(ret)}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.continuous_acquisition_test","title":"<code>continuous_acquisition_test(integration_time_ms=30.0)</code>","text":"<p>Run a continuous image acquisition test with the specified integration time and plots it.</p> <p>Parameters:</p> Name Type Description Default <code>integration_time_ms</code> <code>float</code> <p>The integration time for the acquisition in milliseconds. Default is 100.0 ms.</p> <code>30.0</code> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def continuous_acquisition_test(integration_time_ms:float=30.0) -&gt; None:\n    \"\"\"\n    Run a continuous image acquisition test with the specified integration time and plots it.\n\n    Args:\n        integration_time_ms (float): The integration time for the acquisition in milliseconds. Default is 100.0 ms.\n    \"\"\"\n    print(\"&gt;&gt;&gt;&gt;&gt; Running continuous image acquisition test... &lt;&lt;&lt;&lt;&lt;\")\n\n    pixelx,pixely = getDetector()\n    print(f\"Detector size (X, Y): {pixelx}, {pixely}\")\n\n    setReadMode(mode='4. Image')\n    start_pixel, height_pixel = 0, 255\n    setImage(hbin=1,vbin=height_pixel,hstart=1,hend=pixelx,vstart=start_pixel+1,vend=start_pixel+height_pixel)\n    setKineticCycleTime(0)\n    setAcquisitionMode(mode='5. RunTillAbort')\n\n    setExposureTime(integration_time_ms * 1e-3)\n\n    res = isTriggerModeAvailable('10. Software Trigger')\n    print(f'Trigger mode available: {res}')\n    setTriggerMode('10. Software Trigger')\n\n    print(f'Acquisition timings: {getAcquisitionTimings_sec()}')\n\n    kinetic_cycle_time_sec = getAcquisitionTimings_sec()[2]\n\n    print('Acquiring image')\n    startAcquisition()\n\n    fig, ax = plt.subplots()\n    ax:Axes\n    fig.show()\n\n    while True:\n        t1 = time.time()\n        sendSoftwareTrigger()\n        waitForAcquisitionTimeOut(kinetic_cycle_time_sec*1e3*1.5)\n\n        t2 = time.time()\n        img = getMostRecentImage(pixelx,1,pixelx*1)\n        arr = img.reshape(-1)\n        ax.clear()\n        ax.plot(arr)\n\n        t3 = time.time()\n        print(f'Acquisition time: {t2-t1:.3f} sec, Processing time: {t3-t2:.3f} sec')\n        if fig.waitforbuttonpress(10e-3): break\n\n    abortAcquisition()\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.coolerOFF","title":"<code>coolerOFF()</code>","text":"<p>Turn off the cooler of the Andor SDK.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def coolerOFF() -&gt; None:\n    \"\"\"\n    Turn off the cooler of the Andor SDK.\n    \"\"\"\n    ret = CoolerOFF()\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to turn off cooler: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.coolerON","title":"<code>coolerON()</code>","text":"<p>Turn on the cooler of the Andor SDK.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def coolerON() -&gt; None:\n    \"\"\"\n    Turn on the cooler of the Andor SDK.\n    \"\"\"\n    ret = CoolerON()\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to turn on cooler: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.getAcquisitionTimings_sec","title":"<code>getAcquisitionTimings_sec()</code>","text":"<p>Get the acquisition timings of the current instrument setup (readout and trigger settings). Refer to page 46 (Section 4 - Kinetic Series) of the Andor SDK2 programming manual.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The exposure time, accumulate cycle time, and kinetic cycle times, all in [sec]</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def getAcquisitionTimings_sec() -&gt; tuple[float, float, float]:\n    \"\"\"\n    Get the acquisition timings of the current instrument setup (readout and trigger settings).\n    Refer to page 46 (Section 4 - Kinetic Series) of the Andor SDK2 programming manual.\n\n    Returns:\n        tuple[float, float, float]: The exposure time, accumulate cycle time, and kinetic cycle times, all in [sec]\n    \"\"\"\n    exposure_time = ctypes.c_float()\n    accumulate_cycle_time = ctypes.c_float()\n    kinetic_cycle_time = ctypes.c_float()\n    ret = GetAcquisitionTimings(ctypes.byref(exposure_time), ctypes.byref(accumulate_cycle_time), ctypes.byref(kinetic_cycle_time))\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to get acquisition timings: {msg}\")\n    return exposure_time.value, accumulate_cycle_time.value, kinetic_cycle_time.value\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.getCameraSerialNumber","title":"<code>getCameraSerialNumber()</code>","text":"<p>Get the camera serial number.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The camera serial number.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def getCameraSerialNumber() -&gt; int:\n    \"\"\"\n    Get the camera serial number.\n\n    Returns:\n        int: The camera serial number.\n    \"\"\"\n    serial_number = ctypes.c_int()\n    ret = GetCameraSerialNumber(ctypes.byref(serial_number))\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to get camera serial number: {msg}\")\n    return serial_number.value\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.getDetector","title":"<code>getDetector()</code>","text":"<p>Get the sensor size [pixel x pixel]</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int,int]: The x and y pixels of the sensor in pixels.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def getDetector() -&gt; tuple[int,int]:\n    \"\"\"\n    Get the sensor size [pixel x pixel]\n\n    Returns:\n        tuple[int,int]: The x and y pixels of the sensor in pixels.\n    \"\"\"\n    x_pixel = ctypes.c_int()\n    y_pixel = ctypes.c_int()\n    ret = GetDetector(ctypes.byref(x_pixel), ctypes.byref(y_pixel))\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to get detector: {msg}\")\n    return x_pixel.value, y_pixel.value\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.getMostRecentImage","title":"<code>getMostRecentImage(xpixel, ypixel, total_pixels)</code>","text":"<p>Get the most recent image from the instrument.</p> <p>Parameters:</p> Name Type Description Default <code>xpixel</code> <code>int</code> <p>The x pixel size</p> required <code>ypixel</code> <code>int</code> <p>The y pixel size</p> required <code>total_pixels</code> <code>int</code> <p>The total number of pixels</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The most recent image</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def getMostRecentImage(xpixel:int,ypixel:int,total_pixels:int) -&gt; np.ndarray:\n    \"\"\"\n    Get the most recent image from the instrument.\n\n    Args:\n        xpixel (int): The x pixel size\n        ypixel (int): The y pixel size\n        total_pixels (int): The total number of pixels\n\n    Raises:\n        RuntimeError(\"Library is not initialised\")\n        RuntimeError(\"Unable to communicate with card\")\n        SyntaxError(\"Invalid pointer (i.e. NULL).\")\n        ValueError(\"Array size is incorrect.\")\n        BufferError(\"There is no new data yet\")\n\n    Returns:\n        np.ndarray: The most recent image\n    \"\"\"\n    total_pixels = xpixel*ypixel\n    image_array = (ctypes.c_long * total_pixels)()\n    total_pixels_long = ctypes.c_ulong(total_pixels)\n\n    ret = GetMostRecentImage(image_array, total_pixels_long)\n    if ret == ErrorCodes.DRV_NOT_INITIALIZED.value: raise RuntimeError(\"Library is not initialised\")\n    elif ret == ErrorCodes.DRV_ERROR_ACK.value: raise RuntimeError(\"Unable to communicate with card\")\n    elif ret == ErrorCodes.DRV_P1INVALID.value: raise SyntaxError(\"Invalid pointer (i.e. NULL).\")\n    elif ret == ErrorCodes.DRV_P2INVALID.value: raise ValueError(\"Array size is incorrect.\")\n    elif ret == ErrorCodes.DRV_NO_NEW_DATA.value: raise BufferError(\"There is no new data yet\")\n\n    return np.ctypeslib.as_array(image_array).reshape((ypixel, xpixel))\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.getTemperature","title":"<code>getTemperature()</code>","text":"<p>Get the current temperature of the Andor SDK.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current temperature [degC].</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def getTemperature() -&gt; int:\n    \"\"\"\n    Get the current temperature of the Andor SDK.\n\n    Returns:\n        int: The current temperature [degC].\n    \"\"\"\n    current_temp = ctypes.c_int()\n    GetTemperature(ctypes.byref(current_temp))\n    return current_temp.value\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.getTemperatureRange","title":"<code>getTemperatureRange()</code>","text":"<p>Get the temperature range of the Andor SDK.</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: The minimum and maximum temperature.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def getTemperatureRange() -&gt; tuple[float, float]:\n    \"\"\"\n    Get the temperature range of the Andor SDK.\n\n    Returns:\n        tuple[float, float]: The minimum and maximum temperature.\n    \"\"\"\n    min_temp = ctypes.c_float()\n    max_temp = ctypes.c_float()\n    ret = GetTemperatureRange(ctypes.byref(min_temp), ctypes.byref(max_temp))\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to get temperature range: {msg}\")\n    return min_temp.value, max_temp.value\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.initialize","title":"<code>initialize(dirpath)</code>","text":"<p>Initialize the Andor SDK and set the working directory.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If initialization fails.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def initialize(dirpath: str) -&gt; None:\n    \"\"\"\n    Initialize the Andor SDK and set the working directory.\n\n    Raises:\n        RuntimeError: If initialization fails.\n    \"\"\"\n    # Call the original function\n    ret = Initialize(dirpath.encode('utf-8'))\n    if read_return_message(ret):\n        raise RuntimeError(f\"Failed to initialize Andor SDK: {ret}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.isTriggerModeAvailable","title":"<code>isTriggerModeAvailable(mode)</code>","text":"<p>Check if the trigger mode is available on the instrument.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal</code> <p>The trigger mode to check.</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def isTriggerModeAvailable(mode:Literal[ '0. Internal', '1. External', '6. External Start',\n    '7. External Exposure (Bulb)', '9. External FVB EM', '10. Software Trigger',\n    '12. External Charge Shifting']) -&gt; bool:\n    \"\"\"\n    Check if the trigger mode is available on the instrument.\n\n    Args:\n        mode (Literal): The trigger mode to check.\n    \"\"\"\n    mode_idx = int(mode.split('.')[0])\n    ret = IsTriggerModeAvailable(ctypes.c_int(mode_idx))\n    if ret == ErrorCodes.DRV_SUCCESS.value: mode_available = True\n    elif ret == ErrorCodes.DRV_INVALID_MODE.value: mode_available = False\n    else: raise RuntimeError(f\"Failed to check trigger mode availability: {read_return_message(ret)}\")\n    return mode_available\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.plot_img","title":"<code>plot_img(img)</code>","text":"<p>Plot the acquired image and its profiles.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>The acquired image data.</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def plot_img(img:np.ndarray):\n    \"\"\"\n    Plot the acquired image and its profiles.\n\n    Args:\n        img (np.ndarray): The acquired image data.\n    \"\"\"\n    profile_x = np.sum(img, axis=0)\n    profile_y = np.sum(img, axis=1)\n    y_pixel_indices = np.arange(len(profile_y))\n\n    plt.figure(figsize=(12.5,7.5))\n\n    plt.subplot(2,2,1)\n    plt.imshow(img, cmap='inferno')\n    plt.title('Acquired Image')\n    plt.gca().invert_yaxis()\n    plt.colorbar()\n\n    plt.subplot(2,2,2)\n    plt.plot(profile_y, y_pixel_indices)\n    plt.title('Sum Y Profile')\n    plt.xlabel('Intensity')\n    plt.ylabel('Pixel Index')\n\n    plt.subplot(2,2,3)\n    plt.plot(profile_x)\n    plt.title('Sum X Profile')\n    plt.xlabel('Pixel Index')\n    plt.ylabel('Intensity')\n\n    plt.show()\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.prepareAcquisition","title":"<code>prepareAcquisition()</code>","text":"<p>Prepare the acquisition. It is also automatically called by startAcquisition but, calling this early might save time prior to the actual acquisition.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def prepareAcquisition() -&gt; None:\n    \"\"\"\n    Prepare the acquisition. It is also automatically called by startAcquisition\n    but, calling this early might save time prior to the actual acquisition.\n    \"\"\"\n    ret = PrepareAcquisition()\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to prepare acquisition: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.read_return_message","title":"<code>read_return_message(error_code)</code>","text":"<p>Returns the error message corresponding to the given error code.</p> <p>Parameters:</p> Name Type Description Default <code>error_code</code> <code>int</code> <p>The error code to look up.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The corresponding error message, or None if the code is for DRV_SUCCESS.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def read_return_message(error_code) -&gt; str|None:\n    \"\"\"\n    Returns the error message corresponding to the given error code.\n\n    Args:\n        error_code (int): The error code to look up.\n\n    Returns:\n        str: The corresponding error message, or None if the code is for DRV_SUCCESS.\n    \"\"\"\n    if error_code == ErrorCodes.DRV_SUCCESS.value: return None\n    try: return ErrorCodes(error_code).name\n    except ValueError: return \"Unknown error\"\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.saveAsSif","title":"<code>saveAsSif(path)</code>","text":"<p>Saves the data from the last acquisition into a .sif file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The full file path where the data should be saved.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>System not initialized or communication error.</p> <code>ChildProcessError</code> <p>Acquisition is still in progress.</p> <code>ValueError</code> <p>Invalid filename/path.</p> <code>MemoryError</code> <p>File too large to be generated in memory.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def saveAsSif(path: str) -&gt; None:\n    \"\"\"\n    Saves the data from the last acquisition into a .sif file.\n\n    Args:\n        path (str): The full file path where the data should be saved.\n\n    Raises:\n        RuntimeError: System not initialized or communication error.\n        ChildProcessError: Acquisition is still in progress.\n        ValueError: Invalid filename/path.\n        MemoryError: File too large to be generated in memory.\n    \"\"\"\n\n    # Convert python string to bytes for the C function\n    path_bytes = path.encode('utf-8')\n\n    ret = SaveAsSif(path_bytes)\n\n    # Error Handling based on documentation provided\n    if ret == ErrorCodes.DRV_SUCCESS.value:\n        return\n    elif ret == ErrorCodes.DRV_NOT_INITIALIZED.value:\n        raise RuntimeError(\"System not initialized.\")\n    elif ret == ErrorCodes.DRV_ACQUIRING.value:\n        raise ChildProcessError(\"Acquisition in progress.\")\n    elif ret == ErrorCodes.DRV_ERROR_ACK.value:\n        raise RuntimeError(\"Unable to communicate with card.\")\n    elif ret == ErrorCodes.DRV_P1INVALID.value:\n        raise ValueError(f\"Invalid filename or path: {path}\")\n    elif ret == ErrorCodes.DRV_ERROR_PAGELOCK.value:\n        raise MemoryError(\"File too large to be generated in memory.\")\n    else:\n        raise Exception(f\"Unknown error occurred. Return code: {ret}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.sendSoftwareTrigger","title":"<code>sendSoftwareTrigger()</code>","text":"<p>Send a software trigger to the instrument</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def sendSoftwareTrigger() -&gt; None:\n    \"\"\"\n    Send a software trigger to the instrument\n    \"\"\"\n    ret = SendSoftwareTrigger()\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to send software trigger: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.setAcquisitionMode","title":"<code>setAcquisitionMode(mode)</code>","text":"<p>Set the acquisition mode of the Andor SDK.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal['1. Single', '2. Accumulate', '3. Kinetics', '4. FastKinetics', '5. RunTillAbort']</code> <p>The acquisition mode to set.</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def setAcquisitionMode(mode:Literal['1. Single','2. Accumulate','3. Kinetics','4. FastKinetics','5. RunTillAbort']) -&gt; None:\n    \"\"\"\n    Set the acquisition mode of the Andor SDK.\n\n    Args:\n        mode (Literal['1. Single','2. Accumulate','3. Kinetics','4. FastKinetics','5. RunTillAbort']): The acquisition mode to set.\n    \"\"\"\n    if mode not in ['1. Single','2. Accumulate','3. Kinetics','4. FastKinetics','5. RunTillAbort']: raise ValueError(f\"Invalid acquisition mode: {mode}\")\n    mode_cint = ctypes.c_int(int(mode.split('.')[0]))\n    ret = SetAcquisitionMode(mode_cint)\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to set acquisition mode: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.setExposureTime","title":"<code>setExposureTime(exposure_time_sec)</code>","text":"<p>Set the exposure time for the Andor SDK.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def setExposureTime(exposure_time_sec:float) -&gt; None:\n    \"\"\"\n    Set the exposure time for the Andor SDK.\n    \"\"\"\n    exposure_time_sec = float(exposure_time_sec)\n    exposure_time_cfloat = ctypes.c_float(exposure_time_sec)\n    ret = SetExposureTime(exposure_time_cfloat)\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to set exposure time: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.setImage","title":"<code>setImage(hbin, vbin, hstart, hend, vstart, vend)</code>","text":"<p>Set the image parameters for the instrument (only for the 'Image' mode!). Example to get a full image: SetImage(1,1,1,1024,1,256) for a 1024x256 detector. Refer to page 41 (Section 3 - Readout modes - Image) of the Andor SDK2 programming manual for more details.</p> <p>Parameters:</p> Name Type Description Default <code>hbin</code> <code>int</code> <p>Number of pixels to bin horizontally.</p> required <code>vbin</code> <code>int</code> <p>Number of pixels to bin vertically.</p> required <code>hstart</code> <code>int</code> <p>Start column (inclusive).</p> required <code>hend</code> <code>int</code> <p>End column (inclusive).</p> required <code>vstart</code> <code>int</code> <p>Start row (inclusive).</p> required <code>vend</code> <code>int</code> <p>End row (inclusive).</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def setImage(hbin:int, vbin:int, hstart:int, hend:int, vstart:int, vend:int) -&gt; None:\n    \"\"\"\n    Set the image parameters for the instrument (only for the 'Image' mode!).\n    Example to get a full image: SetImage(1,1,1,1024,1,256) for a 1024x256 detector.\n    Refer to page 41 (Section 3 - Readout modes - Image) of the Andor SDK2 programming manual\n    for more details.\n\n    Args:\n        hbin (int): Number of pixels to bin horizontally.\n        vbin (int): Number of pixels to bin vertically.\n        hstart (int): Start column (inclusive).\n        hend (int): End column (inclusive).\n        vstart (int): Start row (inclusive).\n        vend (int): End row (inclusive).\n    \"\"\"\n    ret = SetImage(ctypes.c_int(hbin), ctypes.c_int(vbin), ctypes.c_int(hstart), ctypes.c_int(hend), ctypes.c_int(vstart), ctypes.c_int(vend))\n\n    if ret == ErrorCodes.DRV_NOT_INITIALIZED.value: raise RuntimeError('System not initialized')\n    elif ret == ErrorCodes.DRV_ACQUIRING.value: raise RuntimeError('Acquisition in progress')\n    elif ret == ErrorCodes.DRV_P1INVALID.value: raise ValueError('Horizontal binning parameters invalid')\n    elif ret == ErrorCodes.DRV_P2INVALID.value: raise ValueError('Vertical binning parameters invalid')\n    elif ret == ErrorCodes.DRV_P3INVALID.value: raise ValueError('Horizontal start sub-area co-ordinate is invalid')\n    elif ret == ErrorCodes.DRV_P4INVALID.value: raise ValueError('Horizontal end sub-area co-ordinate is invalid')\n    elif ret == ErrorCodes.DRV_P5INVALID.value: raise ValueError('Vertical start sub-area co-ordinate is invalid')\n    elif ret == ErrorCodes.DRV_P6INVALID.value: raise ValueError('Vertical end sub-area co-ordinate is invalid')\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.setKineticCycleTime","title":"<code>setKineticCycleTime(time_sec)</code>","text":"<p>Set the kinetic cycle time for the Andor SDK.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def setKineticCycleTime(time_sec: float) -&gt; None:\n    \"\"\"\n    Set the kinetic cycle time for the Andor SDK.\n    \"\"\"\n    time_sec = float(time_sec)\n    time_sec_cfloat = ctypes.c_float(time_sec)\n    ret = SetKineticCycleTime(time_sec_cfloat)\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to set kinetic cycle time: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.setNumberAccumulations","title":"<code>setNumberAccumulations(num_accum)</code>","text":"<p>This function will set the number of scans accumulated in memory. This will only take effect if the acquisition mode is either Accumulate or Kinetic Series.</p> <p>Parameters:</p> Name Type Description Default <code>num_accum</code> <code>int</code> <p>The number of accumulations to set.</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def setNumberAccumulations(num_accum:int) -&gt; None:\n    \"\"\"\n    This function will set the number of scans accumulated in memory. This will only take\n    effect if the acquisition mode is either Accumulate or Kinetic Series.\n\n    Args:\n        num_accum (int): The number of accumulations to set.\n    \"\"\"\n    num_accum = int(num_accum)\n    num_accum_cint = ctypes.c_int(num_accum)\n    ret = SetNumberAccumulations(num_accum_cint)\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to set number of accumulations: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.setReadMode","title":"<code>setReadMode(mode)</code>","text":"<p>Set the read mode of the Andor SDK.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def setReadMode(mode:Literal['0. Full Vertical Binning', '1. Multi-Track', '2. Random-Track',\n                             '3. Single-Track', '4. Image']) -&gt; None:\n    \"\"\"\n    Set the read mode of the Andor SDK.\n\n    Args:\n        mode (Literal['0. Full Vertical Binning', '1. Multi-Track', '2. Random-Track',\n            '3. Single-Track', '4. Image']): The read mode to set.\n    \"\"\"\n    if mode not in ['0. Full Vertical Binning', '1. Multi-Track', '2. Random-Track',\n                    '3. Single-Track', '4. Image']: raise ValueError(f\"Invalid read mode: {mode}\")\n    mode_cint = ctypes.c_int(int(mode.split('.')[0]))\n    ret = SetReadMode(mode_cint)\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to set read mode: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.setSingleTrack","title":"<code>setSingleTrack(centre_pixel, height_pixel)</code>","text":"<p>Set the single track mode for the Andor SDK.</p> <p>Parameters:</p> Name Type Description Default <code>centre_pixel</code> <code>int</code> <p>The centre pixel for the single track.</p> required <code>height_pixel</code> <code>int</code> <p>The height pixel for the single track.</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def setSingleTrack(centre_pixel:int,height_pixel:int) -&gt; None:\n    \"\"\"\n    Set the single track mode for the Andor SDK.\n\n    Args:\n        centre_pixel (int): The centre pixel for the single track.\n        height_pixel (int): The height pixel for the single track.\n    \"\"\"\n    centre_pixel = int(centre_pixel)\n    height_pixel = int(height_pixel)\n    centre_pixel_cint = ctypes.c_int(centre_pixel)\n    height_pixel_cint = ctypes.c_int(height_pixel)\n    ret = SetSingleTrack(centre_pixel_cint, height_pixel_cint)\n    if ret == ErrorCodes.DRV_P1INVALID.value:\n        raise ValueError('Centre row invalid')\n    elif ret == ErrorCodes.DRV_P2INVALID.value:\n        raise ValueError('Track height invalid')\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.setTemperature","title":"<code>setTemperature(target_temp)</code>","text":"<p>Set the temperature of the Andor SDK.</p> <p>Parameters:</p> Name Type Description Default <code>target_temp</code> <code>int</code> <p>The target temperature to set [degC].</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def setTemperature(target_temp: int) -&gt; None:\n    \"\"\"\n    Set the temperature of the Andor SDK.\n\n    Args:\n        target_temp (int): The target temperature to set [degC].\n    \"\"\"\n    target_temp = int(target_temp)\n    ret = SetTemperature(ctypes.c_int(target_temp))\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to set temperature: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.setTriggerMode","title":"<code>setTriggerMode(mode)</code>","text":"<p>Check if the trigger mode is available on the instrument.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal</code> <p>The trigger mode to set.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the trigger mode cannot be set.</p> <code>ValueError</code> <p>If the trigger mode is invalid.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def setTriggerMode(mode:Literal[ '0. Internal', '1. External', '6. External Start',\n    '7. External Exposure (Bulb)', '9. External FVB EM', '10. Software Trigger',\n    '12. External Charge Shifting']) -&gt; bool:\n    \"\"\"\n    Check if the trigger mode is available on the instrument.\n\n    Args:\n        mode (Literal): The trigger mode to set.\n\n    Raises:\n        RuntimeError: If the trigger mode cannot be set.\n        ValueError: If the trigger mode is invalid.\n    \"\"\"\n    if mode not in ['0. Internal', '1. External', '6. External Start',\n                    '7. External Exposure (Bulb)', '9. External FVB EM', '10. Software Trigger',\n                    '12. External Charge Shifting']:\n        raise ValueError(f\"Invalid trigger mode: {mode}\")\n    mode_idx = int(mode.split('.')[0])\n    ret = SetTriggerMode(ctypes.c_int(mode_idx))\n    if ret == ErrorCodes.DRV_SUCCESS.value: return True\n    elif ret == ErrorCodes.DRV_NOT_INITIALIZED.value: raise RuntimeError('System not initialized.')\n    elif ret == ErrorCodes.DRV_ACQUIRING.value: raise RuntimeError('Acquisition in progress.')\n    elif ret == ErrorCodes.DRV_P1INVALID.value: raise ValueError('Invalid trigger mode.')\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the Andor SDK and release resources.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def shutdown() -&gt; None:\n    \"\"\"\n    Shutdown the Andor SDK and release resources.\n    \"\"\"\n    try: abortAcquisition()\n    except: pass\n\n    ret = Shutdown()\n    if read_return_message(ret):\n        raise RuntimeError(f\"Failed to shutdown Andor SDK: {ret}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.startAcquisition","title":"<code>startAcquisition()</code>","text":"<p>Start the acquisition on the Andor SDK.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def startAcquisition() -&gt; None:\n    \"\"\"\n    Start the acquisition on the Andor SDK.\n    \"\"\"\n    ret = StartAcquisition()\n    msg = read_return_message(ret)\n    if msg: raise RuntimeError(f\"Failed to start acquisition: {msg}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_dll/#iris.controllers.raman_spectrometer_controller_Andor_dll.waitForAcquisitionTimeOut","title":"<code>waitForAcquisitionTimeOut(timeout_ms)</code>","text":"<p>Wait for the acquisition to complete or time out.</p> <p>Parameters:</p> Name Type Description Default <code>timeout_ms</code> <code>int</code> <p>The timeout duration in milliseconds.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the acquisition completed successfully, False if it timed out.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_dll.py</code> <pre><code>def waitForAcquisitionTimeOut(timeout_ms:int) -&gt; bool:\n    \"\"\"\n    Wait for the acquisition to complete or time out.\n\n    Args:\n        timeout_ms (int): The timeout duration in milliseconds.\n\n    Returns:\n        bool: True if the acquisition completed successfully, False if it timed out.\n    \"\"\"\n    timeout_ms = int(timeout_ms)\n    ret = WaitForAcquisitionTimeOut(ctypes.c_int(timeout_ms))\n    if ret == ErrorCodes.DRV_NO_NEW_DATA.value: return False\n    else: return True\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/","title":"raman_spectrometer_controller_Andor_pylablib","text":"<p>A class that allows the control of the Andor spectrometers.</p> <p>Technical notes: This script is based on the Andor CCD iVac 316 though, the it should  be applicable to most of Andor's other spectrometers with minimal to no adjustments (aside from the advance features).</p> <p>Acknowledgement: pylablib for the library that provides the interface to the spectrometer.</p>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.SectrometerController_AndorSDK2","title":"<code>SectrometerController_AndorSDK2</code>","text":"<p>               Bases: <code>Class_SpectrometerController</code></p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_pylablib.py</code> <pre><code>class SectrometerController_AndorSDK2(Class_SpectrometerController):\n    def __init__(self,monitor_temp:bool=False) -&gt; None:\n        # &gt; Devices &lt;\n        self._dev:Andor.AndorSDK2Camera = None\n\n        # &gt; Operational parameters\n        self._ope_temperature_degC = None   # Temperature of the device in degrees Celsius\n        self._enable_cooler = True          # Enable the cooler functionality\n        self._flg_monitor_temp = monitor_temp\n\n        # &gt; Locks &lt;\n        self._lock = Lock()     # Lock for the acquisition process\n        self._flg_monitortemp_isrunning = threading.Event()\n\n        # &gt; Device parameters &lt;\n        self.integration_time_min = 1000    # Minimum device integration time in [microsec]\n        self.integration_time_max = 1e10    # Maximum device integration time in [microsec]\n        self.integration_time_inc = 10      # Integration time increment in [microsec]\n\n        # Internal parameters\n        self._integration_time_devUnit = 0.0    # Integration time (stored in the object, NOT the unit) in the device's unit\n\n        self._identifier = None\n        # Start the initialisation process\n        self.initialisation()\n\n        print('NOT YET IMPLEMENTED: ROI AND BINNING')\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the unique identifier of the spectrometer controller.\n\n        Returns:\n            str: The unique identifier of the spectrometer controller.\n        \"\"\"\n        if self._identifier is None:\n            self._identifier = f\"Andor_{self._dev.get_device_info()}\"\n        return self._identifier\n\n# Core functionalities (initialisation, termination)\n    def initialisation(self) -&gt; None:\n        \"\"\"\n        Initializes the Raman spectrometer controller.\n        \"\"\"\n        self._dev = Andor.AndorSDK2Camera()\n        self._identifier = f\"Andor_{self._dev.get_device_info()}\"\n        print(f'&gt;&gt;&gt;&gt;&gt; CONNECTED TO {self._dev.get_device_info()} &lt;&lt;&lt;&lt;&lt;')\n\n        # &gt; Monitor temperature if requested\n        if self._flg_monitor_temp: self.monitor_temperature()\n\n        # &gt; Initialise the cooler\n        self._enable_cooler = True\n        try: temp = float(ControllerSpecificConfigEnum.ANDOR_OPERATIONAL_TEMPERATURE.value)\n        except: temp = self._dev.get_temperature(); self._enable_cooler = False\n        self._dev.set_temperature(temp,enable_cooler=self._enable_cooler)\n        print(f'Cooler enabled: {self._enable_cooler}, temperature: {temp}degC')\n\n        if self._enable_cooler: self._wait_temperature(temp,cooling=True)\n\n        # &gt; Initialise the acquisition mode\n        self._dev.setup_shutter(mode='auto')\n        self._dev.set_trigger_mode(mode='int')\n        self._dev.set_acquisition_mode('cont')\n        # self._dev.set_acquisition_mode('single')\n        print(f'Acquisition parameters: {self._dev.get_acquisition_parameters()}')\n\n        # &gt; Set the ROI and binning\n        try: self._set_ROI_binning()\n        except Exception as e: print(f'ROI and binning ERROR: {e}')\n        finally: print(f'ROI and binning: {self._dev.get_roi()}')\n\n\n    def terminate(self) -&gt; None:\n        \"\"\"\n        To terminate the connections to the Raman spectrometers\n        \"\"\"\n        # Stop the auto measurement\n        # if self._dev.acquisition_in_progress(): self._dev.stop_acquisition()\n\n        # Turn off the cooler\n        try: temp = float(ControllerSpecificConfigEnum.ANDOR_TERMINATION_TEMPERATURE.value)\n        except: temp = DEFAULT_TEMRINATION_TEMPERATURE\n        if not self._enable_cooler: temp = self._dev.get_temperature()\n\n        self._dev.set_temperature(temperature=temp, enable_cooler=False)\n        if self._dev.is_cooler_on(): self._dev.set_cooler(False)\n\n        print(f'Termination temperature: {temp}')\n\n        if self._enable_cooler: self._wait_temperature(temp,cooling=False)\n        print(f'Device back to termination temp')\n\n        self._dev.close()\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n\n    def _set_ROI_binning(self) -&gt; None:\n        \"\"\"\n        Set the region of interest (ROI) of the device\n        \"\"\"\n        # &gt; ROI and binning\n        # row: horizontal (h), col: vertical (v)\n        hlim,vlim = self._dev.get_roi_limits()\n        hmin, hmax, hpstep, hsstep, hmaxbin = hlim\n        hbin = min(hmaxbin,ControllerSpecificConfigEnum.ANDOR_ROI_BIN_ROW.value,\n                   (ControllerSpecificConfigEnum.ANDOR_ROI_ROW_MAX.value-ControllerSpecificConfigEnum.ANDOR_ROI_ROW_MIN.value))\n        hstart = max(hmin,ControllerSpecificConfigEnum.ANDOR_ROI_BIN_ROW.value)\n        hend = min(hmax,ControllerSpecificConfigEnum.ANDOR_ROI_ROW_MAX.value)\n\n        vmin, vmax, vpstep, vsstep, vmaxbin = vlim\n        vbin = min(vmaxbin,ControllerSpecificConfigEnum.ANDOR_ROI_BIN_COL.value,\n                     (ControllerSpecificConfigEnum.ANDOR_ROI_COL_MAX.value-ControllerSpecificConfigEnum.ANDOR_ROI_COL_MIN.value))\n        vstart = max(vmin,ControllerSpecificConfigEnum.ANDOR_ROI_BIN_COL.value)\n        vend = min(vmax,ControllerSpecificConfigEnum.ANDOR_ROI_COL_MAX.value)\n\n        self._dev.set_roi(\n            hstart=hstart,\n            hend=hend,\n            vstart=vstart,\n            vend=vend,\n            hbin=hbin,\n            vbin=vbin\n        )\n\n    def get_integration_time_limits_us(self) -&gt; tuple[int,int,int]:\n        \"\"\"\n        Get the integration time limits of the device\n\n        Returns:\n            tuple: A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)\n        \"\"\"\n        return (self.integration_time_min, self.integration_time_max, self.integration_time_inc)\n\n    def get_integration_time_us(self) -&gt; int:\n        \"\"\"\n        Get the integration time of the device\n\n        Returns:\n            int: Integration time in microseconds\n        \"\"\"\n        with self._lock:\n            if self._dev.acquisition_in_progress(): self._dev.stop_acquisition()\n            self._integration_time_devUnit = self._dev.get_exposure()\n\n        int_time_us = self._integration_time_devUnit*1e6\n        return int_time_us\n\n    def set_integration_time_us(self,integration_time:int) -&gt; int:\n        \"\"\"Sets the integration time of the device\n\n        Args:\n            integration_time (int): Integration time in [device unit] \n            (microseconds for the QE Pro)\n\n        Returns:\n            int: Device integrationt time after set up in microseconds\n        \"\"\"\n\n        print('work here (raman spectrometer controller file)')\n\n        if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n            raise ValueError(\"Integration time must be an integer\")\n        integration_time = int(integration_time)\n\n        with self._lock:\n            if self._dev.acquisition_in_progress(): self._dev.stop_acquisition()\n            self._dev.set_exposure(integration_time*1e-6)\n        int_time = self.get_integration_time_us()\n        print(int_time)\n\n        return int_time\n\n    def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n        \"\"\" \n        A function to measure the spectrum of the Raman spectrometer.\n\n        Returns:\n            tuple[pd.DataFrame, int, int]: A tuple containing the following:\n                - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                    intensity columns, from the config file. (as a global constant)\n                - int: The timestamp of the measurement in integer format (microseconds).\n                - int: The integration time used for the measurement in microseconds.\n        \"\"\"\n        with self._lock:\n            if not self._dev.acquisition_in_progress(): self._dev.start_acquisition()\n\n        # img:np.ndarray = self._dev.snap(timeout=self._integration_time_devUnit)\n        # self._dev.wait_for_frame()\n        # img:np.ndarray = self._dev.read_newest_image(return_info=False)\n        # img = self._dev.grab(1)\n        time1 = time.time()\n        with self._lock:\n            self._dev.wait_for_frame(\"lastwait\")    # Pretty slow, at around 390millisec waiting time\n            img:np.ndarray = self._dev.read_newest_image()\n\n        # print(img)\n        # print(f'image shape: {img.shape}')\n        # plt.imshow(img)\n        # plt.show()\n\n        timestamp = get_timestamp_us_int()\n        # print(f'reading time: {(time.time()-time1)*1e3} millisec')\n        # self._dev.stop_acquisition()\n        # print(img)\n        list_intensity = np.mean(img,axis=0)\n        list_wavelength = list(range(len(list_intensity)+1,1,-1))\n\n        list_wavelength = [float(wavelength) for wavelength in list_wavelength]\n        list_intensity = [float(intensity) for intensity in list_intensity]\n\n        integration_time = self.get_integration_time_us()\n\n        spectra = pd.DataFrame({\n            DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: list_wavelength,\n            DataAnalysisConfigEnum.INTENSITY_LABEL.value: list_intensity,\n        })\n        return (spectra, timestamp, integration_time)\n\n    def _wait_temperature(self,target_temperature:float,cooling:bool):\n        \"\"\"\n        Waits for the device temperature to reach the target temperature\n\n        Args:\n            target_temperature (float): The target temperature\n            cooling (bool): If True, will return when the device temperature is lower than the target\n                temperature. If False, return when the device temperature is above than the target.\n        \"\"\"\n        while True:\n            try:\n                with self._lock: dev_temp = self._dev.get_temperature()\n                if cooling and dev_temp &lt;= (target_temperature + 1): break\n                elif not cooling and dev_temp &gt;= (target_temperature - 1): break\n                time.sleep(1)\n                print(f'Camera temperature: {dev_temp} degC, target temperature: {target_temperature}')\n            except Exception as e:\n                print(f'Error in _wait_temperature: {e}')\n\n        print('Target temperature reached')\n\n\n    @thread_assign\n    def monitor_temperature(self):\n        self._flg_monitortemp_isrunning.set()\n        try:\n            while self._flg_monitortemp_isrunning.is_set():\n                with self._lock:\n                    temp = self._dev.get_temperature()\n                print(f'Spectrometer temperature: {temp}')\n                time.sleep(1)\n        except: pass\n\n# Set of commands for testing/automation\n    def self_test(self):\n        if not __name__ == '__main__': raise ValueError('This function is only for testing purposes within the file and should not be called externally')\n\n        int_time_ms = 100\n        print(f'1. Integration time set test: {int_time_ms} ms')\n        self.set_integration_time_us(int_time_ms*1e3)\n        print(f'1. Integration time get test: {self.get_integration_time_us()} ms')\n        int_time_ms = 50\n        print(f'1.2. Integration time set test: {int_time_ms} ms')\n        self.set_integration_time_us(int_time_ms*1e3)\n        print(f'1.2. Integration time get test: {self.get_integration_time_us()} ms')\n\n        print('2. Acquisition test')\n        # &lt;&lt;&lt;&lt;&lt; Insert the self-test commands here\n        import matplotlib.pyplot as plt\n        matplotlib.use('TkAgg')\n\n        res = self.measure_spectrum()\n        spectra,ts,int_time = res\n        print(spectra)\n        print('^^^^^^^^^^^^ Spectra ^^^^^^^^^^^^\\n')\n        print(f'Timestamp: {ts}, Integration time: {int_time}')\n        plt.plot(spectra[DataAnalysisConfigEnum.WAVELENGTH_LABEL.value],spectra[DataAnalysisConfigEnum.INTENSITY_LABEL.value])\n        plt.show()\n\n        matplotlib.use('Agg')\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.SectrometerController_AndorSDK2.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the unique identifier of the spectrometer controller.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier of the spectrometer controller.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_pylablib.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the unique identifier of the spectrometer controller.\n\n    Returns:\n        str: The unique identifier of the spectrometer controller.\n    \"\"\"\n    if self._identifier is None:\n        self._identifier = f\"Andor_{self._dev.get_device_info()}\"\n    return self._identifier\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.SectrometerController_AndorSDK2.get_integration_time_limits_us","title":"<code>get_integration_time_limits_us()</code>","text":"<p>Get the integration time limits of the device</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[int, int, int]</code> <p>A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_pylablib.py</code> <pre><code>def get_integration_time_limits_us(self) -&gt; tuple[int,int,int]:\n    \"\"\"\n    Get the integration time limits of the device\n\n    Returns:\n        tuple: A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)\n    \"\"\"\n    return (self.integration_time_min, self.integration_time_max, self.integration_time_inc)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.SectrometerController_AndorSDK2.get_integration_time_us","title":"<code>get_integration_time_us()</code>","text":"<p>Get the integration time of the device</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Integration time in microseconds</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_pylablib.py</code> <pre><code>def get_integration_time_us(self) -&gt; int:\n    \"\"\"\n    Get the integration time of the device\n\n    Returns:\n        int: Integration time in microseconds\n    \"\"\"\n    with self._lock:\n        if self._dev.acquisition_in_progress(): self._dev.stop_acquisition()\n        self._integration_time_devUnit = self._dev.get_exposure()\n\n    int_time_us = self._integration_time_devUnit*1e6\n    return int_time_us\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.SectrometerController_AndorSDK2.initialisation","title":"<code>initialisation()</code>","text":"<p>Initializes the Raman spectrometer controller.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_pylablib.py</code> <pre><code>def initialisation(self) -&gt; None:\n    \"\"\"\n    Initializes the Raman spectrometer controller.\n    \"\"\"\n    self._dev = Andor.AndorSDK2Camera()\n    self._identifier = f\"Andor_{self._dev.get_device_info()}\"\n    print(f'&gt;&gt;&gt;&gt;&gt; CONNECTED TO {self._dev.get_device_info()} &lt;&lt;&lt;&lt;&lt;')\n\n    # &gt; Monitor temperature if requested\n    if self._flg_monitor_temp: self.monitor_temperature()\n\n    # &gt; Initialise the cooler\n    self._enable_cooler = True\n    try: temp = float(ControllerSpecificConfigEnum.ANDOR_OPERATIONAL_TEMPERATURE.value)\n    except: temp = self._dev.get_temperature(); self._enable_cooler = False\n    self._dev.set_temperature(temp,enable_cooler=self._enable_cooler)\n    print(f'Cooler enabled: {self._enable_cooler}, temperature: {temp}degC')\n\n    if self._enable_cooler: self._wait_temperature(temp,cooling=True)\n\n    # &gt; Initialise the acquisition mode\n    self._dev.setup_shutter(mode='auto')\n    self._dev.set_trigger_mode(mode='int')\n    self._dev.set_acquisition_mode('cont')\n    # self._dev.set_acquisition_mode('single')\n    print(f'Acquisition parameters: {self._dev.get_acquisition_parameters()}')\n\n    # &gt; Set the ROI and binning\n    try: self._set_ROI_binning()\n    except Exception as e: print(f'ROI and binning ERROR: {e}')\n    finally: print(f'ROI and binning: {self._dev.get_roi()}')\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.SectrometerController_AndorSDK2.measure_spectrum","title":"<code>measure_spectrum()</code>","text":"<p>A function to measure the spectrum of the Raman spectrometer.</p> <p>Returns:</p> Type Description <code>tuple[DataFrame, int, int]</code> <p>tuple[pd.DataFrame, int, int]: A tuple containing the following: - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and     intensity columns, from the config file. (as a global constant) - int: The timestamp of the measurement in integer format (microseconds). - int: The integration time used for the measurement in microseconds.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_pylablib.py</code> <pre><code>def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n    \"\"\" \n    A function to measure the spectrum of the Raman spectrometer.\n\n    Returns:\n        tuple[pd.DataFrame, int, int]: A tuple containing the following:\n            - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                intensity columns, from the config file. (as a global constant)\n            - int: The timestamp of the measurement in integer format (microseconds).\n            - int: The integration time used for the measurement in microseconds.\n    \"\"\"\n    with self._lock:\n        if not self._dev.acquisition_in_progress(): self._dev.start_acquisition()\n\n    # img:np.ndarray = self._dev.snap(timeout=self._integration_time_devUnit)\n    # self._dev.wait_for_frame()\n    # img:np.ndarray = self._dev.read_newest_image(return_info=False)\n    # img = self._dev.grab(1)\n    time1 = time.time()\n    with self._lock:\n        self._dev.wait_for_frame(\"lastwait\")    # Pretty slow, at around 390millisec waiting time\n        img:np.ndarray = self._dev.read_newest_image()\n\n    # print(img)\n    # print(f'image shape: {img.shape}')\n    # plt.imshow(img)\n    # plt.show()\n\n    timestamp = get_timestamp_us_int()\n    # print(f'reading time: {(time.time()-time1)*1e3} millisec')\n    # self._dev.stop_acquisition()\n    # print(img)\n    list_intensity = np.mean(img,axis=0)\n    list_wavelength = list(range(len(list_intensity)+1,1,-1))\n\n    list_wavelength = [float(wavelength) for wavelength in list_wavelength]\n    list_intensity = [float(intensity) for intensity in list_intensity]\n\n    integration_time = self.get_integration_time_us()\n\n    spectra = pd.DataFrame({\n        DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: list_wavelength,\n        DataAnalysisConfigEnum.INTENSITY_LABEL.value: list_intensity,\n    })\n    return (spectra, timestamp, integration_time)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.SectrometerController_AndorSDK2.set_integration_time_us","title":"<code>set_integration_time_us(integration_time)</code>","text":"<p>Sets the integration time of the device</p> <p>Parameters:</p> Name Type Description Default <code>integration_time</code> <code>int</code> <p>Integration time in [device unit] </p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Device integrationt time after set up in microseconds</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_pylablib.py</code> <pre><code>def set_integration_time_us(self,integration_time:int) -&gt; int:\n    \"\"\"Sets the integration time of the device\n\n    Args:\n        integration_time (int): Integration time in [device unit] \n        (microseconds for the QE Pro)\n\n    Returns:\n        int: Device integrationt time after set up in microseconds\n    \"\"\"\n\n    print('work here (raman spectrometer controller file)')\n\n    if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n        raise ValueError(\"Integration time must be an integer\")\n    integration_time = int(integration_time)\n\n    with self._lock:\n        if self._dev.acquisition_in_progress(): self._dev.stop_acquisition()\n        self._dev.set_exposure(integration_time*1e-6)\n    int_time = self.get_integration_time_us()\n    print(int_time)\n\n    return int_time\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.SectrometerController_AndorSDK2.terminate","title":"<code>terminate()</code>","text":"<p>To terminate the connections to the Raman spectrometers</p> Source code in <code>iris/controllers/raman_spectrometer_controller_Andor_pylablib.py</code> <pre><code>def terminate(self) -&gt; None:\n    \"\"\"\n    To terminate the connections to the Raman spectrometers\n    \"\"\"\n    # Stop the auto measurement\n    # if self._dev.acquisition_in_progress(): self._dev.stop_acquisition()\n\n    # Turn off the cooler\n    try: temp = float(ControllerSpecificConfigEnum.ANDOR_TERMINATION_TEMPERATURE.value)\n    except: temp = DEFAULT_TEMRINATION_TEMPERATURE\n    if not self._enable_cooler: temp = self._dev.get_temperature()\n\n    self._dev.set_temperature(temperature=temp, enable_cooler=False)\n    if self._dev.is_cooler_on(): self._dev.set_cooler(False)\n\n    print(f'Termination temperature: {temp}')\n\n    if self._enable_cooler: self._wait_temperature(temp,cooling=False)\n    print(f'Device back to termination temp')\n\n    self._dev.close()\n    print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_Andor_pylablib/#iris.controllers.raman_spectrometer_controller_Andor_pylablib.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/","title":"raman_spectrometer_controller_PI_dll","text":"<p>A class that allows the control of the Princeton Instruments Raman spectrometer.</p> <p>Technical notes: Because the PIXIS100 is very slow at capturing single frames, the acquisition mode is set to 'sequence' and the acquisition is performed continuously from the creation of the object. Even with this, as far as I know, the capture rate is still limited to 10Hz.</p> <p>Acknowledgement: Massive thanks to pylablib for the library that provides the interface to the spectrometer. The dll was written in for C, which we weren't experienced with. Pylablib has provided the necessary interface to the dll in Python.</p>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.SpectrometerController_PI","title":"<code>SpectrometerController_PI</code>","text":"<p>               Bases: <code>Class_SpectrometerController</code></p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_dll.py</code> <pre><code>class SpectrometerController_PI(Class_SpectrometerController):\n    def __init__(self) -&gt; None:\n        self._cameraId = None       # Camera ID to initiate a connection\n        self._cameraHandle = None   # Camera handle to control the camera\n\n        # ROI related parameters\n        self._roi_row = (CSEnum.PIXIS_ROI_ROW_MIN.value, CSEnum.PIXIS_ROI_ROW_MAX.value)\n        self._roi_col = (CSEnum.PIXIS_ROI_COL_MIN.value, CSEnum.PIXIS_ROI_COL_MAX.value)\n        self._roi_bin = (CSEnum.PIXIS_ROI_BIN_ROW.value, CSEnum.PIXIS_ROI_BIN_COL.value)\n\n        self._roi_size = None       # Size of the ROI (width, height)\n        self._roi_binning = None    # Binning of the ROI\n        self._roi_num_pixels = None # Number of read pixels in the ROI\n\n        # &gt; Retrieve the other parameters\n        # Get the pixel bit depth\n        self._roi_pixel_bit_depth = None    # Bit depth of the pixels in the ROI\n\n        self._image_data_size = None        # Size of the image data\n        self._timestamp_data_size = None    # Size of the timestamp data\n        self._frame_data_size = None        # Size of the frame data (image data + timestamp data) \n                                            # assuming 1 frame per readout and assuming that timestmap is enabled\n\n        # Timestamp related parameters\n        # Device related parameters\n        self._timeRes_Hz:float = None               # 'Time Resolution' for time metadata conversion to [sec]\n\n        self._integration_time_local_us:int = None  # Integration time in [us] stored in the object (NOT the device)\n\n        # Aquisition related parameters\n        ## NOTE: these parameters were not defined by the device and thus,\n        ## are set arbitrarily. They may need to be adjusted.\n        self.integration_time_min = 10          # int: Stores the spectrometer's minimum allowable integration time [millisec]\n        self.integration_time_max = 3600*1000   # int: Stores the spectrometer's maximum allowable integration time [millisec]\n        self.integration_time_inc = 1           # int: Stores the spectrometer's allowable integration time increment [millisec]\n\n        # Lock for communication with the device\n        self._lock = mp.Lock()\n\n        # Start the initialisation process\n        self._identifier = None\n        self.initialisation()\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the spectrometer.\n\n        Returns:\n            str: The identifier of the spectrometer\n        \"\"\"\n        if self._identifier is None: self._identifier = self._get_hardware_identifier()\n        return self._identifier\n\n    def _get_hardware_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the hardware identifier of the spectrometer.\n\n        Returns:\n            str: The hardware identifier of the spectrometer\n        \"\"\"\n        return f\"Princeton Instrument camera model: {self._cameraModel}, S/N: {self._cameraSerialNumber}\"\n\n# Core functionalities (initialisation, termination)\n    def initialisation(self):\n        # &gt; Get the camera handle and initialise the connection\n        with self._lock:\n            # Check if the library is initialised\n            if not func_Picam_IsLibraryInitialized():\n                func_Picam_InitializeLibrary()\n\n            self._cameraId = self._get_cameraId()\n            self._cameraHandle = func_Picam_OpenCamera(self._cameraId)\n\n            self._cameraModel = ''\n            self._cameraSerialNumber = ''\n\n            # self._cameraModel = self._cameraId.model.decode('utf-8')\n            # self._cameraSerialNumber = self._cameraId.serial_number.decode('utf-8')\n\n            # &gt; Set the timestamp parameters\n            # Enable the timestamp metadata\n            func_Picam_SetParameterIntegerValue(self._cameraHandle, PicamParameter.PicamParameter_TimeStamps, PicamTimeStampsMask.PicamTimeStampsMask_ExposureStarted)\n            func_Picam_CommitParameters(self._cameraHandle)\n\n            # Check if the timestamp is enabled\n            maskval = func_Picam_GetParameterIntegerValue(self._cameraHandle, PicamParameter.PicamParameter_TimeStamps)\n            if maskval!=PicamTimeStampsMask.PicamTimeStampsMask_ExposureStarted:\n                raise ValueError(\"Timestamps not enabled\")\n\n            # Get the timestamp resolution and bit depth\n            self._timeRes_Hz = func_Picam_GetParameterLargeIntegerValue(self._cameraHandle, PicamParameter.PicamParameter_TimeStampResolution)\n            self._timestamp_bit_depth = func_Picam_GetParameterIntegerValue(self._cameraHandle, PicamParameter.PicamParameter_TimeStampBitDepth)\n\n        # &gt; Set the ROI parameters\n        self._set_ROI(row=self._roi_row, col=self._roi_col, bin_row=self._roi_bin[0])\n\n        # &gt; Set the default integration time\n        self.set_integration_time_us(int(100e3))\n\n        # &gt; Check the acquisition result\n        # Check if the acquisition was successful\n        self.measure_spectrum()\n\n    def terminate(self, error_flag=False):\n        \"\"\"\n        To terminate the connections to the Raman spectrometers\n\n        Args:\n            error_flag (bool, optional): Can also passes an error message. Defaults to False.\n        \"\"\"\n        if error_flag!=False: print(\"\\n Error code:\",error_flag)\n        func_Picam_CloseCamera(self._cameraHandle)\n\n        picamlib.Picam_UninitializeLibrary()\n\n        self._cameraHandle = None\n        self._cameraId = None\n\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n\n    def _get_cameraId(self) -&gt; PicamCameraID:\n        \"\"\"\n        Gets the available camera IDs.\n\n        Returns:\n            PicamCameraID: The camera ID of the connected camera.\n\n        Raises:\n            Exception: If no camera is detected or multiple cameras are detected.\n        \"\"\"\n        camera_ids,camera_no = func_Picam_GetAvailableCameraIDs()\n\n        for i in range(camera_no):\n            camera_id:PicamCameraID = camera_ids[i]\n            print('Detected camera no:',i)\n            print(f\"  Model: {camera_id.model}\")\n            print(f\"  Computer Interface: {camera_id.computer_interface}\")\n            print(f\"  Sensor Name: {camera_id.sensor_name.decode('utf-8')}\")  # Decode to string\n            print(f\"  Serial Number: {camera_id.serial_number.decode('utf-8')}\") # Decode to string\n            print()\n\n        if camera_no==0:\n            # print('No camera detected')\n            # return None\n            raise Exception('No camera detected')\n\n        func_Picam_DestroyCameraIDs(camera_ids)\n\n        if camera_no==1:\n            return camera_ids[0]\n        else:\n            # print('Multiple cameras detected. Please select the camera to be used.')\n            # camera_id = camera_ids[int(input('Enter the camera number: '))]\n            # return camera_id\n            raise Exception('Multiple cameras detected. Please select the camera to be used.')\n\n    def _set_ROI(self, row:tuple[str,str]=('',''), col:tuple[str,str]=('',''),\n                 bin_row:str=''):\n        \"\"\"\n        Sets the Region of Interest (ROI) for the camera as well as the binning.\n\n        Args:\n            row (tuple[float,float]|tuple[str,str], optional): The range of rows to be used for the ROI (min, max).\n                if ('',''), the default ROI will be used. Defaults to ('','').\n            col (tuple[float,float]|tuple[str,str], optional): The range of columns to be used for the ROI (min, max).\n                if ('',''), the default ROI will be used. Defaults to ('','').\n            bin_row (int|str, optional): The number of rows to bin, if larger than the ROI size,\n                the min of the two will be chosen. If '', the default binning will be used. Defaults to ''.\n                'min' will choose the minimum possible binning, 'max' will choose the maximum possible binning.\n        \"\"\"\n        camera_handle = self._cameraHandle\n\n        with self._lock:\n            # Get the default ROI information\n            ptr_picamRoisDefault:PicamRois = func_Picam_GetParameterRoisDefaultValue(camera_handle, PicamParameter.PicamParameter_Rois)\n        picamRoiDefault = ptr_picamRoisDefault.contents.roi_array[0]  # Get the first ROI\n        func_Picam_DestroyRois(ptr_picamRoisDefault)\n\n        # print(\"Default ROI:\")\n        # print(\"  x:\", picamRoiDefault.x)\n        # print(\"  width:\", picamRoiDefault.width)\n        # print(\"  x_binning:\", picamRoiDefault.x_binning)\n        # print(\"  y:\", picamRoiDefault.y)\n        # print(\"  height:\", picamRoiDefault.height)\n        # print(\"  y_binning:\", picamRoiDefault.y_binning)\n\n        # &gt; Convert the input values to the correct format\n        row_min = int(float(row[0])) if row[0] else 0\n        row_max = int(float(row[1])) if row[1] else picamRoiDefault.height\n        col_min = int(float(col[0])) if col[0] else 0\n        col_max = int(float(col[1])) if col[1] else picamRoiDefault.width\n        if bin_row=='min': bin_row = 1\n        elif bin_row=='max': bin_row = int(picamRoiDefault.height)\n        else: bin_row = int(float(bin_row)) if bin_row else None\n\n        # Get the ROI information (assuming a single ROI for now)\n        with self._lock:\n            ptr_picamRois:PicamRois = func_Picam_GetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois)\n        picamRoi = ptr_picamRois.contents.roi_array[0]  # Get the first ROI\n\n        # print(\"Current ROI:\")\n        # print(\"  x:\", picamRoi.x)\n        # print(\"  width:\", picamRoi.width)\n        # print(\"  x_binning:\", picamRoi.x_binning)\n        # print(\"  y:\", picamRoi.y)\n        # print(\"  height:\", picamRoi.height)\n        # print(\"  y_binning:\", picamRoi.y_binning)\n\n        row = (row_min, row_max)\n        col = (col_min, col_max)\n        bin_row = min(bin_row, row[1]-row[0]) if bin_row else picamRoiDefault.y_binning\n\n        new_roi = picamRoi\n        new_roi.x = ctypes.c_int(col[0]) if col else picamRoiDefault.x\n        new_roi.width = ctypes.c_int(col[1]-col[0]) if col else picamRoiDefault.width\n        new_roi.y = ctypes.c_int(row[0]) if row else picamRoiDefault.y\n        new_roi.height = ctypes.c_int(row[1]-row[0]) if row else picamRoiDefault.height\n        new_roi.y_binning = ctypes.c_int(bin_row) if bin_row else picamRoiDefault.y_binning\n\n        with self._lock:\n            # Check if the ROI can be set\n            settable = func_Picam_CanSetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois, ptr_picamRois)\n            print(\"ROI settable:\", settable)\n\n            # Set the ROI\n            if not settable: func_Picam_DestroyRois(ptr_picamRois); raise ValueError(\"ROI cannot be set.\")\n            func_Picam_SetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois, ptr_picamRois)\n            func_Picam_CommitParameters(camera_handle)\n            func_Picam_DestroyRois(ptr_picamRois)\n\n            # Get the ROI information again\n            ptr_picamRois:PicamRois = func_Picam_GetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois)\n        picamRoi = ptr_picamRois.contents.roi_array[0]  # Get the first ROI\n        func_Picam_DestroyRois(ptr_picamRois)\n\n        print(\"Set ROI:\")\n        print(\"  x:\", picamRoi.x)\n        print(\"  width:\", picamRoi.width)\n        print(\"  x_binning:\", picamRoi.x_binning)\n        print(\"  y:\", picamRoi.y)\n        print(\"  height:\", picamRoi.height)\n        print(\"  y_binning:\", picamRoi.y_binning)\n\n        self._roi_size = (picamRoi.width//picamRoi.x_binning, picamRoi.height//picamRoi.y_binning)  # width, height of the ROI\n        self._roi_binning = (picamRoi.x_binning, picamRoi.y_binning)\n        self._roi_num_pixels = self._roi_size[0] * self._roi_size[1]\n\n        # &gt; Retrieve the other parameters\n        # Get the pixel bit depth\n        with self._lock:\n            self._roi_pixel_bit_depth = func_Picam_GetParameterIntegerValue(camera_handle, PicamParameter.PicamParameter_PixelBitDepth)\n\n        self._image_data_size = (self._roi_num_pixels * self._roi_pixel_bit_depth // 8)\n        self._timestamp_data_size = (self._timestamp_bit_depth + 7) // 8\n        self._frame_data_size = self._image_data_size + self._timestamp_data_size\n\n        # &gt; Ensure that the ROI is set correctly\n        # Get the ROI information (assuming a single ROI for now)        \n        with self._lock:\n            ptr_picamRois:PicamRois = func_Picam_GetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois)\n        picamRois = ptr_picamRois.contents\n        num_rois = picamRois.roi_count\n        if num_rois == 0: raise ValueError(\"No ROI found.\")\n        if num_rois &gt; 1: raise ValueError(\"Multiple ROIs found. Only one ROI is supported.\")\n\n        return\n\n    def get_integration_time_limits_us(self) -&gt; tuple[int,int,int]:\n        \"\"\"\n        Get the integration time limits of the device\n\n        Returns:\n            tuple: A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)\n        \"\"\"\n        return (self.integration_time_min*1e3, self.integration_time_max*1e3, self.integration_time_inc*1e3)\n\n    def get_integration_time_us(self, fromdev:bool=True) -&gt; int:\n        \"\"\"\n        Get the integration time of the device\n\n        Args:\n            fromdev (bool, optional): If True, the integration time will be retrieved from the device.\n                Defaults to True.\n\n        Returns:\n            int: Integration time in [device unit] (microseconds for the QE Pro)\n        \"\"\"\n        # Get the new integration time\n        if fromdev:\n            camera_handle = self._cameraHandle\n            with self._lock:\n                int_time_ms = func_Picam_GetParameterFloatingPointValue(camera_handle, PicamParameter.PicamParameter_ExposureTime)\n            self._integration_time_local_us = int(int_time_ms*1000)\n        else:\n            int_time_ms = self._integration_time_local_us/1000\n        return int_time_ms*1000\n\n    def set_integration_time_us(self,integration_time_us:int) -&gt; int:\n        \"\"\"\n        Sets the integration time of the device\n\n        Args:\n            integration_time (int): Integration time in [device unit] \n            (microseconds for the QE Pro)\n\n        Returns:\n            int: Device integrationt time after set up [us]\n        \"\"\"\n        assert isinstance(integration_time_us,int), \"Integration time must be an integer\"\n        int_time_ms = int(integration_time_us/1000)\n\n        with self._lock:\n            camera_handle = self._cameraHandle\n            func_Picam_SetParameterFloatingPointValue(camera_handle, PicamParameter.PicamParameter_ExposureTime, int_time_ms)\n            func_Picam_CommitParameters(camera_handle)\n\n        # Use the get function to ensure that the integration time is set correctly\n        # And to update the locally stored integration time\n        return self.get_integration_time_us()\n\n    def _get_bit_depth(self,depth:int) -&gt; np.dtype:\n        \"\"\"\n        Get the numpy data type based on the bit depth\n\n        Args:\n            depth (int): The bit depth of the data\n        \"\"\"    \n        if depth == 16:\n            return np.uint16\n        elif depth == 32:\n            return np.uint32\n        elif depth == 64:\n            return np.uint64\n        else:\n            raise ValueError(\"Unsupported timestamp bit depth\")\n\n    def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n        \"\"\"\n        Measures the spectrum of the Raman spectrometer.\n\n        Returns:\n            pandas.DataFrame: A DataFrame containing the measured spectrum with the following columns:\n            - 'Wavelength [pixel]': The wavelength values in nanometers.\n            - 'Intensity [a.u.]': The intensity values in arbitrary units.\n            int: The timestamp of the measurement in integer format (microseconds).\n            int: The integration time used for the measurement in microseconds.\n        \"\"\"\n\n        \"\"\"\n        Acquires an image from the camera.\n\n        Args:\n            picamlib: The ctypes library object for the PICam library from pylablib.\n            camera_handle: The camera handle obtained from Picam_OpenCamera.\n            timeout (int): The timeout in milliseconds for the acquisition.\n\n        Returns:\n            np.ndarray: The acquired image data.\n        \"\"\"\n        camera_handle = self._cameraHandle\n\n        # Acquire an image\n        readout_count = 1  # Number of readouts\n        readout_time_out = -1  # Infinite timeout\n\n        # Call the wrapped function\n        init_timestamp = get_timestamp_us_int()\n        with self._lock:\n            available, errors = func_Picam_Acquire(camera_handle, readout_count, readout_time_out)\n\n        # Get the image data\n        ptr_image_data:CPicamAvailableData = available.initial_readout\n\n        # Get the readout stride\n        with self._lock:\n            readout_stride = func_Picam_GetParameterIntegerValue(camera_handle, PicamParameter.PicamParameter_ReadoutStride)\n        # print(\"Readout stride:\", readout_stride)\n\n        # Get the ROI information (assuming a single ROI for now)\n        with self._lock:\n            ptr_picamRois:PicamRois = func_Picam_GetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois)\n        picamRois = ptr_picamRois.contents\n        num_rois = picamRois.roi_count\n        if num_rois == 0: raise ValueError(\"No ROI found.\")\n        if num_rois &gt; 1: raise ValueError(\"Multiple ROIs found. Only one ROI is supported.\")\n\n        if self._frame_data_size != readout_stride: raise ValueError(\"Readout stride does not match the expected frame data size.\\\n            Likely an issue with either, there are multiple readouts, additional masks used, or the frame data size calculation\\\n            is incorrect.\")\n\n        # &gt; Extract the image data &lt;\n        # Create a buffer for the readout data\n        readout_buffer = ctypes.create_string_buffer(self._image_data_size)\n        ctypes.memmove(readout_buffer, ptr_image_data, self._image_data_size) # Copy the readout data from the initial readout pointer to the buffer\n\n        # Convert the buffer to a numpy array based on the pixel bit depth\n        image_data:np.ndarray = np.frombuffer(readout_buffer, dtype=self._get_bit_depth(self._roi_pixel_bit_depth))\n\n        # Reshape the image data\n        image_data = image_data.reshape((self._roi_size[1], self._roi_size[0])) # Reshape to height x width\n        # print(\"Image data shape:\", image_data.shape)\n\n        # &gt; Extract the timestamp data &lt;\n        # Create a buffer for the timestamp data\n        timestamp_buffer = ctypes.create_string_buffer(self._timestamp_data_size)\n        ctypes.memmove(timestamp_buffer, ptr_image_data + self._image_data_size, self._timestamp_data_size) # Copy the timestamp data from the initial readout pointer to the buffer\n\n        # Convert the buffer to a numpy array\n        timestamp_resolution = self._timeRes_Hz\n        timestamp_data = int(np.frombuffer(timestamp_buffer, dtype=self._get_bit_depth(self._timestamp_bit_depth))[0])\n        timestamp_us = timestamp_data*10**6 // timestamp_resolution\n\n        # import matplotlib.pyplot as plt\n        # plt.imshow(image_data, cmap='hot')\n        # plt.colorbar()\n        # plt.show()\n\n        list_intensity = np.mean(image_data,axis=0)\n        list_wavelength = list(range(1, len(list_intensity) + 1))\n\n        list_wavelength = [float(wavelength) for wavelength in list_wavelength]\n        list_intensity = [float(intensity) for intensity in list_intensity]\n\n        timestamp_us_int = init_timestamp + timestamp_us\n        integration_time = self.get_integration_time_us(fromdev=False)\n\n        spectra = pd.DataFrame({\n            DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: list_wavelength,\n            DataAnalysisConfigEnum.INTENSITY_LABEL.value: list_intensity,\n        })\n\n        return (spectra, timestamp_us_int, integration_time)\n\n# Set of commands for testing/automation\n    def self_test(self):\n        print(\"----- Self-test for the Raman spectrometer -----\")\n        print(\"--- Test integration time ---\")\n        print(\"Integration time limits [us]: {}\".format(self.get_integration_time_limits_us()))\n        print(\"Setting integration time to 5ms\")\n        self.set_integration_time_us(5000)\n        print(\"Current integration time [us]: {}\".format(self.get_integration_time_us()))\n        new_int_value_us = 1000000\n        self.set_integration_time_us(new_int_value_us)\n        print(\"Setting integration time to {}ms [~{}Hz]\".format(new_int_value_us/1000,10**6/new_int_value_us))\n        print(\"Current integration time [us]: {}\".format(self.get_integration_time_us()))\n\n        print('\\n--- Test acquisition ---')\n        print(\"Measuring spectrum\")\n\n        import threading as th\n        from typing import Callable\n\n        def offafter5sec(callback:Callable):\n            time.sleep(5)\n            callback()\n\n        flg = th.Event()\n        th.Thread(target=offafter5sec,args=(flg.set,)).start()\n\n        plt.ion()  # Turn on interactive mode \n        fig = plt.figure()  # Create a figure\n        ax = fig.add_subplot(111)  # Create a subplot\n\n        WAVELENGTH_LABEL = DataAnalysisConfigEnum.WAVELENGTH_LABEL.value\n        INTENSITY_LABEL = DataAnalysisConfigEnum.INTENSITY_LABEL.value\n\n        while not flg.is_set():\n            time1 = time.time()\n            result = self.measure_spectrum()\n            print(\"Timestamp: {}\".format(convert_timestamp_us_int_to_str(result[1])))\n            print(\"Integration time [ms]: {}\".format(result[2]/1000))\n            print(\"Spectrum shape: {}\".format(result[0].shape))\n\n            # Clear the previous plot\n            ax.clear()  \n\n            # Plot the new data\n            ax.plot(result[0][WAVELENGTH_LABEL], result[0][INTENSITY_LABEL])\n            ax.set_title(\"Measured spectrum\")\n            ax.set_xlabel(WAVELENGTH_LABEL)\n            ax.set_ylabel(INTENSITY_LABEL)\n\n            # Update the plot\n            fig.canvas.draw()\n            fig.canvas.flush_events()\n\n            time2 = time.time()\n            print(\"Measurement duration: {}ms\".format((time2 - time1)*1000))\n\n        plt.ioff()  # Turn off interactive mode\n        plt.show()  # Keep the plot window open at the end\n\n        print(\"----- Self-test completed -----\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.SpectrometerController_PI.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the spectrometer.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the spectrometer</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_dll.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the spectrometer.\n\n    Returns:\n        str: The identifier of the spectrometer\n    \"\"\"\n    if self._identifier is None: self._identifier = self._get_hardware_identifier()\n    return self._identifier\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.SpectrometerController_PI.get_integration_time_limits_us","title":"<code>get_integration_time_limits_us()</code>","text":"<p>Get the integration time limits of the device</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[int, int, int]</code> <p>A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_dll.py</code> <pre><code>def get_integration_time_limits_us(self) -&gt; tuple[int,int,int]:\n    \"\"\"\n    Get the integration time limits of the device\n\n    Returns:\n        tuple: A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)\n    \"\"\"\n    return (self.integration_time_min*1e3, self.integration_time_max*1e3, self.integration_time_inc*1e3)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.SpectrometerController_PI.get_integration_time_us","title":"<code>get_integration_time_us(fromdev=True)</code>","text":"<p>Get the integration time of the device</p> <p>Parameters:</p> Name Type Description Default <code>fromdev</code> <code>bool</code> <p>If True, the integration time will be retrieved from the device. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Integration time in [device unit] (microseconds for the QE Pro)</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_dll.py</code> <pre><code>def get_integration_time_us(self, fromdev:bool=True) -&gt; int:\n    \"\"\"\n    Get the integration time of the device\n\n    Args:\n        fromdev (bool, optional): If True, the integration time will be retrieved from the device.\n            Defaults to True.\n\n    Returns:\n        int: Integration time in [device unit] (microseconds for the QE Pro)\n    \"\"\"\n    # Get the new integration time\n    if fromdev:\n        camera_handle = self._cameraHandle\n        with self._lock:\n            int_time_ms = func_Picam_GetParameterFloatingPointValue(camera_handle, PicamParameter.PicamParameter_ExposureTime)\n        self._integration_time_local_us = int(int_time_ms*1000)\n    else:\n        int_time_ms = self._integration_time_local_us/1000\n    return int_time_ms*1000\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.SpectrometerController_PI.measure_spectrum","title":"<code>measure_spectrum()</code>","text":"<p>Measures the spectrum of the Raman spectrometer.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>pandas.DataFrame: A DataFrame containing the measured spectrum with the following columns:</p> <code>int</code> <ul> <li>'Wavelength [pixel]': The wavelength values in nanometers.</li> </ul> <code>int</code> <ul> <li>'Intensity [a.u.]': The intensity values in arbitrary units.</li> </ul> <code>int</code> <code>tuple[DataFrame, int, int]</code> <p>The timestamp of the measurement in integer format (microseconds).</p> <code>int</code> <code>tuple[DataFrame, int, int]</code> <p>The integration time used for the measurement in microseconds.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_dll.py</code> <pre><code>def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n    \"\"\"\n    Measures the spectrum of the Raman spectrometer.\n\n    Returns:\n        pandas.DataFrame: A DataFrame containing the measured spectrum with the following columns:\n        - 'Wavelength [pixel]': The wavelength values in nanometers.\n        - 'Intensity [a.u.]': The intensity values in arbitrary units.\n        int: The timestamp of the measurement in integer format (microseconds).\n        int: The integration time used for the measurement in microseconds.\n    \"\"\"\n\n    \"\"\"\n    Acquires an image from the camera.\n\n    Args:\n        picamlib: The ctypes library object for the PICam library from pylablib.\n        camera_handle: The camera handle obtained from Picam_OpenCamera.\n        timeout (int): The timeout in milliseconds for the acquisition.\n\n    Returns:\n        np.ndarray: The acquired image data.\n    \"\"\"\n    camera_handle = self._cameraHandle\n\n    # Acquire an image\n    readout_count = 1  # Number of readouts\n    readout_time_out = -1  # Infinite timeout\n\n    # Call the wrapped function\n    init_timestamp = get_timestamp_us_int()\n    with self._lock:\n        available, errors = func_Picam_Acquire(camera_handle, readout_count, readout_time_out)\n\n    # Get the image data\n    ptr_image_data:CPicamAvailableData = available.initial_readout\n\n    # Get the readout stride\n    with self._lock:\n        readout_stride = func_Picam_GetParameterIntegerValue(camera_handle, PicamParameter.PicamParameter_ReadoutStride)\n    # print(\"Readout stride:\", readout_stride)\n\n    # Get the ROI information (assuming a single ROI for now)\n    with self._lock:\n        ptr_picamRois:PicamRois = func_Picam_GetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois)\n    picamRois = ptr_picamRois.contents\n    num_rois = picamRois.roi_count\n    if num_rois == 0: raise ValueError(\"No ROI found.\")\n    if num_rois &gt; 1: raise ValueError(\"Multiple ROIs found. Only one ROI is supported.\")\n\n    if self._frame_data_size != readout_stride: raise ValueError(\"Readout stride does not match the expected frame data size.\\\n        Likely an issue with either, there are multiple readouts, additional masks used, or the frame data size calculation\\\n        is incorrect.\")\n\n    # &gt; Extract the image data &lt;\n    # Create a buffer for the readout data\n    readout_buffer = ctypes.create_string_buffer(self._image_data_size)\n    ctypes.memmove(readout_buffer, ptr_image_data, self._image_data_size) # Copy the readout data from the initial readout pointer to the buffer\n\n    # Convert the buffer to a numpy array based on the pixel bit depth\n    image_data:np.ndarray = np.frombuffer(readout_buffer, dtype=self._get_bit_depth(self._roi_pixel_bit_depth))\n\n    # Reshape the image data\n    image_data = image_data.reshape((self._roi_size[1], self._roi_size[0])) # Reshape to height x width\n    # print(\"Image data shape:\", image_data.shape)\n\n    # &gt; Extract the timestamp data &lt;\n    # Create a buffer for the timestamp data\n    timestamp_buffer = ctypes.create_string_buffer(self._timestamp_data_size)\n    ctypes.memmove(timestamp_buffer, ptr_image_data + self._image_data_size, self._timestamp_data_size) # Copy the timestamp data from the initial readout pointer to the buffer\n\n    # Convert the buffer to a numpy array\n    timestamp_resolution = self._timeRes_Hz\n    timestamp_data = int(np.frombuffer(timestamp_buffer, dtype=self._get_bit_depth(self._timestamp_bit_depth))[0])\n    timestamp_us = timestamp_data*10**6 // timestamp_resolution\n\n    # import matplotlib.pyplot as plt\n    # plt.imshow(image_data, cmap='hot')\n    # plt.colorbar()\n    # plt.show()\n\n    list_intensity = np.mean(image_data,axis=0)\n    list_wavelength = list(range(1, len(list_intensity) + 1))\n\n    list_wavelength = [float(wavelength) for wavelength in list_wavelength]\n    list_intensity = [float(intensity) for intensity in list_intensity]\n\n    timestamp_us_int = init_timestamp + timestamp_us\n    integration_time = self.get_integration_time_us(fromdev=False)\n\n    spectra = pd.DataFrame({\n        DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: list_wavelength,\n        DataAnalysisConfigEnum.INTENSITY_LABEL.value: list_intensity,\n    })\n\n    return (spectra, timestamp_us_int, integration_time)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.SpectrometerController_PI.set_integration_time_us","title":"<code>set_integration_time_us(integration_time_us)</code>","text":"<p>Sets the integration time of the device</p> <p>Parameters:</p> Name Type Description Default <code>integration_time</code> <code>int</code> <p>Integration time in [device unit] </p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Device integrationt time after set up [us]</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_dll.py</code> <pre><code>def set_integration_time_us(self,integration_time_us:int) -&gt; int:\n    \"\"\"\n    Sets the integration time of the device\n\n    Args:\n        integration_time (int): Integration time in [device unit] \n        (microseconds for the QE Pro)\n\n    Returns:\n        int: Device integrationt time after set up [us]\n    \"\"\"\n    assert isinstance(integration_time_us,int), \"Integration time must be an integer\"\n    int_time_ms = int(integration_time_us/1000)\n\n    with self._lock:\n        camera_handle = self._cameraHandle\n        func_Picam_SetParameterFloatingPointValue(camera_handle, PicamParameter.PicamParameter_ExposureTime, int_time_ms)\n        func_Picam_CommitParameters(camera_handle)\n\n    # Use the get function to ensure that the integration time is set correctly\n    # And to update the locally stored integration time\n    return self.get_integration_time_us()\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.SpectrometerController_PI.terminate","title":"<code>terminate(error_flag=False)</code>","text":"<p>To terminate the connections to the Raman spectrometers</p> <p>Parameters:</p> Name Type Description Default <code>error_flag</code> <code>bool</code> <p>Can also passes an error message. Defaults to False.</p> <code>False</code> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_dll.py</code> <pre><code>def terminate(self, error_flag=False):\n    \"\"\"\n    To terminate the connections to the Raman spectrometers\n\n    Args:\n        error_flag (bool, optional): Can also passes an error message. Defaults to False.\n    \"\"\"\n    if error_flag!=False: print(\"\\n Error code:\",error_flag)\n    func_Picam_CloseCamera(self._cameraHandle)\n\n    picamlib.Picam_UninitializeLibrary()\n\n    self._cameraHandle = None\n    self._cameraId = None\n\n    print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_dll/#iris.controllers.raman_spectrometer_controller_PI_dll.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/","title":"raman_spectrometer_controller_PI_pylablib","text":"<p>A class that allows the control of the Princeton Instruments Raman spectrometer.</p> <p>Technical notes: Because the PIXIS100 is very slow at capturing single frames, the acquisition mode is set to 'sequence' and the acquisition is performed continuously from the creation of the object. Even with this, as far as I know, the capture rate is still limited to 10Hz.</p> <p>Acknowledgement: pylablib for the library that provides the interface to the spectrometer.</p> <p>Made on: 04 March 2024 By: Kevin Uning, The Thomas Group, Biochemical Engineering Dept., UCL In collaboration with: The Bergholt Lab, King's College London</p>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.SpectrometerController_PI","title":"<code>SpectrometerController_PI</code>","text":"<p>               Bases: <code>Class_SpectrometerController</code></p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_pylablib.py</code> <pre><code>class SpectrometerController_PI(Class_SpectrometerController):\n    def __init__(self) -&gt; None:\n        self._dev:pic.PicamCamera = None\n\n        # Device related parameters\n        self._timeRes_Hz:float = None       # 'Time Resolution' for time metadata conversion to [sec]\n        self._timestamp_init_us:int = None  # Initial timestamp for the device. Starts when the capture starts\n\n        # Aquisition related parameters\n        ## NOTE: these parameters were not defined by the device and thus,\n        ## are set arbitrarily. They may need to be adjusted.\n        self.integration_time_min = 10          # int: Stores the spectrometer's minimum allowable integration time [millisec]\n        self.integration_time_max = 3600*1000   # int: Stores the spectrometer's maximum allowable integration time [millisec]\n        self.integration_time_inc = 1           # int: Stores the spectrometer's allowable integration time increment [millisec]\n\n        # Start the initialisation process\n        self._identifier = None\n        self.initialisation()\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the spectrometer.\n\n        Returns:\n            str: The identifier of the spectrometer\n        \"\"\"\n        if self._identifier is None:\n            self._identifier = self._get_hardware_identifier()\n        return self._identifier\n\n    def _get_hardware_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the hardware identifier of the spectrometer.\n\n        Returns:\n            str: The hardware identifier of the spectrometer\n        \"\"\"\n        return f\"Princeton Instrument_{self._dev.get_device_info()}\"\n\n# Core functionalities (initialisation, termination)\n    def initialisation(self):\n        if isinstance(self._dev,pic.PicamCamera): self.terminate()\n        self._dev = pic.PicamCamera()\n        print(\"----- Connected to: {} -----\".format(self._dev.get_device_info()))\n\n        # Enable metadata for the timestamp and \n        ## start the acquisition immediately\n        self._dev.enable_metadata(enable=True)\n        self._dev.setup_acquisition(mode='sequence')\n        self._dev.start_acquisition()\n        self._timestamp_init_us = get_timestamp_us_int()\n\n        # Wait for the first frame to be captured\n        self._timeRes_Hz = self._dev.get_attribute_value(\"Time Stamp Resolution\")\n        self._dev.wait_for_frame()\n\n    def terminate(self, error_flag=False):\n        \"\"\"\n        To terminate the connections to the Raman spectrometers\n\n        Args:\n            error_flag (bool, optional): Can also passes an error message. Defaults to False.\n        \"\"\"\n        if error_flag!=False: print(\"\\n Error code:\",error_flag)\n\n        self._dev.stop_acquisition()\n        self._dev.close()\n\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n\n    def get_integration_time_limits_us(self) -&gt; tuple[int,int,int]:\n        \"\"\"\n        Get the integration time limits of the device\n\n        Returns:\n            tuple: A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)\n        \"\"\"\n        return (self.integration_time_min, self.integration_time_max, self.integration_time_inc)\n\n    def get_integration_time_us(self):\n        \"\"\"\n        Get the integration time of the device\n\n        Returns:\n            int: Integration time in [device unit] (microseconds for the QE Pro)\n        \"\"\"\n        int_time_ms = self._dev.get_attribute_value(\"Exposure Time\")\n        return int_time_ms*1000\n\n    def _restart_acquisition(self):\n        \"\"\"\n        Restarts the acquisition process. This allows for new settings/parameters\n        to be applied to the device.\n        \"\"\"\n        self._dev.stop_acquisition()\n        self._dev.start_acquisition()\n        self._timestamp_init_us = get_timestamp_us_int()\n        self._dev.wait_for_frame()\n\n    def set_integration_time_us(self,integration_time:int) -&gt; int:\n        \"\"\"\n        Sets the integration time of the device\n\n        Args:\n            integration_time (int): Integration time in [device unit] \n            (microseconds for the QE Pro)\n\n        Returns:\n            int: Device integrationt time after set up [us]\n        \"\"\"\n        assert isinstance(integration_time,int), \"Integration time must be an integer\"\n        int_time_ms = int(integration_time/1000)\n\n        self._dev.set_attribute_value(\"Exposure Time\", int_time_ms)\n        self._restart_acquisition()\n        return self._dev.get_attribute_value(\"Exposure Time\")*1000\n\n    def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n        \"\"\"\n        Measures the spectrum of the Raman spectrometer.\n\n        Returns:\n            pandas.DataFrame: A DataFrame containing the measured spectrum with the following columns:\n            - 'Wavelength [pixel]': The wavelength values in nanometers.\n            - 'Intensity [a.u.]': The intensity values in arbitrary units.\n            int: The timestamp of the measurement in integer format (microseconds).\n            int: The integration time used for the measurement in microseconds.\n        \"\"\"\n        # list_time = [] ### &lt;&lt;&lt;\n\n        # list_time.append(time.time()) ### &lt;&lt;&lt;\n        while True:\n            self._dev.wait_for_frame(since='lastread')\n            # list_time.append(time.time()) ### &lt;&lt;&lt;\n            result = self._dev.read_newest_image(return_info=True)\n            if result is not None: break\n            else: print('No data captured. Reinitalising the connection...'); self.initialisation()\n        img,info = result[0],result[1]\n\n        # # list_time.append(time.time()) ### &lt;&lt;&lt; \n\n        img = np.array(img)[74:80,:]\n        # img = np.array(img)\n        list_intensity = np.mean(img,axis=0)\n        list_wavelength = list(range(1, len(list_intensity) + 1))\n\n        # plt.imshow(img)\n        # plt.set_cmap('gray')\n        # plt.colorbar()\n\n        # plt.show()\n\n        # arr1 = np.array(img)[:,300]\n        # plt.plot(arr1)\n        # plt.grid()\n        # plt.minorticks_on()\n        # plt.tick_params(axis='both',which='both',direction='in',top=True,right=True)\n\n        # plt.show()\n\n        # list_time.append(time.time()) ### &lt;&lt;&lt;\n        list_wavelength = [float(wavelength) for wavelength in list_wavelength]\n        list_intensity = [float(intensity) for intensity in list_intensity]\n\n        # list_time.append(time.time()) ### &lt;&lt;&lt;\n        timestamp_us_int = int(info.timestamp_start/self._timeRes_Hz*10**6 + self._timestamp_init_us)\n        integration_time = self.get_integration_time_us()\n\n        # list_time.append(time.time()) ### &lt;&lt;&lt;\n        spectra = pd.DataFrame({\n            DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: list_wavelength,\n            DataAnalysisConfigEnum.INTENSITY_LABEL.value: list_intensity,\n        })\n\n        # list_time.append(time.time()) ### &lt;&lt;&lt;\n        # for i in range(1,len(list_time)):\n        #     print('Time {}: {}ms'.format(i,(list_time[i]-list_time[i-1])*1000))\n\n        return (spectra, timestamp_us_int, integration_time)\n\n# Set of commands for testing/automation\n    def self_test(self):\n        print(\"----- Self-test for the Raman spectrometer -----\")\n        print(\"--- Test integration time ---\")\n        print(\"Integration time limits [us]: {}\".format(self.get_integration_time_limits_us()))\n        print(\"Setting integration time to 5ms\")\n        self.set_integration_time_us(5000)\n        print(\"Current integration time [us]: {}\".format(self.get_integration_time_us()))\n        new_int_value_us = 1000000\n        self.set_integration_time_us(new_int_value_us)\n        print(\"Setting integration time to {}ms [~{}Hz]\".format(new_int_value_us/1000,10**6/new_int_value_us))\n        print(\"Current integration time [us]: {}\".format(self.get_integration_time_us()))\n\n        print('\\n--- Test acquisition ---')\n        print(\"Measuring spectrum\")\n\n        import threading as th\n        from typing import Callable\n\n        def offafter5sec(callback:Callable):\n            time.sleep(2)\n            callback()\n\n        flg = th.Event()\n        th.Thread(target=offafter5sec,args=(flg.set,)).start()\n\n        # plt.ion()  # Turn on interactive mode \n        # fig = plt.figure()  # Create a figure\n        # ax = fig.add_subplot(111)  # Create a subplot\n\n        while not flg.is_set():\n            time1 = time.time()\n            result = self.measure_spectrum()\n            print(\"Timestamp: {}\".format(convert_timestamp_us_int_to_str(result[1])))\n            print(\"Integration time [ms]: {}\".format(result[2]/1000))\n            print(\"Spectrum shape: {}\".format(result[0].shape))\n\n            # Clear the previous plot\n            # ax.clear()  \n\n            # # Plot the new data\n            # ax.plot(result[0][WAVELENGTH_LABEL], result[0][INTENSITY_LABEL])\n            # ax.set_title(\"Measured spectrum\")\n            # ax.set_xlabel(WAVELENGTH_LABEL)\n            # ax.set_ylabel(INTENSITY_LABEL)\n\n            # # Update the plot\n            # fig.canvas.draw()\n            # fig.canvas.flush_events()\n\n            time2 = time.time()\n            print(\"Measurement duration: {}ms\".format((time2 - time1)*1000))\n\n        # plt.ioff()  # Turn off interactive mode\n        # plt.show()  # Keep the plot window open at the end\n\n        print(\"----- Self-test completed -----\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.SpectrometerController_PI.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the spectrometer.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the spectrometer</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_pylablib.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the spectrometer.\n\n    Returns:\n        str: The identifier of the spectrometer\n    \"\"\"\n    if self._identifier is None:\n        self._identifier = self._get_hardware_identifier()\n    return self._identifier\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.SpectrometerController_PI.get_integration_time_limits_us","title":"<code>get_integration_time_limits_us()</code>","text":"<p>Get the integration time limits of the device</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[int, int, int]</code> <p>A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_pylablib.py</code> <pre><code>def get_integration_time_limits_us(self) -&gt; tuple[int,int,int]:\n    \"\"\"\n    Get the integration time limits of the device\n\n    Returns:\n        tuple: A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)\n    \"\"\"\n    return (self.integration_time_min, self.integration_time_max, self.integration_time_inc)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.SpectrometerController_PI.get_integration_time_us","title":"<code>get_integration_time_us()</code>","text":"<p>Get the integration time of the device</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Integration time in [device unit] (microseconds for the QE Pro)</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_pylablib.py</code> <pre><code>def get_integration_time_us(self):\n    \"\"\"\n    Get the integration time of the device\n\n    Returns:\n        int: Integration time in [device unit] (microseconds for the QE Pro)\n    \"\"\"\n    int_time_ms = self._dev.get_attribute_value(\"Exposure Time\")\n    return int_time_ms*1000\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.SpectrometerController_PI.measure_spectrum","title":"<code>measure_spectrum()</code>","text":"<p>Measures the spectrum of the Raman spectrometer.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>pandas.DataFrame: A DataFrame containing the measured spectrum with the following columns:</p> <code>int</code> <ul> <li>'Wavelength [pixel]': The wavelength values in nanometers.</li> </ul> <code>int</code> <ul> <li>'Intensity [a.u.]': The intensity values in arbitrary units.</li> </ul> <code>int</code> <code>tuple[DataFrame, int, int]</code> <p>The timestamp of the measurement in integer format (microseconds).</p> <code>int</code> <code>tuple[DataFrame, int, int]</code> <p>The integration time used for the measurement in microseconds.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_pylablib.py</code> <pre><code>def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n    \"\"\"\n    Measures the spectrum of the Raman spectrometer.\n\n    Returns:\n        pandas.DataFrame: A DataFrame containing the measured spectrum with the following columns:\n        - 'Wavelength [pixel]': The wavelength values in nanometers.\n        - 'Intensity [a.u.]': The intensity values in arbitrary units.\n        int: The timestamp of the measurement in integer format (microseconds).\n        int: The integration time used for the measurement in microseconds.\n    \"\"\"\n    # list_time = [] ### &lt;&lt;&lt;\n\n    # list_time.append(time.time()) ### &lt;&lt;&lt;\n    while True:\n        self._dev.wait_for_frame(since='lastread')\n        # list_time.append(time.time()) ### &lt;&lt;&lt;\n        result = self._dev.read_newest_image(return_info=True)\n        if result is not None: break\n        else: print('No data captured. Reinitalising the connection...'); self.initialisation()\n    img,info = result[0],result[1]\n\n    # # list_time.append(time.time()) ### &lt;&lt;&lt; \n\n    img = np.array(img)[74:80,:]\n    # img = np.array(img)\n    list_intensity = np.mean(img,axis=0)\n    list_wavelength = list(range(1, len(list_intensity) + 1))\n\n    # plt.imshow(img)\n    # plt.set_cmap('gray')\n    # plt.colorbar()\n\n    # plt.show()\n\n    # arr1 = np.array(img)[:,300]\n    # plt.plot(arr1)\n    # plt.grid()\n    # plt.minorticks_on()\n    # plt.tick_params(axis='both',which='both',direction='in',top=True,right=True)\n\n    # plt.show()\n\n    # list_time.append(time.time()) ### &lt;&lt;&lt;\n    list_wavelength = [float(wavelength) for wavelength in list_wavelength]\n    list_intensity = [float(intensity) for intensity in list_intensity]\n\n    # list_time.append(time.time()) ### &lt;&lt;&lt;\n    timestamp_us_int = int(info.timestamp_start/self._timeRes_Hz*10**6 + self._timestamp_init_us)\n    integration_time = self.get_integration_time_us()\n\n    # list_time.append(time.time()) ### &lt;&lt;&lt;\n    spectra = pd.DataFrame({\n        DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: list_wavelength,\n        DataAnalysisConfigEnum.INTENSITY_LABEL.value: list_intensity,\n    })\n\n    # list_time.append(time.time()) ### &lt;&lt;&lt;\n    # for i in range(1,len(list_time)):\n    #     print('Time {}: {}ms'.format(i,(list_time[i]-list_time[i-1])*1000))\n\n    return (spectra, timestamp_us_int, integration_time)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.SpectrometerController_PI.set_integration_time_us","title":"<code>set_integration_time_us(integration_time)</code>","text":"<p>Sets the integration time of the device</p> <p>Parameters:</p> Name Type Description Default <code>integration_time</code> <code>int</code> <p>Integration time in [device unit] </p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Device integrationt time after set up [us]</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_pylablib.py</code> <pre><code>def set_integration_time_us(self,integration_time:int) -&gt; int:\n    \"\"\"\n    Sets the integration time of the device\n\n    Args:\n        integration_time (int): Integration time in [device unit] \n        (microseconds for the QE Pro)\n\n    Returns:\n        int: Device integrationt time after set up [us]\n    \"\"\"\n    assert isinstance(integration_time,int), \"Integration time must be an integer\"\n    int_time_ms = int(integration_time/1000)\n\n    self._dev.set_attribute_value(\"Exposure Time\", int_time_ms)\n    self._restart_acquisition()\n    return self._dev.get_attribute_value(\"Exposure Time\")*1000\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.SpectrometerController_PI.terminate","title":"<code>terminate(error_flag=False)</code>","text":"<p>To terminate the connections to the Raman spectrometers</p> <p>Parameters:</p> Name Type Description Default <code>error_flag</code> <code>bool</code> <p>Can also passes an error message. Defaults to False.</p> <code>False</code> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_pylablib.py</code> <pre><code>def terminate(self, error_flag=False):\n    \"\"\"\n    To terminate the connections to the Raman spectrometers\n\n    Args:\n        error_flag (bool, optional): Can also passes an error message. Defaults to False.\n    \"\"\"\n    if error_flag!=False: print(\"\\n Error code:\",error_flag)\n\n    self._dev.stop_acquisition()\n    self._dev.close()\n\n    print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_pylablib/#iris.controllers.raman_spectrometer_controller_PI_pylablib.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/","title":"raman_spectrometer_controller_PI_trial","text":"<p>A class that allows the control of the Princeton Instruments Raman spectrometer.</p> <p>Technical notes: Because the PIXIS100 is very slow at capturing single frames, the acquisition mode is set to 'sequence' and the acquisition is performed continuously from the creation of the object. Even with this, as far as I know, the capture rate is still limited to 10Hz.</p> <p>Acknowledgement: pylablib for the library that provides the interface to the spectrometer.</p>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.acquire_image","title":"<code>acquire_image(picamlib, camera_handle, timeout=1000)</code>","text":"<p>Acquires an image from the camera.</p> <p>Parameters:</p> Name Type Description Default <code>picamlib</code> <p>The ctypes library object for the PICam library from pylablib.</p> required <code>camera_handle</code> <p>The camera handle obtained from Picam_OpenCamera.</p> required <code>timeout</code> <code>int</code> <p>The timeout in milliseconds for the acquisition.</p> <code>1000</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The acquired image data.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_trial.py</code> <pre><code>def acquire_image(picamlib, camera_handle, timeout:int=1000) -&gt; np.ndarray:\n    \"\"\"\n    Acquires an image from the camera.\n\n    Args:\n        picamlib: The ctypes library object for the PICam library from pylablib.\n        camera_handle: The camera handle obtained from Picam_OpenCamera.\n        timeout (int): The timeout in milliseconds for the acquisition.\n\n    Returns:\n        np.ndarray: The acquired image data.\n    \"\"\"\n    # Wrap the Picam_Acquire function\n    # rconv is used to convert the resulting PicamAvailableData struct to a tuple\n    # ctypes.c_int Picam_Acquire(PicamHandle camera, pi64s readout_count, piint readout_time_out, ctypes.POINTER(PicamAvailableData) available, ctypes.POINTER(ctypes.c_int) errors)\n    func_Picam_Acquire=wrapper(picamlib.Picam_Acquire,rconv={\"available\": CPicamAvailableData.tup_struct}, rvals=[\"available\", \"errors\"])\n\n    # Acquire an image\n    readout_count = 1  # Number of readouts\n    readout_time_out = -1  # Infinite timeout\n\n    # Call the wrapped function\n    available, errors = func_Picam_Acquire(camera_handle, readout_count, readout_time_out)\n\n    # Get the image data\n    ptr_image_data:CPicamAvailableData = available.initial_readout\n    print(\"Total image acquired: \", available.readout_count)\n    print(\"Image data acquired. Pointer:\")\n    print(ptr_image_data)\n\n    # Get the readout stride\n    func_Picam_GetParameterIntegerValue=wrapper(picamlib.Picam_GetParameterIntegerValue)\n    readout_stride = func_Picam_GetParameterIntegerValue(camera_handle, PicamParameter.PicamParameter_ReadoutStride)\n    print(\"Readout stride:\", readout_stride)\n\n    # Get the ROI information (assuming a single ROI for now)\n    func_Picam_GetParameterRoisValue = wrapper(picamlib.Picam_GetParameterRoisValue)\n\n    ptr_picamRois:PicamRois = func_Picam_GetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois)\n    picamRois = ptr_picamRois.contents\n    num_rois = picamRois.roi_count\n    if num_rois == 0: raise ValueError(\"No ROI found.\")\n    if num_rois &gt; 1: raise ValueError(\"Multiple ROIs found. Only one ROI is supported.\")\n\n    roi = picamRois.roi_array[0]  # Get the first ROI\n    roi_size = (roi.width//roi.x_binning, roi.height//roi.y_binning)  # width, height of the ROI\n    num_pixels = roi_size[0] * roi_size[1]\n    print(\"ROI size:\", roi_size)\n\n    # Get the pixel bit depth\n    pixel_bit_depth = func_Picam_GetParameterIntegerValue(camera_handle, PicamParameter.PicamParameter_PixelBitDepth)\n    print(\"Pixel bit depth:\", pixel_bit_depth)\n\n    # Handling the timestamp metadata\n    timestamps_param = func_Picam_GetParameterIntegerValue(camera_handle, PicamParameter.PicamParameter_TimeStamps)\n\n    # Check if timestamps are enabled\n    if timestamps_param == PicamTimeStampsMask.PicamTimeStampsMask_None: flg_timestamps = 0\n    else: flg_timestamps = 1\n\n    # Get the timestamp bit depth\n    timestamp_bit_depth = func_Picam_GetParameterIntegerValue(camera_handle, PicamParameter.PicamParameter_TimeStampBitDepth)\n    print(\"Timestamp bit depth:\", timestamp_bit_depth)\n\n    # Calculate the size of the image data for each frame\n    image_data_size = (num_pixels * pixel_bit_depth // 8)\n    timestamp_data_size = (timestamp_bit_depth + 7) // 8\n    frame_data_size = image_data_size + flg_timestamps * timestamp_data_size\n    print(\"Image data size per frame:\", frame_data_size)\n\n    if frame_data_size != readout_stride: raise ValueError(\"Readout stride does not match the expected frame data size.\")\n\n    # &gt; Extract the image data &lt;\n    # Create a buffer for the readout data\n    readout_buffer = ctypes.create_string_buffer(image_data_size)\n\n    # Copy the readout data from the initial readout pointer to the buffer\n    ctypes.memmove(readout_buffer, ptr_image_data, image_data_size)\n\n    # Convert the buffer to a numpy array based on the pixel bit depth\n    image_data:np.ndarray = np.frombuffer(readout_buffer, dtype=get_bit_depth(pixel_bit_depth))\n\n    # Reshape the image data\n    image_data = image_data.reshape((roi_size[1], roi_size[0])) # Reshape to height x width\n    print(\"Image data shape:\", image_data.shape)\n\n    # &gt; Extract the timestamp data if available &lt;\n    if flg_timestamps:\n        # Create a buffer for the timestamp data\n        timestamp_buffer = ctypes.create_string_buffer(timestamp_data_size)\n\n        # Copy the timestamp data from the initial readout pointer to the buffer\n        ctypes.memmove(timestamp_buffer, ptr_image_data + image_data_size, timestamp_data_size)\n\n        # Convert the buffer to a numpy array\n        func_Picam_GetParameterLargeIntegerValue = wrapper(picamlib.Picam_GetParameterLargeIntegerValue)\n        timestamp_resolution = func_Picam_GetParameterLargeIntegerValue(camera_handle, PicamParameter.PicamParameter_TimeStampResolution)\n        timestamp_data = int(np.frombuffer(timestamp_buffer, dtype=get_bit_depth(timestamp_bit_depth))[0])\n        timestamp_us = timestamp_data*10**6 // timestamp_resolution\n        print(\"Timestamp resolution:\", timestamp_resolution)\n        print(\"Timestamp data:\", timestamp_data)\n        print(\"Timestamp (us):\", timestamp_us)\n\n    # import matplotlib.pyplot as plt\n    # plt.imshow(image_data, cmap='hot')\n    # plt.colorbar()\n    # plt.show()\n\n    return image_data\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.get_available_camera_ids","title":"<code>get_available_camera_ids(picamlib)</code>","text":"<p>Gets the available camera IDs.</p> <p>Parameters:</p> Name Type Description Default <code>picamlib</code> <p>The ctypes library object for the PICam library.</p> required <p>Returns:</p> Type Description <code>tuple[PicamCameraID, list[PicamCameraID]] | None</code> <p>tuple[PicamCameraID,list[PicamCameraID]]|None: A tuple containing the selected camera ID and a list of all available camera IDs. or None if no camera is detected.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_trial.py</code> <pre><code>def get_available_camera_ids(picamlib) -&gt; tuple[PicamCameraID,list[PicamCameraID]]|None:\n    \"\"\"\n    Gets the available camera IDs.\n\n    Args:\n        picamlib: The ctypes library object for the PICam library.\n\n    Returns:\n        tuple[PicamCameraID,list[PicamCameraID]]|None:\n            A tuple containing the selected camera ID and a list of all available camera IDs.\n            or None if no camera is detected.\n    \"\"\"\n    func_Picam_GetAvailableCameraIDs = wrapper(picamlib.Picam_GetAvailableCameraIDs)\n    camera_ids,camera_no = func_Picam_GetAvailableCameraIDs()\n\n    for i in range(camera_no):\n        camera_id:PicamCameraID = camera_ids[i]\n        print('Detected camera no:',i)\n        print(f\"  Model: {camera_id.model}\")\n        print(f\"  Computer Interface: {camera_id.computer_interface}\")\n        print(f\"  Sensor Name: {camera_id.sensor_name.decode('utf-8')}\")  # Decode to string\n        print(f\"  Serial Number: {camera_id.serial_number.decode('utf-8')}\") # Decode to string\n        print()\n\n    if camera_no==0:\n        print('No camera detected')\n        return None\n\n    func_Picam_DestroyCameraIDs = wrapper(picamlib.Picam_DestroyCameraIDs, rvals=[])\n    func_Picam_DestroyCameraIDs(camera_ids)\n\n    if camera_no==1:\n        return camera_ids[0], camera_ids\n    else:\n        print('Multiple cameras detected. Please select the camera to be used.')\n        camera_id = camera_ids[int(input('Enter the camera number: '))]\n        return camera_id, camera_ids\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.get_available_camera_ids_old","title":"<code>get_available_camera_ids_old(picam)</code>","text":"<p>Gets the available camera IDs.</p> <p>Parameters:</p> Name Type Description Default <code>picam</code> <p>The ctypes library object for the PICam library.</p> required <p>Returns:</p> Type Description <p>A list of PicamCameraID objects.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_trial.py</code> <pre><code>def get_available_camera_ids_old(picam):\n    \"\"\"\n    Gets the available camera IDs.\n\n    Args:\n        picam: The ctypes library object for the PICam library.\n\n    Returns:\n        A list of PicamCameraID objects.\n    \"\"\"\n    # Directly wrap the Picam_GetAvailableCameraIDs function\n    wrapped_Picam_GetAvailableCameraIDs = wrapper(picam.Picam_GetAvailableCameraIDs)\n\n    # Call the wrapped function\n    camera_id_pointer_array, id_count = wrapped_Picam_GetAvailableCameraIDs()\n\n    # class PicamCameraID(ctypes.Structure):\n    #     _fields_ = [\n    #         (\"model\", ctypes.c_int),\n    #         (\"computer_interface\", ctypes.c_int),\n    #         (\"sensor_name\", ctypes.c_char*64),  # Adjust size if needed\n    #         (\"serial_number\", ctypes.c_char*64)   # Adjust size if needed\n    #     ]\n\n    # camera_id_pointer_array = ctypes.POINTER(PicamCameraID)()\n    # id_count = ctypes.c_int()\n\n    # # Define the function prototype\n    # picam.Picam_GetAvailableCameraIDs.argtypes = [\n    #     ctypes.POINTER(ctypes.POINTER(PicamCameraID)), \n    #     ctypes.POINTER(ctypes.c_int)  # Use ctypes.c_int for piint\n    # ]\n    # picam.Picam_GetAvailableCameraIDs.restype = ctypes.c_int\n\n    # picam.Picam_GetAvailableCameraIDs(ctypes.byref(camera_id_pointer_array), ctypes.byref(id_count))\n\n    camera_ids = []\n    camera_id_pointer_array\n    if camera_id_pointer_array:\n        # Access the PicamCameraID structure directly\n        camera_id = camera_id_pointer_array.contents\n        camera_ids.append(camera_id)\n\n        # Access and print camera information\n        print(\"Camera Information:\")\n        print(f\"  Model: {camera_id.model}\")\n        print(f\"  Computer Interface: {camera_id.computer_interface}\")\n        print(f\"  Sensor Name: {camera_id.sensor_name.decode('utf-8')}\")  # Decode to string\n        print(f\"  Serial Number: {camera_id.serial_number.decode('utf-8')}\") # Decode to string\n\n        # picam.Picam_DestroyCameraIDs(camera_id_pointer_array)\n    return camera_ids\n\n    class PicamCameraID(ctypes.Structure):\n        _fields_ = [\n            (\"model\", ctypes.c_int),\n            (\"computer_interface\", ctypes.c_int),\n            (\"sensor_name\", ctypes.c_char*64),  # Adjust size if needed\n            (\"serial_number\", ctypes.c_char*64)   # Adjust size if needed\n        ]\n\n    def wrap_available_camera_ids(picam):\n        \"\"\"\n        Wraps the Picam_GetAvailableCameraIDs function from the PICam library.\n\n        Args:\n            picam_lib: The ctypes library object for the PICam library.\n\n        Returns:\n            A wrapped Python function that calls Picam_GetAvailableCameraIDs.\n        \"\"\"\n\n        # Define the function prototype\n        picam.Picam_GetAvailableCameraIDs.argtypes = [\n            ctypes.POINTER(ctypes.POINTER(PicamCameraID)), \n            ctypes.POINTER(ctypes.c_int)  # Use ctypes.c_int for piint\n        ]\n        picam.Picam_GetAvailableCameraIDs.restype = ctypes.c_int\n\n        # Create the wrapper function\n        def wrapped_func():\n            id_array = ctypes.POINTER(PicamCameraID)()\n            id_count = ctypes.c_int()\n            result = picam.Picam_GetAvailableCameraIDs(ctypes.byref(id_array), ctypes.byref(id_count))\n\n            if result != 0:\n                raise ctypes.WinError(result)  # Raise a Windows error if the function fails\n\n            camera_ids = []\n            for i in range(id_count.value):\n                camera_ids.append(id_array[i])\n\n            # picam_lib.Picam_DestroyCameraIDs(ctypes.cast(id_array, ctypes.POINTER(PicamCameraID)))  # Clean up memory\n\n            return camera_ids\n\n        return wrapped_func\n\n    # Example usage:\n    # Assuming you have the PICam library loaded as 'picam_lib'\n    get_available_camera_ids = wrap_available_camera_ids(picam)\n    camera_ids = get_available_camera_ids()\n\n    for camera_id in camera_ids:\n        print(f\"Model: {camera_id.model}\")\n        print(f\"Sensor Name: {camera_id.sensor_name.decode('utf-8')}\")\n        print(f\"Serial Number: {camera_id.serial_number.decode('utf-8')}\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.plot_mean_col","title":"<code>plot_mean_col(image_data)</code>","text":"<p>Plots the mean column of the image data. Useful for setting the ROI rows.</p> <p>Parameters:</p> Name Type Description Default <code>image_data</code> <code>ndarray</code> <p>The image data from acquire_image.</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_PI_trial.py</code> <pre><code>def plot_mean_col(image_data:np.ndarray):\n    \"\"\"\n    Plots the mean column of the image data. Useful for setting the ROI rows.\n\n    Args:\n        image_data (np.ndarray): The image data from acquire_image.\n    \"\"\"\n    import matplotlib.pyplot as plt\n    mean_col = np.mean(image_data, axis=0)\n    plt.plot(mean_col)\n    plt.xlabel(\"Pixel columns\")\n    plt.ylabel(\"Mean Intensity\")\n    plt.title(\"Mean Column of Image Data\")\n    plt.minorticks_on()\n    plt.grid(which='both', linestyle='--', linewidth=0.5)\n    plt.show()\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.plot_mean_row","title":"<code>plot_mean_row(image_data)</code>","text":"<p>Plots the mean row of the image data. Useful for setting the ROI columns.</p> <p>Parameters:</p> Name Type Description Default <code>image_data</code> <code>ndarray</code> <p>The image data from acquire_image.</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_PI_trial.py</code> <pre><code>def plot_mean_row(image_data:np.ndarray):\n    \"\"\"\n    Plots the mean row of the image data. Useful for setting the ROI columns.\n\n    Args:\n        image_data (np.ndarray): The image data from acquire_image.\n    \"\"\"\n    import matplotlib.pyplot as plt\n    mean_row = np.mean(image_data, axis=1)\n    plt.plot(mean_row)\n    plt.xlabel(\"Pixel rows\")\n    plt.ylabel(\"Mean Intensity\")\n    plt.title(\"Mean Row of Image Data\")\n    plt.minorticks_on()\n    plt.grid(which='both', linestyle='--', linewidth=0.5)\n    plt.show()\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.set_ROI","title":"<code>set_ROI(picamlib, camera_handle, row=None, col=None, bin_row=None)</code>","text":"<p>Sets the Region of Interest (ROI) for the camera as well as the binning.</p> <p>Parameters:</p> Name Type Description Default <code>picamlib</code> <p>The ctypes library object for the PICam library from pylablib.</p> required <code>camera_handle</code> <p>The camera handle obtained from Picam_OpenCamera.</p> required <code>row</code> <code>tuple[float, float] | None</code> <p>The range of rows to be used for the ROI (min, max). if None, the default ROI will be used. Defaults to None.</p> <code>None</code> <code>col</code> <code>tuple[float, float] | None</code> <p>The range of columns to be used for the ROI (min, max). if None, the default ROI will be used. Defaults to None.</p> <code>None</code> <code>bin_row</code> <code>int | None</code> <p>The number of rows to bin, if larger than the ROI size, the min of the two will be chosen. If None, the default binning will be used. Defaults to None.</p> <code>None</code> Source code in <code>iris/controllers/raman_spectrometer_controller_PI_trial.py</code> <pre><code>def set_ROI(picamlib, camera_handle, row:tuple[float,float]|None=None, col:tuple[float,float]|None=None, bin_row:int|None=None):\n    \"\"\"\n    Sets the Region of Interest (ROI) for the camera as well as the binning.\n\n    Args:\n        picamlib: The ctypes library object for the PICam library from pylablib.\n        camera_handle: The camera handle obtained from Picam_OpenCamera.\n        row (tuple[float,float]|None, optional): The range of rows to be used for the ROI (min, max).\n            if None, the default ROI will be used. Defaults to None.\n        col (tuple[float,float]|None, optional): The range of columns to be used for the ROI (min, max).\n            if None, the default ROI will be used. Defaults to None.\n        bin_row (int | None, optional): The number of rows to bin, if larger than the ROI size,\n            the min of the two will be chosen. If None, the default binning will be used. Defaults to None.\n    \"\"\"\n    func_Picam_GetParameterRoisDefaultValue=wrapper(picamlib.Picam_GetParameterRoisDefaultValue)\n    func_Picam_GetParameterRoisValue = wrapper(picamlib.Picam_GetParameterRoisValue)\n    func_Picam_CanSetParameterRoisValue=wrapper(picamlib.Picam_CanSetParameterRoisValue, rvals=[\"settable\"])\n    func_Picam_SetParameterRoisValue=wrapper(picamlib.Picam_SetParameterRoisValue, rvals=[])\n    func_Picam_DestroyRois=wrapper(picamlib.Picam_DestroyRois, rvals=[])\n    func_Picam_CommitParameters=wrapper(picamlib.Picam_CommitParameters)\n\n    # Get the default ROI information\n    ptr_picamRoisDefault:PicamRois = func_Picam_GetParameterRoisDefaultValue(camera_handle, PicamParameter.PicamParameter_Rois)\n    picamRoiDefault = ptr_picamRoisDefault.contents.roi_array[0]  # Get the first ROI\n    func_Picam_DestroyRois(ptr_picamRoisDefault)\n\n    print(\"Default ROI:\")\n    print(\"  x:\", picamRoiDefault.x)\n    print(\"  width:\", picamRoiDefault.width)\n    print(\"  x_binning:\", picamRoiDefault.x_binning)\n    print(\"  y:\", picamRoiDefault.y)\n    print(\"  height:\", picamRoiDefault.height)\n    print(\"  y_binning:\", picamRoiDefault.y_binning)\n\n    # Get the ROI information (assuming a single ROI for now)\n    ptr_picamRois:PicamRois = func_Picam_GetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois)\n    picamRoi = ptr_picamRois.contents.roi_array[0]  # Get the first ROI\n\n    print(\"Current ROI:\")\n    print(\"  x:\", picamRoi.x)\n    print(\"  width:\", picamRoi.width)\n    print(\"  x_binning:\", picamRoi.x_binning)\n    print(\"  y:\", picamRoi.y)\n    print(\"  height:\", picamRoi.height)\n    print(\"  y_binning:\", picamRoi.y_binning)\n\n    row = (max(row[0],0), min(row[1],picamRoiDefault.height)) if row else (picamRoi.y, picamRoi.y+picamRoi.height)\n    col = (max(col[0],0), min(col[1],picamRoiDefault.width)) if col else (picamRoi.x, picamRoi.x+picamRoi.width)\n    bin_row = min(bin_row, row[1]-row[0]) if bin_row else picamRoiDefault.y_binning\n\n    new_roi = picamRoi\n    new_roi.x = ctypes.c_int(col[0]) if col else picamRoiDefault.x\n    new_roi.width = ctypes.c_int(col[1]-col[0]) if col else picamRoiDefault.width\n    new_roi.y = ctypes.c_int(row[0]) if row else picamRoiDefault.y\n    new_roi.height = ctypes.c_int(row[1]-row[0]) if row else picamRoiDefault.height\n    new_roi.y_binning = ctypes.c_int(bin_row) if bin_row else picamRoiDefault.y_binning\n\n    # Check if the ROI can be set\n    settable = func_Picam_CanSetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois, ptr_picamRois)\n    print(\"ROI settable:\", settable)\n\n    # Set the ROI\n    if not settable: func_Picam_DestroyRois(ptr_picamRois); raise ValueError(\"ROI cannot be set.\")\n    func_Picam_SetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois, ptr_picamRois)\n    func_Picam_CommitParameters(camera_handle)\n    func_Picam_DestroyRois(ptr_picamRois)\n\n    # Get the ROI information again\n    ptr_picamRois:PicamRois = func_Picam_GetParameterRoisValue(camera_handle, PicamParameter.PicamParameter_Rois)\n    picamRoi = ptr_picamRois.contents.roi_array[0]  # Get the first ROI\n    func_Picam_DestroyRois(ptr_picamRois)\n\n    print(\"New ROI:\")\n    print(\"  x:\", picamRoi.x)\n    print(\"  width:\", picamRoi.width)\n    print(\"  x_binning:\", picamRoi.x_binning)\n    print(\"  y:\", picamRoi.y)\n    print(\"  height:\", picamRoi.height)\n    print(\"  y_binning:\", picamRoi.y_binning)\n\n    return\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.set_integration_time","title":"<code>set_integration_time(picamlib, camera_handle, int_time_ms)</code>","text":"<p>Sets the integration time for the camera.</p> <p>Parameters:</p> Name Type Description Default <code>picamlib</code> <p>The ctypes library object for the PICam library from pylablib.</p> required <code>camera_handle</code> <p>The camera handle obtained from Picam_OpenCamera.</p> required <code>integration_time</code> <code>float</code> <p>The integration time in milliseconds.</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_PI_trial.py</code> <pre><code>def set_integration_time(picamlib, camera_handle, int_time_ms:float):\n    \"\"\"\n    Sets the integration time for the camera.\n\n    Args:\n        picamlib: The ctypes library object for the PICam library from pylablib.\n        camera_handle: The camera handle obtained from Picam_OpenCamera.\n        integration_time (float): The integration time in milliseconds.\n    \"\"\"\n    func_Picam_GetParameterFloatingPointValue=wrapper(picamlib.Picam_GetParameterFloatingPointValue)\n    func_Picam_SetParameterFloatingPointValue=wrapper(picamlib.Picam_SetParameterFloatingPointValue)\n    func_Picam_CommitParameters=wrapper(picamlib.Picam_CommitParameters)\n\n    # Get the current integration time\n    curr_int_time_ms = func_Picam_GetParameterFloatingPointValue(camera_handle, PicamParameter.PicamParameter_ExposureTime)\n    print(\"Current integration time:\", curr_int_time_ms)\n\n    func_Picam_SetParameterFloatingPointValue(camera_handle, PicamParameter.PicamParameter_ExposureTime, int_time_ms)\n    func_Picam_CommitParameters(camera_handle)\n\n    # Get the new integration time\n    curr_int_time_ms = func_Picam_GetParameterFloatingPointValue(camera_handle, PicamParameter.PicamParameter_ExposureTime)\n    print(\"New integration time:\", curr_int_time_ms)\n\n    return\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_PI_trial/#iris.controllers.raman_spectrometer_controller_PI_trial.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/","title":"raman_spectrometer_controller_QEPro","text":"<p>A class that allows the control of the QE Pro spectrometer from Ocean Insight. This implementation is based on the API provided by Ocean Insight.</p>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.SpectrometerController_QEPro","title":"<code>SpectrometerController_QEPro</code>","text":"<p>               Bases: <code>Class_SpectrometerController</code></p> Source code in <code>iris/controllers/raman_spectrometer_controller_QEPro.py</code> <pre><code>class SpectrometerController_QEPro(Class_SpectrometerController):\n    def __init__(self) -&gt; None:\n        # Get the Ocean Direct classes from the wrapper\n        OceanDirectAPI, OceanDirectError, FeatureID = get_oceandirect_classes()\n\n        # Store the classes as instance variables for use in other methods\n        self.OceanDirectAPI = OceanDirectAPI\n        self.OceanDirectError = OceanDirectError\n        self.FeatureID = FeatureID\n\n        # Create the API instance with proper path handling\n        self.od = create_oceandirect_api()                  # Ocean Direct API\n        self.dev_count = self.od.find_usb_devices()         # Device count\n        self.dev_ids = self.od.get_device_ids()             # Device IDs (if multiple)\n        self.api_info = self.od.get_api_version_numbers()   # API info\n\n        self.dev = None         # OD API device class\n        self.dev_id = None      # Store the device ID\n        self.dev_serial = None  # device serial number\n\n        # Aquisition related parameters\n        self.integration_time_min = None        # int: Stores the spectrometer's minimum allowable integration time [millisec]\n        self.integration_time_max = None        # int: Stores the spectrometer's maximum allowable integration time [millisec]\n        self.integration_time_inc = None        # int: Stores the spectrometer's allowable integration time increment [millisec]\n\n        # Calibration related parameters\n        self.bg_acq_num = 10    # Number of aquisition for the background removal\n        self.bg_spec = None     # The background spectrum\n\n\n        # Lock for the device communications\n        self._lock = Lock()     # Lock for the acquisition process\n\n        self._mode:Literal['discreet','continuous'] = ControllerSpecificConfigEnum.OCEANINSIGHT_MODE.value\n        if not self._mode in ['discreet','continuous']: self._mode = 'continuous'\n\n        # &gt;&gt;&gt; Current implementation is for the 'continuous' mode only. The 'discreet' mode seems to be causing some weird communication slowdowns.\n        print(f\"\\n&gt;&gt;&gt;&gt;&gt; QEPro: Current mode: {self._mode}\")\n        print(f\"Warning: The 'discreet' mode is NOT FULLY IMPLEMENTED yet and might cause some random SLOWDOWNS. If you experience any issues, please switch to the 'continuous' mode.\\n\")\n        print(\"&lt;&lt;&lt;&lt;&lt;\\n\")\n\n\n        # Measurement related parameters\n        if self._mode == 'discreet':\n            self._init_timestamp = None # Initial timestamp of the measurement\n            self._offset_timestamp = None # Offset timestamp of the measurement\n            self._temp_list_mea = []    # Temporary list to transfer measurements from the device\n            self._temp_list_ts = []     # Temporary list to transfer timestamps from the device\n\n        # Acquisition parameters:\n        self._wavelength:list = None\n\n        # Start the initialisation process\n        self.initialisation()\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the spectrometer.\n\n        Returns:\n            str: The identifier of the spectrometer\n        \"\"\"\n        return self._identifier\n\n# Core functionalities (initialisation, termination)\n    def initialisation(self):\n        \"\"\"\n        Initializes the Raman spectrometer controller.\n\n        This function performs the following tasks:\n        1. Prints the API info and the number of devices connected.\n        2. Checks if any device is found. If not, it terminates the program.\n        3. Checks if more than one device is found. If so, it terminates the program.\n        4. Creates a device instance using the first device in the device list.\n        5. Retrieves the serial number of the device.\n        6. Retrieves the integration time requirements of the device.\n        \"\"\"\n        # Print the API info and the devices connected\n        print(\"API Version  : %d.%d.%d \" % self.api_info)   # if this doesn't work, try (self.api_info[0],self.api_info[1],self.api_info[2])\n        print(\"Total Device : %d     \\n\" % self.dev_count)\n\n        if self.dev_count == 0:\n            print(\"&gt;&gt; No device found &lt;&lt;\")\n            self.terminate()\n            return\n        elif self.dev_count&gt;1:\n            print(\"&gt;&gt; More than 1 device is found &lt;&lt;\")\n            print(\"The program has not been designed to handle more than 1 devices and thus will be shut down\")\n            self.terminate(True)\n            return\n\n        # Create a device instance by taking the 1st in the device list\n        self.dev_id = self.dev_ids[0]\n        self.dev = self.od.open_device(self.dev_id)\n        self.dev_serial = self.dev.get_serial_number()\n        print(\"First Device : %d       \" % self.dev_id)\n        print(\"Serial Number: %s     \\n\" % self.dev_serial)\n\n        self._identifier = f\"Ocean Insight, device id: {self.dev_id}, S/N:{self.dev_serial}\"\n\n        # Retrieve the integration time requirements of the device\n        self.integration_time_max = self.dev.get_maximum_integration_time()\n        self.integration_time_min = self.dev.get_minimum_integration_time()\n        self.integration_time_inc = self.dev.get_integration_time_increment()\n\n        # Initialise the timestamp\n        if self._mode == 'discreet':\n            with self._lock:\n                int_time = self.dev.get_integration_time()\n                min_int_time = self.dev.get_minimum_integration_time()\n                self.dev.set_integration_time(min_int_time)\n\n                self._init_timestamp = get_timestamp_us_int()\n                self._temp_list_mea.clear(); self._temp_list_ts.clear()\n\n                # self.dev.Advanced.set_number_of_backtoback_scans(1)\n                self.dev.Advanced.acquire_spectra_to_buffer()\n                self.dev.Advanced.get_raw_spectrum_with_metadata(self._temp_list_mea, self._temp_list_ts, 1)\n\n                self._offset_timestamp = self._temp_list_ts[-1]\n                self.dev.set_integration_time(int_time)\n\n        if self._mode == 'continuous':\n            with self._lock:\n                self.dev.Advanced.acquire_spectra_to_buffer()\n\n        # Grab the wavelengths of the device\n        self._wavelength = self.dev.get_wavelengths()\n\n    def terminate(self, error_flag=False):\n        \"\"\"\n        To terminate the connections to the Raman spectrometers\n\n        Args:\n            error_flag (bool, optional): Can also passes an error message. Defaults to False.\n        \"\"\"\n        if error_flag!=False:\n            print(\"\\n Error code:\")\n            print(error_flag)\n\n        for i in range(len(self.dev_ids)):\n            self.od.close_device(self.dev_ids[i])\n\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n        print(\"Ocean Insight devices disconnected\")\n\n    def get_integration_time_limits_us(self):\n        \"\"\"\n        Get the integration time limits of the device\n\n        Returns:\n            tuple: A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)\n        \"\"\"\n        return (self.integration_time_min, self.integration_time_max, self.integration_time_inc)\n\n    def get_integration_time_us(self):\n        \"\"\"\n        Get the integration time of the device\n\n        Returns:\n            int: Integration time in [device unit] (microseconds for the QE Pro)\n        \"\"\"\n        with self._lock:\n            int_time = self.dev.get_integration_time()\n        return int_time\n\n    def set_integration_time_us(self,integration_time:int):\n        \"\"\"Sets the integration time of the device\n\n        Args:\n            integration_time (int): Integration time in [device unit] \n            (microseconds for the QE Pro)\n\n        Returns:\n            int: Device integrationt time after set up\n        \"\"\"\n\n        print('work here (raman spectrometer controller file)')\n\n        if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n            raise ValueError(\"Integration time must be an integer\")\n        integration_time = int(integration_time)\n\n        with self._lock:\n            self.dev.set_integration_time(integration_time)\n            int_time = self.dev.get_integration_time()\n\n        return int_time\n\n# Spectrometer acquisition control\n    def _acquisitionDelay(self, delay_value):\n        \"\"\"\n        Sets the acquisition delay of the spectrometer.\n        This may also be referred to as the trigger delay.\n        In any event, it is the time between some event (such as a request for data, or an external trigger pulse) and when data acquisition begins.\n\n        Q. Why is it needed?\n        Sometimes we want to delay the acquisition so that the \n\n        Args:\n            delay_value (int): The acquisition delay to be set [us]\n        \"\"\"\n        #device.set_acquisition_delay(120)\n        #print(\"acquisitionDelay(device): set acqDelay 120\")\n        device = self.dev\n\n        acqDelay    = device.get_acquisition_delay()\n        acqDelayInc = device.get_acquisition_delay_increment()\n        acqDelayMin = device.get_acquisition_delay_minimum()\n        acqDelayMax = device.get_acquisition_delay_maximum()\n\n        print(\"acquisitionDelay(device): acqDelay     =  %d \" % acqDelay)\n        print(\"acquisitionDelay(device): acqDelayInc  =  %d \" % acqDelayInc)\n        print(\"acquisitionDelay(device): acqDelayMin  =  %d \" % acqDelayMin)\n        print(\"acquisitionDelay(device): acqDelayMax  =  %d \" % acqDelayMax)\n        print(\"\")\n\n        # Now to set the delay value\n        with self._lock:\n            self.dev.set_acquisition_delay(delay_value)\n            print(\"acquisitionDelay(device): set acqDelay =  %d \" % delay_value)\n\n            # Print the new delay value to check\n            acqDelay = self.dev.get_acquisition_delay()\n        print(\"acquisitionDelay(device): get acqDelay(expected %d)  =  %d \" % (delay_value,acqDelay))\n        print(\"\")\n\n    def _set_analyser_boxcar(self, scanToAve, boxcarWidth):\n        \"\"\"\n        A function to smoothen the read spectrum using the boxcar method.\n        Basically, it takes the points around it and averages them out.\n        It also takes several acquisition data and averages them too, hence the name boxcar.\n\n        Args:\n            scanToAve (int): the number of scan acquisition to be averaged out\n            boxcarWidth (int): the number of neighboring data points to be averaged out\n        \"\"\"\n\n        # Set the device to set up as the device of this current class instance\n        device = self.dev\n        try:\n            value = device.get_scans_to_average() #Gets the number of spectra to average.\n            print(\"scanToAverageBoxcar(): cur scans_to_average        =  %d\" % value)\n\n            value = device.get_integration_time() #Returns the current integration time on the device in microseconds.\n            print(\"scanToAverageBoxcar(): current integrationTimeUs   =  %dus\" % value)\n\n            minAveIntTime = device.get_minimum_averaging_integration_time()\n            # This function returns the smallest integration time setting, in microseconds, that is valid for the spectrometer.\n            # NOTE: some devices that make use of onboard functionality to perform averaging have a different, larger, minimum integration time\n            # for acquisition when averaging is enabled. Refer to the documentation for your spectrometer to see if this is the case. The \n            # minimum integration time when averaging is enabled can be determined using odapi_get_minimum_averaging_integration_time_micros.\n            print(\"scanToAverageBoxcar(): minAverageIntegrationTimeUs =  %d\" % minAveIntTime)\n            print(\"\")\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"scanToAverageBoxcar(): set/get / %d = %s\" % (errorCode, errorMsg))\n\n        try:\n            # Sets the number of spectra to average.\n            print(\"scanToAverageBoxcar(): set_scans_to_average        =  %d\" % scanToAve)\n            device.set_scans_to_average(scanToAve)\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"scanToAverageBoxcar(): ERROR with code/scanToAverage, %d = %s ************\" % (errorCode, scanToAve))\n\n        try:\n            # Print to check the new value\n            value = device.get_scans_to_average()\n            print(\"scanToAverageBoxcar(): get_scans_to_average        =  %d\" % value)\n\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"scanToAverageBoxcar(device): set/get / %d = %s\" % (errorCode, errorMsg))\n\n        try:\n            # Sets the boxcar width to average the spectral data.\n            device.set_boxcar_width(boxcarWidth)\n            print(\"scanToAverageBoxcar(): set_boxcar_width            =  %d\" % boxcarWidth)\n\n            # Print to check the boxcar width we just set\n            value = device.get_boxcar_width()\n            print(\"scanToAverageBoxcar(): get_boxcar_width            =  %d\" % value)\n\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"scanToAverageBoxcar(): set/get / %d = %s\" % (errorCode, errorMsg))\n        print(\"\")\n\n    def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n        \"\"\" \n        A function to measure the spectrum of the Raman spectrometer.\n\n        Returns:\n            tuple[pd.DataFrame, int, int]: A tuple containing the following:\n                - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                    intensity columns, from the config file. (as a global constant)\n                - int: The timestamp of the measurement in integer format (microseconds).\n                - int: The integration time used for the measurement in microseconds.\n        \"\"\"\n        with self._lock:\n            if self._mode == 'continuous':\n                timestamp = get_timestamp_us_int()\n                intensity_raw = self.dev.get_formatted_spectrum()\n                timestamp = int((timestamp + get_timestamp_us_int())/2)\n\n            if self._mode == 'discreet':\n                # new method:\n                adv = self.dev.Advanced\n                adv.abort_acquisition()\n                adv.clear_data_buffer()\n\n                self._temp_list_mea.clear()\n                self._temp_list_ts.clear()\n\n                adv.acquire_spectra_to_buffer()\n                adv.get_raw_spectrum_with_metadata(self._temp_list_mea, self._temp_list_ts, 1)\n\n                adv.abort_acquisition()\n                adv.clear_data_buffer()\n\n                intensity_raw = self._temp_list_mea[-1]\n                timestamp = self._temp_list_ts[-1] + self._init_timestamp - self._offset_timestamp\n\n            wavelength = self._wavelength\n            integration_time = self.dev.get_integration_time()\n\n        # Convert ctypes LP_c_double objects to Python floats\n        # The Ocean Direct API returns ctypes objects that need to be converted\n        try:\n            # For continuous mode: intensity_raw is a ctypes array\n            # For discrete mode: intensity_raw is a ctypes POINTER(c_double)\n            if hasattr(intensity_raw, '_length_'):\n                # It's a ctypes array, convert each element\n                intensity = [float(intensity_raw[i]) for i in range(len(intensity_raw))]\n            else:\n                # It's a ctypes pointer, convert each element by indexing\n                # Get the length from wavelength array since they should match\n                intensity = [float(intensity_raw[i]) for i in range(len(wavelength))]\n        except (TypeError, AttributeError):\n            # Fallback: if intensity_raw is already a list of floats, use as-is\n            intensity = intensity_raw\n\n        spectra = pd.DataFrame({\n            DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: wavelength,\n            DataAnalysisConfigEnum.INTENSITY_LABEL.value: intensity,\n        })\n        return (spectra, timestamp, integration_time)\n\n    def self_test_get_spec_formatted(self):\n        \"\"\"\n        Q. Honestly, I don't really understand what this does.\n        \"\"\"\n        device = self.dev\n        sn = self.dev_serial\n        try:\n            #100ms\n            device.set_integration_time(100000)\n\n            print(\"Reading spectra for dev s/n = %s\" % sn, flush=True)\n            for i in range(10):\n                spectra = device.get_formatted_spectrum()\n                print(\"spectra[100]: %d, %d, %d, %d\" % (spectra[100], spectra[101], spectra[102], spectra[103]), flush=True)\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"get_spec_formatted(device): exception / %d = %s\" % (errorCode, errorMsg))\n\n\n        \"\"\"\n        To set up an external light source\n        \"\"\"\n        device = self.dev\n        periodInc = 0\n        try:\n            periodInc = device.Advanced.get_continuous_strobe_period_increment()\n            print(\"continuousStrobe(device): period increment =  %d \" % periodInc)\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"continuousStrobe(device): get_continuous_strobe_period_increment() %d = %s\" % (errorCode, errorMsg))\n\n        strobePeriod = device.Advanced.get_continuous_strobe_period()\n        print(\"continuousStrobe(device): get strobePeriod =  %d \" % strobePeriod)\n\n        strobeEnable = device.Advanced.get_continuous_strobe_enable()\n        print(\"continuousStrobe(device): get strobeEnable =  %s \" % strobeEnable)\n\n        values = [False, True]\n        for enable in values:\n            device.Advanced.set_continuous_strobe_enable(False)\n            print(\"continuousStrobe(device): get strobeEnable =  %s \" % enable)\n            strobeEnable = device.Advanced.get_continuous_strobe_enable()\n            print(\"continuousStrobe(device): set strobeEnable =  %s \" % enable)\n            print(\"\")\n\n        try:\n            periodMin = device.Advanced.get_continuous_strobe_period_minimum()\n            print(\"continuousStrobe(device): periodMin          =  %d \" % periodMin)\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"continuousStrobe(device): get_continuous_strobe_period_minimum() %d = %s\" % (errorCode, errorMsg))\n\n        try:\n            periodMax = device.Advanced.get_continuous_strobe_period_maximum()\n            print(\"continuousStrobe(device): periodMax          =  %d \" % periodMax)\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"continuousStrobe(device): get_continuous_strobe_period_maximum() %d = %s\" % (errorCode, errorMsg))\n\n\n\n        strobePeriodList = [1200, 1505, 800, 453]\n        for period in strobePeriodList:\n            if (periodInc &gt; 1) and ((period % periodInc) != 0):\n                print(\"continuousStrobe(device): set strobePeriod =  %d  ====&gt; ********* expecting EXCEPTION!\" % period)\n\n            try:\n                device.Advanced.set_continuous_strobe_period(period)\n                print(\"continuousStrobe(device): set strobePeriod =  %d \" % period)\n            except self.OceanDirectError as err:\n                [errorCode, errorMsg] = err.get_error_details()\n                print(\"continuousStrobe(device): set_continuous_strobe_period() %d = %s\" % (errorCode, errorMsg))\n\n            try:\n                period = device.Advanced.get_continuous_strobe_period()\n                print(\"continuousStrobe(device): get strobePeriod =  %d \" % period)\n            except self.OceanDirectError as err:\n                [errorCode, errorMsg] = err.get_error_details()\n                print(\"continuousStrobe(device): get_continuous_strobe_period() %d = %s\" % (errorCode, errorMsg))\n            print(\"\")\n\n        try:\n            strobeWidth = 216\n            device.Advanced.set_continuous_strobe_width(strobeWidth)\n            print(\"continuousStrobe(device): set strobeWidth    =  %d \" % strobeWidth)\n\n            strobeWidth = device.Advanced.get_continuous_strobe_width()\n            print(\"continuousStrobe(device): get strobeWidth    =  %d \" % strobeWidth)\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"continuousStrobe(device): %d = %s\" % (errorCode, errorMsg))\n\n        print(\"\")\n\n# Set of commands for testing/automation\n    def self_test(self):\n        self._acquisitionDelay(400)\n        self._set_analyser_boxcar(scanToAve= 2, boxcarWidth= 0)\n        self.self_test_get_spec_formatted()\n\n        #Reset the analyser\n        self._set_analyser_boxcar(scanToAve= 1, boxcarWidth= 0)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.SpectrometerController_QEPro.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the spectrometer.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the spectrometer</p> Source code in <code>iris/controllers/raman_spectrometer_controller_QEPro.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the spectrometer.\n\n    Returns:\n        str: The identifier of the spectrometer\n    \"\"\"\n    return self._identifier\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.SpectrometerController_QEPro.get_integration_time_limits_us","title":"<code>get_integration_time_limits_us()</code>","text":"<p>Get the integration time limits of the device</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)</p> Source code in <code>iris/controllers/raman_spectrometer_controller_QEPro.py</code> <pre><code>def get_integration_time_limits_us(self):\n    \"\"\"\n    Get the integration time limits of the device\n\n    Returns:\n        tuple: A tuple containing the minimum, maximum, and increment of the integration time in [device unit] (microseconds for the QE Pro)\n    \"\"\"\n    return (self.integration_time_min, self.integration_time_max, self.integration_time_inc)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.SpectrometerController_QEPro.get_integration_time_us","title":"<code>get_integration_time_us()</code>","text":"<p>Get the integration time of the device</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Integration time in [device unit] (microseconds for the QE Pro)</p> Source code in <code>iris/controllers/raman_spectrometer_controller_QEPro.py</code> <pre><code>def get_integration_time_us(self):\n    \"\"\"\n    Get the integration time of the device\n\n    Returns:\n        int: Integration time in [device unit] (microseconds for the QE Pro)\n    \"\"\"\n    with self._lock:\n        int_time = self.dev.get_integration_time()\n    return int_time\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.SpectrometerController_QEPro.initialisation","title":"<code>initialisation()</code>","text":"<p>Initializes the Raman spectrometer controller.</p> <p>This function performs the following tasks: 1. Prints the API info and the number of devices connected. 2. Checks if any device is found. If not, it terminates the program. 3. Checks if more than one device is found. If so, it terminates the program. 4. Creates a device instance using the first device in the device list. 5. Retrieves the serial number of the device. 6. Retrieves the integration time requirements of the device.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_QEPro.py</code> <pre><code>def initialisation(self):\n    \"\"\"\n    Initializes the Raman spectrometer controller.\n\n    This function performs the following tasks:\n    1. Prints the API info and the number of devices connected.\n    2. Checks if any device is found. If not, it terminates the program.\n    3. Checks if more than one device is found. If so, it terminates the program.\n    4. Creates a device instance using the first device in the device list.\n    5. Retrieves the serial number of the device.\n    6. Retrieves the integration time requirements of the device.\n    \"\"\"\n    # Print the API info and the devices connected\n    print(\"API Version  : %d.%d.%d \" % self.api_info)   # if this doesn't work, try (self.api_info[0],self.api_info[1],self.api_info[2])\n    print(\"Total Device : %d     \\n\" % self.dev_count)\n\n    if self.dev_count == 0:\n        print(\"&gt;&gt; No device found &lt;&lt;\")\n        self.terminate()\n        return\n    elif self.dev_count&gt;1:\n        print(\"&gt;&gt; More than 1 device is found &lt;&lt;\")\n        print(\"The program has not been designed to handle more than 1 devices and thus will be shut down\")\n        self.terminate(True)\n        return\n\n    # Create a device instance by taking the 1st in the device list\n    self.dev_id = self.dev_ids[0]\n    self.dev = self.od.open_device(self.dev_id)\n    self.dev_serial = self.dev.get_serial_number()\n    print(\"First Device : %d       \" % self.dev_id)\n    print(\"Serial Number: %s     \\n\" % self.dev_serial)\n\n    self._identifier = f\"Ocean Insight, device id: {self.dev_id}, S/N:{self.dev_serial}\"\n\n    # Retrieve the integration time requirements of the device\n    self.integration_time_max = self.dev.get_maximum_integration_time()\n    self.integration_time_min = self.dev.get_minimum_integration_time()\n    self.integration_time_inc = self.dev.get_integration_time_increment()\n\n    # Initialise the timestamp\n    if self._mode == 'discreet':\n        with self._lock:\n            int_time = self.dev.get_integration_time()\n            min_int_time = self.dev.get_minimum_integration_time()\n            self.dev.set_integration_time(min_int_time)\n\n            self._init_timestamp = get_timestamp_us_int()\n            self._temp_list_mea.clear(); self._temp_list_ts.clear()\n\n            # self.dev.Advanced.set_number_of_backtoback_scans(1)\n            self.dev.Advanced.acquire_spectra_to_buffer()\n            self.dev.Advanced.get_raw_spectrum_with_metadata(self._temp_list_mea, self._temp_list_ts, 1)\n\n            self._offset_timestamp = self._temp_list_ts[-1]\n            self.dev.set_integration_time(int_time)\n\n    if self._mode == 'continuous':\n        with self._lock:\n            self.dev.Advanced.acquire_spectra_to_buffer()\n\n    # Grab the wavelengths of the device\n    self._wavelength = self.dev.get_wavelengths()\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.SpectrometerController_QEPro.measure_spectrum","title":"<code>measure_spectrum()</code>","text":"<p>A function to measure the spectrum of the Raman spectrometer.</p> <p>Returns:</p> Type Description <code>tuple[DataFrame, int, int]</code> <p>tuple[pd.DataFrame, int, int]: A tuple containing the following: - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and     intensity columns, from the config file. (as a global constant) - int: The timestamp of the measurement in integer format (microseconds). - int: The integration time used for the measurement in microseconds.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_QEPro.py</code> <pre><code>def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n    \"\"\" \n    A function to measure the spectrum of the Raman spectrometer.\n\n    Returns:\n        tuple[pd.DataFrame, int, int]: A tuple containing the following:\n            - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                intensity columns, from the config file. (as a global constant)\n            - int: The timestamp of the measurement in integer format (microseconds).\n            - int: The integration time used for the measurement in microseconds.\n    \"\"\"\n    with self._lock:\n        if self._mode == 'continuous':\n            timestamp = get_timestamp_us_int()\n            intensity_raw = self.dev.get_formatted_spectrum()\n            timestamp = int((timestamp + get_timestamp_us_int())/2)\n\n        if self._mode == 'discreet':\n            # new method:\n            adv = self.dev.Advanced\n            adv.abort_acquisition()\n            adv.clear_data_buffer()\n\n            self._temp_list_mea.clear()\n            self._temp_list_ts.clear()\n\n            adv.acquire_spectra_to_buffer()\n            adv.get_raw_spectrum_with_metadata(self._temp_list_mea, self._temp_list_ts, 1)\n\n            adv.abort_acquisition()\n            adv.clear_data_buffer()\n\n            intensity_raw = self._temp_list_mea[-1]\n            timestamp = self._temp_list_ts[-1] + self._init_timestamp - self._offset_timestamp\n\n        wavelength = self._wavelength\n        integration_time = self.dev.get_integration_time()\n\n    # Convert ctypes LP_c_double objects to Python floats\n    # The Ocean Direct API returns ctypes objects that need to be converted\n    try:\n        # For continuous mode: intensity_raw is a ctypes array\n        # For discrete mode: intensity_raw is a ctypes POINTER(c_double)\n        if hasattr(intensity_raw, '_length_'):\n            # It's a ctypes array, convert each element\n            intensity = [float(intensity_raw[i]) for i in range(len(intensity_raw))]\n        else:\n            # It's a ctypes pointer, convert each element by indexing\n            # Get the length from wavelength array since they should match\n            intensity = [float(intensity_raw[i]) for i in range(len(wavelength))]\n    except (TypeError, AttributeError):\n        # Fallback: if intensity_raw is already a list of floats, use as-is\n        intensity = intensity_raw\n\n    spectra = pd.DataFrame({\n        DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: wavelength,\n        DataAnalysisConfigEnum.INTENSITY_LABEL.value: intensity,\n    })\n    return (spectra, timestamp, integration_time)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.SpectrometerController_QEPro.self_test_get_spec_formatted","title":"<code>self_test_get_spec_formatted()</code>","text":"<p>Q. Honestly, I don't really understand what this does.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_QEPro.py</code> <pre><code>def self_test_get_spec_formatted(self):\n    \"\"\"\n    Q. Honestly, I don't really understand what this does.\n    \"\"\"\n    device = self.dev\n    sn = self.dev_serial\n    try:\n        #100ms\n        device.set_integration_time(100000)\n\n        print(\"Reading spectra for dev s/n = %s\" % sn, flush=True)\n        for i in range(10):\n            spectra = device.get_formatted_spectrum()\n            print(\"spectra[100]: %d, %d, %d, %d\" % (spectra[100], spectra[101], spectra[102], spectra[103]), flush=True)\n    except self.OceanDirectError as err:\n        [errorCode, errorMsg] = err.get_error_details()\n        print(\"get_spec_formatted(device): exception / %d = %s\" % (errorCode, errorMsg))\n\n\n    \"\"\"\n    To set up an external light source\n    \"\"\"\n    device = self.dev\n    periodInc = 0\n    try:\n        periodInc = device.Advanced.get_continuous_strobe_period_increment()\n        print(\"continuousStrobe(device): period increment =  %d \" % periodInc)\n    except self.OceanDirectError as err:\n        [errorCode, errorMsg] = err.get_error_details()\n        print(\"continuousStrobe(device): get_continuous_strobe_period_increment() %d = %s\" % (errorCode, errorMsg))\n\n    strobePeriod = device.Advanced.get_continuous_strobe_period()\n    print(\"continuousStrobe(device): get strobePeriod =  %d \" % strobePeriod)\n\n    strobeEnable = device.Advanced.get_continuous_strobe_enable()\n    print(\"continuousStrobe(device): get strobeEnable =  %s \" % strobeEnable)\n\n    values = [False, True]\n    for enable in values:\n        device.Advanced.set_continuous_strobe_enable(False)\n        print(\"continuousStrobe(device): get strobeEnable =  %s \" % enable)\n        strobeEnable = device.Advanced.get_continuous_strobe_enable()\n        print(\"continuousStrobe(device): set strobeEnable =  %s \" % enable)\n        print(\"\")\n\n    try:\n        periodMin = device.Advanced.get_continuous_strobe_period_minimum()\n        print(\"continuousStrobe(device): periodMin          =  %d \" % periodMin)\n    except self.OceanDirectError as err:\n        [errorCode, errorMsg] = err.get_error_details()\n        print(\"continuousStrobe(device): get_continuous_strobe_period_minimum() %d = %s\" % (errorCode, errorMsg))\n\n    try:\n        periodMax = device.Advanced.get_continuous_strobe_period_maximum()\n        print(\"continuousStrobe(device): periodMax          =  %d \" % periodMax)\n    except self.OceanDirectError as err:\n        [errorCode, errorMsg] = err.get_error_details()\n        print(\"continuousStrobe(device): get_continuous_strobe_period_maximum() %d = %s\" % (errorCode, errorMsg))\n\n\n\n    strobePeriodList = [1200, 1505, 800, 453]\n    for period in strobePeriodList:\n        if (periodInc &gt; 1) and ((period % periodInc) != 0):\n            print(\"continuousStrobe(device): set strobePeriod =  %d  ====&gt; ********* expecting EXCEPTION!\" % period)\n\n        try:\n            device.Advanced.set_continuous_strobe_period(period)\n            print(\"continuousStrobe(device): set strobePeriod =  %d \" % period)\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"continuousStrobe(device): set_continuous_strobe_period() %d = %s\" % (errorCode, errorMsg))\n\n        try:\n            period = device.Advanced.get_continuous_strobe_period()\n            print(\"continuousStrobe(device): get strobePeriod =  %d \" % period)\n        except self.OceanDirectError as err:\n            [errorCode, errorMsg] = err.get_error_details()\n            print(\"continuousStrobe(device): get_continuous_strobe_period() %d = %s\" % (errorCode, errorMsg))\n        print(\"\")\n\n    try:\n        strobeWidth = 216\n        device.Advanced.set_continuous_strobe_width(strobeWidth)\n        print(\"continuousStrobe(device): set strobeWidth    =  %d \" % strobeWidth)\n\n        strobeWidth = device.Advanced.get_continuous_strobe_width()\n        print(\"continuousStrobe(device): get strobeWidth    =  %d \" % strobeWidth)\n    except self.OceanDirectError as err:\n        [errorCode, errorMsg] = err.get_error_details()\n        print(\"continuousStrobe(device): %d = %s\" % (errorCode, errorMsg))\n\n    print(\"\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.SpectrometerController_QEPro.set_integration_time_us","title":"<code>set_integration_time_us(integration_time)</code>","text":"<p>Sets the integration time of the device</p> <p>Parameters:</p> Name Type Description Default <code>integration_time</code> <code>int</code> <p>Integration time in [device unit] </p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Device integrationt time after set up</p> Source code in <code>iris/controllers/raman_spectrometer_controller_QEPro.py</code> <pre><code>def set_integration_time_us(self,integration_time:int):\n    \"\"\"Sets the integration time of the device\n\n    Args:\n        integration_time (int): Integration time in [device unit] \n        (microseconds for the QE Pro)\n\n    Returns:\n        int: Device integrationt time after set up\n    \"\"\"\n\n    print('work here (raman spectrometer controller file)')\n\n    if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n        raise ValueError(\"Integration time must be an integer\")\n    integration_time = int(integration_time)\n\n    with self._lock:\n        self.dev.set_integration_time(integration_time)\n        int_time = self.dev.get_integration_time()\n\n    return int_time\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.SpectrometerController_QEPro.terminate","title":"<code>terminate(error_flag=False)</code>","text":"<p>To terminate the connections to the Raman spectrometers</p> <p>Parameters:</p> Name Type Description Default <code>error_flag</code> <code>bool</code> <p>Can also passes an error message. Defaults to False.</p> <code>False</code> Source code in <code>iris/controllers/raman_spectrometer_controller_QEPro.py</code> <pre><code>def terminate(self, error_flag=False):\n    \"\"\"\n    To terminate the connections to the Raman spectrometers\n\n    Args:\n        error_flag (bool, optional): Can also passes an error message. Defaults to False.\n    \"\"\"\n    if error_flag!=False:\n        print(\"\\n Error code:\")\n        print(error_flag)\n\n    for i in range(len(self.dev_ids)):\n        self.od.close_device(self.dev_ids[i])\n\n    print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n    print(\"Ocean Insight devices disconnected\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_QEPro/#iris.controllers.raman_spectrometer_controller_QEPro.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/","title":"raman_spectrometer_controller_WasatchEnlighten","text":"<p>Class definition for the Raman spectrometer controller and a guide to writing one for the IRIS</p>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.SpectrometerController_WasatchEnlighten","title":"<code>SpectrometerController_WasatchEnlighten</code>","text":"<p>               Bases: <code>Class_SpectrometerController</code></p> Source code in <code>iris/controllers/raman_spectrometer_controller_WasatchEnlighten.py</code> <pre><code>class SpectrometerController_WasatchEnlighten(Class_SpectrometerController):\n    def __init__(self) -&gt; None:\n        from wasatch.WasatchBus import WasatchBus\n        from wasatch.WasatchDevice import WasatchDevice\n\n        bus = WasatchBus()\n        if not bus.device_ids:\n            raise RuntimeError(\"No Wasatch Enlighten spectrometers found\")\n\n        dev_id = bus.device_ids[0]\n        print(\"-\"*20)\n        print(f\"Connected to Wasatch Enlighten spectrometer with Device ID: {dev_id}\")\n\n        self.device = WasatchDevice(dev_id)\n\n        # Device internal parameters\n        self._integration_time_us = 100000\n\n        self._lock = Lock()     # Lock for the acquisition process\n\n        self._identifier = None\n        # Start the initialisation process\n        self.initialisation()\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the spectrometer.\n\n        Returns:\n            str: The identifier of the spectrometer\n        \"\"\"\n        if self._identifier is None: self._identifier = self._get_hardware_identifier()\n        return self._identifier\n\n    def _get_hardware_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the hardware identifier of the spectrometer.\n\n        Returns:\n            str: The hardware identifier of the spectrometer\n        \"\"\"\n        model = self.device.settings.eeprom.model\n        serial_number = self.device.settings.eeprom.serial_number\n        return f\"WasatchEnlighten_{model}_S/N:{serial_number}\"\n\n# Core functionalities (initialisation, termination)\n    def initialisation(self) -&gt; None:\n        \"\"\"\n        Initializes the Raman spectrometer controller.\n        \"\"\"\n        self.device.connect()\n        self._identifier = self._get_hardware_identifier()\n        self._list_pixels = self.device.settings.pixels()\n\n        self._wavelengths = np.asarray(self.device.settings.wavelengths)\n        self._wavelengths = self._wavelengths.astype(float).tolist()\n\n        self.device.hardware.set_integration_time_ms(100)  # Set a default integration time of 100 ms\n\n        if LASER_ENABLE:\n            self.device.hardware.set_laser_enable(True)\n            self.device.hardware.set_laser_power_mW(LASER_POWER_MW)\n\n    def terminate(self) -&gt; None:\n        \"\"\"\n        To terminate the connections to the Raman spectrometers\n        \"\"\"\n        if LASER_ENABLE:\n            self.device.hardware.set_laser_enable(False)\n        self.device.disconnect()\n\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n\n    def get_integration_time_us(self) -&gt; int:\n        \"\"\"\n        Get the integration time of the device\n\n        Returns:\n            int: Integration time in [device unit] (microseconds for the QE Pro)\n        \"\"\"\n        # with self._lock:\n        #     int_time = self.device.hardware.get_integration_time_ms()\n        #     int_time = int(int_time * 1000)  # Convert milliseconds to microseconds\n\n        self._integration_time_us\n\n        # print(f'Received a get_integration_time_us call, returning {self._integration_time_us/1e3} ms')\n\n        return self._integration_time_us\n\n    def get_integration_time_limits_us(self):\n        \"\"\"\n        Get the integration time limits of the device\n\n        Returns:\n            tuple: A tuple containing the minimum, maximum, and increment of the integration time in [us]\n        \"\"\"\n        return (10, 1e9, 1)\n\n    def set_integration_time_us(self,integration_time:int) -&gt; int:\n        \"\"\"Sets the integration time of the device\n\n        Args:\n            integration_time (int): Integration time in [device unit] \n            (microseconds for the QE Pro)\n\n        Returns:\n            int: Device integrationt time after set up in microseconds\n        \"\"\"\n\n        # print(f'Received a set_integration_time_us call with integration_time={integration_time/1e3} ms')\n\n        if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n            raise ValueError(\"Integration time must be an integer\")\n        integration_time = int(integration_time)\n\n        with self._lock:\n            self.device.hardware.set_integration_time_ms(integration_time/1e3)\n            self._integration_time_us = integration_time\n\n        return self._integration_time_us\n\n    def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n        \"\"\" \n        A function to measure the spectrum of the Raman spectrometer.\n\n        Returns:\n            tuple[pd.DataFrame, int, int]: A tuple containing the following:\n                - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                    intensity columns, from the config file. (as a global constant)\n                - int: The timestamp of the measurement in integer format (microseconds).\n                - int: The integration time used for the measurement in microseconds.\n        \"\"\"\n        with self._lock:\n            intensity = np.asarray(self.device.hardware.get_line().data.spectrum)\n            intensity = intensity.astype(float).tolist()\n\n            timestamp = get_timestamp_us_int()\n            integration_time = self._integration_time_us if self._integration_time_us is not None else self.get_integration_time_us()\n\n        spectra = pd.DataFrame({\n            DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: self._wavelengths,\n            DataAnalysisConfigEnum.INTENSITY_LABEL.value: intensity,\n        })\n        return (spectra, timestamp, integration_time)\n\n# Set of commands for testing/automation\n    def self_test(self):\n        # &lt;&lt;&lt;&lt;&lt; Insert the self-test commands here\n        pass\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.SpectrometerController_WasatchEnlighten.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the spectrometer.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the spectrometer</p> Source code in <code>iris/controllers/raman_spectrometer_controller_WasatchEnlighten.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the spectrometer.\n\n    Returns:\n        str: The identifier of the spectrometer\n    \"\"\"\n    if self._identifier is None: self._identifier = self._get_hardware_identifier()\n    return self._identifier\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.SpectrometerController_WasatchEnlighten.get_integration_time_limits_us","title":"<code>get_integration_time_limits_us()</code>","text":"<p>Get the integration time limits of the device</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the minimum, maximum, and increment of the integration time in [us]</p> Source code in <code>iris/controllers/raman_spectrometer_controller_WasatchEnlighten.py</code> <pre><code>def get_integration_time_limits_us(self):\n    \"\"\"\n    Get the integration time limits of the device\n\n    Returns:\n        tuple: A tuple containing the minimum, maximum, and increment of the integration time in [us]\n    \"\"\"\n    return (10, 1e9, 1)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.SpectrometerController_WasatchEnlighten.get_integration_time_us","title":"<code>get_integration_time_us()</code>","text":"<p>Get the integration time of the device</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Integration time in [device unit] (microseconds for the QE Pro)</p> Source code in <code>iris/controllers/raman_spectrometer_controller_WasatchEnlighten.py</code> <pre><code>def get_integration_time_us(self) -&gt; int:\n    \"\"\"\n    Get the integration time of the device\n\n    Returns:\n        int: Integration time in [device unit] (microseconds for the QE Pro)\n    \"\"\"\n    # with self._lock:\n    #     int_time = self.device.hardware.get_integration_time_ms()\n    #     int_time = int(int_time * 1000)  # Convert milliseconds to microseconds\n\n    self._integration_time_us\n\n    # print(f'Received a get_integration_time_us call, returning {self._integration_time_us/1e3} ms')\n\n    return self._integration_time_us\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.SpectrometerController_WasatchEnlighten.initialisation","title":"<code>initialisation()</code>","text":"<p>Initializes the Raman spectrometer controller.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_WasatchEnlighten.py</code> <pre><code>def initialisation(self) -&gt; None:\n    \"\"\"\n    Initializes the Raman spectrometer controller.\n    \"\"\"\n    self.device.connect()\n    self._identifier = self._get_hardware_identifier()\n    self._list_pixels = self.device.settings.pixels()\n\n    self._wavelengths = np.asarray(self.device.settings.wavelengths)\n    self._wavelengths = self._wavelengths.astype(float).tolist()\n\n    self.device.hardware.set_integration_time_ms(100)  # Set a default integration time of 100 ms\n\n    if LASER_ENABLE:\n        self.device.hardware.set_laser_enable(True)\n        self.device.hardware.set_laser_power_mW(LASER_POWER_MW)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.SpectrometerController_WasatchEnlighten.measure_spectrum","title":"<code>measure_spectrum()</code>","text":"<p>A function to measure the spectrum of the Raman spectrometer.</p> <p>Returns:</p> Type Description <code>tuple[DataFrame, int, int]</code> <p>tuple[pd.DataFrame, int, int]: A tuple containing the following: - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and     intensity columns, from the config file. (as a global constant) - int: The timestamp of the measurement in integer format (microseconds). - int: The integration time used for the measurement in microseconds.</p> Source code in <code>iris/controllers/raman_spectrometer_controller_WasatchEnlighten.py</code> <pre><code>def measure_spectrum(self) -&gt; tuple[pd.DataFrame, int, int]:\n    \"\"\" \n    A function to measure the spectrum of the Raman spectrometer.\n\n    Returns:\n        tuple[pd.DataFrame, int, int]: A tuple containing the following:\n            - pandas.DataFrame: A DataFrame containing the measured spectrum with the wavelength and\n                intensity columns, from the config file. (as a global constant)\n            - int: The timestamp of the measurement in integer format (microseconds).\n            - int: The integration time used for the measurement in microseconds.\n    \"\"\"\n    with self._lock:\n        intensity = np.asarray(self.device.hardware.get_line().data.spectrum)\n        intensity = intensity.astype(float).tolist()\n\n        timestamp = get_timestamp_us_int()\n        integration_time = self._integration_time_us if self._integration_time_us is not None else self.get_integration_time_us()\n\n    spectra = pd.DataFrame({\n        DataAnalysisConfigEnum.WAVELENGTH_LABEL.value: self._wavelengths,\n        DataAnalysisConfigEnum.INTENSITY_LABEL.value: intensity,\n    })\n    return (spectra, timestamp, integration_time)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.SpectrometerController_WasatchEnlighten.set_integration_time_us","title":"<code>set_integration_time_us(integration_time)</code>","text":"<p>Sets the integration time of the device</p> <p>Parameters:</p> Name Type Description Default <code>integration_time</code> <code>int</code> <p>Integration time in [device unit] </p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Device integrationt time after set up in microseconds</p> Source code in <code>iris/controllers/raman_spectrometer_controller_WasatchEnlighten.py</code> <pre><code>def set_integration_time_us(self,integration_time:int) -&gt; int:\n    \"\"\"Sets the integration time of the device\n\n    Args:\n        integration_time (int): Integration time in [device unit] \n        (microseconds for the QE Pro)\n\n    Returns:\n        int: Device integrationt time after set up in microseconds\n    \"\"\"\n\n    # print(f'Received a set_integration_time_us call with integration_time={integration_time/1e3} ms')\n\n    if not isinstance(integration_time,int) and not isinstance(integration_time,float):\n        raise ValueError(\"Integration time must be an integer\")\n    integration_time = int(integration_time)\n\n    with self._lock:\n        self.device.hardware.set_integration_time_ms(integration_time/1e3)\n        self._integration_time_us = integration_time\n\n    return self._integration_time_us\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.SpectrometerController_WasatchEnlighten.terminate","title":"<code>terminate()</code>","text":"<p>To terminate the connections to the Raman spectrometers</p> Source code in <code>iris/controllers/raman_spectrometer_controller_WasatchEnlighten.py</code> <pre><code>def terminate(self) -&gt; None:\n    \"\"\"\n    To terminate the connections to the Raman spectrometers\n    \"\"\"\n    if LASER_ENABLE:\n        self.device.hardware.set_laser_enable(False)\n    self.device.disconnect()\n\n    print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_WasatchEnlighten/#iris.controllers.raman_spectrometer_controller_WasatchEnlighten.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/","title":"raman_spectrometer_controller_dummy","text":"<p>A class that allows the control of the QE Pro spectrometer from Ocean Insight. This implementation is based on the API provided by Ocean Insight.</p> <p>Inspiration: Ocean Insight Inc. example code Made on: 04 March 2024 For: The Thomas Group, Biochemical Engineering Dept., UCL By: Kevin Uning</p>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.SpectrometerController_Dummy","title":"<code>SpectrometerController_Dummy</code>","text":"<p>               Bases: <code>Class_SpectrometerController</code></p> Source code in <code>iris/controllers/raman_spectrometer_controller_dummy.py</code> <pre><code>class SpectrometerController_Dummy(Class_SpectrometerController):\n    def __init__(self, **kwargs) -&gt; None:\n        # self.od = OceanDirectAPI()                          # Ocean Direct API\n        # self.dev_count = self.od.find_usb_devices()         # Device count\n        # self.dev_ids = self.od.get_device_ids()             # Device IDs (if multiple)\n        # self.api_info = self.od.get_api_version_numbers()   # API info\n\n        self.dev = dummy_spectrometer()         # OD API device class\n        self.dev_id = None      # Store the device ID\n        self.dev_serial = None  # device serial number\n\n        # Aquisition related parameters\n        self.integration_time_us = 500e3        # int: Stores the spectrometer's integration time [microsec]\n        self.integration_time_min = 10*1e3      # int: Stores the spectrometer's minimum allowable integration time [microsec]\n        self.integration_time_max = 10000*1e3   # int: Stores the spectrometer's maximum allowable integration time [microsec]\n        self.integration_time_inc = 25*1e3      # int: Stores the spectrometer's allowable integration time increment [microsec]\n\n        # Calibration related parameters\n        self.bg_acq_num = 10    # Number of aquisition for the background removal\n        self.bg_spec = None     # The background spectrum\n\n        # Start the initialisation process\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; DUMMY Raman controller is used &lt;&lt;&lt;&lt;&lt;\")\n        self.initialisation()\n\n    def get_identifier(self) -&gt; str:\n        return \"Dummy Spectrometer Controller\"\n\n# Core functionalities (initialisation, termination)\n    def initialisation(self):\n        pass\n\n    def terminate(self, error_flag=False):\n        \"\"\"\n        To terminate the connections to the Raman spectrometers\n\n        Args:\n            error_flag (bool, optional): Can also passes an error message. Defaults to False.\n        \"\"\"\n        if error_flag!=False:\n            print(\"\\n Error code:\")\n            print(error_flag)\n\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n        print(\"Ocean Insight devices disconnected\")\n\n# Spectrometer acquisition control\n    def acquisitionDelay(self, delay_value):\n        \"\"\"\n        Sets the acquisition delay of the spectrometer.\n        This may also be referred to as the trigger delay.\n        In any event, it is the time between some event (such as a request for data, or an external trigger pulse) and when data acquisition begins.\n\n        Q. Why is it needed?\n        Sometimes we want to delay the acquisition so that the \n\n        Args:\n            delay_value (int): The acquisition delay to be set [us]\n        \"\"\"\n        #device.set_acquisition_delay(120)\n        #print(\"acquisitionDelay(device): set acqDelay 120\")\n        device = self.dev\n\n        acqDelay    = 5\n        acqDelayInc = 1\n        acqDelayMin = 0\n        acqDelayMax = 1000\n\n        print(\"acquisitionDelay(device): acqDelay     =  %d \" % acqDelay)\n        print(\"acquisitionDelay(device): acqDelayInc  =  %d \" % acqDelayInc)\n        print(\"acquisitionDelay(device): acqDelayMin  =  %d \" % acqDelayMin)\n        print(\"acquisitionDelay(device): acqDelayMax  =  %d \" % acqDelayMax)\n        print(\"\")\n\n        # Now to set the delay value\n        print(\"acquisitionDelay(device): set acqDelay =  %d \" % delay_value)\n\n        # Print the new delay value to check\n        acqDelay = delay_value\n        print(\"acquisitionDelay(device): get acqDelay(expected %d)  =  %d \" % (delay_value,acqDelay))\n        print(\"\")\n\n    def set_analyser_boxcar(self, scanToAve, boxcarWidth):\n        \"\"\"\n        A function to smoothen the read spectrum using the boxcar method.\n        Basically, it takes the points around it and averages them out.\n        It also takes several acquisition data and averages them too, hence the name boxcar.\n\n        Args:\n            scanToAve (int): the number of scan acquisition to be averaged out\n            boxcarWidth (int): the number of neighboring data points to be averaged out\n        \"\"\"\n\n        print(\"Assume that things has been set properly\")\n\n    # def get_spec(self):\n    #     device = self.dev\n\n    #     print(\"Integration time: %d\" %(device.get_integration_time()))\n\n    #     intensity = device.get_formatted_spectrum()\n    #     wavelength = device.get_wavelengths()\n    #     timestamp = [datetime.now()] * len(intensity)\n\n    #     spectra = pd.DataFrame({\n    #     'Wavelength [nm]': wavelength,\n    #     'Intensity [a.u.]': intensity,\n    #     'Timestamp [yyyy-mm-dd hh:mm:ss.microsec]': timestamp\n    #     })\n\n    #     return spectra\n\n    def measure_spectrum(self) -&gt; tuple[pd.DataFrame,int,int]:\n        \"\"\"\n        Performs a single spectrum measurement using the spectrometer\n\n        Returns:\n            tuple[pd.DataFrame,int,int]: The measured spectrum, timestamp, and integration time\n\n        Note:\n            - The measured spectrum is a DataFrame with the (wavelength and intensity) columns set in the config file.\n            - The timestamp is in the integer format [us].\n        \"\"\"\n        def dummy_raman_spectrum(x, num_peaks=5):\n            # Dummy raman spectrum fixed parameters\n            list_A = [0.7,0.4,0.55,1.0,0.5]\n            list_x0 = [800, 950, 1200, 1600, 1800]\n            list_sigma = [10, 20, 30, 40, 50]\n            spectrum = np.zeros_like(x)\n            for i in range(num_peaks):\n                # A = np.random.uniform(0.1, 1.0)  # Intensity\n                # x0 = np.random.uniform(300, 2000)  # Wavenumber\n                # sigma = np.random.uniform(5, 50)  # Width\n                A = list_A[i%len(list_A)]\n                x0 = list_x0[i%len(list_x0)]\n                sigma = list_sigma[i%len(list_sigma)]\n\n                spectrum += A * np.exp(-0.5 * ((x - x0) / sigma) ** 2)\n            return spectrum\n\n        time1_sec = get_timestamp_us_int()/1e6\n\n        x_range = np.linspace(800, 2000, 1000)\n        raman_spectrum = dummy_raman_spectrum(x_range)\n\n        wavelength = x_range\n        intensity = raman_spectrum * 100\n\n        def add_uniform_noise(data, low=-1.0, high=1.0):\n            noise = np.random.uniform(low, high, data.shape)\n            return data + noise\n\n        noisy_intensity = add_uniform_noise(intensity,low=-5,high=5)\n        timestamp = get_timestamp_us_int()\n        spectra = pd.DataFrame({\n        'Wavelength [nm]': wavelength,\n        'Intensity [a.u.]': noisy_intensity,\n        })\n\n        integration_time_sec = self.integration_time_us/1e6\n        time2_sec = get_timestamp_us_int()/1e6\n\n        # Sleep for the remaining time\n        if (time2_sec-time1_sec) &lt; integration_time_sec:\n            time.sleep(integration_time_sec - (time2_sec-time1_sec))\n        # time3_sec = get_timestamp_us_int()/1e6\n        # print ('Integration time: ',integration_time_sec)\n        # print('Time taken: ',time3_sec-time1_sec)\n\n        return (spectra,timestamp,self.integration_time_us)\n\n    def get_integration_time_us(self):\n        \"\"\"\n        Returns the integration time of the device in [microsec]\n\n        Returns:\n            int: Integration time in [microsec]\n        \"\"\"\n        return self.integration_time_us\n\n    def get_integration_time_limits_us(self):\n        \"\"\"\n        Returns the minimum, maximum, and increment of the integration time of the device\n\n        Returns:\n            tuple: (min, max, increment) of the integration time in [microsec]\n        \"\"\"\n        return (self.integration_time_min, self.integration_time_max, self.integration_time_inc)\n\n    def set_integration_time_us(self,integration_time):\n        \"\"\"\n        Sets the integration time of the device\n\n        Args:\n            integration_time (int): Integration time in [millisec]\n\n        Returns:\n            int: Device integrationt time after set up\n        \"\"\"\n        self.integration_time_us = integration_time\n        return self.integration_time_us\n\n# &lt;&lt;&lt;&lt;&lt; Implementations: requires additional checks on the min, max, and increment of the integration time\n\n        # sets the integration time of the device\n        try: # try to set\n            print('integration time set to {}'.format(integration_time))\n            print(type(integration_time))\n        except: # if failure reports it\n            print('integration time could not be set:')\n            print('error message here')\n\n        # reads the actual device integration time\n        device_integration_time = integration_time\n\n        return device_integration_time\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.SpectrometerController_Dummy.acquisitionDelay","title":"<code>acquisitionDelay(delay_value)</code>","text":"<p>Sets the acquisition delay of the spectrometer. This may also be referred to as the trigger delay. In any event, it is the time between some event (such as a request for data, or an external trigger pulse) and when data acquisition begins.</p> <p>Q. Why is it needed? Sometimes we want to delay the acquisition so that the </p> <p>Parameters:</p> Name Type Description Default <code>delay_value</code> <code>int</code> <p>The acquisition delay to be set [us]</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_dummy.py</code> <pre><code>def acquisitionDelay(self, delay_value):\n    \"\"\"\n    Sets the acquisition delay of the spectrometer.\n    This may also be referred to as the trigger delay.\n    In any event, it is the time between some event (such as a request for data, or an external trigger pulse) and when data acquisition begins.\n\n    Q. Why is it needed?\n    Sometimes we want to delay the acquisition so that the \n\n    Args:\n        delay_value (int): The acquisition delay to be set [us]\n    \"\"\"\n    #device.set_acquisition_delay(120)\n    #print(\"acquisitionDelay(device): set acqDelay 120\")\n    device = self.dev\n\n    acqDelay    = 5\n    acqDelayInc = 1\n    acqDelayMin = 0\n    acqDelayMax = 1000\n\n    print(\"acquisitionDelay(device): acqDelay     =  %d \" % acqDelay)\n    print(\"acquisitionDelay(device): acqDelayInc  =  %d \" % acqDelayInc)\n    print(\"acquisitionDelay(device): acqDelayMin  =  %d \" % acqDelayMin)\n    print(\"acquisitionDelay(device): acqDelayMax  =  %d \" % acqDelayMax)\n    print(\"\")\n\n    # Now to set the delay value\n    print(\"acquisitionDelay(device): set acqDelay =  %d \" % delay_value)\n\n    # Print the new delay value to check\n    acqDelay = delay_value\n    print(\"acquisitionDelay(device): get acqDelay(expected %d)  =  %d \" % (delay_value,acqDelay))\n    print(\"\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.SpectrometerController_Dummy.get_integration_time_limits_us","title":"<code>get_integration_time_limits_us()</code>","text":"<p>Returns the minimum, maximum, and increment of the integration time of the device</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(min, max, increment) of the integration time in [microsec]</p> Source code in <code>iris/controllers/raman_spectrometer_controller_dummy.py</code> <pre><code>def get_integration_time_limits_us(self):\n    \"\"\"\n    Returns the minimum, maximum, and increment of the integration time of the device\n\n    Returns:\n        tuple: (min, max, increment) of the integration time in [microsec]\n    \"\"\"\n    return (self.integration_time_min, self.integration_time_max, self.integration_time_inc)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.SpectrometerController_Dummy.get_integration_time_us","title":"<code>get_integration_time_us()</code>","text":"<p>Returns the integration time of the device in [microsec]</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Integration time in [microsec]</p> Source code in <code>iris/controllers/raman_spectrometer_controller_dummy.py</code> <pre><code>def get_integration_time_us(self):\n    \"\"\"\n    Returns the integration time of the device in [microsec]\n\n    Returns:\n        int: Integration time in [microsec]\n    \"\"\"\n    return self.integration_time_us\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.SpectrometerController_Dummy.measure_spectrum","title":"<code>measure_spectrum()</code>","text":"<p>Performs a single spectrum measurement using the spectrometer</p> <p>Returns:</p> Type Description <code>tuple[DataFrame, int, int]</code> <p>tuple[pd.DataFrame,int,int]: The measured spectrum, timestamp, and integration time</p> Note <ul> <li>The measured spectrum is a DataFrame with the (wavelength and intensity) columns set in the config file.</li> <li>The timestamp is in the integer format [us].</li> </ul> Source code in <code>iris/controllers/raman_spectrometer_controller_dummy.py</code> <pre><code>def measure_spectrum(self) -&gt; tuple[pd.DataFrame,int,int]:\n    \"\"\"\n    Performs a single spectrum measurement using the spectrometer\n\n    Returns:\n        tuple[pd.DataFrame,int,int]: The measured spectrum, timestamp, and integration time\n\n    Note:\n        - The measured spectrum is a DataFrame with the (wavelength and intensity) columns set in the config file.\n        - The timestamp is in the integer format [us].\n    \"\"\"\n    def dummy_raman_spectrum(x, num_peaks=5):\n        # Dummy raman spectrum fixed parameters\n        list_A = [0.7,0.4,0.55,1.0,0.5]\n        list_x0 = [800, 950, 1200, 1600, 1800]\n        list_sigma = [10, 20, 30, 40, 50]\n        spectrum = np.zeros_like(x)\n        for i in range(num_peaks):\n            # A = np.random.uniform(0.1, 1.0)  # Intensity\n            # x0 = np.random.uniform(300, 2000)  # Wavenumber\n            # sigma = np.random.uniform(5, 50)  # Width\n            A = list_A[i%len(list_A)]\n            x0 = list_x0[i%len(list_x0)]\n            sigma = list_sigma[i%len(list_sigma)]\n\n            spectrum += A * np.exp(-0.5 * ((x - x0) / sigma) ** 2)\n        return spectrum\n\n    time1_sec = get_timestamp_us_int()/1e6\n\n    x_range = np.linspace(800, 2000, 1000)\n    raman_spectrum = dummy_raman_spectrum(x_range)\n\n    wavelength = x_range\n    intensity = raman_spectrum * 100\n\n    def add_uniform_noise(data, low=-1.0, high=1.0):\n        noise = np.random.uniform(low, high, data.shape)\n        return data + noise\n\n    noisy_intensity = add_uniform_noise(intensity,low=-5,high=5)\n    timestamp = get_timestamp_us_int()\n    spectra = pd.DataFrame({\n    'Wavelength [nm]': wavelength,\n    'Intensity [a.u.]': noisy_intensity,\n    })\n\n    integration_time_sec = self.integration_time_us/1e6\n    time2_sec = get_timestamp_us_int()/1e6\n\n    # Sleep for the remaining time\n    if (time2_sec-time1_sec) &lt; integration_time_sec:\n        time.sleep(integration_time_sec - (time2_sec-time1_sec))\n    # time3_sec = get_timestamp_us_int()/1e6\n    # print ('Integration time: ',integration_time_sec)\n    # print('Time taken: ',time3_sec-time1_sec)\n\n    return (spectra,timestamp,self.integration_time_us)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.SpectrometerController_Dummy.set_analyser_boxcar","title":"<code>set_analyser_boxcar(scanToAve, boxcarWidth)</code>","text":"<p>A function to smoothen the read spectrum using the boxcar method. Basically, it takes the points around it and averages them out. It also takes several acquisition data and averages them too, hence the name boxcar.</p> <p>Parameters:</p> Name Type Description Default <code>scanToAve</code> <code>int</code> <p>the number of scan acquisition to be averaged out</p> required <code>boxcarWidth</code> <code>int</code> <p>the number of neighboring data points to be averaged out</p> required Source code in <code>iris/controllers/raman_spectrometer_controller_dummy.py</code> <pre><code>def set_analyser_boxcar(self, scanToAve, boxcarWidth):\n    \"\"\"\n    A function to smoothen the read spectrum using the boxcar method.\n    Basically, it takes the points around it and averages them out.\n    It also takes several acquisition data and averages them too, hence the name boxcar.\n\n    Args:\n        scanToAve (int): the number of scan acquisition to be averaged out\n        boxcarWidth (int): the number of neighboring data points to be averaged out\n    \"\"\"\n\n    print(\"Assume that things has been set properly\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.SpectrometerController_Dummy.set_integration_time_us","title":"<code>set_integration_time_us(integration_time)</code>","text":"<p>Sets the integration time of the device</p> <p>Parameters:</p> Name Type Description Default <code>integration_time</code> <code>int</code> <p>Integration time in [millisec]</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Device integrationt time after set up</p> Source code in <code>iris/controllers/raman_spectrometer_controller_dummy.py</code> <pre><code>    def set_integration_time_us(self,integration_time):\n        \"\"\"\n        Sets the integration time of the device\n\n        Args:\n            integration_time (int): Integration time in [millisec]\n\n        Returns:\n            int: Device integrationt time after set up\n        \"\"\"\n        self.integration_time_us = integration_time\n        return self.integration_time_us\n\n# &lt;&lt;&lt;&lt;&lt; Implementations: requires additional checks on the min, max, and increment of the integration time\n\n        # sets the integration time of the device\n        try: # try to set\n            print('integration time set to {}'.format(integration_time))\n            print(type(integration_time))\n        except: # if failure reports it\n            print('integration time could not be set:')\n            print('error message here')\n\n        # reads the actual device integration time\n        device_integration_time = integration_time\n\n        return device_integration_time\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.SpectrometerController_Dummy.terminate","title":"<code>terminate(error_flag=False)</code>","text":"<p>To terminate the connections to the Raman spectrometers</p> <p>Parameters:</p> Name Type Description Default <code>error_flag</code> <code>bool</code> <p>Can also passes an error message. Defaults to False.</p> <code>False</code> Source code in <code>iris/controllers/raman_spectrometer_controller_dummy.py</code> <pre><code>def terminate(self, error_flag=False):\n    \"\"\"\n    To terminate the connections to the Raman spectrometers\n\n    Args:\n        error_flag (bool, optional): Can also passes an error message. Defaults to False.\n    \"\"\"\n    if error_flag!=False:\n        print(\"\\n Error code:\")\n        print(error_flag)\n\n    print(\"\\n&gt;&gt;&gt;&gt;&gt; Raman controller TERMINATED &lt;&lt;&lt;&lt;&lt;\")\n    print(\"Ocean Insight devices disconnected\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/raman_spectrometer_controller_dummy/#iris.controllers.raman_spectrometer_controller_dummy.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/","title":"xy_stage_controller_PI","text":"<p>This is a Python script that handles the control of the Physik Instrumente (PI) U-751.24 XY stage controller. To be used with the Open Raman Microscopy (ORM) controller app.</p>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI","title":"<code>XYController_PI</code>","text":"<p>               Bases: <code>Class_XYController</code></p> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>class XYController_PI(Class_XYController):\n    def __init__(self,sim=None):\n        \"\"\"\n        Initialises the xy stage controller class.\n\n        Args:\n            sim (bool, optional): Not used in this case\n\n        Important note:\n            When developing this for use with image capture-related functionalities,\n            the x-axis has to be the horizontal axis in the image capture and y-axis for \n            the vertical axis. Otherwise some of the image processing functions will not work.\n        \"\"\"\n        self.device:GCS30Device = GCSDevice()\n        self._serial_no = ControllerSpecificConfigEnum.PISTAGE_SERIAL.value\n\n        # Axes names placeholder\n        self._allaxes = None\n\n        # Axes control remapping\n        self.dict_ctrl_remap = {\n            'xfwd':ControllerDirectionEnum.XFWD.value,\n            'xrev':ControllerDirectionEnum.XREV.value,\n            'yfwd':ControllerDirectionEnum.YFWD.value,\n            'yrev':ControllerDirectionEnum.YREV.value,\n        }   # Dictionary to remap the controls (only for the continuous and jog movements)\n\n        self._flipxy = ControllerConfigEnum.STAGE_FLIPXY            # Flag to indicate if the x and y axes are flipped\n        self._invertx = ControllerConfigEnum.STAGE_INVERTX.value    # Flag to indicate if the x-axis is flipped (inversed, *= -1)\n        self._inverty = ControllerConfigEnum.STAGE_INVERTY.value    # Flag to indicate if the y-axis is flipped (inversed, *= -1)\n\n        self._dict_axes = { # Placeholder for the axes names\n            'x':None,\n            'y':None\n        }\n\n        # Movement parameters setup\n        self._max_vel:float = 100.0  # Maximum velocity of the motor in mm/s\n        self._min_vel:float = 0.001   # Minimum velocity of the motor in mm/s\n        self._vel:float = None\n\n        self._min_travelx:float = None\n        self._min_travely:float = None\n        self._max_travelx:float = None\n        self._max_travely:float = None\n\n        self._jog_min_mm:float = 0.001\n        self._jog_max_mm:float = 1.0\n        self._jog_mm:float = 1\n\n        self._max_vel_mmS = self._max_vel   # Maximum velocity of the motor in mm/s\n        self._min_vel_mmS = self._min_vel   # Minimum velocity of the motor in mm/s\n\n        # Initialises the device\n        try: self.initialisation()\n        except Exception as e: print(e)\n\n    def get_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the identifier of the stage controller.\n\n        Returns:\n            str: The identifier of the stage controller\n        \"\"\"\n        if self._identifier is None: self._identifier = self._get_hardware_identifier()\n        return self._identifier\n\n    def _get_hardware_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the hardware identifier of the stage controller.\n\n        Returns:\n            str: The hardware identifier of the stage controller\n        \"\"\"\n        if self._model is None: self._model = self.device.qIDN().strip()\n        return f\"Physik Instrumente device model: {self._model}, S/N:{self._serial_no}\"\n\n    def _remap_coordinates_flip(self,coor:tuple[float,float],get:bool) -&gt; tuple[float,float]:\n        \"\"\"\n        Remaps the coordinates if the x and y axes are flipped\n\n        Args:\n            coor (tuple[float,float]): the coordinate to remap\n            get (bool): True if the coordinate is to be retrieved, False if the coordinate is to be set\n                this is to ensure that the flip is done before/after the inversion of the axes depending on the get flag\n\n        Returns:\n            tuple[float,float]: the remapped coordinate\n        \"\"\"\n        x,y = coor\n        if self._flipxy and get:\n            x,y = y,x\n        if self._invertx:\n            x = -1*x\n        if self._inverty:\n            y = -1*y\n        if self._flipxy and not get:\n            x,y = y,x\n        # Note:\n        # The flip is done before/after the inversion of the axes depending on the get flag because\n        # a matrix multiplication is not commutative. i.e., A*B != B*A\n        return (x,y)\n\n    def initialisation(self):\n        self.device.ConnectUSB(serialnum=self._serial_no)\n        print('connected: {}'.format(self.device.qIDN().strip()))\n\n        # Get axes names\n        ## NOTE: Flip the axes indices if the stage is mounted in a different orientation\n        ## make sure that the x-axis is the horizontal axis in the image capture and y-axis for\n        self._allaxes = self.device.allaxes\n        self._dict_axes = {\n            'x':self.device.axes[1],\n            'y':self.device.axes[0]\n        }\n\n        # Enable the servos\n        self.device.SVO(self._allaxes, [1]*2)\n\n        # Home the axes\n        self.homing_n_coor_calibration()\n\n        # Get max travel range\n        minrange = pitools.getmintravelrange(self.device, self.device.allaxes)\n        maxrange = pitools.getmaxtravelrange(self.device, self.device.allaxes)\n        self._min_travelx, self._min_travely = minrange[self._dict_axes['x']], minrange[self._dict_axes['y']]\n        self._max_travelx, self._max_travely = maxrange[self._dict_axes['x']], maxrange[self._dict_axes['y']]\n\n        # Get max velocity\n        self._max_vel:float = 10.0\n        self._min_vel:float = 0.1\n\n        # Set velocity and acceleration\n        self.get_vel_acc_relative()\n\n    def terminate(self,close_connection=True):\n        \"\"\"\n        Terminate the operation. Returns the stage to home and disconnects the device.\n\n        Args:\n                close_connection (bool): True to close the connection to the device\n        \"\"\"\n        if close_connection: self.device.CloseConnection()\n\n    def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n        \"\"\"\n        Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n        Args:\n            speed_mm_s (float): The speed to be converted in mm/s\n\n        Returns:\n            float: The relative velocity parameter in percentage\n        \"\"\"\n        # Adjust the speed to the limits if it is out of bounds\n        if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n            speed_mm_s = self._min_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n        if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n            speed_mm_s = self._max_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n        # Calculate the relative speed\n        speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n        return speed_rel\n\n    def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100):\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): Legacy parameter. Is ignored.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        assert 0 &lt; vel_move &lt;= 100, 'Velocity must be between 0 and 100'\n\n        # Set velocity\n        vel = self._max_vel * vel_move / 100\n        self.device.VEL(self._allaxes, [vel]*2)\n\n        self._vel = vel\n\n    def get_vel_acc_relative(self):\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        dict_relvel = self.device.qVEL(self._allaxes)\n        relvel1 = dict_relvel[self._dict_axes['x']] / self._max_vel * 100\n        relvel2 = dict_relvel[self._dict_axes['y']] / self._max_vel * 100\n\n        if relvel1 != relvel2: print('Axes have different velocities'); self._vel = relvel1\n\n        return (100, relvel1, 100)\n\n    def report_attributes(self):\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Device and motor attributes &lt;&lt;&lt;&lt;&lt;\")\n        for attr, value in vars(self).items():\n            print(f\"{attr}: {value}\")\n\n    def get_coordinates(self):\n        \"\"\"\n        Returns the current motor coordinates\n\n        Returns:\n            tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n        \"\"\"\n        positions = self.device.qPOS(self.device.allaxes)\n        x,y = positions[self._dict_axes['x']], positions[self._dict_axes['y']]\n\n        x,y = self._remap_coordinates_flip((x,y),get=True)\n\n        return (x, y)\n\n    def homing_n_coor_calibration(self):\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        - Also called as 'homing'\n        \"\"\"\n\n        # Set velocity\n        self.set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)\n\n        # Move to home position\n        self.device.FRF(self._allaxes)\n        pitools.waitontarget(self.device, self._allaxes)\n        print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n\n    def move_direct(self,coor_abs:tuple[float,float],remap:bool=True):\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n            remap (bool): Option to remap the coor according to the set flip (made specifically\n                for jog)\n        \"\"\"\n        if remap: coor_abs = self._remap_coordinates_flip(coor_abs,get=False)\n\n        assert self._min_travelx &lt;= coor_abs[0] &lt;= self._max_travelx, 'Coordinate x is out of range'\n        assert self._min_travely &lt;= coor_abs[1] &lt;= self._max_travely, 'Coordinate y is out of range'\n\n        self.device.MOV([self._dict_axes['x'],self._dict_axes['y']], coor_abs)\n\n        # Wait until target is reached\n        pitools.waitontarget(self.device, self._allaxes)\n\n        return\n\n    def move_continuous(self,dir:str):\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n        \"\"\"\n        assert dir in ['xfwd','xrev','yfwd','yrev'], 'Invalid direction'\n\n        dir = self.dict_ctrl_remap[dir]\n\n        if dir == 'xfwd': self.device.MOV(self._dict_axes['x'], self._max_travelx)\n        elif dir == 'xrev': self.device.MOV(self._dict_axes['x'], self._min_travelx)\n        elif dir == 'yfwd': self.device.MOV(self._dict_axes['y'], self._max_travely)\n        elif dir == 'yrev': self.device.MOV(self._dict_axes['y'], self._min_travely)\n\n    def stop_move(self):\n        \"\"\"\n        Stops the continuous movement of the motors by sending a new\n        target position to the current position\n        \"\"\"\n        coor = self.get_coordinates()\n        coor = self._remap_coordinates_flip(coor,get=True)\n        self.device.MOV([self._dict_axes['x'],self._dict_axes['y']], coor)\n        pitools.waitontarget(self.device, self._allaxes)\n        return\n\n    def get_jog(self):\n        \"\"\"\n        Returns the current jog step in [mm]:\n\n        Returns:\n            tuple of floats: 6 elements:\n            (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n        \"\"\"\n        return (self._jog_mm, self._jog_mm, self._vel, self._vel, 0, 0)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): Legacy parameter. Is ignored.\n            acc_rel (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        assert self._jog_min_mm &lt;= dist_mm &lt;= self._jog_max_mm, 'Jog distance is out of range'\n        assert 0 &lt;= vel_rel &lt;= 100, 'Velocity must be between 0 and 100'\n        assert 0 &lt;= acc_rel &lt;= 100, 'Acceleration must be between 0 and 100'\n\n        # Set velocity\n        ## Currently not implemented. i.e., it will jog at the same velocity as\n        ## the last set velocity\n\n        self._jog_mm = dist_mm\n\n    def move_jog(self,direction:str):\n        \"\"\"\n        Moves the motor with a single jogging motion.\n\n        Args:\n            direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n        \"\"\"\n        assert direction in ['xfwd','xrev','yfwd','yrev'], 'Invalid direction'\n\n        coor = self.get_coordinates()\n        coor = self._remap_coordinates_flip(coor,get=False)\n        if direction == 'xfwd': coor = (coor[0]+self._jog_mm, coor[1])\n        elif direction == 'xrev': coor = (coor[0]-self._jog_mm, coor[1])\n        elif direction == 'yfwd': coor = (coor[0], coor[1]+self._jog_mm)\n        elif direction == 'yrev': coor = (coor[0], coor[1]-self._jog_mm)\n        self.move_direct(coor,remap=False)\n        pitools.waitontarget(self.device,self._allaxes)\n\n        return\n\n    def movementtest(self):\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; MOTOR TEST: CIRCULAR MOTION &lt;&lt;&lt;&lt;&lt;\")\n        # Create circle coordinates\n        angles = np.arange(0, 2 * np.pi, 0.25)\n        radius = 10.0    # mm\n        xs = radius * np.cos(angles)+radius\n        ys = radius * np.sin(angles)+radius\n\n        for i in range(len(angles)):\n            print(i, float(xs[i]))\n            coor = [float(xs[i]), float(ys[i])]\n            self.move_direct(coor)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.__init__","title":"<code>__init__(sim=None)</code>","text":"<p>Initialises the xy stage controller class.</p> <p>Parameters:</p> Name Type Description Default <code>sim</code> <code>bool</code> <p>Not used in this case</p> <code>None</code> Important note <p>When developing this for use with image capture-related functionalities, the x-axis has to be the horizontal axis in the image capture and y-axis for  the vertical axis. Otherwise some of the image processing functions will not work.</p> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def __init__(self,sim=None):\n    \"\"\"\n    Initialises the xy stage controller class.\n\n    Args:\n        sim (bool, optional): Not used in this case\n\n    Important note:\n        When developing this for use with image capture-related functionalities,\n        the x-axis has to be the horizontal axis in the image capture and y-axis for \n        the vertical axis. Otherwise some of the image processing functions will not work.\n    \"\"\"\n    self.device:GCS30Device = GCSDevice()\n    self._serial_no = ControllerSpecificConfigEnum.PISTAGE_SERIAL.value\n\n    # Axes names placeholder\n    self._allaxes = None\n\n    # Axes control remapping\n    self.dict_ctrl_remap = {\n        'xfwd':ControllerDirectionEnum.XFWD.value,\n        'xrev':ControllerDirectionEnum.XREV.value,\n        'yfwd':ControllerDirectionEnum.YFWD.value,\n        'yrev':ControllerDirectionEnum.YREV.value,\n    }   # Dictionary to remap the controls (only for the continuous and jog movements)\n\n    self._flipxy = ControllerConfigEnum.STAGE_FLIPXY            # Flag to indicate if the x and y axes are flipped\n    self._invertx = ControllerConfigEnum.STAGE_INVERTX.value    # Flag to indicate if the x-axis is flipped (inversed, *= -1)\n    self._inverty = ControllerConfigEnum.STAGE_INVERTY.value    # Flag to indicate if the y-axis is flipped (inversed, *= -1)\n\n    self._dict_axes = { # Placeholder for the axes names\n        'x':None,\n        'y':None\n    }\n\n    # Movement parameters setup\n    self._max_vel:float = 100.0  # Maximum velocity of the motor in mm/s\n    self._min_vel:float = 0.001   # Minimum velocity of the motor in mm/s\n    self._vel:float = None\n\n    self._min_travelx:float = None\n    self._min_travely:float = None\n    self._max_travelx:float = None\n    self._max_travely:float = None\n\n    self._jog_min_mm:float = 0.001\n    self._jog_max_mm:float = 1.0\n    self._jog_mm:float = 1\n\n    self._max_vel_mmS = self._max_vel   # Maximum velocity of the motor in mm/s\n    self._min_vel_mmS = self._min_vel   # Minimum velocity of the motor in mm/s\n\n    # Initialises the device\n    try: self.initialisation()\n    except Exception as e: print(e)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.calculate_vel_relative","title":"<code>calculate_vel_relative(speed_mm_s)</code>","text":"<p>Calculates the relative velocity parameter for the motor given the speed in mm/s</p> <p>Parameters:</p> Name Type Description Default <code>speed_mm_s</code> <code>float</code> <p>The speed to be converted in mm/s</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The relative velocity parameter in percentage</p> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n    \"\"\"\n    Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n    Args:\n        speed_mm_s (float): The speed to be converted in mm/s\n\n    Returns:\n        float: The relative velocity parameter in percentage\n    \"\"\"\n    # Adjust the speed to the limits if it is out of bounds\n    if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n        speed_mm_s = self._min_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n    if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n        speed_mm_s = self._max_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n    # Calculate the relative speed\n    speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n    return speed_rel\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Returns the current motor coordinates</p> <p>Returns:</p> Type Description <p>tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)</p> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"\n    Returns the current motor coordinates\n\n    Returns:\n        tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n    \"\"\"\n    positions = self.device.qPOS(self.device.allaxes)\n    x,y = positions[self._dict_axes['x']], positions[self._dict_axes['y']]\n\n    x,y = self._remap_coordinates_flip((x,y),get=True)\n\n    return (x, y)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.get_identifier","title":"<code>get_identifier()</code>","text":"<p>Returns the identifier of the stage controller.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the stage controller</p> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def get_identifier(self) -&gt; str:\n    \"\"\"\n    Returns the identifier of the stage controller.\n\n    Returns:\n        str: The identifier of the stage controller\n    \"\"\"\n    if self._identifier is None: self._identifier = self._get_hardware_identifier()\n    return self._identifier\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.get_jog","title":"<code>get_jog()</code>","text":"<p>Returns the current jog step in [mm]:</p> <p>Returns:</p> Type Description <p>tuple of floats: 6 elements:</p> <p>(jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)</p> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def get_jog(self):\n    \"\"\"\n    Returns the current jog step in [mm]:\n\n    Returns:\n        tuple of floats: 6 elements:\n        (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n    \"\"\"\n    return (self._jog_mm, self._jog_mm, self._vel, self._vel, 0, 0)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def get_vel_acc_relative(self):\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    dict_relvel = self.device.qVEL(self._allaxes)\n    relvel1 = dict_relvel[self._dict_axes['x']] / self._max_vel * 100\n    relvel2 = dict_relvel[self._dict_axes['y']] / self._max_vel * 100\n\n    if relvel1 != relvel2: print('Axes have different velocities'); self._vel = relvel1\n\n    return (100, relvel1, 100)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. - Also called as 'homing'</p> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def homing_n_coor_calibration(self):\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    - Also called as 'homing'\n    \"\"\"\n\n    # Set velocity\n    self.set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)\n\n    # Move to home position\n    self.device.FRF(self._allaxes)\n    pitools.waitontarget(self.device, self._allaxes)\n    print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement</p> required Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def move_continuous(self,dir:str):\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n    \"\"\"\n    assert dir in ['xfwd','xrev','yfwd','yrev'], 'Invalid direction'\n\n    dir = self.dict_ctrl_remap[dir]\n\n    if dir == 'xfwd': self.device.MOV(self._dict_axes['x'], self._max_travelx)\n    elif dir == 'xrev': self.device.MOV(self._dict_axes['x'], self._min_travelx)\n    elif dir == 'yfwd': self.device.MOV(self._dict_axes['y'], self._max_travely)\n    elif dir == 'yrev': self.device.MOV(self._dict_axes['y'], self._min_travely)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.move_direct","title":"<code>move_direct(coor_abs, remap=True)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>tuple[float, float]</code> <p>the absolute coordinate to move to in [mm]</p> required <code>remap</code> <code>bool</code> <p>Option to remap the coor according to the set flip (made specifically for jog)</p> <code>True</code> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def move_direct(self,coor_abs:tuple[float,float],remap:bool=True):\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n        remap (bool): Option to remap the coor according to the set flip (made specifically\n            for jog)\n    \"\"\"\n    if remap: coor_abs = self._remap_coordinates_flip(coor_abs,get=False)\n\n    assert self._min_travelx &lt;= coor_abs[0] &lt;= self._max_travelx, 'Coordinate x is out of range'\n    assert self._min_travely &lt;= coor_abs[1] &lt;= self._max_travely, 'Coordinate y is out of range'\n\n    self.device.MOV([self._dict_axes['x'],self._dict_axes['y']], coor_abs)\n\n    # Wait until target is reached\n    pitools.waitontarget(self.device, self._allaxes)\n\n    return\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single jogging motion.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.</p> required Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def move_jog(self,direction:str):\n    \"\"\"\n    Moves the motor with a single jogging motion.\n\n    Args:\n        direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n    \"\"\"\n    assert direction in ['xfwd','xrev','yfwd','yrev'], 'Invalid direction'\n\n    coor = self.get_coordinates()\n    coor = self._remap_coordinates_flip(coor,get=False)\n    if direction == 'xfwd': coor = (coor[0]+self._jog_mm, coor[1])\n    elif direction == 'xrev': coor = (coor[0]-self._jog_mm, coor[1])\n    elif direction == 'yfwd': coor = (coor[0], coor[1]+self._jog_mm)\n    elif direction == 'yrev': coor = (coor[0], coor[1]-self._jog_mm)\n    self.move_direct(coor,remap=False)\n    pitools.waitontarget(self.device,self._allaxes)\n\n    return\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): Legacy parameter. Is ignored.\n        acc_rel (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    assert self._jog_min_mm &lt;= dist_mm &lt;= self._jog_max_mm, 'Jog distance is out of range'\n    assert 0 &lt;= vel_rel &lt;= 100, 'Velocity must be between 0 and 100'\n    assert 0 &lt;= acc_rel &lt;= 100, 'Acceleration must be between 0 and 100'\n\n    # Set velocity\n    ## Currently not implemented. i.e., it will jog at the same velocity as\n    ## the last set velocity\n\n    self._jog_mm = dist_mm\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100):\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): Legacy parameter. Is ignored.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    assert 0 &lt; vel_move &lt;= 100, 'Velocity must be between 0 and 100'\n\n    # Set velocity\n    vel = self._max_vel * vel_move / 100\n    self.device.VEL(self._allaxes, [vel]*2)\n\n    self._vel = vel\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops the continuous movement of the motors by sending a new target position to the current position</p> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def stop_move(self):\n    \"\"\"\n    Stops the continuous movement of the motors by sending a new\n    target position to the current position\n    \"\"\"\n    coor = self.get_coordinates()\n    coor = self._remap_coordinates_flip(coor,get=True)\n    self.device.MOV([self._dict_axes['x'],self._dict_axes['y']], coor)\n    pitools.waitontarget(self.device, self._allaxes)\n    return\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.XYController_PI.terminate","title":"<code>terminate(close_connection=True)</code>","text":"<p>Terminate the operation. Returns the stage to home and disconnects the device.</p> <p>Parameters:</p> Name Type Description Default <code>close_connection</code> <code>bool</code> <p>True to close the connection to the device</p> <code>True</code> Source code in <code>iris/controllers/xy_stage_controller_PI.py</code> <pre><code>def terminate(self,close_connection=True):\n    \"\"\"\n    Terminate the operation. Returns the stage to home and disconnects the device.\n\n    Args:\n            close_connection (bool): True to close the connection to the device\n    \"\"\"\n    if close_connection: self.device.CloseConnection()\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI/#iris.controllers.xy_stage_controller_PI.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/","title":"xy_stage_controller_PI_dll","text":"<p>This is a Python script that handles the control of the Physik Instrumente (PI) U-751.24 XY stage controller. To be used with the Open Raman Microscopy (ORM) controller app.</p>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI","title":"<code>XYController_PI</code>","text":"<p>               Bases: <code>Class_XYController</code></p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>class XYController_PI(Class_XYController):\n    def __init__(self,sim=None):\n        \"\"\"\n        Initialises the xy stage controller class.\n\n        Args:\n            sim (bool, optional): Not used in this case\n\n        Important note:\n            When developing this for use with image capture-related functionalities,\n            the x-axis has to be the horizontal axis in the image capture and y-axis for \n            the vertical axis. Otherwise some of the image processing functions will not work.\n        \"\"\"\n        self.device:GCS2Device = None\n        self._serial_no = ControllerSpecificConfigEnum.PISTAGE_SERIAL.value\n\n        # Axes names placeholder\n        self._allaxes = None\n\n        # Axes control remapping\n        self.dict_ctrl_remap = {\n            'xfwd':ControllerDirectionEnum.XFWD.value,\n            'xrev':ControllerDirectionEnum.XREV.value,\n            'yfwd':ControllerDirectionEnum.YFWD.value,\n            'yrev':ControllerDirectionEnum.YREV.value,\n        }   # Dictionary to remap the controls (only for the continuous and jog movements)\n\n        self._flipxy = ControllerConfigEnum.STAGE_FLIPXY.value      # Flag to indicate if the x and y axes are flipped\n        self._invertx = ControllerConfigEnum.STAGE_INVERTX.value   # Flag to indicate if the x-axis is flipped (inversed, *= -1)\n        self._inverty = ControllerConfigEnum.STAGE_INVERTY.value   # Flag to indicate if the y-axis is flipped (inversed, *= -1)\n\n        self._dict_axes = { # Placeholder for the axes names\n            'x':None,\n            'y':None\n        }\n\n        # Movement parameters setup\n        self._max_vel_mmPerSec:float = None     # Maximum velocity in mm/s\n        self._min_vel_mmPerSec:float = None     # Minimum velocity in mm/s\n        self._vel_mmPerSec:float = None         # Current velocity in mm/s\n\n        self._max_acc_mmPerSec2:float = 250.0   # Maximum acceleration in mm/s^2\n        self._min_acc_mmPerSec2:float = 0.01    # Minimum acceleration in mm/s^2\n\n        self._slow_vel_tresh_mmPerSec:float = 2.0   # Threshold velocity for slow movements\n        self._slow_jogsize_mm:float = 1e-3          # Jog size for slow movements [mm]\n        self._slow_minJogsize_mm:float = 1e-4       # Minimum jog size for slow movements [mm]\n        self._slow_commRate_ms:float = ControllerSpecificConfigEnum.PI_SLOW_COMRATE_MS.value  # Command rate for slow movements [ms]\n        self._slow_flg_stop = Event()               # Flag to stop the slow movement\n        self._slow_stepsize_modifier = 1.1          # Modifier for the step size when it's too slow (to dynamically increase the step size)\n\n        self._min_travelx:float = None\n        self._min_travely:float = None\n        self._max_travelx:float = None\n        self._max_travely:float = None\n\n        self._jog_min_mm:float = 0.001\n        self._jog_max_mm:float = 1.0\n        self._jog_mm:float = 1\n\n        # Coordinate logging setup\n        self._init_uptime_us = None         # Initial uptime in microseconds\n        self._init_uptime_TsRef_us = None   # Reference timestamp in microseconds\n        self._delay_ms = 0                  # Delay in milliseconds\n\n        self._lock = Lock()\n\n        # Calculation initialisation\n        self._max_vel_mmS = self._max_vel_mmPerSec  # Maximum velocity of the motor in mm/s\n        self._min_vel_mmS = self._min_vel_mmPerSec  # Minimum velocity of the motor in mm/s\n\n        self._flg_isrunning_autoreconnect = threading.Event()\n        self._reconnect_freq_sec = 3600 * ControllerSpecificConfigEnum.PISTAGE_AUTORECONNECT_HOURS.value\n        if self._reconnect_freq_sec &gt; 0:\n            self._thread_reconnect = threading.Thread(target=self.auto_reconnect)\n            self._thread_reconnect.start()\n        # Data recorder setup\n        self._flg_useDrec = ControllerSpecificConfigEnum.PISTAGE_DEVTIMESTAMP.value # To activate/deactivate the data recorder\n\n        # Initialises the device\n        self._identifier = None\n        try: self.initialisation()\n        except Exception as e: print(f'__init__ Error: {e}')\n\n    def get_identifier(self) -&gt; str:\n        try:\n            if self._identifier is None:\n                self._identifier = self._get_hardware_identifier()\n        except Exception as e:\n            self._identifier = f'Error getting identifier: {e}'\n        return self._identifier\n\n    def _get_hardware_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the hardware identifier of the stage.\n\n        Returns:\n            str: The hardware identifier of the stage\n        \"\"\"\n        if self._devname is None:\n            with self._lock: self._devname = self.device.devname\n        serialnum = self._serial_no\n        return f\"Physik Instrumente device model: {self._devname}, S/N:{serialnum}\"\n\n    def auto_reconnect(self) -&gt; None:\n        \"\"\"\n        Automatically reconnect to the device after some time\n        \"\"\"\n        self._flg_isrunning_autoreconnect.set()\n        print('Auto-reconnect thread started')\n        while self._flg_isrunning_autoreconnect.is_set():\n            time.sleep(self._reconnect_freq_sec)\n            print('Attempting to forcefully reconnect to the device...')\n            try:\n                self.reinitialise_connection()\n                print('Forcefully reconnected the device')\n            except Exception as e:\n                print(f'Error during reconnection: {e}')\n                continue\n\n    def reinitialise_connection(self) -&gt; None:\n        \"\"\"\n        Reinitialise the connection to the device\n        \"\"\"\n        coor = np.array(self.get_coordinates())\n        while True:\n            self._flg_movedone.wait(timeout=5)\n            new_coor = np.array(self.get_coordinates())\n            if np.allclose(coor, new_coor, atol=1e-3): break\n            coor = new_coor\n\n        print('Terminating')\n        try: self.terminate()\n        except Exception as e: print(f'reinitialise_connection Error: {e}')\n\n        print('Reinitialising')\n        try: self.initialisation()\n        except Exception as e: print(f'reinitialise_connection Error: {e}')\n\n    def _remap_coordinates_flip(self,coor:tuple[float,float],get:bool) -&gt; tuple[float,float]:\n        \"\"\"\n        Remaps the coordinates if the x and y axes are flipped\n\n        Args:\n            coor (tuple[float,float]): the coordinate to remap\n            get (bool): True if the coordinate is to be retrieved, False if the coordinate is to be set\n                this is to ensure that the flip is done before/after the inversion of the axes depending on the get flag\n\n        Returns:\n            tuple[float,float]: the remapped coordinate\n        \"\"\"\n        x,y = coor\n        if self._flipxy and get:\n            x,y = y,x\n        if self._invertx:\n            x = -1*x\n        if self._inverty:\n            y = -1*y\n        if self._flipxy and not get:\n            x,y = y,x\n        # Note:\n        # The flip is done before/after the inversion of the axes depending on the get flag because\n        # a matrix multiplication is not commutative. i.e., A*B != B*A\n        return (x,y)\n\n    def initialisation(self):\n        self.device:GCS2Device = GCSDevice()\n\n        try: self.device.ConnectUSB(serialnum=self._serial_no)\n        except Exception as e: assert False, f'Error during connection (typically device serial number is not found): {e}'\n        print('connected: {}'.format(self.device.qIDN().strip()))\n\n        # Get axes names\n        ## NOTE: Flip the axes indices if the stage is mounted in a different orientation\n        ## make sure that the x-axis is the horizontal axis in the image capture and y-axis for\n        self._allaxes = self.device.allaxes\n        self._dict_axes = {\n            'x':self.device.axes[1],\n            'y':self.device.axes[0]\n        }\n\n        # Get max velocity\n        pass # Todo: Get max velocity and acceleration from the device\n        # self._max_vel_mmPerSec:float = 50.0\n        # self._min_vel_mmPerSec:float = 0.01\n\n        # self._max_acc:float = 250.0\n        # self._min_acc:float = 0.01\n\n        # Get max acceleration and deceleration \n        pass\n\n        # Enable the servos\n        self.device.SVO(self._allaxes, [1]*2)\n\n        # Get max velocity\n        self._max_vel_mmPerSec:float = 25.0\n        self._min_vel_mmPerSec:float = 0.0001\n\n        # Get max travel range\n        minrange = pitools.getmintravelrange(self.device, self.device.allaxes)\n        maxrange = pitools.getmaxtravelrange(self.device, self.device.allaxes)\n        self._min_travelx, self._min_travely = minrange[self._dict_axes['x']], minrange[self._dict_axes['y']]\n        self._max_travelx, self._max_travely = maxrange[self._dict_axes['x']], maxrange[self._dict_axes['y']]\n\n        # # Set velocity and acceleration\n        # self.get_vel_acc_relative()\n\n    # # &gt;&gt; Recording setup &lt;&lt;\n    #     self.device.RTR(1)     # Record every servo cycle\n\n    #     # Set up data recorder\n    #     self.device.DRC(1,self._dict_axes['x'],44)\n    #     self.device.DRC(2,self._dict_axes['x'],2)\n    #     self.device.DRC(3,self._dict_axes['y'],2)\n\n        if self._flg_useDrec:\n            # Set the initial uptime\n            self._init_uptime_us = int(self.device.qTIM()*1e3)\n        else: self._init_uptime_us = get_timestamp_us_int()\n\n        self._init_uptime_TsRef_us = get_timestamp_us_int()\n\n        # Calculation initialisation\n        self._max_vel_mmS = self._max_vel_mmPerSec  # Maximum velocity of the motor in mm/s\n        self._min_vel_mmS = self._min_vel_mmPerSec  # Minimum velocity of the motor in mm/s\n\n        time.sleep(4)  # Wait for the device to be ready\n\n        self._flg_isrunning_autoreconnect.set()\n        self._flg_movedone = Event()\n        self._flg_movedone.clear()\n\n    def _convert_uptime_to_timestamp(self,uptime_us:int) -&gt; int:\n        \"\"\"\n        Converts the uptime in microseconds to a timestamp\n\n        Args:\n            uptime_us (int): the uptime in microseconds\n\n        Returns:\n            int: the timestamp in microseconds\n        \"\"\"\n        diff_us = uptime_us - self._init_uptime_us\n        timestamp_us = self._init_uptime_TsRef_us + diff_us + self._delay_ms*1e3\n        return timestamp_us\n\n    def _dev_ReadDataRecorder(self) -&gt; tuple[int,float,float]:\n        \"\"\"\n        Function to read the data recorder of the device\n\n        Returns:\n            tuple[int,float,float]: 3 elements: (timestamp_us, axis1_pos_mm, axis2_pos_mm)\n        \"\"\"\n        while not self.device.IsControllerReady():\n            time.sleep(0.01)\n        with self._lock:\n            if self._flg_useDrec:\n                timestamp_us = int(self.device.qTIM()*1e3)\n            else: timestamp_us = get_timestamp_us_int()\n            pos = self.device.qPOS(self._allaxes)\n            axis1_pos_mm = pos[self._dict_axes['x']]\n            axis2_pos_mm = pos[self._dict_axes['y']]\n\n        return timestamp_us, axis1_pos_mm, axis2_pos_mm\n\n    def terminate(self,close_connection=True):\n        \"\"\"\n        Terminate the operation. Returns the stage to home and disconnects the device.\n\n        Args:\n            close_connection (bool): True to close the connection to the device\n        \"\"\"\n        while not self.device.IsControllerReady(): time.sleep(0.01)\n        if close_connection:\n            self._flg_isrunning_autoreconnect.clear()  # Stop the auto-reconnect thread\n            with self._lock:\n                self.device.CloseConnection()\n\n    def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n        \"\"\"\n        Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n        Args:\n            speed_mm_s (float): The speed to be converted in mm/s\n\n        Returns:\n            float: The relative velocity parameter in percentage\n        \"\"\"\n        # Adjust the speed to the limits if it is out of bounds\n        if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n            speed_mm_s = self._min_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n        if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n            speed_mm_s = self._max_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n        # Calculate the relative speed\n        speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n        return speed_rel\n\n    def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100):\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): Legacy parameter. Is ignored.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        assert 0 &lt; vel_move &lt;= 100, 'Velocity must be between 0 and 100'\n\n        # Set velocity\n        vel_mmPerSec = self._max_vel_mmPerSec * vel_move / 100\n\n        while not self.device.IsControllerReady(): time.sleep(0.01)\n        with self._lock: self.device.VEL(self._allaxes, [vel_mmPerSec]*2)\n\n        self._vel_mmPerSec = vel_mmPerSec\n\n    def get_vel_acc_relative(self):\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        while not self.device.IsControllerReady(): time.sleep(0.01)\n        with self._lock: dict_relvel = self.device.qVEL(self._allaxes)\n        relvel1 = dict_relvel[self._dict_axes['x']] / self._max_vel_mmPerSec * 100\n        relvel2 = dict_relvel[self._dict_axes['y']] / self._max_vel_mmPerSec * 100\n\n        if relvel1 != relvel2: print('Axes have different velocities'); self._vel_mmPerSec = relvel1\n\n        return (100, relvel1, 100)\n\n    def report_attributes(self):\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Device and motor attributes &lt;&lt;&lt;&lt;&lt;\")\n        for attr, value in vars(self).items():\n            print(f\"{attr}: {value}\")\n\n    def get_coordinates(self):\n        \"\"\"\n        Returns the current motor coordinates\n\n        Returns:\n            tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n        \"\"\"\n        def interpolate_coor(target_ts:int,list_ts:list[int],list_coor_x:list[float],\n                             list_coor_y:list[float]) -&gt; tuple[float,float]:\n            \"\"\"\n            Interpolates the coordinates based on the timestamps\n\n            Args:\n                target_ts (int): the target timestamp to retrieve the coordinates\n                list_ts (list[int]): list of timestamps\n                list_coor_x (list[float]): list of x coordinates\n                list_coor_y (list[float]): list of y coordinates\n\n            Returns:\n                tuple[float,float]: the interpolated coordinates\n            \"\"\"\n            assert len(list_ts) == len(list_coor_x) == len(list_coor_y) == 2,\\\n            \"Length of the lists must be 2\"\n            assert list_ts[0] &lt; target_ts &lt; list_ts[1], \"Target timestamp must be within the range\"\n\n            # Interpolate the coordinates\n            coor_x = np.interp(target_ts,list_ts,list_coor_x)\n            coor_y = np.interp(target_ts,list_ts,list_coor_y)\n            return (coor_x,coor_y)\n\n        ts_request = get_timestamp_us_int()\n        ts_return = []\n        coor_x_return = []\n        coor_y_return = []\n\n        while True:\n            ts, coor_x, coor_y = self._dev_ReadDataRecorder()\n            ts = self._convert_uptime_to_timestamp(ts)\n            ts_return.append(ts)\n            coor_x_return.append(coor_x)\n            coor_y_return.append(coor_y)\n            if ts &gt;= ts_request: break\n            time.sleep(1/1000)  # delay to prevent overloading the comm port\n\n        if len(ts_return) == 1:\n            coor_x, coor_y = coor_x_return[-1], coor_y_return[-1]\n        else:\n            coor_x, coor_y = interpolate_coor(ts_request,ts_return[-2:],\n                coor_x_return[-2:],coor_y_return[-2:])\n\n        coor_x, coor_y = self._remap_coordinates_flip((coor_x,coor_y),get=True)\n\n        return (coor_x, coor_y)\n\n    def get_coordinates_ts(self) -&gt; tuple[int,float,float]:\n        \"\"\"\n        Returns the current motor coordinates and timestamp\n\n        Returns:\n            tuple[int,float,float]: 3 elements: (timestamp_us, coor_x, coor_y), in microseconds and millimetre (float)\n        \"\"\"\n        ts_request = get_timestamp_us_int()\n        ts_return = []\n        coor_x_return = []\n        coor_y_return = []\n\n        while True:\n            ts, coor_x, coor_y = self._dev_ReadDataRecorder()\n            ts = self._convert_uptime_to_timestamp(ts)\n            ts_return.append(ts)\n            coor_x_return.append(coor_x)\n            coor_y_return.append(coor_y)\n            if ts &gt;= ts_request: break\n            time.sleep(1/1000)  # delay to prevent overloading the comm port\n\n        ts = ts_return[-1]\n        coor_x, coor_y = coor_x_return[-1], coor_y_return[-1]\n\n        return (ts, coor_x, coor_y)\n\n    def get_coordinates_old(self):\n        while not self.device.IsControllerReady(): time.sleep(0.01)\n        with self._lock: positions = self.device.qPOS(self.device.allaxes)\n        x,y = positions[self._dict_axes['x']], positions[self._dict_axes['y']]\n\n        x,y = self._remap_coordinates_flip((x,y),get=True)\n        return (x,y)\n\n    def homing_n_coor_calibration(self):\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        - Also called as 'homing'\n        \"\"\"\n\n        # Set velocity\n        self.set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)\n\n        # Move to home position\n        while not self.device.IsControllerReady(): time.sleep(0.01)\n        with self._lock: self.device.FRF(self._allaxes)\n        pitools.waitontarget(self.device, self._allaxes)\n        print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n\n    def move_direct(self,coor_abs:tuple[float,float],remap:bool=True):\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n            remap (bool): Option to remap the coor according to the set flip (made specifically\n                for jog)\n        \"\"\"\n        print(f'Moving to coordinates: {coor_abs}')\n\n        if remap: coor_abs = self._remap_coordinates_flip(coor_abs,get=False)\n\n        print(f'Remapped coordinates: {coor_abs}')\n\n        assert self._min_travelx &lt;= coor_abs[0] &lt;= self._max_travelx, 'Coordinate x is out of range'\n        assert self._min_travely &lt;= coor_abs[1] &lt;= self._max_travely, 'Coordinate y is out of range'\n\n        # if self._vel_mmPerSec &lt; self._slow_vel_tresh_mmPerSec:\n        #     self._move_direct_slow(coor_abs)\n        # else:\n        #     with self._lock: self.device.MOV([self._dict_axes['x'],self._dict_axes['y']], coor_abs)\n\n        #     # Wait until target is reached\n        #     pitools.waitontarget(self.device, self._allaxes)\n\n        while not self.device.IsControllerReady(): time.sleep(0.01)\n        self._flg_movedone.clear()\n        with self._lock: self.device.MOV([self._dict_axes['x'],self._dict_axes['y']], coor_abs)\n\n        # Wait until target is reached\n        pitools.waitontarget(self.device, self._allaxes)\n        self._flg_movedone.set()\n\n        return\n\n    def move_continuous(self,dir:str):\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n        \"\"\"\n        assert dir in ['xfwd','xrev','yfwd','yrev'], 'Invalid direction'\n\n        dir = self.dict_ctrl_remap[dir]\n\n        while not self.device.IsControllerReady(): time.sleep(0.01)\n        with self._lock:\n            self._flg_movedone.clear()\n            if dir == 'xfwd': self.device.MOV(self._dict_axes['x'], self._max_travelx)\n            elif dir == 'xrev': self.device.MOV(self._dict_axes['x'], self._min_travelx)\n            elif dir == 'yfwd': self.device.MOV(self._dict_axes['y'], self._max_travely)\n            elif dir == 'yrev': self.device.MOV(self._dict_axes['y'], self._min_travely)\n\n    def stop_move(self):\n        \"\"\"\n        Stops the continuous movement of the motors by sending a new\n        target position to the current position\n        \"\"\"\n        while not self.device.IsControllerReady(): time.sleep(0.01)\n        with self._lock: self.device.HLT(self._allaxes,noraise=True)\n        self._flg_movedone.set()\n        return\n\n    def get_jog(self):\n        \"\"\"\n        Returns the current jog step in [mm]:\n\n        Returns:\n            tuple of floats: 6 elements:\n            (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n        \"\"\"\n        return (self._jog_mm, self._jog_mm, self._vel_mmPerSec, self._vel_mmPerSec, 0, 0)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): Legacy parameter. Is ignored.\n            acc_rel (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        assert self._jog_min_mm &lt;= dist_mm &lt;= self._jog_max_mm, 'Jog distance is out of range'\n        assert 0 &lt;= vel_rel &lt;= 100, 'Velocity must be between 0 and 100'\n        assert 0 &lt;= acc_rel &lt;= 100, 'Acceleration must be between 0 and 100'\n\n        # Set velocity\n        ## Currently not implemented. i.e., it will jog at the same velocity as\n        ## the last set velocity\n\n        self._jog_mm = dist_mm\n\n    def move_jog(self,direction:str):\n        \"\"\"\n        Moves the motor with a single jogging motion.\n\n        Args:\n            direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n        \"\"\"\n        assert direction in ['xfwd','xrev','yfwd','yrev'], 'Invalid direction'\n\n        direction = self.dict_ctrl_remap[direction]\n\n        coor = self.get_coordinates()\n        coor = self._remap_coordinates_flip(coor,get=False)\n\n        self._flg_movedone.clear()\n        if direction == 'xfwd': coor = (coor[0]+self._jog_mm, coor[1])\n        elif direction == 'xrev': coor = (coor[0]-self._jog_mm, coor[1])\n        elif direction == 'yfwd': coor = (coor[0], coor[1]+self._jog_mm)\n        elif direction == 'yrev': coor = (coor[0], coor[1]-self._jog_mm)\n        self.move_direct(coor,remap=False)\n        pitools.waitontarget(self.device,self._allaxes)\n        self._flg_movedone.set()\n\n        return\n\n    def movementtest(self):\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; MOTOR TEST: CIRCULAR MOTION &lt;&lt;&lt;&lt;&lt;\")\n        # Create circle coordinates\n        angles = np.arange(0, 2 * np.pi, 0.25)\n        radius = 10.0    # mm\n        xs = radius * np.cos(angles)+radius\n        ys = radius * np.sin(angles)+radius\n\n        for i in range(len(angles)):\n            print('{}. Moving to coordinates: ({},{})'.format(i+1,xs[i],ys[i]))\n            coor = [float(xs[i]), float(ys[i])]\n            self.move_direct(coor)\n            print('Current coordinates: {}'.format(self.get_coordinates()))\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.__init__","title":"<code>__init__(sim=None)</code>","text":"<p>Initialises the xy stage controller class.</p> <p>Parameters:</p> Name Type Description Default <code>sim</code> <code>bool</code> <p>Not used in this case</p> <code>None</code> Important note <p>When developing this for use with image capture-related functionalities, the x-axis has to be the horizontal axis in the image capture and y-axis for  the vertical axis. Otherwise some of the image processing functions will not work.</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def __init__(self,sim=None):\n    \"\"\"\n    Initialises the xy stage controller class.\n\n    Args:\n        sim (bool, optional): Not used in this case\n\n    Important note:\n        When developing this for use with image capture-related functionalities,\n        the x-axis has to be the horizontal axis in the image capture and y-axis for \n        the vertical axis. Otherwise some of the image processing functions will not work.\n    \"\"\"\n    self.device:GCS2Device = None\n    self._serial_no = ControllerSpecificConfigEnum.PISTAGE_SERIAL.value\n\n    # Axes names placeholder\n    self._allaxes = None\n\n    # Axes control remapping\n    self.dict_ctrl_remap = {\n        'xfwd':ControllerDirectionEnum.XFWD.value,\n        'xrev':ControllerDirectionEnum.XREV.value,\n        'yfwd':ControllerDirectionEnum.YFWD.value,\n        'yrev':ControllerDirectionEnum.YREV.value,\n    }   # Dictionary to remap the controls (only for the continuous and jog movements)\n\n    self._flipxy = ControllerConfigEnum.STAGE_FLIPXY.value      # Flag to indicate if the x and y axes are flipped\n    self._invertx = ControllerConfigEnum.STAGE_INVERTX.value   # Flag to indicate if the x-axis is flipped (inversed, *= -1)\n    self._inverty = ControllerConfigEnum.STAGE_INVERTY.value   # Flag to indicate if the y-axis is flipped (inversed, *= -1)\n\n    self._dict_axes = { # Placeholder for the axes names\n        'x':None,\n        'y':None\n    }\n\n    # Movement parameters setup\n    self._max_vel_mmPerSec:float = None     # Maximum velocity in mm/s\n    self._min_vel_mmPerSec:float = None     # Minimum velocity in mm/s\n    self._vel_mmPerSec:float = None         # Current velocity in mm/s\n\n    self._max_acc_mmPerSec2:float = 250.0   # Maximum acceleration in mm/s^2\n    self._min_acc_mmPerSec2:float = 0.01    # Minimum acceleration in mm/s^2\n\n    self._slow_vel_tresh_mmPerSec:float = 2.0   # Threshold velocity for slow movements\n    self._slow_jogsize_mm:float = 1e-3          # Jog size for slow movements [mm]\n    self._slow_minJogsize_mm:float = 1e-4       # Minimum jog size for slow movements [mm]\n    self._slow_commRate_ms:float = ControllerSpecificConfigEnum.PI_SLOW_COMRATE_MS.value  # Command rate for slow movements [ms]\n    self._slow_flg_stop = Event()               # Flag to stop the slow movement\n    self._slow_stepsize_modifier = 1.1          # Modifier for the step size when it's too slow (to dynamically increase the step size)\n\n    self._min_travelx:float = None\n    self._min_travely:float = None\n    self._max_travelx:float = None\n    self._max_travely:float = None\n\n    self._jog_min_mm:float = 0.001\n    self._jog_max_mm:float = 1.0\n    self._jog_mm:float = 1\n\n    # Coordinate logging setup\n    self._init_uptime_us = None         # Initial uptime in microseconds\n    self._init_uptime_TsRef_us = None   # Reference timestamp in microseconds\n    self._delay_ms = 0                  # Delay in milliseconds\n\n    self._lock = Lock()\n\n    # Calculation initialisation\n    self._max_vel_mmS = self._max_vel_mmPerSec  # Maximum velocity of the motor in mm/s\n    self._min_vel_mmS = self._min_vel_mmPerSec  # Minimum velocity of the motor in mm/s\n\n    self._flg_isrunning_autoreconnect = threading.Event()\n    self._reconnect_freq_sec = 3600 * ControllerSpecificConfigEnum.PISTAGE_AUTORECONNECT_HOURS.value\n    if self._reconnect_freq_sec &gt; 0:\n        self._thread_reconnect = threading.Thread(target=self.auto_reconnect)\n        self._thread_reconnect.start()\n    # Data recorder setup\n    self._flg_useDrec = ControllerSpecificConfigEnum.PISTAGE_DEVTIMESTAMP.value # To activate/deactivate the data recorder\n\n    # Initialises the device\n    self._identifier = None\n    try: self.initialisation()\n    except Exception as e: print(f'__init__ Error: {e}')\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.auto_reconnect","title":"<code>auto_reconnect()</code>","text":"<p>Automatically reconnect to the device after some time</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def auto_reconnect(self) -&gt; None:\n    \"\"\"\n    Automatically reconnect to the device after some time\n    \"\"\"\n    self._flg_isrunning_autoreconnect.set()\n    print('Auto-reconnect thread started')\n    while self._flg_isrunning_autoreconnect.is_set():\n        time.sleep(self._reconnect_freq_sec)\n        print('Attempting to forcefully reconnect to the device...')\n        try:\n            self.reinitialise_connection()\n            print('Forcefully reconnected the device')\n        except Exception as e:\n            print(f'Error during reconnection: {e}')\n            continue\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.calculate_vel_relative","title":"<code>calculate_vel_relative(speed_mm_s)</code>","text":"<p>Calculates the relative velocity parameter for the motor given the speed in mm/s</p> <p>Parameters:</p> Name Type Description Default <code>speed_mm_s</code> <code>float</code> <p>The speed to be converted in mm/s</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The relative velocity parameter in percentage</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n    \"\"\"\n    Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n    Args:\n        speed_mm_s (float): The speed to be converted in mm/s\n\n    Returns:\n        float: The relative velocity parameter in percentage\n    \"\"\"\n    # Adjust the speed to the limits if it is out of bounds\n    if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n        speed_mm_s = self._min_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n    if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n        speed_mm_s = self._max_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n    # Calculate the relative speed\n    speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n    return speed_rel\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Returns the current motor coordinates</p> <p>Returns:</p> Type Description <p>tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"\n    Returns the current motor coordinates\n\n    Returns:\n        tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n    \"\"\"\n    def interpolate_coor(target_ts:int,list_ts:list[int],list_coor_x:list[float],\n                         list_coor_y:list[float]) -&gt; tuple[float,float]:\n        \"\"\"\n        Interpolates the coordinates based on the timestamps\n\n        Args:\n            target_ts (int): the target timestamp to retrieve the coordinates\n            list_ts (list[int]): list of timestamps\n            list_coor_x (list[float]): list of x coordinates\n            list_coor_y (list[float]): list of y coordinates\n\n        Returns:\n            tuple[float,float]: the interpolated coordinates\n        \"\"\"\n        assert len(list_ts) == len(list_coor_x) == len(list_coor_y) == 2,\\\n        \"Length of the lists must be 2\"\n        assert list_ts[0] &lt; target_ts &lt; list_ts[1], \"Target timestamp must be within the range\"\n\n        # Interpolate the coordinates\n        coor_x = np.interp(target_ts,list_ts,list_coor_x)\n        coor_y = np.interp(target_ts,list_ts,list_coor_y)\n        return (coor_x,coor_y)\n\n    ts_request = get_timestamp_us_int()\n    ts_return = []\n    coor_x_return = []\n    coor_y_return = []\n\n    while True:\n        ts, coor_x, coor_y = self._dev_ReadDataRecorder()\n        ts = self._convert_uptime_to_timestamp(ts)\n        ts_return.append(ts)\n        coor_x_return.append(coor_x)\n        coor_y_return.append(coor_y)\n        if ts &gt;= ts_request: break\n        time.sleep(1/1000)  # delay to prevent overloading the comm port\n\n    if len(ts_return) == 1:\n        coor_x, coor_y = coor_x_return[-1], coor_y_return[-1]\n    else:\n        coor_x, coor_y = interpolate_coor(ts_request,ts_return[-2:],\n            coor_x_return[-2:],coor_y_return[-2:])\n\n    coor_x, coor_y = self._remap_coordinates_flip((coor_x,coor_y),get=True)\n\n    return (coor_x, coor_y)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.get_coordinates_ts","title":"<code>get_coordinates_ts()</code>","text":"<p>Returns the current motor coordinates and timestamp</p> <p>Returns:</p> Type Description <code>tuple[int, float, float]</code> <p>tuple[int,float,float]: 3 elements: (timestamp_us, coor_x, coor_y), in microseconds and millimetre (float)</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def get_coordinates_ts(self) -&gt; tuple[int,float,float]:\n    \"\"\"\n    Returns the current motor coordinates and timestamp\n\n    Returns:\n        tuple[int,float,float]: 3 elements: (timestamp_us, coor_x, coor_y), in microseconds and millimetre (float)\n    \"\"\"\n    ts_request = get_timestamp_us_int()\n    ts_return = []\n    coor_x_return = []\n    coor_y_return = []\n\n    while True:\n        ts, coor_x, coor_y = self._dev_ReadDataRecorder()\n        ts = self._convert_uptime_to_timestamp(ts)\n        ts_return.append(ts)\n        coor_x_return.append(coor_x)\n        coor_y_return.append(coor_y)\n        if ts &gt;= ts_request: break\n        time.sleep(1/1000)  # delay to prevent overloading the comm port\n\n    ts = ts_return[-1]\n    coor_x, coor_y = coor_x_return[-1], coor_y_return[-1]\n\n    return (ts, coor_x, coor_y)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.get_jog","title":"<code>get_jog()</code>","text":"<p>Returns the current jog step in [mm]:</p> <p>Returns:</p> Type Description <p>tuple of floats: 6 elements:</p> <p>(jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def get_jog(self):\n    \"\"\"\n    Returns the current jog step in [mm]:\n\n    Returns:\n        tuple of floats: 6 elements:\n        (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n    \"\"\"\n    return (self._jog_mm, self._jog_mm, self._vel_mmPerSec, self._vel_mmPerSec, 0, 0)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def get_vel_acc_relative(self):\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    while not self.device.IsControllerReady(): time.sleep(0.01)\n    with self._lock: dict_relvel = self.device.qVEL(self._allaxes)\n    relvel1 = dict_relvel[self._dict_axes['x']] / self._max_vel_mmPerSec * 100\n    relvel2 = dict_relvel[self._dict_axes['y']] / self._max_vel_mmPerSec * 100\n\n    if relvel1 != relvel2: print('Axes have different velocities'); self._vel_mmPerSec = relvel1\n\n    return (100, relvel1, 100)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. - Also called as 'homing'</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def homing_n_coor_calibration(self):\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    - Also called as 'homing'\n    \"\"\"\n\n    # Set velocity\n    self.set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)\n\n    # Move to home position\n    while not self.device.IsControllerReady(): time.sleep(0.01)\n    with self._lock: self.device.FRF(self._allaxes)\n    pitools.waitontarget(self.device, self._allaxes)\n    print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement</p> required Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def move_continuous(self,dir:str):\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n    \"\"\"\n    assert dir in ['xfwd','xrev','yfwd','yrev'], 'Invalid direction'\n\n    dir = self.dict_ctrl_remap[dir]\n\n    while not self.device.IsControllerReady(): time.sleep(0.01)\n    with self._lock:\n        self._flg_movedone.clear()\n        if dir == 'xfwd': self.device.MOV(self._dict_axes['x'], self._max_travelx)\n        elif dir == 'xrev': self.device.MOV(self._dict_axes['x'], self._min_travelx)\n        elif dir == 'yfwd': self.device.MOV(self._dict_axes['y'], self._max_travely)\n        elif dir == 'yrev': self.device.MOV(self._dict_axes['y'], self._min_travely)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.move_direct","title":"<code>move_direct(coor_abs, remap=True)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>tuple[float, float]</code> <p>the absolute coordinate to move to in [mm]</p> required <code>remap</code> <code>bool</code> <p>Option to remap the coor according to the set flip (made specifically for jog)</p> <code>True</code> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def move_direct(self,coor_abs:tuple[float,float],remap:bool=True):\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n        remap (bool): Option to remap the coor according to the set flip (made specifically\n            for jog)\n    \"\"\"\n    print(f'Moving to coordinates: {coor_abs}')\n\n    if remap: coor_abs = self._remap_coordinates_flip(coor_abs,get=False)\n\n    print(f'Remapped coordinates: {coor_abs}')\n\n    assert self._min_travelx &lt;= coor_abs[0] &lt;= self._max_travelx, 'Coordinate x is out of range'\n    assert self._min_travely &lt;= coor_abs[1] &lt;= self._max_travely, 'Coordinate y is out of range'\n\n    # if self._vel_mmPerSec &lt; self._slow_vel_tresh_mmPerSec:\n    #     self._move_direct_slow(coor_abs)\n    # else:\n    #     with self._lock: self.device.MOV([self._dict_axes['x'],self._dict_axes['y']], coor_abs)\n\n    #     # Wait until target is reached\n    #     pitools.waitontarget(self.device, self._allaxes)\n\n    while not self.device.IsControllerReady(): time.sleep(0.01)\n    self._flg_movedone.clear()\n    with self._lock: self.device.MOV([self._dict_axes['x'],self._dict_axes['y']], coor_abs)\n\n    # Wait until target is reached\n    pitools.waitontarget(self.device, self._allaxes)\n    self._flg_movedone.set()\n\n    return\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single jogging motion.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.</p> required Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def move_jog(self,direction:str):\n    \"\"\"\n    Moves the motor with a single jogging motion.\n\n    Args:\n        direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n    \"\"\"\n    assert direction in ['xfwd','xrev','yfwd','yrev'], 'Invalid direction'\n\n    direction = self.dict_ctrl_remap[direction]\n\n    coor = self.get_coordinates()\n    coor = self._remap_coordinates_flip(coor,get=False)\n\n    self._flg_movedone.clear()\n    if direction == 'xfwd': coor = (coor[0]+self._jog_mm, coor[1])\n    elif direction == 'xrev': coor = (coor[0]-self._jog_mm, coor[1])\n    elif direction == 'yfwd': coor = (coor[0], coor[1]+self._jog_mm)\n    elif direction == 'yrev': coor = (coor[0], coor[1]-self._jog_mm)\n    self.move_direct(coor,remap=False)\n    pitools.waitontarget(self.device,self._allaxes)\n    self._flg_movedone.set()\n\n    return\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.reinitialise_connection","title":"<code>reinitialise_connection()</code>","text":"<p>Reinitialise the connection to the device</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def reinitialise_connection(self) -&gt; None:\n    \"\"\"\n    Reinitialise the connection to the device\n    \"\"\"\n    coor = np.array(self.get_coordinates())\n    while True:\n        self._flg_movedone.wait(timeout=5)\n        new_coor = np.array(self.get_coordinates())\n        if np.allclose(coor, new_coor, atol=1e-3): break\n        coor = new_coor\n\n    print('Terminating')\n    try: self.terminate()\n    except Exception as e: print(f'reinitialise_connection Error: {e}')\n\n    print('Reinitialising')\n    try: self.initialisation()\n    except Exception as e: print(f'reinitialise_connection Error: {e}')\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): Legacy parameter. Is ignored.\n        acc_rel (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    assert self._jog_min_mm &lt;= dist_mm &lt;= self._jog_max_mm, 'Jog distance is out of range'\n    assert 0 &lt;= vel_rel &lt;= 100, 'Velocity must be between 0 and 100'\n    assert 0 &lt;= acc_rel &lt;= 100, 'Acceleration must be between 0 and 100'\n\n    # Set velocity\n    ## Currently not implemented. i.e., it will jog at the same velocity as\n    ## the last set velocity\n\n    self._jog_mm = dist_mm\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100):\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): Legacy parameter. Is ignored.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    assert 0 &lt; vel_move &lt;= 100, 'Velocity must be between 0 and 100'\n\n    # Set velocity\n    vel_mmPerSec = self._max_vel_mmPerSec * vel_move / 100\n\n    while not self.device.IsControllerReady(): time.sleep(0.01)\n    with self._lock: self.device.VEL(self._allaxes, [vel_mmPerSec]*2)\n\n    self._vel_mmPerSec = vel_mmPerSec\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops the continuous movement of the motors by sending a new target position to the current position</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def stop_move(self):\n    \"\"\"\n    Stops the continuous movement of the motors by sending a new\n    target position to the current position\n    \"\"\"\n    while not self.device.IsControllerReady(): time.sleep(0.01)\n    with self._lock: self.device.HLT(self._allaxes,noraise=True)\n    self._flg_movedone.set()\n    return\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.XYController_PI.terminate","title":"<code>terminate(close_connection=True)</code>","text":"<p>Terminate the operation. Returns the stage to home and disconnects the device.</p> <p>Parameters:</p> Name Type Description Default <code>close_connection</code> <code>bool</code> <p>True to close the connection to the device</p> <code>True</code> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def terminate(self,close_connection=True):\n    \"\"\"\n    Terminate the operation. Returns the stage to home and disconnects the device.\n\n    Args:\n        close_connection (bool): True to close the connection to the device\n    \"\"\"\n    while not self.device.IsControllerReady(): time.sleep(0.01)\n    if close_connection:\n        self._flg_isrunning_autoreconnect.clear()  # Stop the auto-reconnect thread\n        with self._lock:\n            self.device.CloseConnection()\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.test_movecontinuous_slow_with_coorRecord","title":"<code>test_movecontinuous_slow_with_coorRecord(rel_speed=0.2)</code>","text":"<p>Test the continuous movement with a slow velocity and record the coordinates at the same time. The coordinates are then reported at the end of the movement.</p> Source code in <code>iris/controllers/xy_stage_controller_PI_dll.py</code> <pre><code>def test_movecontinuous_slow_with_coorRecord(rel_speed=0.2):\n    \"\"\"\n    Test the continuous movement with a slow velocity and record the coordinates at the same time.\n    The coordinates are then reported at the end of the movement.\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    xystage = XYController_PI()\n    xystage.homing_n_coor_calibration()\n    xystage.set_vel_acc_relative(vel_homing=100, vel_move=rel_speed, acc_move=100)\n\n    @thread_assign\n    def record_coor(flg:threading.Event, ts_coor_list:list):\n        while not flg.is_set():\n            ts,coorx,coory = xystage.get_coordinates_ts()\n            ts_coor_list.append((ts,coorx,coory))\n            time.sleep(20/1000) # 20 ms\n\n    print('Move continuous test')\n    xystage.move_continuous('xfwd')\n    xystage.move_continuous('yfwd')\n\n    # Record the coordinates\n    flg_stop = threading.Event()\n    ts_coor_list = []\n    record_coor(flg_stop,ts_coor_list)\n\n    # Allow the stage to move for 2 seconds\n    time.sleep(5)\n    xystage.stop_move()\n    flg_stop.set()\n\n    # Plot the coordinates\n    ts_coor_list = np.array(ts_coor_list)\n    plt.plot(ts_coor_list[:,0],ts_coor_list[:,1],label='X-coordinate')\n    plt.plot(ts_coor_list[:,0],ts_coor_list[:,2],label='Y-coordinate')\n    plt.xlabel('Timestamp (us)')\n    plt.ylabel('Coordinate (mm)')\n\n    plt.legend()\n    plt.show()\n\n    xystage.terminate()\n    print('Termination complete')\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_PI_dll/#iris.controllers.xy_stage_controller_PI_dll.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/","title":"xy_stage_controller_dummy","text":"<p>A class to control the XY stage using the Zaber ASCII protocol.</p> <p>Notes: - For better coordinate retrieval, a timestamp of the uptime of the device is used as a reference. - This uptime is then converted by adding its difference to the reference timestamp 'self.uptime_TsRef_us'</p>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy","title":"<code>XYController_Dummy</code>","text":"<p>               Bases: <code>Class_XYController</code></p> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>class XYController_Dummy(Class_XYController):\n    def __init__(self,**kwargs) -&gt; None:\n        # Remapping of the controls\n        self._coor_x_mm = float(0)\n        self._coor_y_mm = float(0)\n\n        self._invertx = 1 if not ControllerConfigEnum.STAGE_INVERTX.value else -1\n        self._inverty = 1 if not ControllerConfigEnum.STAGE_INVERTY.value else -1\n\n        self._max_vel_mmS = 100.0    # Maximum velocity of the motor in mm/s\n        self._min_vel_mmS = 0.1      # Minimum velocity of the motor in mm/s\n\n        self._jog_step_min_um = 1 # Minimum jog step size in [um]\n\n        self._vel = 100\n        self._step_um = 1               # distance traveled per step in [um], i.e., the step size\n        self._step_wait_time_sec = 1e-6 # waiting time between steps in [s]\n\n        self._jog_step_mm = 0.1            # jog step size in [mm]\n\n        self._thread_movecontinuous:threading.Thread|None = None\n        self._flg_movecontinuous = threading.Event()\n\n        print('\\n&gt;&gt;&gt;&gt;&gt; DUMMY XY controller is used &lt;&lt;&lt;&lt;&lt;')\n\n    def get_identifier(self) -&gt; str:\n        return \"Dummy XY Stage Controller\"\n\n    def initialisation(self,commport:str):\n        \"\"\"\n        Initialises the device, setup the connection, channels, motors and their parameters, etc.\n\n        Args:\n            commport (str): the communication port for the device\n        \"\"\"\n        pass\n\n    def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100):\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): Legacy parameter. Is ignored.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if vel_move &lt;= 0:\n            raise ValueError(\"Velocity and acceleration parameters must be larger than 0%\")\n        if vel_move &gt; 100:\n            raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n        self._vel = vel_move\n\n    def get_vel_acc_relative(self):\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        return (100, self._vel, 100)\n\n    def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n        \"\"\"\n        Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n        Args:\n            speed_mm_s (float): The speed to be converted in mm/s\n\n        Returns:\n            float: The relative velocity parameter in percentage\n        \"\"\"\n        # Adjust the speed to the limits if it is out of bounds\n        if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n            speed_mm_s = self._min_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n        if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n            speed_mm_s = self._max_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n        # Calculate the relative speed\n        speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n        return speed_rel\n\n    def report_attributes(self):\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Device and motor attributes &lt;&lt;&lt;&lt;&lt;\")\n        for attr, value in vars(self).items():\n            print(f\"{attr}: {value}\")\n\n    def get_coordinates(self):\n        \"\"\"\n        Returns the current motor coordinates\n\n        Returns:\n            tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n        \"\"\"\n        return (self._coor_x_mm*self._invertx, self._coor_y_mm*self._inverty)\n\n    def homing_n_coor_calibration(self):\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        - Also called as 'homing'\n        \"\"\"\n        print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n        # Home the device, use multithreading to operate both motors at once\n        self._coor_x_mm = float(0)\n        self._coor_y_mm = float(0)\n        print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n\n    def move_direct(self,coor_abs:tuple[float,float]):\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n        \"\"\"\n        coor_abs = (coor_abs[0]*self._invertx, coor_abs[1]*self._inverty)\n        count_x = int((coor_abs[0]-self._coor_x_mm*self._invertx)/self._step_um*1000)\n        count_y = int((coor_abs[1]-self._coor_y_mm*self._inverty)/self._step_um*1000)\n\n        target_x_mm = self._coor_x_mm + count_x*self._step_um/1000\n        target_y_mm = self._coor_y_mm + count_y*self._step_um/1000\n\n        while True:\n            if self._coor_x_mm &lt; target_x_mm:\n                self._coor_x_mm += self._step_um/1000\n            elif self._coor_x_mm &gt; target_x_mm:\n                self._coor_x_mm -= self._step_um/1000\n            if self._coor_y_mm &lt; target_y_mm:\n                self._coor_y_mm += self._step_um/1000\n            elif self._coor_y_mm &gt; target_y_mm:\n                self._coor_y_mm -= self._step_um/1000\n\n            time.sleep(self._step_wait_time_sec/(self._vel/100))\n\n            error = np.sqrt((self._coor_x_mm-target_x_mm)**2 + (self._coor_y_mm-target_y_mm)**2)\n            # print(coor_abs,(self._coor_x_mm,self._coor_y_mm),(target_x_mm,target_y_mm),error)\n            if error &lt; 0.001:\n                break\n\n        return\n\n    def move_continuous(self,dir:str):\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n        \"\"\"\n        def move_continuous_thread(self:XYController_Dummy,dir):\n            self._flg_movecontinuous.set()\n            while self._flg_movecontinuous.is_set():\n                if dir == 'xfwd':\n                    self._coor_x_mm += self._step_um/1000\n                elif dir == 'xrev':\n                    self._coor_x_mm -= self._step_um/1000\n                elif dir == 'yfwd':\n                    self._coor_y_mm += self._step_um/1000\n                elif dir == 'yrev':\n                    self._coor_y_mm -= self._step_um/1000\n                time.sleep(self._step_wait_time_sec/(self._vel/100))\n\n        self._thread_movecontinuous = threading.Thread(target=move_continuous_thread,args=(self,dir))\n        self._thread_movecontinuous.start()\n\n    def stop_move(self):\n        \"\"\"\n        Stops the continuous movement of the motors\n        \"\"\"\n        if isinstance(self._thread_movecontinuous, threading.Thread):\n            if self._thread_movecontinuous.is_alive():\n                self._flg_movecontinuous.clear()\n                self._thread_movecontinuous.join(timeout=1)\n                self._thread_movecontinuous = None\n                print(\"&gt;&gt;&gt;&gt;&gt; Continuous movement stopped &lt;&lt;&lt;&lt;&lt;\")\n            else:\n                self._thread_movecontinuous = None\n\n    def get_jog(self):\n        \"\"\"\n        Returns the current jog step in [mm]:\n\n        Returns:\n            tuple of floats: 6 elements:\n            (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n        \"\"\"\n        jog_step_x = self._jog_step_mm\n        jog_step_y = self._jog_step_mm\n        jog_vel_x = float(100)\n        jog_vel_y = float(100)\n        jog_acc_x = float(100)\n        jog_acc_y = float(100)\n        return (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): Legacy parameter. Is ignored.\n            acc_rel (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n            raise ValueError(\"Distance must be a float\")\n\n        if dist_mm*1e3 &lt; self._jog_step_min_um:\n            raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min_um))\n\n        # Set the jog step size\n        self._jog_step_mm = float(dist_mm)\n\n    def move_jog(self,direction:str):\n        \"\"\"\n        Moves the motor with a single jogging motion.\n\n        Args:\n            direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n        \"\"\"\n        if not isinstance(direction, str):\n            raise ValueError(\"Direction must be a string\")\n\n        if direction not in ['xfwd','xrev','yfwd','yrev']:\n            raise ValueError(\"Direction must be 'xfwd', 'xrev', 'yfwd', 'yrev'\")\n\n\n        while True:\n            if direction == 'xfwd':\n                self._coor_x_mm += self._jog_step_mm * self._invertx\n            elif direction == 'xrev':\n                self._coor_x_mm -= self._jog_step_mm * self._invertx\n            elif direction == 'yfwd':\n                self._coor_y_mm += self._jog_step_mm * self._inverty\n            elif direction == 'yrev':\n                self._coor_y_mm -= self._jog_step_mm * self._inverty\n\n            time.sleep(self._step_wait_time_sec/(self._vel/100))\n\n            break\n\n    def terminate(self):\n        \"\"\"\n        Terminates the operation and closes the connection to the device\n        \"\"\"\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; DUMMY XY controller terminated &lt;&lt;&lt;&lt;&lt;\")\n        pass\n\n    def movementtest(self):\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; MOTOR TEST: CIRCULAR MOTION &lt;&lt;&lt;&lt;&lt;\")\n        # Create circle coordinates\n        angles = np.arange(0, 2 * np.pi, 0.25)\n        radius = 10.0    # mm\n        xs = radius * np.cos(angles)+radius\n        ys = radius * np.sin(angles)+radius\n\n        for i in range(len(angles)):\n            print(i, float(xs[i]))\n            coor = [float(xs[i]), float(ys[i])]\n            self.move_direct(coor)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.calculate_vel_relative","title":"<code>calculate_vel_relative(speed_mm_s)</code>","text":"<p>Calculates the relative velocity parameter for the motor given the speed in mm/s</p> <p>Parameters:</p> Name Type Description Default <code>speed_mm_s</code> <code>float</code> <p>The speed to be converted in mm/s</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The relative velocity parameter in percentage</p> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n    \"\"\"\n    Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n    Args:\n        speed_mm_s (float): The speed to be converted in mm/s\n\n    Returns:\n        float: The relative velocity parameter in percentage\n    \"\"\"\n    # Adjust the speed to the limits if it is out of bounds\n    if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n        speed_mm_s = self._min_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n    if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n        speed_mm_s = self._max_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n    # Calculate the relative speed\n    speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n    return speed_rel\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Returns the current motor coordinates</p> <p>Returns:</p> Type Description <p>tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)</p> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"\n    Returns the current motor coordinates\n\n    Returns:\n        tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n    \"\"\"\n    return (self._coor_x_mm*self._invertx, self._coor_y_mm*self._inverty)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.get_jog","title":"<code>get_jog()</code>","text":"<p>Returns the current jog step in [mm]:</p> <p>Returns:</p> Type Description <p>tuple of floats: 6 elements:</p> <p>(jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)</p> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def get_jog(self):\n    \"\"\"\n    Returns the current jog step in [mm]:\n\n    Returns:\n        tuple of floats: 6 elements:\n        (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n    \"\"\"\n    jog_step_x = self._jog_step_mm\n    jog_step_y = self._jog_step_mm\n    jog_vel_x = float(100)\n    jog_vel_y = float(100)\n    jog_acc_x = float(100)\n    jog_acc_y = float(100)\n    return (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def get_vel_acc_relative(self):\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    return (100, self._vel, 100)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. - Also called as 'homing'</p> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def homing_n_coor_calibration(self):\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    - Also called as 'homing'\n    \"\"\"\n    print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n    # Home the device, use multithreading to operate both motors at once\n    self._coor_x_mm = float(0)\n    self._coor_y_mm = float(0)\n    print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.initialisation","title":"<code>initialisation(commport)</code>","text":"<p>Initialises the device, setup the connection, channels, motors and their parameters, etc.</p> <p>Parameters:</p> Name Type Description Default <code>commport</code> <code>str</code> <p>the communication port for the device</p> required Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def initialisation(self,commport:str):\n    \"\"\"\n    Initialises the device, setup the connection, channels, motors and their parameters, etc.\n\n    Args:\n        commport (str): the communication port for the device\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement</p> required Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def move_continuous(self,dir:str):\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n    \"\"\"\n    def move_continuous_thread(self:XYController_Dummy,dir):\n        self._flg_movecontinuous.set()\n        while self._flg_movecontinuous.is_set():\n            if dir == 'xfwd':\n                self._coor_x_mm += self._step_um/1000\n            elif dir == 'xrev':\n                self._coor_x_mm -= self._step_um/1000\n            elif dir == 'yfwd':\n                self._coor_y_mm += self._step_um/1000\n            elif dir == 'yrev':\n                self._coor_y_mm -= self._step_um/1000\n            time.sleep(self._step_wait_time_sec/(self._vel/100))\n\n    self._thread_movecontinuous = threading.Thread(target=move_continuous_thread,args=(self,dir))\n    self._thread_movecontinuous.start()\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.move_direct","title":"<code>move_direct(coor_abs)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>tuple[float, float]</code> <p>the absolute coordinate to move to in [mm]</p> required Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def move_direct(self,coor_abs:tuple[float,float]):\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n    \"\"\"\n    coor_abs = (coor_abs[0]*self._invertx, coor_abs[1]*self._inverty)\n    count_x = int((coor_abs[0]-self._coor_x_mm*self._invertx)/self._step_um*1000)\n    count_y = int((coor_abs[1]-self._coor_y_mm*self._inverty)/self._step_um*1000)\n\n    target_x_mm = self._coor_x_mm + count_x*self._step_um/1000\n    target_y_mm = self._coor_y_mm + count_y*self._step_um/1000\n\n    while True:\n        if self._coor_x_mm &lt; target_x_mm:\n            self._coor_x_mm += self._step_um/1000\n        elif self._coor_x_mm &gt; target_x_mm:\n            self._coor_x_mm -= self._step_um/1000\n        if self._coor_y_mm &lt; target_y_mm:\n            self._coor_y_mm += self._step_um/1000\n        elif self._coor_y_mm &gt; target_y_mm:\n            self._coor_y_mm -= self._step_um/1000\n\n        time.sleep(self._step_wait_time_sec/(self._vel/100))\n\n        error = np.sqrt((self._coor_x_mm-target_x_mm)**2 + (self._coor_y_mm-target_y_mm)**2)\n        # print(coor_abs,(self._coor_x_mm,self._coor_y_mm),(target_x_mm,target_y_mm),error)\n        if error &lt; 0.001:\n            break\n\n    return\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single jogging motion.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.</p> required Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def move_jog(self,direction:str):\n    \"\"\"\n    Moves the motor with a single jogging motion.\n\n    Args:\n        direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n    \"\"\"\n    if not isinstance(direction, str):\n        raise ValueError(\"Direction must be a string\")\n\n    if direction not in ['xfwd','xrev','yfwd','yrev']:\n        raise ValueError(\"Direction must be 'xfwd', 'xrev', 'yfwd', 'yrev'\")\n\n\n    while True:\n        if direction == 'xfwd':\n            self._coor_x_mm += self._jog_step_mm * self._invertx\n        elif direction == 'xrev':\n            self._coor_x_mm -= self._jog_step_mm * self._invertx\n        elif direction == 'yfwd':\n            self._coor_y_mm += self._jog_step_mm * self._inverty\n        elif direction == 'yrev':\n            self._coor_y_mm -= self._jog_step_mm * self._inverty\n\n        time.sleep(self._step_wait_time_sec/(self._vel/100))\n\n        break\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): Legacy parameter. Is ignored.\n        acc_rel (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n        raise ValueError(\"Distance must be a float\")\n\n    if dist_mm*1e3 &lt; self._jog_step_min_um:\n        raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min_um))\n\n    # Set the jog step size\n    self._jog_step_mm = float(dist_mm)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100):\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): Legacy parameter. Is ignored.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if vel_move &lt;= 0:\n        raise ValueError(\"Velocity and acceleration parameters must be larger than 0%\")\n    if vel_move &gt; 100:\n        raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n    self._vel = vel_move\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops the continuous movement of the motors</p> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def stop_move(self):\n    \"\"\"\n    Stops the continuous movement of the motors\n    \"\"\"\n    if isinstance(self._thread_movecontinuous, threading.Thread):\n        if self._thread_movecontinuous.is_alive():\n            self._flg_movecontinuous.clear()\n            self._thread_movecontinuous.join(timeout=1)\n            self._thread_movecontinuous = None\n            print(\"&gt;&gt;&gt;&gt;&gt; Continuous movement stopped &lt;&lt;&lt;&lt;&lt;\")\n        else:\n            self._thread_movecontinuous = None\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.XYController_Dummy.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the operation and closes the connection to the device</p> Source code in <code>iris/controllers/xy_stage_controller_dummy.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminates the operation and closes the connection to the device\n    \"\"\"\n    print(\"\\n&gt;&gt;&gt;&gt;&gt; DUMMY XY controller terminated &lt;&lt;&lt;&lt;&lt;\")\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_dummy/#iris.controllers.xy_stage_controller_dummy.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/","title":"xy_stage_controller_m30xy","text":"<p>A class that allows the control of the M30XY/M Thorlabs stage. This implementation is based on the .NET Kinesis Libraries to connect to and control the stage.</p>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM","title":"<code>XYController_M30XYM</code>","text":"<p>               Bases: <code>Class_XYController</code></p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>class XYController_M30XYM(Class_XYController):\n    def __init__(self,sim=False) -&gt; None:\n        self.serial_no = ControllerSpecificConfigEnum.M30XYM_SERIAL.value\n\n        self._dev = None             # Stores the device object\n        self._dev_info = None        # Stores the device information\n        self._dev_sett = None        # Stores the device settings\n\n        # Remapping of the controls\n        self.dict_ctrl_remap = {\n            'xfwd':ControllerDirectionEnum.XFWD.value,\n            'xrev':ControllerDirectionEnum.XREV.value,\n            'yfwd':ControllerDirectionEnum.YFWD.value,\n            'yrev':ControllerDirectionEnum.YREV.value,\n        }   # Dictionary to remap the controls (only for the continuous and jog movements)\n\n        self._flipxy = ControllerConfigEnum.STAGE_FLIPXY.value      # Flag to indicate if the x and y axes are flipped in referece to the image capture\n        self._invertx = ControllerConfigEnum.STAGE_INVERTX.value    # Flag to indicate if the x and y axes are flipped in referece to the image capture\n        self._inverty = ControllerConfigEnum.STAGE_INVERTY.value    # Flag to indicate if the y axis is flipped in referece to the image capture\n\n        # Motor parameters\n        self._motorx = None          # Stores the x-axis motor object\n        self._motory = None          # Stores the y-axis motor object\n        self._isrunning_motorx = 0       # Running state of the x-motor. 1: forward, -1: backward, 0: not moving\n        self._isrunning_motory = 0       # Running state of the y-motor. 1: forward, -1: backward, 0: not moving\n        self._motorx_config = None   # Stores the motor config\n        self._motory_config = None   # same but for y\n        self._motorx_homing = None   # Motor-x homing parameters object for coordinate calibration\n        self._motory_homing = None   # same but for y\n        self._motorx_mvmt = None     # Motor-x movement parameters object\n        self._motory_mvmt = None     # Motor-y movement parameter object\n\n        self.unit_converter_x = None    # Unit converter for x-motor\n        self.unit_converter_y = None    # Unit converter for y-motor\n        self.convert_type_length = None # Type of conversion for length\n\n        self._jog_step = None       # Stores the jog step size in [mm]\n        self._jog_vel = None        # Stores the jog velocity in [mm/s]\n        self._jog_acc = None        # Stores the jog acceleration in [mm/s^2]\n        self._jog_step_min = 0.0025 # Minimum jog step size in [mm]\n\n        self._vel_max = float(2.4)      # Maximum velocity of the device [mm/s]\n        self._vel_min = float(0.1)      # Minimum velocity of the device [mm/s]\n        self._acc_max = float(5.0)      # Maximum acceleration of the device [mm/s^2]\n        self._acc_min = float(0.1)      # Minimum acceleration of the device [mm/s^2]\n\n        self._vel_homing = float(2.4)   # Homing velocity\n        self._vel_move = float(2.4)     # Other movement velocity (everything else other than homing operation)\n        self._acc_move = float(5.0)     # Other movement acceleration (^^^^^ as above ^^^^^)\n        self._timeout_move_fast = 10000  # Waiting time for movements to finish (in milisecond, integer)\n        self._timeout_move_slow = 10000 # Waiting time for longer movements to finish (in milisecond, integer)\n        self._stoptime = 0.85           # Waiting time to stop the motor [sec] &gt; 0.75 otherwise error\n\n        self.issimulation = sim     # True: To use when interacting with 'Kinesis Simulator'\n        self.running = False        # Indicate the start and finish of the program.\n                                    # True for start (initialization) and False for finish (termination)\n\n        self._max_vel_mmS = self._vel_max   # Maximum velocity of the motor in mm/s\n        self._min_vel_mmS = self._vel_min   # Minimum velocity of the motor in mm/s\n\n        self._lock = mp.Lock()      # Lock to prevent simultaneous access to the motors\n\n        # Start by initializing the connection, device, motors, and their parameters\n        try:\n            self.initialisation()\n        except Exception as e:\n            print('Run ABORTED due to error in intialization:')\n            print(e)\n            self.terminate(error_flag=True)\n\n        # Continue by setting up the motors and initializing (calibrating) the coordinate system of the motors\n        try:\n            self._set_vel_acc()\n            # if not self.issimulation or (self._motorx.NeedsHoming or self._motory.NeedsHoming):\n            #     self.homing_n_coor_calibration()\n        except Exception as e:\n            print('Coordinate calibration has failed:')\n            print(e)\n            self.terminate(error_flag=True)\n\n    def reinitialise_connection(self) -&gt; None:\n        \"\"\"\n        Reinitialise the connection to the device\n        \"\"\"\n        try:\n            self.terminate()\n        except Exception as e:\n            print('XYController_M30XYM reinitialise_connection error:\\n{}'.format(e))\n\n        try:\n            self.initialisation()\n        except Exception as e:\n            print('XYController_M30XYM reinitialise_connection error:\\n{}'.format(e))\n\n    def _remap_coordinates_flip(self,coor:tuple[float,float],get:bool) -&gt; tuple[float,float]:\n        \"\"\"\n        Remaps the coordinates based on the flip flags\n\n        Args:\n            coor (tuple[float,float]): The coordinate to be remapped\n            get (bool): True: get (bool): True if the coordinate is to be retrieved, False if the coordinate is to be set\n                this is to ensure that the flip is done before/after the inversion of the axes depending on the get flag\n\n        Returns:\n            tuple[float,float]: the remapped coordinate\n        \"\"\"\n        x,y = coor\n        if self._flipxy and get:\n            x,y = y,x\n        if self._invertx:\n            x = -1*x\n        if self._inverty:\n            y = -1*y\n        if self._flipxy and not get:\n            x,y = y,x\n        # Note:\n        # The flip is done before/after the inversion of the axes depending on the get flag because\n        # a matrix multiplication is not commutative. i.e., A*B != B*A\n        return (x,y)\n\n    def get_identifier(self) -&gt; str:\n        return f\"M30XY/M Stage, {self._dev_info}\"\n\n    def reset_state(self):\n        self._isrunning_motorx = 0       # Running state of the x-motor. 1: forward, -1: backward, 0: not moving\n        self._isrunning_motory = 0       # Running state of the y-motor. 1: forward, -1: backward, 0: not moving\n\n    def initialisation(self):\n        \"\"\"\n        Initialises the device, setup the connection, channels, motors and their parameters, etc.\n        \"\"\"\n        if self.issimulation:\n            print(\"&gt;&gt;&gt;&gt;&gt; INITIALISING SIMULATION &lt;&lt;&lt;&lt;&lt;\")\n            SimulationManager.Instance.InitializeSimulations()\n            print(\"&lt;&lt;&lt;&lt;&lt; Simulation Initialised &gt;&gt;&gt;&gt;&gt;\")\n        else:\n            print(\"&lt;&lt;&lt;&lt;&lt; NOT A SIMULATION &gt;&gt;&gt;&gt;&gt;\")\n\n        DeviceManagerCLI.BuildDeviceList()\n\n        # Creates the device object, based on the serial number we have\n        self._dev = BenchtopDCServo.CreateBenchtopDCServo(self.serial_no)\n\n        # Connect, begin polling, and enable\n        self._dev.Connect(self.serial_no)\n        time.sleep(0.25)  # wait statements are important to allow settings to be sent to the device\n\n        # Get Device Information and display description\n        self._dev_info = self._dev.GetDeviceInfo()\n        print('Connected to: ' + self._dev_info.Description)\n\n        # Get the channel for the device\n        self._motorx = self._dev.GetChannel(1)  # Returns a benchtop channel object, i.e., the motors\n        self._motory = self._dev.GetChannel(2)  # index: 1,2 for channel 1 and 2 respectively\n\n        # Start Polling and enable channel\n        self._motorx.StartPolling(ControllerSpecificConfigEnum.M30XYM_POLLING_INTERVAL.value)\n        self._motory.StartPolling(ControllerSpecificConfigEnum.M30XYM_POLLING_INTERVAL.value)\n        time.sleep(0.5)\n        self._motorx.EnableDevice()\n        self._motory.EnableDevice()\n        time.sleep(0.5)\n\n        # Check that the settings are initialised, else error.\n        if not self._motorx.IsSettingsInitialized() or not self._motory.IsSettingsInitialized():\n        # if not x_channel.IsSettingsInitialized():\n            self._motorx.WaitForSettingsInitialized(10000)  # 10 second timeout\n            self._motory.WaitForSettingsInitialized(10000)\n            assert self._dev.IsSettingsInitialized() is True\n\n        # Load the motor configuration on the channel\n        self._motorx_config = self._motorx.LoadMotorConfiguration(self._motorx.DeviceID)\n        self._motory_config = self._motory.LoadMotorConfiguration(self._motory.DeviceID)\n\n        # Read in the device settings\n        self._dev_sett = self._motorx.MotorDeviceSettings\n\n        # Get the Homing Params for coordinate calibration(ccal)\n        self._motorx_homing = self._motorx.GetHomingParams()\n        self._motory_homing = self._motory.GetHomingParams()\n\n        # Set the movement velocity and acceleration parameters\n        self._motorx_mvmt = self._motorx.GetVelocityParams()\n        self._motory_mvmt = self._motory.GetVelocityParams()\n\n        # Set the unit converters\n        self.unit_converter_x = self._motorx.UnitConverter\n        self.unit_converter_y = self._motory.UnitConverter\n\n        self.convert_type_length = self.unit_converter_x.UnitType(0)\n\n        print('\\n&gt;&gt;&gt;&gt;&gt; Device and motor initialisation complete &lt;&lt;&lt;&lt;&lt;')\n\n    def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n        \"\"\"\n        Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n        Args:\n            speed_mm_s (float): The speed to be converted in mm/s\n\n        Returns:\n            float: The relative velocity parameter in percentage\n        \"\"\"\n        # Adjust the speed to the limits if it is out of bounds\n        if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n            speed_mm_s = self._min_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n        if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n            speed_mm_s = self._max_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n        # Calculate the relative speed\n        speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n        return speed_rel\n\n    def get_vel_acc_relative(self):\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        with self._lock:\n            # Get the Homing Params for coordinate calibration(ccal)\n            self._motorx_homing = self._motorx.GetHomingParams()\n            self._motory_homing = self._motory.GetHomingParams()\n\n            # Set the movement velocity and acceleration parameters\n            self._motorx_mvmt = self._motorx.GetVelocityParams()\n            self._motory_mvmt = self._motory.GetVelocityParams()\n\n            # Get the maximum velocity and acceleration of the device\n            self._vel_homing = float(str(self._motorx_homing.Velocity))\n            self._vel_move = float(str(self._motorx_mvmt.MaxVelocity))\n            self._acc_move = float(str(self._motorx_mvmt.Acceleration))\n\n        # Convert the actual value to percentage\n        vel_homing = self._vel_homing * 100 / self._vel_max\n        vel_move = self._vel_move * 100 / self._vel_max\n        acc_move = self._acc_move * 100 / self._acc_max\n\n        return (vel_homing, vel_move, acc_move)\n\n    def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100):\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): New motor homing velocity in percentage of max velocity. Defaults to 100.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): New motor movement acceleration in percentage of max acceleration. Defaults to 100.\n        \"\"\"\n        if vel_homing &lt;=0 or vel_move &lt;=0 or acc_move &lt;=0:\n            raise ValueError(\"Velocity and acceleration parameters must be larger than 1%\")\n        if vel_homing &gt; 100 or vel_move &gt; 100 or acc_move &gt; 100:\n            raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n        # Convert the percentage to the actual value\n        vel_homing = self._vel_max * vel_homing / 100\n        vel_move = self._vel_max * vel_move / 100\n        acc_move = self._acc_max * acc_move / 100\n\n        self._set_vel_acc(vel_homing, vel_move, acc_move)\n\n    def _set_vel_acc(self,vel_homing:float=None, vel_move:float=None, acc_move:float=None):\n        \"\"\"\n        Function to setup the velocity and acceleration parameters of the motors\n        for both homing and typical movements. Will be applied equally to both x and y motors\n\n        Args:\n            vel_homing (Decimal, optional): New motor homing velocity. Defaults to None.\n            vel_move (Decimal, optional): New motor movement velocity. Defaults to None.\n            acc_move (Decimal, optional): New motor movement acceleration. Defaults to None.\n        \"\"\"\n        if vel_homing == None and vel_move == None and acc_move == None:\n            vel_homing = self._vel_homing\n            vel_move = self._vel_move\n            acc_move = self._acc_move\n\n        # Modify the homing velocity if requested\n        if vel_homing is not None:\n            if not isinstance(vel_homing, float):\n                raise ValueError(\"Velocity must be a float\")\n\n            # Set a hard limit to protect the motor\n            if vel_homing &gt; self._vel_max:\n                print(\"Maximum device velocity is {}\".format(self._vel_max))\n                vel_homing = self._vel_max\n\n            with self._lock:\n                # Updates the stored value\n                self._vel_homing = float(vel_homing)\n                vel_homing = Decimal(vel_homing)\n\n                # Modify the value in the motors\n                self._motorx_homing.Velocity = vel_homing\n                self._motory_homing.Velocity = vel_homing\n\n        # Modify the movement velocity and acceleration parameters if requested\n        if vel_move is not None:\n            if not isinstance(vel_move, float) or isinstance(vel_move, int):\n                raise ValueError(\"Velocity must be a float\")\n\n            if vel_move &gt; self._vel_max:\n                print(\"Maximum device velocity is {}\".format(self._vel_max))\n                vel_move = self._vel_max\n\n            with self._lock:\n                # Updates the stored value\n                self._vel_move = float(vel_move)\n                vel_move = Decimal(vel_move)\n\n                # Modify the value in the motors\n                self._motorx_mvmt.MaxVelocity = vel_move\n                self._motory_mvmt.MaxVelocity = vel_move\n\n        if acc_move is not None:\n            if not isinstance(acc_move, float):\n                raise ValueError(\"Velocity must be a float\")\n\n            if acc_move &gt; self._acc_max:\n                print(\"Maximum device velocity is {}\".format(self._acc_max))\n                acc_move = self._acc_max\n\n            with self._lock:\n                # Updates the stored value\n                self._acc_move = float(acc_move)\n                acc_move = Decimal(acc_move)\n\n                # Modify the value in the motors\n                self._motorx_mvmt.Acceleration = acc_move\n                self._motory_mvmt.Acceleration = acc_move\n\n        with self._lock:\n            # Assign the set parameters to the motors\n            self._motorx.SetHomingParams(self._motorx_homing)\n            self._motory.SetHomingParams(self._motory_homing)\n\n            # Assign the velocity and acceleration parameters to the motors\n            self._motorx.SetVelocityParams(self._motorx_mvmt)\n            self._motory.SetVelocityParams(self._motory_mvmt)\n\n            self._motorx.WaitForSettingsInitialized(self._timeout_move_fast)\n            self._motory.WaitForSettingsInitialized(self._timeout_move_fast)\n\n    def get_coordinates_old(self):\n        \"\"\"\n        Returns the current motor coordinates. Does NOT work properly\n        ~1 sec after the motor has just started moving.\n        DO NOT USE. Kept for reference only.\n\n        Returns:\n            tuple of floats: 2 elements: (coor_x, coor_y)\n        \"\"\"\n        self._lock.acquire()\n        coor_x = float(str(self._motorx.Position))\n        coor_y = float(str(self._motory.Position))\n        self._lock.release()\n        return coor_x,coor_y\n\n    def homing_n_coor_calibration(self):\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        - Also called as 'homing'\n        \"\"\"\n        if self._isrunning_motorx != 0 or self._isrunning_motory != 0:\n            print(\"!!!!! Motor is running, homing request BLOCKED !!!!!\")\n            return\n\n        print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n        with self._lock:\n            # Home the device, use multithreading to operate both motors at once\n            workx = self._motorx.InitializeWaitHandler()\n            worky = self._motory.InitializeWaitHandler()\n            self._motorx.Home(workx)\n            self._motory.Home(worky)\n\n            # Starts the movement\n            self._isrunning_motorx = 1\n            self._isrunning_motory = 1\n\n        self._motorx.Wait(120000)\n        self._motory.Wait(120000)\n\n        # Ends the multithreading\n        self._isrunning_motorx = 0\n        self._isrunning_motory = 0\n        print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n\n    def terminate(self,error_flag=False):\n        \"\"\"\n        Terminate the operation. Returns the stage to home and disconnects the device.\n\n        Args:\n            error_flag (bool, optional): If termination is caused by an error, skip homing. True: there is an error, False: there is none. Defaults to False.\n        \"\"\"\n\n        # Return the stage to Home\n        # if not error_flag:\n        #     self.homing_n_coor_calibration()\n\n        # Stop polling and disconnects the device\n        with self._lock:\n            self._motorx.StopPolling()\n            self._motory.StopPolling()\n            self._dev.Disconnect()\n\n            if self.issimulation:\n                print(\"&gt;&gt;&gt;&gt;&gt; TERMINATING SIMULATION STOPPED &lt;&lt;&lt;&lt;&lt;\")\n                SimulationManager.Instance.UninitializeSimulations()\n            self.running = False\n\n    def check_device_availability(self):\n        check_motorx= self._motorx.IsDeviceAvailable()\n        check_motory= self._motory.IsDeviceAvailable()\n        if not check_motorx or not check_motory:\n            print(\"Device not available: reinitialising...\")\n            try:\n                self.initialisation()\n            except:\n                print(\"Device reinitialisation failed\")\n                raise Exception(\"Device reinitialisation failed\")\n\n    def move_direct(self,coor_abs):\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (list of Decimal): coordinate of the destination [x,y]\n        \"\"\"\n        # Correct the coordinates if the axes are flipped\n        coor_x,coor_y = self._remap_coordinates_flip(coor_abs,get=False)\n\n        # Reassign it to a list in case a tuple is received\n        coor_abs = [Decimal(coor_x),Decimal(coor_y)]\n\n        with self._lock:\n            # Convert the coordinates to decimals if floats are received\n            if type(coor_abs[0]) is float:\n                coor_abs[0] = Decimal(coor_x)\n\n            if type(coor_abs[1]) is float:\n                coor_abs[1] = Decimal(coor_y)\n\n            if self._isrunning_motorx != 0:\n                print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n                return\n\n            # Check device availability\n            self.check_device_availability()\n\n            # Use multithreading to operate both motors at once\n            # timeout_rel = int(self._timeout_move_slow * self._vel_max/self._vel_move)\n            workx = self._motorx.InitializeWaitHandler()\n            worky = self._motory.InitializeWaitHandler()\n\n            self._motorx.MoveTo(coor_abs[0], workx)\n            self._motory.MoveTo(coor_abs[1], worky)\n\n            # Starts the movement\n            self._isrunning_motorx = 1\n            self._isrunning_motory = 1\n\n            self._motorx.WaitForSettingsInitialized(self._timeout_move_fast)\n            self._motory.WaitForSettingsInitialized(self._timeout_move_fast)\n\n        self._motorx.Wait(self._timeout_move_fast)\n        self._motory.Wait(self._timeout_move_fast)\n\n        # Waits for both threads to end\n        self._isrunning_motorx = 0\n        self._isrunning_motory = 0\n\n    def move_continuous(self,dir:str):\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movements\n        \"\"\"\n        # Check if the motor is running, prevents command overlap\n        if self._isrunning_motorx != 0:\n            print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n            return\n\n        # Update the motor test\n        self._isrunning_motorx = 1\n        self._isrunning_motory = 1\n\n        dir = self.dict_ctrl_remap[dir] # Remap the controls\n\n        with self._lock:\n            self.check_device_availability()\n            if dir == 'xfwd':\n                self._motorx.MoveContinuous(MotorDirection.Forward)\n            elif dir == 'xrev':\n                self._motorx.MoveContinuous(MotorDirection.Backward)\n\n            if dir == 'yfwd':\n                self._motory.MoveContinuous(MotorDirection.Forward)\n            elif dir == 'yrev':\n                self._motory.MoveContinuous(MotorDirection.Backward)\n\n    def move_continuous_old(self,xdir=None,ydir=None):\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            xdir (str): 'fwd' forward and 'rev' for reverse/backward for the xmotor or None for no movement\n            ydir (str): 'fwd' forward and 'rev' for reverse/backward for the ymotor or None for no movement\n        \"\"\"\n        # Check if the motor is running, prevents command overlap\n        if self._isrunning_motorx != 0:\n            print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n            return\n\n        # Update the motor test\n        self._isrunning_motorx = 1\n        self._isrunning_motory = 1\n\n        with self._lock:\n            self.check_device_availability()\n            if xdir == 'fwd':\n                self._motorx.MoveContinuous(MotorDirection.Forward)\n            elif xdir == 'rev':\n                self._motorx.MoveContinuous(MotorDirection.Backward)\n\n            if ydir == 'fwd':\n                self._motory.MoveContinuous(MotorDirection.Forward)\n            elif ydir == 'rev':\n                self._motory.MoveContinuous(MotorDirection.Backward)\n\n    def get_jog(self):\n        \"\"\"\n        Get the jog parameters for the motor\n\n        Returns:\n            tuple of floats: 6 elements:\n            (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n        \"\"\"\n        with self._lock:\n            JogParams_x = self._motorx.GetJogParams()\n            JogParams_y = self._motory.GetJogParams()\n\n            self._jog_step_x = float(str(JogParams_x.StepSize))\n            self._jog_step_y = float(str(JogParams_y.StepSize))\n\n            VelocityParams_x = JogParams_x.VelocityParams\n            VelocityParams_y = JogParams_y.VelocityParams\n\n            self._jog_vel_x = float(str(VelocityParams_x.MaxVelocity))\n            self._jog_vel_y = float(str(VelocityParams_x.MaxVelocity))\n\n            self._jog_acc_x = float(str(VelocityParams_y.Acceleration))\n            self._jog_acc_y = float(str(VelocityParams_y.Acceleration))\n\n        return (self._jog_step_x,self._jog_step_y,self._jog_vel_x,self._jog_vel_y,\n                self._jog_acc_x,self._jog_acc_y)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): velocity in percentage of max velocity. Defaults to 100.\n            acc_rel (int, optional): acceleration in percentage of max acceleration. Defaults to 100.\n        \"\"\"\n        if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n            raise ValueError(\"Distance must be a float\")\n\n        if dist_mm &lt; self._jog_step_min:\n            raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n        dist_mm = float(dist_mm)\n\n        with self._lock:\n            JogParams_x = self._motorx.GetJogParams()\n            JogParams_y = self._motory.GetJogParams()\n\n            VelocityParams_x = JogParams_x.VelocityParams\n            VelocityParams_y = JogParams_y.VelocityParams\n\n            if not isinstance(vel_rel, int) or isinstance(vel_rel, float):\n                raise ValueError(\"Velocity must be an integer\")\n            if not isinstance(acc_rel, int) or isinstance(acc_rel, float):\n                raise ValueError(\"Acceleration must be an integer\")\n\n            VelocityParams_x.MaxVelocity = Decimal(self._vel_max * vel_rel / 100)\n            VelocityParams_x.Acceleration = Decimal(self._acc_max * acc_rel / 100)\n            VelocityParams_y.MaxVelocity = Decimal(self._vel_max * vel_rel / 100)\n            VelocityParams_y.Acceleration = Decimal(self._acc_max * acc_rel / 100)\n\n            JogParams_x.StepSize = Decimal(dist_mm)\n            JogParams_y.StepSize = Decimal(dist_mm)\n\n            self._motorx.SetJogParams(JogParams_x)\n            self._motory.SetJogParams(JogParams_y)\n\n            self._motorx.WaitForSettingsInitialized(self._timeout_move_fast)\n            self._motory.WaitForSettingsInitialized(self._timeout_move_fast)\n\n    def move_jog(self,direction:str):\n        \"\"\"\n        Moves the motor with a single jogging motion.\n\n        Args:\n            direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n        \"\"\"\n        # timeout_rel = int(self._timeout_move_slow * self._vel_max/self._vel_move)\n\n        if not isinstance(direction, str):\n            raise ValueError(\"Direction must be a string\")\n\n        if direction not in ['xfwd','xrev','yfwd','yrev']:\n            raise ValueError(\"Direction must be 'xfwd', 'xrev', 'yfwd', or 'yrev'\")\n\n        if self._isrunning_motorx == True or self._isrunning_motory == True:\n            print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n            return\n\n        self._isrunning_motorx = True\n        self._isrunning_motory = True\n\n        direction = self.dict_ctrl_remap[direction] # Remap the controls\n\n        with self._lock:\n            self.check_device_availability()\n            if direction in ['xfwd','xrev']:\n                workx = self._motorx.InitializeWaitHandler()\n            elif direction in ['yfwd','yrev']:\n                worky = self._motory.InitializeWaitHandler()\n\n            if direction == 'xfwd':\n                self._motorx.MoveJog(MotorDirection.Forward,workx)\n            elif direction == 'xrev':\n                self._motorx.MoveJog(MotorDirection.Backward,workx)\n            elif direction == 'yfwd':\n                self._motory.MoveJog(MotorDirection.Forward,worky)\n            elif direction == 'yrev':\n                self._motory.MoveJog(MotorDirection.Backward,worky)\n\n            if direction in ['xfwd','xrev']:\n                self._motorx.WaitForSettingsInitialized(self._timeout_move_fast)\n            elif direction in ['yfwd','yrev']:\n                self._motory.WaitForSettingsInitialized(self._timeout_move_fast)\n\n        if direction in ['xfwd','xrev']:\n            self._motorx.Wait(self._timeout_move_slow)\n        elif direction in ['yfwd','yrev']:\n            self._motory.Wait(self._timeout_move_slow)\n\n        self._isrunning_motorx = False\n        self._isrunning_motory = False\n\n    def stop_move(self):\n        \"\"\"\n        Stops the continuous movement of the motors\n        \"\"\"\n        with self._lock:\n            self._motorx.Stop(0)\n            self._motory.Stop(0)\n        time.sleep(self._stoptime)\n\n        # Update the motor test\n        self._isrunning_motorx = 0\n        self._isrunning_motory = 0\n\n    def movementtest(self):\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; MOTOR TEST: CIRCULAR MOTION &lt;&lt;&lt;&lt;&lt;\")\n        # Create circle coordinates\n        angles = np.arange(0, 2 * np.pi, 0.25)\n        radius = 5.0  # mm\n\n        offset = 5.0 # mm\n\n        xs = radius * np.cos(angles) + offset\n        ys = radius * np.sin(angles) + offset\n\n        for i in range(len(angles)):\n            print(i, float(xs[i]))\n            coor = [float(xs[i]), float(ys[i])]\n            self.move_direct(coor)\n\n    def get_coordinates(self):\n        \"\"\"\n        Returns the current motor coordinates\n\n        Returns:\n            tuple of floats: 2 elements: (coor_x, coor_y)\n        \"\"\"\n        with self._lock:\n            posx = Decimal(self._motorx.GetPositionCounter())\n            posy = Decimal(self._motory.GetPositionCounter())\n\n            coorx = float(str(self.unit_converter_x.DeviceUnitToReal(posx,self.convert_type_length)))\n            coory = float(str(self.unit_converter_y.DeviceUnitToReal(posy,self.convert_type_length)))\n\n        coorx,coory = self._remap_coordinates_flip((coorx,coory),get=True)\n        return coorx,coory\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.calculate_vel_relative","title":"<code>calculate_vel_relative(speed_mm_s)</code>","text":"<p>Calculates the relative velocity parameter for the motor given the speed in mm/s</p> <p>Parameters:</p> Name Type Description Default <code>speed_mm_s</code> <code>float</code> <p>The speed to be converted in mm/s</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The relative velocity parameter in percentage</p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n    \"\"\"\n    Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n    Args:\n        speed_mm_s (float): The speed to be converted in mm/s\n\n    Returns:\n        float: The relative velocity parameter in percentage\n    \"\"\"\n    # Adjust the speed to the limits if it is out of bounds\n    if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n        speed_mm_s = self._min_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n    if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n        speed_mm_s = self._max_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n    # Calculate the relative speed\n    speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n    return speed_rel\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Returns the current motor coordinates</p> <p>Returns:</p> Type Description <p>tuple of floats: 2 elements: (coor_x, coor_y)</p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"\n    Returns the current motor coordinates\n\n    Returns:\n        tuple of floats: 2 elements: (coor_x, coor_y)\n    \"\"\"\n    with self._lock:\n        posx = Decimal(self._motorx.GetPositionCounter())\n        posy = Decimal(self._motory.GetPositionCounter())\n\n        coorx = float(str(self.unit_converter_x.DeviceUnitToReal(posx,self.convert_type_length)))\n        coory = float(str(self.unit_converter_y.DeviceUnitToReal(posy,self.convert_type_length)))\n\n    coorx,coory = self._remap_coordinates_flip((coorx,coory),get=True)\n    return coorx,coory\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.get_coordinates_old","title":"<code>get_coordinates_old()</code>","text":"<p>Returns the current motor coordinates. Does NOT work properly ~1 sec after the motor has just started moving. DO NOT USE. Kept for reference only.</p> <p>Returns:</p> Type Description <p>tuple of floats: 2 elements: (coor_x, coor_y)</p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def get_coordinates_old(self):\n    \"\"\"\n    Returns the current motor coordinates. Does NOT work properly\n    ~1 sec after the motor has just started moving.\n    DO NOT USE. Kept for reference only.\n\n    Returns:\n        tuple of floats: 2 elements: (coor_x, coor_y)\n    \"\"\"\n    self._lock.acquire()\n    coor_x = float(str(self._motorx.Position))\n    coor_y = float(str(self._motory.Position))\n    self._lock.release()\n    return coor_x,coor_y\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.get_jog","title":"<code>get_jog()</code>","text":"<p>Get the jog parameters for the motor</p> <p>Returns:</p> Type Description <p>tuple of floats: 6 elements:</p> <p>(jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)</p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def get_jog(self):\n    \"\"\"\n    Get the jog parameters for the motor\n\n    Returns:\n        tuple of floats: 6 elements:\n        (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n    \"\"\"\n    with self._lock:\n        JogParams_x = self._motorx.GetJogParams()\n        JogParams_y = self._motory.GetJogParams()\n\n        self._jog_step_x = float(str(JogParams_x.StepSize))\n        self._jog_step_y = float(str(JogParams_y.StepSize))\n\n        VelocityParams_x = JogParams_x.VelocityParams\n        VelocityParams_y = JogParams_y.VelocityParams\n\n        self._jog_vel_x = float(str(VelocityParams_x.MaxVelocity))\n        self._jog_vel_y = float(str(VelocityParams_x.MaxVelocity))\n\n        self._jog_acc_x = float(str(VelocityParams_y.Acceleration))\n        self._jog_acc_y = float(str(VelocityParams_y.Acceleration))\n\n    return (self._jog_step_x,self._jog_step_y,self._jog_vel_x,self._jog_vel_y,\n            self._jog_acc_x,self._jog_acc_y)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def get_vel_acc_relative(self):\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    with self._lock:\n        # Get the Homing Params for coordinate calibration(ccal)\n        self._motorx_homing = self._motorx.GetHomingParams()\n        self._motory_homing = self._motory.GetHomingParams()\n\n        # Set the movement velocity and acceleration parameters\n        self._motorx_mvmt = self._motorx.GetVelocityParams()\n        self._motory_mvmt = self._motory.GetVelocityParams()\n\n        # Get the maximum velocity and acceleration of the device\n        self._vel_homing = float(str(self._motorx_homing.Velocity))\n        self._vel_move = float(str(self._motorx_mvmt.MaxVelocity))\n        self._acc_move = float(str(self._motorx_mvmt.Acceleration))\n\n    # Convert the actual value to percentage\n    vel_homing = self._vel_homing * 100 / self._vel_max\n    vel_move = self._vel_move * 100 / self._vel_max\n    acc_move = self._acc_move * 100 / self._acc_max\n\n    return (vel_homing, vel_move, acc_move)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. - Also called as 'homing'</p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def homing_n_coor_calibration(self):\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    - Also called as 'homing'\n    \"\"\"\n    if self._isrunning_motorx != 0 or self._isrunning_motory != 0:\n        print(\"!!!!! Motor is running, homing request BLOCKED !!!!!\")\n        return\n\n    print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n    with self._lock:\n        # Home the device, use multithreading to operate both motors at once\n        workx = self._motorx.InitializeWaitHandler()\n        worky = self._motory.InitializeWaitHandler()\n        self._motorx.Home(workx)\n        self._motory.Home(worky)\n\n        # Starts the movement\n        self._isrunning_motorx = 1\n        self._isrunning_motory = 1\n\n    self._motorx.Wait(120000)\n    self._motory.Wait(120000)\n\n    # Ends the multithreading\n    self._isrunning_motorx = 0\n    self._isrunning_motory = 0\n    print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.initialisation","title":"<code>initialisation()</code>","text":"<p>Initialises the device, setup the connection, channels, motors and their parameters, etc.</p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def initialisation(self):\n    \"\"\"\n    Initialises the device, setup the connection, channels, motors and their parameters, etc.\n    \"\"\"\n    if self.issimulation:\n        print(\"&gt;&gt;&gt;&gt;&gt; INITIALISING SIMULATION &lt;&lt;&lt;&lt;&lt;\")\n        SimulationManager.Instance.InitializeSimulations()\n        print(\"&lt;&lt;&lt;&lt;&lt; Simulation Initialised &gt;&gt;&gt;&gt;&gt;\")\n    else:\n        print(\"&lt;&lt;&lt;&lt;&lt; NOT A SIMULATION &gt;&gt;&gt;&gt;&gt;\")\n\n    DeviceManagerCLI.BuildDeviceList()\n\n    # Creates the device object, based on the serial number we have\n    self._dev = BenchtopDCServo.CreateBenchtopDCServo(self.serial_no)\n\n    # Connect, begin polling, and enable\n    self._dev.Connect(self.serial_no)\n    time.sleep(0.25)  # wait statements are important to allow settings to be sent to the device\n\n    # Get Device Information and display description\n    self._dev_info = self._dev.GetDeviceInfo()\n    print('Connected to: ' + self._dev_info.Description)\n\n    # Get the channel for the device\n    self._motorx = self._dev.GetChannel(1)  # Returns a benchtop channel object, i.e., the motors\n    self._motory = self._dev.GetChannel(2)  # index: 1,2 for channel 1 and 2 respectively\n\n    # Start Polling and enable channel\n    self._motorx.StartPolling(ControllerSpecificConfigEnum.M30XYM_POLLING_INTERVAL.value)\n    self._motory.StartPolling(ControllerSpecificConfigEnum.M30XYM_POLLING_INTERVAL.value)\n    time.sleep(0.5)\n    self._motorx.EnableDevice()\n    self._motory.EnableDevice()\n    time.sleep(0.5)\n\n    # Check that the settings are initialised, else error.\n    if not self._motorx.IsSettingsInitialized() or not self._motory.IsSettingsInitialized():\n    # if not x_channel.IsSettingsInitialized():\n        self._motorx.WaitForSettingsInitialized(10000)  # 10 second timeout\n        self._motory.WaitForSettingsInitialized(10000)\n        assert self._dev.IsSettingsInitialized() is True\n\n    # Load the motor configuration on the channel\n    self._motorx_config = self._motorx.LoadMotorConfiguration(self._motorx.DeviceID)\n    self._motory_config = self._motory.LoadMotorConfiguration(self._motory.DeviceID)\n\n    # Read in the device settings\n    self._dev_sett = self._motorx.MotorDeviceSettings\n\n    # Get the Homing Params for coordinate calibration(ccal)\n    self._motorx_homing = self._motorx.GetHomingParams()\n    self._motory_homing = self._motory.GetHomingParams()\n\n    # Set the movement velocity and acceleration parameters\n    self._motorx_mvmt = self._motorx.GetVelocityParams()\n    self._motory_mvmt = self._motory.GetVelocityParams()\n\n    # Set the unit converters\n    self.unit_converter_x = self._motorx.UnitConverter\n    self.unit_converter_y = self._motory.UnitConverter\n\n    self.convert_type_length = self.unit_converter_x.UnitType(0)\n\n    print('\\n&gt;&gt;&gt;&gt;&gt; Device and motor initialisation complete &lt;&lt;&lt;&lt;&lt;')\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movements</p> required Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def move_continuous(self,dir:str):\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movements\n    \"\"\"\n    # Check if the motor is running, prevents command overlap\n    if self._isrunning_motorx != 0:\n        print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n        return\n\n    # Update the motor test\n    self._isrunning_motorx = 1\n    self._isrunning_motory = 1\n\n    dir = self.dict_ctrl_remap[dir] # Remap the controls\n\n    with self._lock:\n        self.check_device_availability()\n        if dir == 'xfwd':\n            self._motorx.MoveContinuous(MotorDirection.Forward)\n        elif dir == 'xrev':\n            self._motorx.MoveContinuous(MotorDirection.Backward)\n\n        if dir == 'yfwd':\n            self._motory.MoveContinuous(MotorDirection.Forward)\n        elif dir == 'yrev':\n            self._motory.MoveContinuous(MotorDirection.Backward)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.move_continuous_old","title":"<code>move_continuous_old(xdir=None, ydir=None)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>xdir</code> <code>str</code> <p>'fwd' forward and 'rev' for reverse/backward for the xmotor or None for no movement</p> <code>None</code> <code>ydir</code> <code>str</code> <p>'fwd' forward and 'rev' for reverse/backward for the ymotor or None for no movement</p> <code>None</code> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def move_continuous_old(self,xdir=None,ydir=None):\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        xdir (str): 'fwd' forward and 'rev' for reverse/backward for the xmotor or None for no movement\n        ydir (str): 'fwd' forward and 'rev' for reverse/backward for the ymotor or None for no movement\n    \"\"\"\n    # Check if the motor is running, prevents command overlap\n    if self._isrunning_motorx != 0:\n        print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n        return\n\n    # Update the motor test\n    self._isrunning_motorx = 1\n    self._isrunning_motory = 1\n\n    with self._lock:\n        self.check_device_availability()\n        if xdir == 'fwd':\n            self._motorx.MoveContinuous(MotorDirection.Forward)\n        elif xdir == 'rev':\n            self._motorx.MoveContinuous(MotorDirection.Backward)\n\n        if ydir == 'fwd':\n            self._motory.MoveContinuous(MotorDirection.Forward)\n        elif ydir == 'rev':\n            self._motory.MoveContinuous(MotorDirection.Backward)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.move_direct","title":"<code>move_direct(coor_abs)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>list of Decimal</code> <p>coordinate of the destination [x,y]</p> required Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def move_direct(self,coor_abs):\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (list of Decimal): coordinate of the destination [x,y]\n    \"\"\"\n    # Correct the coordinates if the axes are flipped\n    coor_x,coor_y = self._remap_coordinates_flip(coor_abs,get=False)\n\n    # Reassign it to a list in case a tuple is received\n    coor_abs = [Decimal(coor_x),Decimal(coor_y)]\n\n    with self._lock:\n        # Convert the coordinates to decimals if floats are received\n        if type(coor_abs[0]) is float:\n            coor_abs[0] = Decimal(coor_x)\n\n        if type(coor_abs[1]) is float:\n            coor_abs[1] = Decimal(coor_y)\n\n        if self._isrunning_motorx != 0:\n            print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n            return\n\n        # Check device availability\n        self.check_device_availability()\n\n        # Use multithreading to operate both motors at once\n        # timeout_rel = int(self._timeout_move_slow * self._vel_max/self._vel_move)\n        workx = self._motorx.InitializeWaitHandler()\n        worky = self._motory.InitializeWaitHandler()\n\n        self._motorx.MoveTo(coor_abs[0], workx)\n        self._motory.MoveTo(coor_abs[1], worky)\n\n        # Starts the movement\n        self._isrunning_motorx = 1\n        self._isrunning_motory = 1\n\n        self._motorx.WaitForSettingsInitialized(self._timeout_move_fast)\n        self._motory.WaitForSettingsInitialized(self._timeout_move_fast)\n\n    self._motorx.Wait(self._timeout_move_fast)\n    self._motory.Wait(self._timeout_move_fast)\n\n    # Waits for both threads to end\n    self._isrunning_motorx = 0\n    self._isrunning_motory = 0\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single jogging motion.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.</p> required Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def move_jog(self,direction:str):\n    \"\"\"\n    Moves the motor with a single jogging motion.\n\n    Args:\n        direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n    \"\"\"\n    # timeout_rel = int(self._timeout_move_slow * self._vel_max/self._vel_move)\n\n    if not isinstance(direction, str):\n        raise ValueError(\"Direction must be a string\")\n\n    if direction not in ['xfwd','xrev','yfwd','yrev']:\n        raise ValueError(\"Direction must be 'xfwd', 'xrev', 'yfwd', or 'yrev'\")\n\n    if self._isrunning_motorx == True or self._isrunning_motory == True:\n        print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n        return\n\n    self._isrunning_motorx = True\n    self._isrunning_motory = True\n\n    direction = self.dict_ctrl_remap[direction] # Remap the controls\n\n    with self._lock:\n        self.check_device_availability()\n        if direction in ['xfwd','xrev']:\n            workx = self._motorx.InitializeWaitHandler()\n        elif direction in ['yfwd','yrev']:\n            worky = self._motory.InitializeWaitHandler()\n\n        if direction == 'xfwd':\n            self._motorx.MoveJog(MotorDirection.Forward,workx)\n        elif direction == 'xrev':\n            self._motorx.MoveJog(MotorDirection.Backward,workx)\n        elif direction == 'yfwd':\n            self._motory.MoveJog(MotorDirection.Forward,worky)\n        elif direction == 'yrev':\n            self._motory.MoveJog(MotorDirection.Backward,worky)\n\n        if direction in ['xfwd','xrev']:\n            self._motorx.WaitForSettingsInitialized(self._timeout_move_fast)\n        elif direction in ['yfwd','yrev']:\n            self._motory.WaitForSettingsInitialized(self._timeout_move_fast)\n\n    if direction in ['xfwd','xrev']:\n        self._motorx.Wait(self._timeout_move_slow)\n    elif direction in ['yfwd','yrev']:\n        self._motory.Wait(self._timeout_move_slow)\n\n    self._isrunning_motorx = False\n    self._isrunning_motory = False\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.reinitialise_connection","title":"<code>reinitialise_connection()</code>","text":"<p>Reinitialise the connection to the device</p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def reinitialise_connection(self) -&gt; None:\n    \"\"\"\n    Reinitialise the connection to the device\n    \"\"\"\n    try:\n        self.terminate()\n    except Exception as e:\n        print('XYController_M30XYM reinitialise_connection error:\\n{}'.format(e))\n\n    try:\n        self.initialisation()\n    except Exception as e:\n        print('XYController_M30XYM reinitialise_connection error:\\n{}'.format(e))\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>acceleration in percentage of max acceleration. Defaults to 100.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): velocity in percentage of max velocity. Defaults to 100.\n        acc_rel (int, optional): acceleration in percentage of max acceleration. Defaults to 100.\n    \"\"\"\n    if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n        raise ValueError(\"Distance must be a float\")\n\n    if dist_mm &lt; self._jog_step_min:\n        raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n    dist_mm = float(dist_mm)\n\n    with self._lock:\n        JogParams_x = self._motorx.GetJogParams()\n        JogParams_y = self._motory.GetJogParams()\n\n        VelocityParams_x = JogParams_x.VelocityParams\n        VelocityParams_y = JogParams_y.VelocityParams\n\n        if not isinstance(vel_rel, int) or isinstance(vel_rel, float):\n            raise ValueError(\"Velocity must be an integer\")\n        if not isinstance(acc_rel, int) or isinstance(acc_rel, float):\n            raise ValueError(\"Acceleration must be an integer\")\n\n        VelocityParams_x.MaxVelocity = Decimal(self._vel_max * vel_rel / 100)\n        VelocityParams_x.Acceleration = Decimal(self._acc_max * acc_rel / 100)\n        VelocityParams_y.MaxVelocity = Decimal(self._vel_max * vel_rel / 100)\n        VelocityParams_y.Acceleration = Decimal(self._acc_max * acc_rel / 100)\n\n        JogParams_x.StepSize = Decimal(dist_mm)\n        JogParams_y.StepSize = Decimal(dist_mm)\n\n        self._motorx.SetJogParams(JogParams_x)\n        self._motory.SetJogParams(JogParams_y)\n\n        self._motorx.WaitForSettingsInitialized(self._timeout_move_fast)\n        self._motory.WaitForSettingsInitialized(self._timeout_move_fast)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>New motor homing velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>New motor movement acceleration in percentage of max acceleration. Defaults to 100.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100):\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): New motor homing velocity in percentage of max velocity. Defaults to 100.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): New motor movement acceleration in percentage of max acceleration. Defaults to 100.\n    \"\"\"\n    if vel_homing &lt;=0 or vel_move &lt;=0 or acc_move &lt;=0:\n        raise ValueError(\"Velocity and acceleration parameters must be larger than 1%\")\n    if vel_homing &gt; 100 or vel_move &gt; 100 or acc_move &gt; 100:\n        raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n    # Convert the percentage to the actual value\n    vel_homing = self._vel_max * vel_homing / 100\n    vel_move = self._vel_max * vel_move / 100\n    acc_move = self._acc_max * acc_move / 100\n\n    self._set_vel_acc(vel_homing, vel_move, acc_move)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops the continuous movement of the motors</p> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def stop_move(self):\n    \"\"\"\n    Stops the continuous movement of the motors\n    \"\"\"\n    with self._lock:\n        self._motorx.Stop(0)\n        self._motory.Stop(0)\n    time.sleep(self._stoptime)\n\n    # Update the motor test\n    self._isrunning_motorx = 0\n    self._isrunning_motory = 0\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_m30xy/#iris.controllers.xy_stage_controller_m30xy.XYController_M30XYM.terminate","title":"<code>terminate(error_flag=False)</code>","text":"<p>Terminate the operation. Returns the stage to home and disconnects the device.</p> <p>Parameters:</p> Name Type Description Default <code>error_flag</code> <code>bool</code> <p>If termination is caused by an error, skip homing. True: there is an error, False: there is none. Defaults to False.</p> <code>False</code> Source code in <code>iris/controllers/xy_stage_controller_m30xy.py</code> <pre><code>def terminate(self,error_flag=False):\n    \"\"\"\n    Terminate the operation. Returns the stage to home and disconnects the device.\n\n    Args:\n        error_flag (bool, optional): If termination is caused by an error, skip homing. True: there is an error, False: there is none. Defaults to False.\n    \"\"\"\n\n    # Return the stage to Home\n    # if not error_flag:\n    #     self.homing_n_coor_calibration()\n\n    # Stop polling and disconnects the device\n    with self._lock:\n        self._motorx.StopPolling()\n        self._motory.StopPolling()\n        self._dev.Disconnect()\n\n        if self.issimulation:\n            print(\"&gt;&gt;&gt;&gt;&gt; TERMINATING SIMULATION STOPPED &lt;&lt;&lt;&lt;&lt;\")\n            SimulationManager.Instance.UninitializeSimulations()\n        self.running = False\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/","title":"xy_stage_controller_zaber","text":"<p>A class to control the XY stage using the Zaber ASCII protocol.</p> <p>Notes: - For better coordinate retrieval, a timestamp of the uptime of the device is used as a reference. - This uptime is then converted by adding its difference to the reference timestamp 'self.uptime_TsRef_us'</p>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber","title":"<code>XYController_Zaber</code>","text":"<p>               Bases: <code>Class_XYController</code></p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>class XYController_Zaber(Class_XYController):\n    def __init__(self,**kwargs) -&gt; None:\n        self.conn:Connection = None         # Connection to the device\n        self.dev:zma.device.Device = None          # Device object (for the motors)\n\n        self.unit_vel = Units.VELOCITY_MILLIMETRES_PER_SECOND\n        self.unit_len = Units.LENGTH_MILLIMETRES\n\n        # Remapping of the controls\n        self.dict_ctrl_remap = {\n            'xfwd':ControllerDirectionEnum.XFWD.value,\n            'xrev':ControllerDirectionEnum.XREV.value,\n            'yfwd':ControllerDirectionEnum.YFWD.value,\n            'yrev':ControllerDirectionEnum.YREV.value,\n        }   # Dictionary to remap the controls (only for the continuous and jog movements)\n\n        self._flipxy = ControllerConfigEnum.STAGE_FLIPXY.value      # Flag to indicate if the x and y axes are flipped in referece to the image capture\n        self._invertx = ControllerConfigEnum.STAGE_INVERTX.value    # Flag to indicate if the x axis is flipped (inverted)\n        self._inverty = ControllerConfigEnum.STAGE_INVERTY.value    # Flag to indicate if the y axis is flipped (inverted)\n\n        # Motor parameters\n        self.motorx:zma.Axis = None\n        self.motory:zma.Axis = None\n        self.motorx_sett:zma.AxisSettings = None # ascii setting for the motor\n        self.motory_sett:zma.AxisSettings = None # ascii setting for the motor\n\n        self.motorx_maxvel_mms = 0    # mm/s\n        self.motory_maxvel_mms = 0    # mm/s\n        self.motorx_vel_mms = 0       # mm/s\n        self.motory_vel_mms = 0       # mm/s\n        self.motorx_state = 0     # 0: stopped, 1: running\n        self.motory_state = 0     # 0: stopped, 1: running\n\n        self.motorx_max_coor = 0    # max coordinate in [mm] of motor x\n        self.motory_max_coor = 0    # max coordinate in [mm] of motor y\n        self.motorx_min_coor = 0    # min coordinate in [mm] of motor x\n        self.motory_min_coor = 0    # min coordinate in [mm] of motor x\n\n        self._jog_step_mm = 0.25        # jog step in [mm]\n        self._jog_step_min_um = 0.001   # minimum jog step in [mm]\n\n        # Setup parameters for coordinate retrievals\n        self._init_uptime_us = None                      # Uptime of the device in [us]\n        self._init_uptime_TsRef_us = None                # Timestamp reference for the uptime in [us]\n        self._getsettings:list[ascii.GetSetting] = []   # List of settings to retrieve\n        self._getsettings.append(ascii.GetSetting('system.uptime',unit=Units.TIME_MICROSECONDS,axes=[0]))\n        self._getsettings.append(ascii.GetSetting('pos',unit=Units.LENGTH_MILLIMETRES,axes=[1,2]))\n        self._delay_ms = 0     # Uptime delay in [ms] for the coordinate retrieval\n\n        self._max_vel_mmS = 85          # Maximum velocity of the motor in mm/s\n        self._min_vel_mmS = 0.000095    # Minimum velocity of the motor in mm/s\n\n        # Lock for multiprocessing safety\n        self._lock = Lock()\n\n        # Start by initializing the connection, device, motors, and their parameters\n        self._identifier = None\n        try:\n            self.initialisation(ControllerSpecificConfigEnum.ZABER_COMPORT.value)\n        except Exception as e:\n            print('Run ABORTED due to error in intialization:')\n            print(e)\n            self.terminate()\n\n        # Continue by setting up the motors and initializing (calibrating) the coordinate system of the motors\n        try:\n            if self.motorx.is_homed() == False or self.motory.is_homed() == False:\n                self.homing_n_coor_calibration()\n        except Exception as e:\n            print('Coordinate calibration has failed:')\n            print(e)\n            self.terminate()\n\n    def get_identifier(self) -&gt; str:\n        if self._identifier is None:\n            self._identifier = self._get_hardware_identifier()\n        return self._identifier\n\n    def _get_hardware_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the hardware identifier of the stage.\n\n        Returns:\n            str: The hardware identifier of the stage\n        \"\"\"\n        device_info = self.dev.identify()\n        name = device_info.name\n        dev_id = device_info.device_id\n        firmware = device_info.firmware_version\n        serial = device_info.serial_number\n        return f\"Zaber XY Stage, Name: {name}, ID: {dev_id}, firmware: {firmware}, S/N: {serial}\"\n\n\n    def reinitialise_connection(self):\n        \"\"\"\n        Reinitialises the connection to the device and the motors.\n        This is useful when the connection is lost or needs to be reset.\n        \"\"\"\n        try: self.terminate()\n        except Exception as e: print('Error in closing the connection:\\n{}'.format(e))\n\n        try: self.initialisation(ControllerSpecificConfigEnum.ZABER_COMPORT.value)\n        except Exception as e: print('Error in initialisation:\\n{}'.format(e))\n\n        try: self.homing_n_coor_calibration()\n        except Exception as e: print('Error in coordinate calibration:\\n{}'.format(e))\n\n        print('Reinitialisation complete')\n\n    def _remap_coordinates_flip_get(self,coor:tuple[float,float]) -&gt; tuple[float,float]:\n        \"\"\"\n        Remaps the coordinates based on the flip flags for getting the coordinates\n        This is because matrix operations are not commutative.\n\n        Args:\n            coor (tuple[float,float]): The coordinate to be remapped\n\n        Returns:\n            tuple[float,float]: the remapped coordinate\n        \"\"\"\n        x,y = coor\n        if self._flipxy:\n            x,y = y,x\n        if self._invertx:\n            x = -1*x\n        if self._inverty:\n            y = -1*y\n        return (x,y)\n\n    def _remap_coordinates_flip_set(self,coor:tuple[float,float]) -&gt; tuple[float,float]:\n        \"\"\"\n        Remaps the coordinates based on the flip flags for setting the coordinates (moving the motors).\n        This is because matrix operations are not commutative.\n\n        Args:\n            coor (tuple[float,float]): The coordinate to be remapped\n\n        Returns:\n            tuple[float,float]: the remapped coordinate\n        \"\"\"\n        x,y = coor\n        if self._invertx:\n            x = -1*x\n        if self._inverty:\n            y = -1*y\n        if self._flipxy:\n            x,y = y,x\n        return (x,y)\n\n    def initialisation(self,commport:str):\n        \"\"\"\n        Initialises the device, setup the connection, channels, motors and their parameters, etc.\n\n        Args:\n            commport (str): the communication port for the device\n        \"\"\"\n        self._lock.acquire()\n\n        self.conn = Connection.open_serial_port(commport)\n        self.conn.enable_alerts()\n\n        device_list = self.conn.detect_devices()\n        print(\"Found {} devices\".format(len(device_list)))\n\n        self.dev:zma.Device = device_list[0]\n\n        self.motorx:zma.Axis = self.dev.get_axis(1)\n        self.motory:zma.Axis = self.dev.get_axis(2)\n\n        self.motorx_sett = self.motorx.settings\n        self.motory_sett = self.motory.settings\n\n        self.motorx_maxvel_mms = self.motorx_sett.get('limit.approach.maxspeed',unit=self.unit_vel)\n        self.motory_maxvel_mms = self.motory_sett.get('limit.approach.maxspeed',unit=self.unit_vel)\n\n        self.motorx_vel_mms = self.motorx_sett.get('maxspeed',unit=self.unit_vel)\n        self.motory_vel_mms = self.motory_sett.get('maxspeed',unit=self.unit_vel)\n        self.motorx_vel_rel = self.motorx_vel_mms/self.motorx_maxvel_mms*100\n        self.motory_vel_rel = self.motory_vel_mms/self.motory_maxvel_mms*100\n        self.motorx_state = 0     # 0: stopped, 1: running\n        self.motory_state = 0     # 0: stopped, 1: running\n\n        self.motorx_max_coor = self.motorx_sett.get('limit.max',unit=self.unit_len)\n        self.motory_max_coor = self.motory_sett.get('limit.max',unit=self.unit_len)\n        self.motorx_min_coor = self.motorx_sett.get('limit.min',unit=self.unit_len)\n        self.motory_min_coor = self.motory_sett.get('limit.min',unit=self.unit_len)\n\n        # Set the parameters for coordinate retrievals\n        self._init_uptime_us = self.dev.settings.get('system.uptime',unit=Units.TIME_MICROSECONDS)\n        self._init_uptime_TsRef_us = get_timestamp_us_int()\n\n        # Update the max velocity for data analysis accordingly\n        self._max_vel_mmS = min(self.motorx_maxvel_mms,self.motory_maxvel_mms)\n\n        self._lock.release()\n\n        print('\\n&gt;&gt;&gt;&gt;&gt; Device and motor initialisation complete &lt;&lt;&lt;&lt;&lt;')\n\n    def _convert_uptime_to_timestamp(self,uptime_us:int) -&gt; int:\n        \"\"\"\n        Converts the uptime of the device to a timestamp\n\n        Args:\n            uptime_us (int): the uptime of the device in [us]\n\n        Returns:\n            int: the timestamp in [us]\n        \"\"\"\n        diff_us = uptime_us - self._init_uptime_us\n        timestamp_us = self._init_uptime_TsRef_us + diff_us + self._delay_ms*1000\n        return timestamp_us\n\n    def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n        \"\"\"\n        Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n        Args:\n            speed_mm_s (float): The speed to be converted in mm/s\n\n        Returns:\n            float: The relative velocity parameter in percentage\n        \"\"\"\n        # Adjust the speed to the limits if it is out of bounds\n        if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n            speed_mm_s = self._min_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n        if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n            speed_mm_s = self._max_vel_mmS\n            print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n        # Calculate the relative speed\n        speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n        return speed_rel\n\n    def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100):\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): Legacy parameter. Is ignored.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if vel_move &lt;= 0:\n            raise ValueError(\"Velocity and acceleration parameters must be larger than 1%\")\n        if vel_move &gt; 100:\n            raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n        # Convert the percentage to the actual value\n        self.motorx_vel_rel = vel_move\n        self.motory_vel_rel = vel_move\n\n        self.motorx_vel_mms = self.motorx_maxvel_mms * vel_move / 100\n        self.motory_vel_mms = self.motory_maxvel_mms * vel_move / 100\n\n    def get_vel_acc_relative(self):\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        relvel = min(self.motorx_vel_rel,self.motory_vel_rel) # Get the minimum relative velocity\n        return (relvel,relvel,float(100))\n\n    def report_attributes(self):\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; Device and motor attributes &lt;&lt;&lt;&lt;&lt;\")\n        for attr, value in vars(self).items():\n            print(f\"{attr}: {value}\")\n\n    def get_coordinates(self):\n        \"\"\"\n        Returns the current motor coordinates\n\n        Returns:\n            tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n        \"\"\"\n        def interpolate_coor(target_ts:int,list_ts:list[int],list_coor_x:list[float],\n                             list_coor_y:list[float]) -&gt; tuple[float,float]:\n            \"\"\"\n            Interpolates the coordinates based on the timestamps\n\n            Args:\n                target_ts (int): the target timestamp to retrieve the coordinates\n                list_ts (list[int]): list of timestamps\n                list_coor_x (list[float]): list of x coordinates\n                list_coor_y (list[float]): list of y coordinates\n\n            Returns:\n                tuple[float,float]: the interpolated coordinates\n            \"\"\"\n            assert len(list_ts) == len(list_coor_x) == len(list_coor_y) == 2,\\\n            \"Length of the lists must be 2\"\n            assert list_ts[0] &lt; target_ts &lt; list_ts[1], \"Target timestamp must be within the range\"\n\n            # Interpolate the coordinates\n            coor_x = np.interp(target_ts,list_ts,list_coor_x)\n            coor_y = np.interp(target_ts,list_ts,list_coor_y)\n            return (coor_x,coor_y)\n\n        ts_request = get_timestamp_us_int()\n        ts_return = []\n        coor_x_return = []\n        coor_y_return = []\n\n        while True:\n            with self._lock: res = self.dev.settings.get_many(*self._getsettings)\n            uptime_return = int(res[0].values[0])\n            ts_return_temp = self._convert_uptime_to_timestamp(uptime_return)\n            ts_return.append(ts_return_temp)\n            coor_x_return.append(float(res[1].values[0]))\n            coor_y_return.append(float(res[1].values[1]))\n            if ts_return[-1] &gt;= ts_request:\n                break\n            time.sleep(1/1000) # delay to prevent overloading the comm port\n\n        if len(ts_return) == 1:\n            coor_x = coor_x_return[-1]\n            coor_y = coor_y_return[-1]\n        else:\n            coor_x,coor_y = interpolate_coor(ts_request,\n                ts_return[-2:],coor_x_return[-2:],coor_y_return[-2:])\n\n        # Remap the coordinates, ensure the returned coordinates are correct\n        coor_x,coor_y = self._remap_coordinates_flip_get((coor_x,coor_y))\n        return (coor_x,coor_y)\n\n    def get_coordinates_old(self):\n        \"\"\"\n        Returns the current motor coordinates. This is the old version of the function,\n        which is less accurate (due to the delay between the request and the device response).\n\n        Returns:\n            tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n        \"\"\"\n        with self._lock:\n            coor_x = self.motorx.get_position(unit=self.unit_len)\n            coor_y = self.motory.get_position(unit=self.unit_len)\n\n        # Remap the coordinates, ensure the returned coordinates are correct\n        coor_x,coor_y = self._remap_coordinates_flip_get((coor_x,coor_y))\n        return (coor_x,coor_y)\n\n    def homing_n_coor_calibration(self):\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        - Also called as 'homing'\n        \"\"\"\n        if self.motorx_state != 0 or self.motory_state != 0:\n                print(\"!!!!! Motor is running, homing request BLOCKED !!!!!\")\n                return\n\n        print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n        # Home the device, use multithreading to operate both motors at once\n        with self._lock:\n            self.motorx_state = 1\n            self.motory_state = 1\n            self.motorx.home(wait_until_idle=False)\n            self.motory.home(wait_until_idle=False)\n\n            self.motorx.wait_until_idle()\n            self.motory.wait_until_idle()\n\n            self.motorx_state = 0\n            self.motory_state = 0\n        print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n\n\n    def move_direct(self,coor_abs:tuple[float,float]):\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n        \"\"\"\n        if self.motorx_state != 0 or self.motory_state != 0:\n            print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n            return\n\n        self.motorx_state = 1\n        self.motory_state = 1\n\n        # Remap the coordinates, ensure the motors move in the correct direction\n        coor_x,coor_y = self._remap_coordinates_flip_set(coor_abs)\n\n        with self._lock:\n            # Use multithreading to operate both motors at once\n            self.motorx.move_absolute(coor_x,unit=self.unit_len,\n                velocity=self.motorx_vel_mms,velocity_unit=self.unit_vel,\n                wait_until_idle=False)\n            self.motory.move_absolute(coor_y,unit=self.unit_len,\n                velocity=self.motory_vel_mms,velocity_unit=self.unit_vel,\n                wait_until_idle=False)\n\n        self.motorx.wait_until_idle()\n        self.motory.wait_until_idle()\n\n        self.motorx_state = 0\n        self.motory_state = 0\n\n    def move_continuous(self,dir:str):\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n        \"\"\"\n        # Check if the motor is running, prevents command overlap\n        if self.motorx_state != 0 or self.motory_state != 0:\n            print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n            return\n\n        dir = self.dict_ctrl_remap[dir] # Remap the control\n\n        with self._lock:\n            if dir == 'xfwd':\n                self.motorx_state = 1\n                self.motorx.move_velocity(self.motorx_vel_mms,unit=self.unit_vel)\n            elif dir == 'xrev':\n                self.motorx_state = 1\n                self.motorx.move_velocity(-1*self.motorx_vel_mms,unit=self.unit_vel)\n            elif dir == 'yfwd':\n                self.motory_state = 1\n                self.motory.move_velocity(self.motory_vel_mms,unit=self.unit_vel)\n            elif dir == 'yrev':\n                self.motory_state = 1\n                self.motory.move_velocity(-1*self.motory_vel_mms,unit=self.unit_vel)\n\n    def stop_move(self):\n        \"\"\"\n        Stops the continuous movement of the motors\n        \"\"\"\n\n        with self._lock:\n            self.motorx.stop(wait_until_idle=False)\n            self.motory.stop(wait_until_idle=False)\n\n        self.motorx.wait_until_idle()\n        self.motory.wait_until_idle()\n\n        # Update the motor test\n        self.motorx_state = 0\n        self.motory_state = 0\n\n    def get_jog(self):\n        \"\"\"\n        Returns the current jog step in [mm]:\n\n        Returns:\n            tuple of floats: 6 elements:\n            (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n        \"\"\"\n        jog_step_x = self._jog_step_mm\n        jog_step_y = self._jog_step_mm\n        jog_vel_x = self.motorx_vel_mms/self.motorx_maxvel_mms*100\n        jog_vel_y = self.motory_vel_mms/self.motory_maxvel_mms*100\n        jog_acc_x = float(100)\n        jog_acc_y = float(100)\n        return (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): Legacy parameter. Is ignored.\n            acc_rel (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n            raise ValueError(\"Distance must be a float\")\n\n        if dist_mm &lt; self._jog_step_min_um:\n            raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min_um))\n\n        # Set the jog step size\n        self._jog_step_mm = float(dist_mm)\n\n    def move_jog(self,direction:str):\n        \"\"\"\n        Moves the motor with a single jogging motion.\n\n        Args:\n            direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n        \"\"\"\n\n        if not isinstance(direction, str):\n            raise ValueError(\"Direction must be a string\")\n\n        if direction not in ['xfwd','xrev','yfwd','yrev']:\n            raise ValueError(\"Direction must be 'xfwd', 'xrev', 'yfwd', 'yrev'\")\n\n        if self.motorx_state != 0 or self.motory_state != 0:\n            print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n            return\n\n        direction = self.dict_ctrl_remap[direction] # Remap the control\n\n        self.motorx_state = 1\n        self.motory_state = 1\n        with self._lock:\n            if direction == 'xfwd':\n                self.motorx.move_relative(self._jog_step_mm,unit=self.unit_len,\n                    velocity=self.motorx_vel_mms,velocity_unit=self.unit_vel,\n                    wait_until_idle=True)\n            elif direction == 'xrev':\n                self.motorx.move_relative(-1*self._jog_step_mm,unit=self.unit_len,\n                    velocity=self.motorx_vel_mms,velocity_unit=self.unit_vel,\n                    wait_until_idle=True)\n            elif direction == 'yfwd':\n                self.motory.move_relative(self._jog_step_mm,unit=self.unit_len,\n                    velocity=self.motory_vel_mms,velocity_unit=self.unit_vel,\n                    wait_until_idle=True)\n            elif direction == 'yrev':\n                self.motory.move_relative(-1*self._jog_step_mm,unit=self.unit_len,\n                    velocity=self.motory_vel_mms,velocity_unit=self.unit_vel,\n                    wait_until_idle=True)\n        self.motorx_state = 0\n        self.motory_state = 0\n\n    def terminate(self):\n        \"\"\"\n        Terminates the operation and closes the connection to the device\n        \"\"\"\n        try:\n            self.conn.close()\n            print('xy_stage_controller: Connection closed')\n        except Exception as e:\n            print('xy_stage_controller: Error in closing the connection:\\n{}'.format(e))\n\n    def movementtest(self):\n        print(\"\\n&gt;&gt;&gt;&gt;&gt; MOTOR TEST: CIRCULAR MOTION &lt;&lt;&lt;&lt;&lt;\")\n        # Create circle coordinates\n        angles = np.arange(0, 2 * np.pi, 0.25)\n        radius = 10.0    # mm\n        xs = radius * np.cos(angles)+radius\n        ys = radius * np.sin(angles)+radius\n\n        for i in range(len(angles)):\n            print(i, float(xs[i]))\n            coor = [float(xs[i]), float(ys[i])]\n            self.move_direct(coor)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.calculate_vel_relative","title":"<code>calculate_vel_relative(speed_mm_s)</code>","text":"<p>Calculates the relative velocity parameter for the motor given the speed in mm/s</p> <p>Parameters:</p> Name Type Description Default <code>speed_mm_s</code> <code>float</code> <p>The speed to be converted in mm/s</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The relative velocity parameter in percentage</p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def calculate_vel_relative(self, speed_mm_s:float) -&gt; float:\n    \"\"\"\n    Calculates the relative velocity parameter for the motor given the speed in mm/s\n\n    Args:\n        speed_mm_s (float): The speed to be converted in mm/s\n\n    Returns:\n        float: The relative velocity parameter in percentage\n    \"\"\"\n    # Adjust the speed to the limits if it is out of bounds\n    if not abs(speed_mm_s/self._min_vel_mmS) &gt; 1:\n        speed_mm_s = self._min_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to minimum speed {self._min_vel_mmS} [mm/s] !!!!!')\n    if not abs(speed_mm_s/self._max_vel_mmS) &lt; 1:\n        speed_mm_s = self._max_vel_mmS\n        print(f'!!!!! The requested speed is out of bounds. Adjusted to maximum speed {self._max_vel_mmS} [mm/s] !!!!!')\n\n    # Calculate the relative speed\n    speed_rel = abs(speed_mm_s/self._max_vel_mmS * 100)\n\n    return speed_rel\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Returns the current motor coordinates</p> <p>Returns:</p> Type Description <p>tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)</p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"\n    Returns the current motor coordinates\n\n    Returns:\n        tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n    \"\"\"\n    def interpolate_coor(target_ts:int,list_ts:list[int],list_coor_x:list[float],\n                         list_coor_y:list[float]) -&gt; tuple[float,float]:\n        \"\"\"\n        Interpolates the coordinates based on the timestamps\n\n        Args:\n            target_ts (int): the target timestamp to retrieve the coordinates\n            list_ts (list[int]): list of timestamps\n            list_coor_x (list[float]): list of x coordinates\n            list_coor_y (list[float]): list of y coordinates\n\n        Returns:\n            tuple[float,float]: the interpolated coordinates\n        \"\"\"\n        assert len(list_ts) == len(list_coor_x) == len(list_coor_y) == 2,\\\n        \"Length of the lists must be 2\"\n        assert list_ts[0] &lt; target_ts &lt; list_ts[1], \"Target timestamp must be within the range\"\n\n        # Interpolate the coordinates\n        coor_x = np.interp(target_ts,list_ts,list_coor_x)\n        coor_y = np.interp(target_ts,list_ts,list_coor_y)\n        return (coor_x,coor_y)\n\n    ts_request = get_timestamp_us_int()\n    ts_return = []\n    coor_x_return = []\n    coor_y_return = []\n\n    while True:\n        with self._lock: res = self.dev.settings.get_many(*self._getsettings)\n        uptime_return = int(res[0].values[0])\n        ts_return_temp = self._convert_uptime_to_timestamp(uptime_return)\n        ts_return.append(ts_return_temp)\n        coor_x_return.append(float(res[1].values[0]))\n        coor_y_return.append(float(res[1].values[1]))\n        if ts_return[-1] &gt;= ts_request:\n            break\n        time.sleep(1/1000) # delay to prevent overloading the comm port\n\n    if len(ts_return) == 1:\n        coor_x = coor_x_return[-1]\n        coor_y = coor_y_return[-1]\n    else:\n        coor_x,coor_y = interpolate_coor(ts_request,\n            ts_return[-2:],coor_x_return[-2:],coor_y_return[-2:])\n\n    # Remap the coordinates, ensure the returned coordinates are correct\n    coor_x,coor_y = self._remap_coordinates_flip_get((coor_x,coor_y))\n    return (coor_x,coor_y)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.get_coordinates_old","title":"<code>get_coordinates_old()</code>","text":"<p>Returns the current motor coordinates. This is the old version of the function, which is less accurate (due to the delay between the request and the device response).</p> <p>Returns:</p> Type Description <p>tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)</p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def get_coordinates_old(self):\n    \"\"\"\n    Returns the current motor coordinates. This is the old version of the function,\n    which is less accurate (due to the delay between the request and the device response).\n\n    Returns:\n        tuple of floats: 2 elements: (coor_x, coor_y), in millimetre (float)\n    \"\"\"\n    with self._lock:\n        coor_x = self.motorx.get_position(unit=self.unit_len)\n        coor_y = self.motory.get_position(unit=self.unit_len)\n\n    # Remap the coordinates, ensure the returned coordinates are correct\n    coor_x,coor_y = self._remap_coordinates_flip_get((coor_x,coor_y))\n    return (coor_x,coor_y)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.get_jog","title":"<code>get_jog()</code>","text":"<p>Returns the current jog step in [mm]:</p> <p>Returns:</p> Type Description <p>tuple of floats: 6 elements:</p> <p>(jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)</p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def get_jog(self):\n    \"\"\"\n    Returns the current jog step in [mm]:\n\n    Returns:\n        tuple of floats: 6 elements:\n        (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n    \"\"\"\n    jog_step_x = self._jog_step_mm\n    jog_step_y = self._jog_step_mm\n    jog_vel_x = self.motorx_vel_mms/self.motorx_maxvel_mms*100\n    jog_vel_y = self.motory_vel_mms/self.motory_maxvel_mms*100\n    jog_acc_x = float(100)\n    jog_acc_y = float(100)\n    return (jog_step_x, jog_step_y, jog_vel_x, jog_vel_y, jog_acc_x, jog_acc_y)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def get_vel_acc_relative(self):\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    relvel = min(self.motorx_vel_rel,self.motory_vel_rel) # Get the minimum relative velocity\n    return (relvel,relvel,float(100))\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. - Also called as 'homing'</p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def homing_n_coor_calibration(self):\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    - Also called as 'homing'\n    \"\"\"\n    if self.motorx_state != 0 or self.motory_state != 0:\n            print(\"!!!!! Motor is running, homing request BLOCKED !!!!!\")\n            return\n\n    print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n    # Home the device, use multithreading to operate both motors at once\n    with self._lock:\n        self.motorx_state = 1\n        self.motory_state = 1\n        self.motorx.home(wait_until_idle=False)\n        self.motory.home(wait_until_idle=False)\n\n        self.motorx.wait_until_idle()\n        self.motory.wait_until_idle()\n\n        self.motorx_state = 0\n        self.motory_state = 0\n    print(\"&gt;&gt;&gt;&gt;&gt; Coordinate calibration/Homing finished &lt;&lt;&lt;&lt;&lt;\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.initialisation","title":"<code>initialisation(commport)</code>","text":"<p>Initialises the device, setup the connection, channels, motors and their parameters, etc.</p> <p>Parameters:</p> Name Type Description Default <code>commport</code> <code>str</code> <p>the communication port for the device</p> required Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def initialisation(self,commport:str):\n    \"\"\"\n    Initialises the device, setup the connection, channels, motors and their parameters, etc.\n\n    Args:\n        commport (str): the communication port for the device\n    \"\"\"\n    self._lock.acquire()\n\n    self.conn = Connection.open_serial_port(commport)\n    self.conn.enable_alerts()\n\n    device_list = self.conn.detect_devices()\n    print(\"Found {} devices\".format(len(device_list)))\n\n    self.dev:zma.Device = device_list[0]\n\n    self.motorx:zma.Axis = self.dev.get_axis(1)\n    self.motory:zma.Axis = self.dev.get_axis(2)\n\n    self.motorx_sett = self.motorx.settings\n    self.motory_sett = self.motory.settings\n\n    self.motorx_maxvel_mms = self.motorx_sett.get('limit.approach.maxspeed',unit=self.unit_vel)\n    self.motory_maxvel_mms = self.motory_sett.get('limit.approach.maxspeed',unit=self.unit_vel)\n\n    self.motorx_vel_mms = self.motorx_sett.get('maxspeed',unit=self.unit_vel)\n    self.motory_vel_mms = self.motory_sett.get('maxspeed',unit=self.unit_vel)\n    self.motorx_vel_rel = self.motorx_vel_mms/self.motorx_maxvel_mms*100\n    self.motory_vel_rel = self.motory_vel_mms/self.motory_maxvel_mms*100\n    self.motorx_state = 0     # 0: stopped, 1: running\n    self.motory_state = 0     # 0: stopped, 1: running\n\n    self.motorx_max_coor = self.motorx_sett.get('limit.max',unit=self.unit_len)\n    self.motory_max_coor = self.motory_sett.get('limit.max',unit=self.unit_len)\n    self.motorx_min_coor = self.motorx_sett.get('limit.min',unit=self.unit_len)\n    self.motory_min_coor = self.motory_sett.get('limit.min',unit=self.unit_len)\n\n    # Set the parameters for coordinate retrievals\n    self._init_uptime_us = self.dev.settings.get('system.uptime',unit=Units.TIME_MICROSECONDS)\n    self._init_uptime_TsRef_us = get_timestamp_us_int()\n\n    # Update the max velocity for data analysis accordingly\n    self._max_vel_mmS = min(self.motorx_maxvel_mms,self.motory_maxvel_mms)\n\n    self._lock.release()\n\n    print('\\n&gt;&gt;&gt;&gt;&gt; Device and motor initialisation complete &lt;&lt;&lt;&lt;&lt;')\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement</p> required Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def move_continuous(self,dir:str):\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the movement\n    \"\"\"\n    # Check if the motor is running, prevents command overlap\n    if self.motorx_state != 0 or self.motory_state != 0:\n        print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n        return\n\n    dir = self.dict_ctrl_remap[dir] # Remap the control\n\n    with self._lock:\n        if dir == 'xfwd':\n            self.motorx_state = 1\n            self.motorx.move_velocity(self.motorx_vel_mms,unit=self.unit_vel)\n        elif dir == 'xrev':\n            self.motorx_state = 1\n            self.motorx.move_velocity(-1*self.motorx_vel_mms,unit=self.unit_vel)\n        elif dir == 'yfwd':\n            self.motory_state = 1\n            self.motory.move_velocity(self.motory_vel_mms,unit=self.unit_vel)\n        elif dir == 'yrev':\n            self.motory_state = 1\n            self.motory.move_velocity(-1*self.motory_vel_mms,unit=self.unit_vel)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.move_direct","title":"<code>move_direct(coor_abs)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>tuple[float, float]</code> <p>the absolute coordinate to move to in [mm]</p> required Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def move_direct(self,coor_abs:tuple[float,float]):\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (tuple[float,float]): the absolute coordinate to move to in [mm]\n    \"\"\"\n    if self.motorx_state != 0 or self.motory_state != 0:\n        print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n        return\n\n    self.motorx_state = 1\n    self.motory_state = 1\n\n    # Remap the coordinates, ensure the motors move in the correct direction\n    coor_x,coor_y = self._remap_coordinates_flip_set(coor_abs)\n\n    with self._lock:\n        # Use multithreading to operate both motors at once\n        self.motorx.move_absolute(coor_x,unit=self.unit_len,\n            velocity=self.motorx_vel_mms,velocity_unit=self.unit_vel,\n            wait_until_idle=False)\n        self.motory.move_absolute(coor_y,unit=self.unit_len,\n            velocity=self.motory_vel_mms,velocity_unit=self.unit_vel,\n            wait_until_idle=False)\n\n    self.motorx.wait_until_idle()\n    self.motory.wait_until_idle()\n\n    self.motorx_state = 0\n    self.motory_state = 0\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single jogging motion.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.</p> required Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def move_jog(self,direction:str):\n    \"\"\"\n    Moves the motor with a single jogging motion.\n\n    Args:\n        direction (str): 'xfwd', 'xrev', 'yfwd', 'yrev' for the direction of the jog.\n    \"\"\"\n\n    if not isinstance(direction, str):\n        raise ValueError(\"Direction must be a string\")\n\n    if direction not in ['xfwd','xrev','yfwd','yrev']:\n        raise ValueError(\"Direction must be 'xfwd', 'xrev', 'yfwd', 'yrev'\")\n\n    if self.motorx_state != 0 or self.motory_state != 0:\n        print(\"!!!!! Motor is currently running, movement request BLOCKED !!!!!\")\n        return\n\n    direction = self.dict_ctrl_remap[direction] # Remap the control\n\n    self.motorx_state = 1\n    self.motory_state = 1\n    with self._lock:\n        if direction == 'xfwd':\n            self.motorx.move_relative(self._jog_step_mm,unit=self.unit_len,\n                velocity=self.motorx_vel_mms,velocity_unit=self.unit_vel,\n                wait_until_idle=True)\n        elif direction == 'xrev':\n            self.motorx.move_relative(-1*self._jog_step_mm,unit=self.unit_len,\n                velocity=self.motorx_vel_mms,velocity_unit=self.unit_vel,\n                wait_until_idle=True)\n        elif direction == 'yfwd':\n            self.motory.move_relative(self._jog_step_mm,unit=self.unit_len,\n                velocity=self.motory_vel_mms,velocity_unit=self.unit_vel,\n                wait_until_idle=True)\n        elif direction == 'yrev':\n            self.motory.move_relative(-1*self._jog_step_mm,unit=self.unit_len,\n                velocity=self.motory_vel_mms,velocity_unit=self.unit_vel,\n                wait_until_idle=True)\n    self.motorx_state = 0\n    self.motory_state = 0\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.reinitialise_connection","title":"<code>reinitialise_connection()</code>","text":"<p>Reinitialises the connection to the device and the motors. This is useful when the connection is lost or needs to be reset.</p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def reinitialise_connection(self):\n    \"\"\"\n    Reinitialises the connection to the device and the motors.\n    This is useful when the connection is lost or needs to be reset.\n    \"\"\"\n    try: self.terminate()\n    except Exception as e: print('Error in closing the connection:\\n{}'.format(e))\n\n    try: self.initialisation(ControllerSpecificConfigEnum.ZABER_COMPORT.value)\n    except Exception as e: print('Error in initialisation:\\n{}'.format(e))\n\n    try: self.homing_n_coor_calibration()\n    except Exception as e: print('Error in coordinate calibration:\\n{}'.format(e))\n\n    print('Reinitialisation complete')\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): Legacy parameter. Is ignored.\n        acc_rel (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n        raise ValueError(\"Distance must be a float\")\n\n    if dist_mm &lt; self._jog_step_min_um:\n        raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min_um))\n\n    # Set the jog step size\n    self._jog_step_mm = float(dist_mm)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:float=100, vel_move:float=100, acc_move:float=100):\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): Legacy parameter. Is ignored.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if vel_move &lt;= 0:\n        raise ValueError(\"Velocity and acceleration parameters must be larger than 1%\")\n    if vel_move &gt; 100:\n        raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n    # Convert the percentage to the actual value\n    self.motorx_vel_rel = vel_move\n    self.motory_vel_rel = vel_move\n\n    self.motorx_vel_mms = self.motorx_maxvel_mms * vel_move / 100\n    self.motory_vel_mms = self.motory_maxvel_mms * vel_move / 100\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops the continuous movement of the motors</p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def stop_move(self):\n    \"\"\"\n    Stops the continuous movement of the motors\n    \"\"\"\n\n    with self._lock:\n        self.motorx.stop(wait_until_idle=False)\n        self.motory.stop(wait_until_idle=False)\n\n    self.motorx.wait_until_idle()\n    self.motory.wait_until_idle()\n\n    # Update the motor test\n    self.motorx_state = 0\n    self.motory_state = 0\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.XYController_Zaber.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the operation and closes the connection to the device</p> Source code in <code>iris/controllers/xy_stage_controller_zaber.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminates the operation and closes the connection to the device\n    \"\"\"\n    try:\n        self.conn.close()\n        print('xy_stage_controller: Connection closed')\n    except Exception as e:\n        print('xy_stage_controller: Error in closing the connection:\\n{}'.format(e))\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/xy_stage_controller_zaber/#iris.controllers.xy_stage_controller_zaber.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/","title":"z_stage_controller_dummy","text":"<p>A class that allows the control of the Z825B Thorlabs stage. This implementation is based on the .NET Kinesis Libraries to connect to and control the stage.</p>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy","title":"<code>ZController_Dummy</code>","text":"<p>               Bases: <code>Class_ZController</code></p> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>class ZController_Dummy(Class_ZController):\n    def __init__(self,**kwargs) -&gt; None:\n        self._coor_mm = float(0)    # Stores the current coordinate of the motor in [mm]\n\n        self._vel = 100  # Stores the velocity of the motor in percentage of max velocity\n        self._motor_step_mm = float(0.001)  # Stores the motor step size in [mm]\n        self._motor_step_wait_s = 1e-6  # Stores the time to wait for the motor to move in [s]\n\n        self._jog_step_mm = float(0.1)  # Stores the jog step size of the motor in [mm]\n\n        self._vel = float(100)  # Stores the velocity of the motor in percentage of max velocity\n\n        self._thread_movecontinuous:threading.Thread|None = None    # Thread to move the motor continuously\n        self._flg_movecontinuous = threading.Event()    # Flag to stop the continuous movement\n\n        self._isrunning_motor = False   # Flag to check if the motor is running\n        print('\\n&gt;&gt;&gt;&gt;&gt; DUMMY Z controller is used &lt;&lt;&lt;&lt;&lt;')\n\n    def get_identifier(self) -&gt; str:\n        return \"Dummy Z stage controller\"\n\n    def initialisation(self):\n        \"\"\"\n        Initialises the parameters\n        \"\"\"\n        pass\n\n    def get_vel_acc_relative(self):\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        # Unfortunately the MCM301 library doesn't provide a way to get the velocity and acceleration parameters\n        return (100, self._vel, 100)\n\n    def set_vel_acc_relative(self,vel_homing:int|float=100, vel_move:int|float=100, acc_move:int|float=100):\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): Legacy parameter. Is ignored.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if vel_move &lt;= 0 or vel_move &gt; 100:\n            raise ValueError(\"Velocity and acceleration parameters must be larger than 0% and smaller than 100%\")\n\n        if not isinstance(vel_move, int) and not isinstance(vel_move, float):\n            raise ValueError(\"Velocity must be an integer\")\n\n        self._vel = float(vel_move)\n\n    def homing_n_coor_calibration(self):\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        Also called as 'homing'\n        \"\"\"\n        print('Homing the Z stage')\n        self._coor_mm = float(0)\n\n        print('Homing done')\n\n    def terminate(self):\n        \"\"\"\n        Terminate the operation. Returns the stage to home and disconnects the device.\n        \"\"\"\n        print('Terminating the Z stage controller')\n\n    def move_direct(self,coor_abs):\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (float): coordinate of the destination [mm]\n        \"\"\"\n        if not isinstance(coor_abs, float) and not isinstance(coor_abs, int):\n            raise ValueError(\"Coordinate must be a float\")\n\n        count = int((coor_abs-self._coor_mm) / self._motor_step_mm)\n\n        target = self._coor_mm + count*self._motor_step_mm\n\n        while True:\n            if self._coor_mm &lt; target:\n                self._coor_mm += self._motor_step_mm\n            elif self._coor_mm &gt; target:\n                self._coor_mm -= self._motor_step_mm\n\n            error = abs(self._coor_mm - target)\n            if error &lt; 0.02:\n                break\n            time.sleep(self._motor_step_wait_s/(self._vel/100))\n\n        return\n\n    def move_continuous(self,dir):\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n\n        def move_continuous_thread(self:ZController_Dummy,dir):\n            self._flg_movecontinuous.set()\n            while self._flg_movecontinuous.is_set():\n                if dir == 'zfwd':\n                    self._coor_mm += self._motor_step_mm\n                elif dir == 'zrev':\n                    self._coor_mm -= self._motor_step_mm\n                else:\n                    raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n                time.sleep(self._motor_step_wait_s/(self._vel/100))\n\n        self._thread_movecontinuous = threading.Thread(target=move_continuous_thread,args=(self,dir))\n        self._thread_movecontinuous.start()\n\n    def get_jog(self):\n        \"\"\"\n        Get the jog parameters for the motor\n\n        Returns:\n            tuple of floats: 3 elements: (jog_step [mm], jog_vel, jog_acc)\n\n        Note:\n            - jog_vel and jog_acc are not available in the MCM301 library\n        \"\"\"\n        return (self._jog_step_mm, None, None)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): Legacy parameter. Is ignored.\n            acc_rel (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n            raise ValueError(\"Distance must be a float\")\n\n        if dist_mm &lt;= 0:\n            raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n        self._jog_step_mm = dist_mm\n\n    def move_jog(self,direction:str):\n        \"\"\"\n        Moves the motor with a single/continuous jogging motion until a stop command.\n\n        Args:\n            direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n\n        if direction == 'zfwd':\n            target = self._coor_mm + self._jog_step_mm\n        elif direction == 'zrev':\n            target = self._coor_mm - self._jog_step_mm\n\n        while True:\n            if direction == 'zfwd':\n                self._coor_mm += self._jog_step_mm\n            elif direction == 'zrev':\n                self._coor_mm -= self._jog_step_mm\n            else:\n                raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n            error = abs(self._coor_mm - target)\n            if error &lt; 0.01:\n                break\n\n            time.sleep(self._motor_step_wait_s/(self._vel/100))\n\n    def stop_move(self):\n        \"\"\"\n        Stops all motor movement. Will try 5 times before giving up.\n        \"\"\"\n        if isinstance(self._thread_movecontinuous, threading.Thread):\n            if self._thread_movecontinuous.is_alive():\n                self._flg_movecontinuous.clear()\n                self._thread_movecontinuous.join()\n                self._thread_movecontinuous = None\n            else:\n                self._thread_movecontinuous = None\n\n    def _MoveTestAbsolute(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        distances = np.arange(0, 25, 2)\n        for i,distance in enumerate(distances):\n            print(i, distance)\n            self.move_direct(float(distance))\n\n    def _MoveTestJog(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        jog_step = 2 # [mm]\n        self.set_jog(jog_step)\n        for i in range(5):\n            print(self.get_coordinates())\n            self.move_jog('zfwd')\n\n        jog_step = 1 # [mm]\n        self.set_jog(jog_step)\n        for i in range(10):\n            print(self.get_coordinates())\n            self.move_jog('zrev')\n\n    def get_coordinates(self):\n        \"\"\"\n        Get the coordinates of the motor [mm]\n        \"\"\"\n        return self._coor_mm\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Get the coordinates of the motor [mm]</p> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"\n    Get the coordinates of the motor [mm]\n    \"\"\"\n    return self._coor_mm\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.get_jog","title":"<code>get_jog()</code>","text":"<p>Get the jog parameters for the motor</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (jog_step [mm], jog_vel, jog_acc)</p> Note <ul> <li>jog_vel and jog_acc are not available in the MCM301 library</li> </ul> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def get_jog(self):\n    \"\"\"\n    Get the jog parameters for the motor\n\n    Returns:\n        tuple of floats: 3 elements: (jog_step [mm], jog_vel, jog_acc)\n\n    Note:\n        - jog_vel and jog_acc are not available in the MCM301 library\n    \"\"\"\n    return (self._jog_step_mm, None, None)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def get_vel_acc_relative(self):\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    # Unfortunately the MCM301 library doesn't provide a way to get the velocity and acceleration parameters\n    return (100, self._vel, 100)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. Also called as 'homing'</p> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def homing_n_coor_calibration(self):\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    Also called as 'homing'\n    \"\"\"\n    print('Homing the Z stage')\n    self._coor_mm = float(0)\n\n    print('Homing done')\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.initialisation","title":"<code>initialisation()</code>","text":"<p>Initialises the parameters</p> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def initialisation(self):\n    \"\"\"\n    Initialises the parameters\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def move_continuous(self,dir):\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n\n    def move_continuous_thread(self:ZController_Dummy,dir):\n        self._flg_movecontinuous.set()\n        while self._flg_movecontinuous.is_set():\n            if dir == 'zfwd':\n                self._coor_mm += self._motor_step_mm\n            elif dir == 'zrev':\n                self._coor_mm -= self._motor_step_mm\n            else:\n                raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n            time.sleep(self._motor_step_wait_s/(self._vel/100))\n\n    self._thread_movecontinuous = threading.Thread(target=move_continuous_thread,args=(self,dir))\n    self._thread_movecontinuous.start()\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.move_direct","title":"<code>move_direct(coor_abs)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>float</code> <p>coordinate of the destination [mm]</p> required Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def move_direct(self,coor_abs):\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (float): coordinate of the destination [mm]\n    \"\"\"\n    if not isinstance(coor_abs, float) and not isinstance(coor_abs, int):\n        raise ValueError(\"Coordinate must be a float\")\n\n    count = int((coor_abs-self._coor_mm) / self._motor_step_mm)\n\n    target = self._coor_mm + count*self._motor_step_mm\n\n    while True:\n        if self._coor_mm &lt; target:\n            self._coor_mm += self._motor_step_mm\n        elif self._coor_mm &gt; target:\n            self._coor_mm -= self._motor_step_mm\n\n        error = abs(self._coor_mm - target)\n        if error &lt; 0.02:\n            break\n        time.sleep(self._motor_step_wait_s/(self._vel/100))\n\n    return\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single/continuous jogging motion until a stop command.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def move_jog(self,direction:str):\n    \"\"\"\n    Moves the motor with a single/continuous jogging motion until a stop command.\n\n    Args:\n        direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n\n    if direction == 'zfwd':\n        target = self._coor_mm + self._jog_step_mm\n    elif direction == 'zrev':\n        target = self._coor_mm - self._jog_step_mm\n\n    while True:\n        if direction == 'zfwd':\n            self._coor_mm += self._jog_step_mm\n        elif direction == 'zrev':\n            self._coor_mm -= self._jog_step_mm\n        else:\n            raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n        error = abs(self._coor_mm - target)\n        if error &lt; 0.01:\n            break\n\n        time.sleep(self._motor_step_wait_s/(self._vel/100))\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): Legacy parameter. Is ignored.\n        acc_rel (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n        raise ValueError(\"Distance must be a float\")\n\n    if dist_mm &lt;= 0:\n        raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n    self._jog_step_mm = dist_mm\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:int|float=100, vel_move:int|float=100, acc_move:int|float=100):\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): Legacy parameter. Is ignored.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if vel_move &lt;= 0 or vel_move &gt; 100:\n        raise ValueError(\"Velocity and acceleration parameters must be larger than 0% and smaller than 100%\")\n\n    if not isinstance(vel_move, int) and not isinstance(vel_move, float):\n        raise ValueError(\"Velocity must be an integer\")\n\n    self._vel = float(vel_move)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops all motor movement. Will try 5 times before giving up.</p> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def stop_move(self):\n    \"\"\"\n    Stops all motor movement. Will try 5 times before giving up.\n    \"\"\"\n    if isinstance(self._thread_movecontinuous, threading.Thread):\n        if self._thread_movecontinuous.is_alive():\n            self._flg_movecontinuous.clear()\n            self._thread_movecontinuous.join()\n            self._thread_movecontinuous = None\n        else:\n            self._thread_movecontinuous = None\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_dummy/#iris.controllers.z_stage_controller_dummy.ZController_Dummy.terminate","title":"<code>terminate()</code>","text":"<p>Terminate the operation. Returns the stage to home and disconnects the device.</p> Source code in <code>iris/controllers/z_stage_controller_dummy.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminate the operation. Returns the stage to home and disconnects the device.\n    \"\"\"\n    print('Terminating the Z stage controller')\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/","title":"z_stage_controller_mcm301","text":"<p>A class that allows the control of the Z825B Thorlabs stage. This implementation is based on the .NET Kinesis Libraries to connect to and control the stage.</p>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301","title":"<code>ZController_MCM301</code>","text":"<p>               Bases: <code>Class_ZController</code></p> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>class ZController_MCM301(Class_ZController):\n    def __init__(self,sim=False) -&gt; None:\n        # Get the MCM301 class from the wrapper\n        MCM301 = get_mcm301_class()\n\n        self.controller = MCM301()\n        self.devs = MCM301.list_devices()\n\n        if len(self.devs) &lt;= 0:\n            raise ConnectionError(\"MCM301: There is no devices connected\")\n\n        self.BitPerSec = 115200 # Baud rate\n        self.timeout_connect = 3 # Connection timeout in seconds\n\n        self.dev_info = self.devs[0]\n        self.serial_no = self.dev_info[0]\n        self.hdl = self.controller.open(self.serial_no, self.BitPerSec, self.timeout_connect)\n\n        if self.hdl &lt; 0:\n            raise ConnectionError(\"MCM301: Open failed\")\n        if self.controller.is_open(self.serial_no) == 0:\n            raise ConnectionError(\"MCM301: MCM301IsOpen failed\")\n\n        # Motor parameters setup\n        self.slot = 4               # Slot number of the motor\n        self.mot_waittime = 0.005   # Wait time for the motor to stop moving [sec]\n\n        self.status_bit = [0]       # Status bit of the motor for get_mot_status\n        self.encoder = [0]          # Encoder value of the motor for get_mot_status\n        self.info = [0]             # Information of the motor for get_stage_params\n\n        self.max_hw_enc = None      # Maximum hardware position of the motor in encoder units\n        self.min_hw_enc = None      # Minimum hardware position of the motor in encoder units\n        self.max_hw_mm = None      # Maximum hardware position of the motor in [mm]\n        self.min_hw_mm = None      # Minimum hardware position of the motor in [mm]\n\n        self.dict_ctrl_remap = {\n            'zfwd':ControllerDirectionEnum.ZFWD.value,\n            'zrev':ControllerDirectionEnum.ZREV.value\n        }   # Dictionary to remap the controls\n\n        self._jog_step_mm = None    # Stores the jog step size in [mm]\n        self._jog_step_min = 0.0002 # Minimum jog step size in [mm]\n\n        self._vel = int(100)      # Stores the velocity of the motor [%]\n        self._vel_max = int(100)  # Maximum velocity of the motor [%]\n        self._vel_min = int(1)    # Minimum velocity of the motor [%]\n\n        self._isrunning_motor = False   # Flag to check if the motor is running\n\n\n        # Start by initializing the connection, device, motors, and their parameters\n        self._identifier = None\n        try:\n            self.initialisation()\n        except Exception as e:\n            print('Run ABORTED due to error in intialization:')\n            print(e)\n            self.terminate()\n\n        # Continue by setting up the motors and initializing (calibrating) the coordinate system of the motors\n        try:\n            self.set_vel_acc_relative()\n            self.homing_n_coor_calibration()\n        except Exception as e:\n            print('Coordinate calibration has failed:')\n            print(e)\n            self.terminate()\n\n    def get_identifier(self) -&gt; str:\n        if self._identifier is None:\n            self._identifier = self._get_hardware_identifier()\n        return self._identifier\n\n    def _get_hardware_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the hardware identifier of the stage.\n\n        Returns:\n            str: The hardware identifier of the stage\n        \"\"\"\n        return f\"MCM301, S/N:{self.serial_no}\"\n\n    def initialisation(self):\n        \"\"\"\n        Initialises the parameters\n        \"\"\"\n        self.controller.get_stage_params(self.slot, self.info)\n        dev_info:list = self.info[0]\n\n        self.min_hw_enc = dev_info[2]   # Minimum hardware position of the motor in encoder units\n        self.max_hw_enc = dev_info[3]   # Maximum hardware position of the motor in encoder units\n\n        pos_container = [0]\n        self.controller.convert_encoder_to_nm(self.slot, self.min_hw_enc, pos_container) * 1e-6\n        self.min_hw_mm = float(pos_container[0] * 1e-6)\n        self.controller.convert_encoder_to_nm(self.slot, self.max_hw_enc, pos_container) * 1e-6\n        self.max_hw_mm = float(pos_container[0] * 1e-6)\n\n    def get_vel_acc_relative(self):\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        # Unfortunately the MCM301 library doesn't provide a way to get the velocity and acceleration parameters\n\n        return (self._vel,self._vel,float(100))\n\n    def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100):\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): Legacy parameter. Is ignored.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if vel_move &lt;= 0 or vel_move &gt; 100:\n            raise ValueError(\"Velocity and acceleration parameters must be larger than 0% and smaller than 100%\")\n\n        if not isinstance(vel_move, int) and not isinstance(vel_move, float):\n            raise ValueError(\"Velocity must be an integer\")\n\n        # Convert the percentage to the actual value\n        vel = vel_move\n\n        if isinstance(vel,float):\n            vel = int(vel)\n\n        if vel &gt; self._vel_max:\n            print(\"Maximum device velocity is {}\".format(self._vel_max))\n            vel = self._vel_max\n\n        if vel &lt; self._vel_min:\n            print(\"Minimum device velocity is {}\".format(self._vel_min))\n            vel = self._vel_min\n\n        # Update the stored value\n        self._vel = vel\n\n    def homing_n_coor_calibration(self):\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        Also called as 'homing'\n        \"\"\"\n        if self._isrunning_motor == True:\n            print('!!!!! Motor is running, homing request BLOCKED !!!!!')\n            return\n\n        result = self.controller.home(self.slot)\n        if result &lt; 0:\n            print(\"Homing failed\")\n            return\n\n        # Wait for the motor to stop moving\n        self._wait_stop()\n        self._isrunning_motor = False\n\n    def _wait_stop(self):\n        \"\"\"\n        Wait for all movements to stop\n        \"\"\"\n        isrunning = True\n        while isrunning:\n            self.controller.get_mot_status(self.slot, self.encoder, self.status_bit)\n            isrunning = (self.status_bit[0] &amp; 0x10) or (self.status_bit[0] &amp; 0x20)\\\n                or (self.status_bit[0] &amp; 0x40) or (self.status_bit[0] &amp; 0x80)\n            time.sleep(self.mot_waittime)\n\n    def _wait_moving_stop(self):\n        \"\"\"\n        A function to wait for the motor to stop moving.\n        \"\"\"\n        isrunning = True\n        status_bit = [0]\n        encoder = [0]\n        while isrunning:\n            self.controller.get_mot_status(self.slot, encoder, status_bit)\n            status_bit_value = status_bit[0]\n            isrunning = (status_bit_value &amp; 0x10) or (status_bit_value &amp; 0x20)\n            time.sleep(self.mot_waittime)\n\n    def _wait_jog_stop(self):\n        \"\"\"\n        A function to wait for the motor to stop jogging.\n        \"\"\"\n        isrunning = True\n        status_bit = [0]\n        encoder = [0]\n        while isrunning:\n            self.controller.get_mot_status(self.slot, encoder, status_bit)\n            status_bit_value = status_bit[0]\n            isrunning = (status_bit_value &amp; 0x40) or (status_bit_value &amp; 0x80)\n            time.sleep(self.mot_waittime)\n\n    def terminate(self):\n        \"\"\"\n        Terminate the operation. Returns the stage to home and disconnects the device.\n        \"\"\"\n        try:\n            self.controller.close()\n        except Exception as e:\n            print('Error in closing the device:')\n            print(e)\n\n    def move_direct(self,coor_abs):\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (float): coordinate of the destination [mm]\n        \"\"\"\n        if not isinstance(coor_abs, float) and not isinstance(coor_abs, int):\n            raise ValueError(\"Coordinate must be a float\")\n\n        coor_enc = [0]\n        ret = self.controller.convert_nm_to_encoder(self.slot, float(coor_abs*1000000), coor_enc)\n        if ret &lt; 0:\n            raise Exception(\"move_direct: conversion failed\")\n\n        self._isrunning_motor = True\n        ret = self.controller.move_absolute(self.slot, coor_enc[0])\n        if ret &lt; 0:\n            raise Exception(\"move_direct: move_absolute failed\")\n        self._wait_stop()\n        self._isrunning_motor = False\n\n    def move_continuous(self,dir):\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n        if self._isrunning_motor == True:\n            print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n            return\n\n        dir = self.dict_ctrl_remap[dir] # Remap the controls\n\n        if dir == 'zfwd':\n            self.controller.set_velocity(self.slot,1,self._vel)\n        elif dir == 'zrev':\n            self.controller.set_velocity(self.slot,0,self._vel)\n        else:\n            raise ValueError(\"Direction must be 'fwd' or 'rev'\")\n\n    def get_jog(self):\n        \"\"\"\n        Get the jog parameters for the motor\n\n        Returns:\n            tuple of floats: 3 elements: (jog_step [mm], jog_vel, jog_acc)\n\n        Note:\n            - jog_vel and jog_acc are not available in the MCM301 library\n        \"\"\"\n\n        jog_step_enc = [0]\n        self.controller.get_jog_params(self.slot, jog_step_enc)\n        pos_container = [0]\n        self.controller.convert_encoder_to_nm(self.slot, jog_step_enc[0], pos_container)\n        self._jog_step_mm = float(pos_container[0] * 1e-6)\n\n        return (self._jog_step_mm, None, None)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): Legacy parameter. Is ignored.\n            acc_rel (int, optional): Legacy parameter. Is ignored.\n        \"\"\"\n        if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n            raise ValueError(\"Distance must be a float\")\n\n        if dist_mm &lt; self._jog_step_min:\n            raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n        dist_enc = [0]\n        self.controller.convert_nm_to_encoder(self.slot, float(dist_mm*1000000), dist_enc)\n\n        # Set the jog step size\n        self.controller.set_jog_params(self.slot, dist_enc[0])\n\n    def move_jog(self,direction:str):\n        \"\"\"\n        Moves the motor with a single/continuous jogging motion until a stop command.\n\n        Args:\n            direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n        if self._isrunning_motor == True:\n            print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n            return\n\n        direction = self.dict_ctrl_remap[direction] # Remap the controls\n\n        self._isrunning_motor = True\n        if direction == 'zfwd':\n            self.controller.move_jog(self.slot, 1)\n        elif direction == 'zrev':\n            self.controller.move_jog(self.slot, 0)\n        else:\n            raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n        self._isrunning_motor = False\n        self._wait_stop()\n\n    def stop_move(self):\n        \"\"\"\n        Stops all motor movement. Will try 5 times before giving up.\n        \"\"\"\n        ret = self.controller.move_stop(self.slot)\n        for i in range(4):\n            if ret &lt; 0:\n                print(\"move_stop failed\")\n                time.sleep(0.5)\n                ret = self.controller.move_stop(self.slot)\n            else:\n                break\n\n        if ret &lt; 0:\n            raise Exception(\"stop_move: move_stop failed\")\n        else:\n            self._isrunning_motor = False\n\n    def _MoveTestAbsolute(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        distances = np.arange(0, 25, 2)\n        for i,distance in enumerate(distances):\n            print(i, distance)\n            self.move_direct(float(distance))\n\n    def _MoveTestJog(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        jog_step = 2 # [mm]\n        self.set_jog(jog_step)\n        for i in range(5):\n            print(self.get_coordinates())\n            self.move_jog('fwd')\n\n        jog_step = 1 # [mm]\n        self.set_jog(jog_step)\n        for i in range(10):\n            print(self.get_coordinates())\n            self.move_jog('rev')\n\n    def get_coordinates(self):\n        \"\"\"\n        Get the coordinates of the motor [mm]\n        \"\"\"\n        ret = self.controller.get_mot_status(self.slot, self.encoder, self.status_bit)\n\n        pos_container = [0]\n        self.controller.convert_encoder_to_nm(self.slot, self.encoder[0], pos_container)\n        position_mm = float(pos_container[0] * 1e-6)\n        return position_mm\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Get the coordinates of the motor [mm]</p> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"\n    Get the coordinates of the motor [mm]\n    \"\"\"\n    ret = self.controller.get_mot_status(self.slot, self.encoder, self.status_bit)\n\n    pos_container = [0]\n    self.controller.convert_encoder_to_nm(self.slot, self.encoder[0], pos_container)\n    position_mm = float(pos_container[0] * 1e-6)\n    return position_mm\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.get_jog","title":"<code>get_jog()</code>","text":"<p>Get the jog parameters for the motor</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (jog_step [mm], jog_vel, jog_acc)</p> Note <ul> <li>jog_vel and jog_acc are not available in the MCM301 library</li> </ul> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def get_jog(self):\n    \"\"\"\n    Get the jog parameters for the motor\n\n    Returns:\n        tuple of floats: 3 elements: (jog_step [mm], jog_vel, jog_acc)\n\n    Note:\n        - jog_vel and jog_acc are not available in the MCM301 library\n    \"\"\"\n\n    jog_step_enc = [0]\n    self.controller.get_jog_params(self.slot, jog_step_enc)\n    pos_container = [0]\n    self.controller.convert_encoder_to_nm(self.slot, jog_step_enc[0], pos_container)\n    self._jog_step_mm = float(pos_container[0] * 1e-6)\n\n    return (self._jog_step_mm, None, None)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def get_vel_acc_relative(self):\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    # Unfortunately the MCM301 library doesn't provide a way to get the velocity and acceleration parameters\n\n    return (self._vel,self._vel,float(100))\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. Also called as 'homing'</p> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def homing_n_coor_calibration(self):\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    Also called as 'homing'\n    \"\"\"\n    if self._isrunning_motor == True:\n        print('!!!!! Motor is running, homing request BLOCKED !!!!!')\n        return\n\n    result = self.controller.home(self.slot)\n    if result &lt; 0:\n        print(\"Homing failed\")\n        return\n\n    # Wait for the motor to stop moving\n    self._wait_stop()\n    self._isrunning_motor = False\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.initialisation","title":"<code>initialisation()</code>","text":"<p>Initialises the parameters</p> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def initialisation(self):\n    \"\"\"\n    Initialises the parameters\n    \"\"\"\n    self.controller.get_stage_params(self.slot, self.info)\n    dev_info:list = self.info[0]\n\n    self.min_hw_enc = dev_info[2]   # Minimum hardware position of the motor in encoder units\n    self.max_hw_enc = dev_info[3]   # Maximum hardware position of the motor in encoder units\n\n    pos_container = [0]\n    self.controller.convert_encoder_to_nm(self.slot, self.min_hw_enc, pos_container) * 1e-6\n    self.min_hw_mm = float(pos_container[0] * 1e-6)\n    self.controller.convert_encoder_to_nm(self.slot, self.max_hw_enc, pos_container) * 1e-6\n    self.max_hw_mm = float(pos_container[0] * 1e-6)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def move_continuous(self,dir):\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n    if self._isrunning_motor == True:\n        print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n        return\n\n    dir = self.dict_ctrl_remap[dir] # Remap the controls\n\n    if dir == 'zfwd':\n        self.controller.set_velocity(self.slot,1,self._vel)\n    elif dir == 'zrev':\n        self.controller.set_velocity(self.slot,0,self._vel)\n    else:\n        raise ValueError(\"Direction must be 'fwd' or 'rev'\")\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.move_direct","title":"<code>move_direct(coor_abs)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>float</code> <p>coordinate of the destination [mm]</p> required Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def move_direct(self,coor_abs):\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (float): coordinate of the destination [mm]\n    \"\"\"\n    if not isinstance(coor_abs, float) and not isinstance(coor_abs, int):\n        raise ValueError(\"Coordinate must be a float\")\n\n    coor_enc = [0]\n    ret = self.controller.convert_nm_to_encoder(self.slot, float(coor_abs*1000000), coor_enc)\n    if ret &lt; 0:\n        raise Exception(\"move_direct: conversion failed\")\n\n    self._isrunning_motor = True\n    ret = self.controller.move_absolute(self.slot, coor_enc[0])\n    if ret &lt; 0:\n        raise Exception(\"move_direct: move_absolute failed\")\n    self._wait_stop()\n    self._isrunning_motor = False\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single/continuous jogging motion until a stop command.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def move_jog(self,direction:str):\n    \"\"\"\n    Moves the motor with a single/continuous jogging motion until a stop command.\n\n    Args:\n        direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n    if self._isrunning_motor == True:\n        print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n        return\n\n    direction = self.dict_ctrl_remap[direction] # Remap the controls\n\n    self._isrunning_motor = True\n    if direction == 'zfwd':\n        self.controller.move_jog(self.slot, 1)\n    elif direction == 'zrev':\n        self.controller.move_jog(self.slot, 0)\n    else:\n        raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n    self._isrunning_motor = False\n    self._wait_stop()\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): Legacy parameter. Is ignored.\n        acc_rel (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n        raise ValueError(\"Distance must be a float\")\n\n    if dist_mm &lt; self._jog_step_min:\n        raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n    dist_enc = [0]\n    self.controller.convert_nm_to_encoder(self.slot, float(dist_mm*1000000), dist_enc)\n\n    # Set the jog step size\n    self.controller.set_jog_params(self.slot, dist_enc[0])\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>Legacy parameter. Is ignored.</p> <code>100</code> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100):\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): Legacy parameter. Is ignored.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): Legacy parameter. Is ignored.\n    \"\"\"\n    if vel_move &lt;= 0 or vel_move &gt; 100:\n        raise ValueError(\"Velocity and acceleration parameters must be larger than 0% and smaller than 100%\")\n\n    if not isinstance(vel_move, int) and not isinstance(vel_move, float):\n        raise ValueError(\"Velocity must be an integer\")\n\n    # Convert the percentage to the actual value\n    vel = vel_move\n\n    if isinstance(vel,float):\n        vel = int(vel)\n\n    if vel &gt; self._vel_max:\n        print(\"Maximum device velocity is {}\".format(self._vel_max))\n        vel = self._vel_max\n\n    if vel &lt; self._vel_min:\n        print(\"Minimum device velocity is {}\".format(self._vel_min))\n        vel = self._vel_min\n\n    # Update the stored value\n    self._vel = vel\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops all motor movement. Will try 5 times before giving up.</p> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def stop_move(self):\n    \"\"\"\n    Stops all motor movement. Will try 5 times before giving up.\n    \"\"\"\n    ret = self.controller.move_stop(self.slot)\n    for i in range(4):\n        if ret &lt; 0:\n            print(\"move_stop failed\")\n            time.sleep(0.5)\n            ret = self.controller.move_stop(self.slot)\n        else:\n            break\n\n    if ret &lt; 0:\n        raise Exception(\"stop_move: move_stop failed\")\n    else:\n        self._isrunning_motor = False\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_mcm301/#iris.controllers.z_stage_controller_mcm301.ZController_MCM301.terminate","title":"<code>terminate()</code>","text":"<p>Terminate the operation. Returns the stage to home and disconnects the device.</p> Source code in <code>iris/controllers/z_stage_controller_mcm301.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminate the operation. Returns the stage to home and disconnects the device.\n    \"\"\"\n    try:\n        self.controller.close()\n    except Exception as e:\n        print('Error in closing the device:')\n        print(e)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/","title":"z_stage_controller_pfm450","text":"<p>A class that allows the control of the Z825B Thorlabs stage. This implementation is based on the .NET Kinesis Libraries to connect to and control the stage.</p>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450","title":"<code>ZController_PFM450</code>","text":"<p>               Bases: <code>Class_ZController</code></p> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>class ZController_PFM450(Class_ZController):\n    def __init__(self,sim=False) -&gt; None:\n        self._serial_no = ControllerSpecificConfigEnum.PFM450_SERIAL.value # The device's serial number\n\n        self._dev = None            # Stores the device object\n        self._dev_info = None       # Stores the device information\n        self._channel = None        # Stores the channel object\n        self._channel_polling_ms = 50   # Polling rate in [ms]\n\n        self._isrunning_motor = False   # Running state of the motor. True: running, False: stopped\n\n        self._dict_ctrl_remap = {\n            'zfwd':ControllerDirectionEnum.ZFWD.value,\n            'zrev':ControllerDirectionEnum.ZREV.value\n        }   # Dictionary to remap the controls\n\n        self._min_travel:float = 0.0    # Minimum travel distance of the motor in [mm]\n        self._max_travel:float = None   # Maximum travel distance of the motor in [mm]\n\n        self._jog_step_mm = 0.01        # Stores the jog step size in [mm]\n        self._jog_step_min = 0.0002     # Minimum jog step size in [mm]\n\n        self._timeout_move_fast = 2000  # Waiting time for movements to finish (in milisecond, integer)\n        self._timeout_move_slow = 6000  # Waiting time for longer movements to finish (in milisecond, integer)\n        self._stoptime = 0.1            # Waiting time to stop the motor [sec] &gt; 0.75 otherwise error\n\n        self._issimulation = sim     # True: To use when interacting with 'Kinesis Simulator'\n        self._running = False        # Indicate the start and finish of the program.\n                                    # True for start (initialization) and False for finish (termination)\n\n\n        # Start by initializing the connection, device, motors, and their parameters\n        self._identifier = None\n        try: self.initialisation()\n        except Exception as e:\n            print('Run ABORTED due to error in intialization: ',e)\n            self.terminate(error_flag=True)\n\n        # The piezo controller does not need homing (not sure?) and so won't be used here\n\n    def get_identifier(self) -&gt; str:\n        if self._identifier is None:\n            self._identifier = self._get_hardware_identifier()\n        return self._identifier\n\n    def _get_hardware_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the hardware identifier of the stage.\n\n        Returns:\n            str: The hardware identifier of the stage\n        \"\"\"\n        identifier = f\"PFM450 Piezo Stage, S/N:{self._serial_no}\"\n        return identifier\n\n    def initialisation(self):\n        \"\"\"\n        Initialises the device, setup the connection, channels, motors and their parameters, etc.\n        \"\"\"\n        if self._issimulation:\n            print(\"&gt;&gt;&gt;&gt;&gt; INITIALISING SIMULATION &lt;&lt;&lt;&lt;&lt;\")\n            SimulationManager.Instance.InitializeSimulations()\n            print(\"&gt;&gt;&gt;&gt;&gt; Simulation Initialised &lt;&lt;&lt;&lt;&lt;\")\n        else:\n            print(\"&gt;&gt;&gt;&gt;&gt; NOT A SIMULATION &lt;&lt;&lt;&lt;&lt;\")\n\n        DeviceManagerCLI.BuildDeviceList()\n\n        # Creates the device object, based on the serial number we have\n        self._dev = BenchtopPrecisionPiezo.CreateBenchtopPiezo(self._serial_no)\n\n        # Connect, begin polling, and enable\n        self._dev.Connect(self._serial_no)\n        time.sleep(0.25)  # wait statements are important to allow settings to be sent to the device\n        self._channel = self._dev.GetChannel(1)\n        self._channel.StartPolling(self._channel_polling_ms)    # Start polling\n\n        # Check that the settings are initialised, else error.\n        if not self._channel.IsSettingsInitialized():\n        # if not x_channel.IsSettingsInitialized():\n            self._channel.WaitForSettingsInitialized(10000)  # 10 second timeout\n            assert self._channel.IsSettingsInitialized() is True\n\n        # Get channel information\n        self._max_travel = float(str(self._channel.GetMaxTravel()))\n\n        # Set the control mode\n        self._channel.SetPositionControlMode(Piezo.PiezoControlModeTypes.CloseLoop)\n        time.sleep(.25)\n\n    def terminate(self,error_flag=False):\n        \"\"\"\n        Terminate the operation. Returns the stage to home and disconnects the device.\n        \"\"\"\n\n        # Return the stage to Home\n        # if not error_flag:\n        #     self.homing_n_coor_calibration()\n\n        # Stop polling and disconnects the device\n        self._channel.StopPolling()\n        self._dev.Disconnect()\n\n        # Terminates the simulation (if it is a simulation, automatic detection)\n        if self._issimulation:\n            print(\"&gt;&gt;&gt;&gt;&gt; TERMINATING SIMULATION STOPPED &lt;&lt;&lt;&lt;&lt;\")\n            SimulationManager.Instance.UninitializeSimulations()\n        self._running = False\n\n    def get_vel_acc_relative(self):\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the channe.\n        In this case, everything is at 100% as they cannot be controlled\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        vel_homing = vel_move = acc_move = 100\n        return (vel_homing, vel_move, acc_move)\n\n    def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100):\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): New motor homing velocity in percentage of max velocity. Defaults to 100.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): New motor movement acceleration in percentage of max acceleration. Defaults to 100.\n\n        Note:\n            - Because of the piezo control, this function does not change the velocity and acceleration parameters.\n        \"\"\"\n        if vel_homing &lt;= 0 or vel_move &lt;= 0 or acc_move &lt;= 0:\n            raise ValueError(\"Velocity and acceleration parameters must be larger than 0%\")\n        if vel_homing &gt; 100 or vel_move &gt; 100 or acc_move &gt; 100:\n            raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n        return\n\n    def get_coordinates(self) -&gt; float:\n        \"\"\"\n        Get the coordinates of the motor\n\n        Returns:\n            float: coordinate of the motor in [mm]\n        \"\"\"\n        position_um = self._channel.GetPosition()\n        coor = float(str(position_um))/10**3\n        return coor\n\n    def move_direct(self,coor_abs,waittime_sec:float=0.5):\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (Decimal): coordinate of the destination in [mm]\n            waittime_sec (float, optional): Waiting time for the motor to stop. Defaults to 0.5.\n        \"\"\"\n        assert isinstance(coor_abs, (float,int)), \"Coordinate must be a Decimal or float\"\n        assert self._min_travel &lt;= coor_abs &lt;= self._max_travel, \"Coordinate out of bounds\"\n        assert isinstance(waittime_sec, (float,int)), \"Wait time must be a float\"\n        assert waittime_sec &gt; 0, 'Wait time must be greater than 0'\n\n        # Convert the coordinates to decimals if floats are received\n        if self._isrunning_motor == True:\n            print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n            return\n\n        self._isrunning_motor = True\n\n        decimal_coor_abs_um = Decimal(float(coor_abs*10**3))\n        self._channel.SetPosition(decimal_coor_abs_um)\n        self._isrunning_motor = False\n        time.sleep(waittime_sec) # Wait for the motor to stop\n\n    def move_continuous(self,dir):\n        \"\"\"\n        NOT AVAILABLE for this device: Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n        print('z_stage_controller.move_continuous() is NOT AVAILABLE for piezo devices')\n        return\n\n    def homing_n_coor_calibration(self):\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        - Also called as 'homing'\n        \"\"\"\n        if self._isrunning_motor == True:\n            print('!!!!! Motor is running, homing request BLOCKED !!!!!')\n            return\n\n        print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n        self._isrunning_motor = True\n        self.move_direct(coor_abs=0.0)\n        self._isrunning_motor = False\n        print(\"&lt;&lt;&lt;&lt;&lt; Coordinate calibration/Homing finished &gt;&gt;&gt;&gt;&gt;\")\n\n    def get_jog(self) -&gt; tuple[float,float,float]:\n        \"\"\"\n        Get the jog parameters for the motor\n\n        Returns:\n            tuple of floats: 3 elements: (jog_step, jog_vel, jog_acc)\n\n        Note:\n            - The jog velocity and acceleration are not controlled by the user and are set to 100%.\n        \"\"\"\n        return (self._jog_step_mm, 100, 100)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): velocity in percentage of max velocity. Defaults to 100.\n            acc_rel (int, optional): acceleration in percentage of max acceleration. Defaults to 100.\n        \"\"\"\n        assert isinstance(dist_mm, (float,int)), \"Distance must be a float\"\n        assert dist_mm &gt;= self._jog_step_min,\"Minimum jog step size is {}\".format(self._jog_step_min)\n\n        self._jog_step_mm = dist_mm\n\n    def move_jog(self,direction:str):\n        \"\"\"\n        Moves the motor with a single/continuous jogging motion until a stop command.\n\n        Args:\n            direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n        if not isinstance(direction, str):\n            raise ValueError(\"Direction must be a string\")\n        if direction not in ['zfwd', 'zrev']:\n            raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n        direction = self._dict_ctrl_remap[direction] # Remap the controls\n\n        coor = self.get_coordinates()\n        if direction == 'zfwd':\n            coor_target = coor + self._jog_step_mm\n        elif direction == 'zrev':\n            coor_target = coor - self._jog_step_mm\n\n        if coor_target &lt; self._min_travel: coor_target = self._min_travel\n        elif coor_target &gt; self._max_travel: coor_target = self._max_travel\n\n        try: self.move_direct(coor_target,waittime_sec=0.1)\n        except: pass\n\n    def stop_move(self):\n        \"\"\"\n        Stop is NOT AVAILABLE for this device. This is because\n        move_continuous() is also not available. And the move_direct() function\n        is already blocking and waits for the movement to stop.\n        \"\"\"\n        print('Stop is not available for piezo devices')\n        return\n\n    def MoveTestAbsolute(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        distances = np.arange(0, 0.450, 0.020)\n        for i,distance in enumerate(distances):\n            print(i, distance)\n            self.move_direct(float(distance))\n\n    def MoveTestJog(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        jog_step = 0.05 # [mm]\n        self.set_jog(jog_step)\n        for i in range(20):\n            print(self.get_coordinates())\n            self.move_jog('zrev')\n\n        jog_step = 0.05 # [mm]\n        self.set_jog(jog_step)\n        for i in range(20):\n            print(self.get_coordinates())\n            self.move_jog('zfwd')\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.MoveTestAbsolute","title":"<code>MoveTestAbsolute()</code>","text":"<p>Test the motor movement</p> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def MoveTestAbsolute(self):\n    \"\"\"\n    Test the motor movement\n    \"\"\"\n    # Stops at every few points\n    distances = np.arange(0, 0.450, 0.020)\n    for i,distance in enumerate(distances):\n        print(i, distance)\n        self.move_direct(float(distance))\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.MoveTestJog","title":"<code>MoveTestJog()</code>","text":"<p>Test the motor movement</p> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def MoveTestJog(self):\n    \"\"\"\n    Test the motor movement\n    \"\"\"\n    # Stops at every few points\n    jog_step = 0.05 # [mm]\n    self.set_jog(jog_step)\n    for i in range(20):\n        print(self.get_coordinates())\n        self.move_jog('zrev')\n\n    jog_step = 0.05 # [mm]\n    self.set_jog(jog_step)\n    for i in range(20):\n        print(self.get_coordinates())\n        self.move_jog('zfwd')\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Get the coordinates of the motor</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>coordinate of the motor in [mm]</p> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def get_coordinates(self) -&gt; float:\n    \"\"\"\n    Get the coordinates of the motor\n\n    Returns:\n        float: coordinate of the motor in [mm]\n    \"\"\"\n    position_um = self._channel.GetPosition()\n    coor = float(str(position_um))/10**3\n    return coor\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.get_jog","title":"<code>get_jog()</code>","text":"<p>Get the jog parameters for the motor</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple of floats: 3 elements: (jog_step, jog_vel, jog_acc)</p> Note <ul> <li>The jog velocity and acceleration are not controlled by the user and are set to 100%.</li> </ul> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def get_jog(self) -&gt; tuple[float,float,float]:\n    \"\"\"\n    Get the jog parameters for the motor\n\n    Returns:\n        tuple of floats: 3 elements: (jog_step, jog_vel, jog_acc)\n\n    Note:\n        - The jog velocity and acceleration are not controlled by the user and are set to 100%.\n    \"\"\"\n    return (self._jog_step_mm, 100, 100)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the channe. In this case, everything is at 100% as they cannot be controlled</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def get_vel_acc_relative(self):\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the channe.\n    In this case, everything is at 100% as they cannot be controlled\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    vel_homing = vel_move = acc_move = 100\n    return (vel_homing, vel_move, acc_move)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. - Also called as 'homing'</p> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def homing_n_coor_calibration(self):\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    - Also called as 'homing'\n    \"\"\"\n    if self._isrunning_motor == True:\n        print('!!!!! Motor is running, homing request BLOCKED !!!!!')\n        return\n\n    print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n    self._isrunning_motor = True\n    self.move_direct(coor_abs=0.0)\n    self._isrunning_motor = False\n    print(\"&lt;&lt;&lt;&lt;&lt; Coordinate calibration/Homing finished &gt;&gt;&gt;&gt;&gt;\")\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.initialisation","title":"<code>initialisation()</code>","text":"<p>Initialises the device, setup the connection, channels, motors and their parameters, etc.</p> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def initialisation(self):\n    \"\"\"\n    Initialises the device, setup the connection, channels, motors and their parameters, etc.\n    \"\"\"\n    if self._issimulation:\n        print(\"&gt;&gt;&gt;&gt;&gt; INITIALISING SIMULATION &lt;&lt;&lt;&lt;&lt;\")\n        SimulationManager.Instance.InitializeSimulations()\n        print(\"&gt;&gt;&gt;&gt;&gt; Simulation Initialised &lt;&lt;&lt;&lt;&lt;\")\n    else:\n        print(\"&gt;&gt;&gt;&gt;&gt; NOT A SIMULATION &lt;&lt;&lt;&lt;&lt;\")\n\n    DeviceManagerCLI.BuildDeviceList()\n\n    # Creates the device object, based on the serial number we have\n    self._dev = BenchtopPrecisionPiezo.CreateBenchtopPiezo(self._serial_no)\n\n    # Connect, begin polling, and enable\n    self._dev.Connect(self._serial_no)\n    time.sleep(0.25)  # wait statements are important to allow settings to be sent to the device\n    self._channel = self._dev.GetChannel(1)\n    self._channel.StartPolling(self._channel_polling_ms)    # Start polling\n\n    # Check that the settings are initialised, else error.\n    if not self._channel.IsSettingsInitialized():\n    # if not x_channel.IsSettingsInitialized():\n        self._channel.WaitForSettingsInitialized(10000)  # 10 second timeout\n        assert self._channel.IsSettingsInitialized() is True\n\n    # Get channel information\n    self._max_travel = float(str(self._channel.GetMaxTravel()))\n\n    # Set the control mode\n    self._channel.SetPositionControlMode(Piezo.PiezoControlModeTypes.CloseLoop)\n    time.sleep(.25)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>NOT AVAILABLE for this device: Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def move_continuous(self,dir):\n    \"\"\"\n    NOT AVAILABLE for this device: Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n    print('z_stage_controller.move_continuous() is NOT AVAILABLE for piezo devices')\n    return\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.move_direct","title":"<code>move_direct(coor_abs, waittime_sec=0.5)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>Decimal</code> <p>coordinate of the destination in [mm]</p> required <code>waittime_sec</code> <code>float</code> <p>Waiting time for the motor to stop. Defaults to 0.5.</p> <code>0.5</code> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def move_direct(self,coor_abs,waittime_sec:float=0.5):\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (Decimal): coordinate of the destination in [mm]\n        waittime_sec (float, optional): Waiting time for the motor to stop. Defaults to 0.5.\n    \"\"\"\n    assert isinstance(coor_abs, (float,int)), \"Coordinate must be a Decimal or float\"\n    assert self._min_travel &lt;= coor_abs &lt;= self._max_travel, \"Coordinate out of bounds\"\n    assert isinstance(waittime_sec, (float,int)), \"Wait time must be a float\"\n    assert waittime_sec &gt; 0, 'Wait time must be greater than 0'\n\n    # Convert the coordinates to decimals if floats are received\n    if self._isrunning_motor == True:\n        print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n        return\n\n    self._isrunning_motor = True\n\n    decimal_coor_abs_um = Decimal(float(coor_abs*10**3))\n    self._channel.SetPosition(decimal_coor_abs_um)\n    self._isrunning_motor = False\n    time.sleep(waittime_sec) # Wait for the motor to stop\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single/continuous jogging motion until a stop command.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def move_jog(self,direction:str):\n    \"\"\"\n    Moves the motor with a single/continuous jogging motion until a stop command.\n\n    Args:\n        direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n    if not isinstance(direction, str):\n        raise ValueError(\"Direction must be a string\")\n    if direction not in ['zfwd', 'zrev']:\n        raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n    direction = self._dict_ctrl_remap[direction] # Remap the controls\n\n    coor = self.get_coordinates()\n    if direction == 'zfwd':\n        coor_target = coor + self._jog_step_mm\n    elif direction == 'zrev':\n        coor_target = coor - self._jog_step_mm\n\n    if coor_target &lt; self._min_travel: coor_target = self._min_travel\n    elif coor_target &gt; self._max_travel: coor_target = self._max_travel\n\n    try: self.move_direct(coor_target,waittime_sec=0.1)\n    except: pass\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>acceleration in percentage of max acceleration. Defaults to 100.</p> <code>100</code> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): velocity in percentage of max velocity. Defaults to 100.\n        acc_rel (int, optional): acceleration in percentage of max acceleration. Defaults to 100.\n    \"\"\"\n    assert isinstance(dist_mm, (float,int)), \"Distance must be a float\"\n    assert dist_mm &gt;= self._jog_step_min,\"Minimum jog step size is {}\".format(self._jog_step_min)\n\n    self._jog_step_mm = dist_mm\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>New motor homing velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>New motor movement acceleration in percentage of max acceleration. Defaults to 100.</p> <code>100</code> Note <ul> <li>Because of the piezo control, this function does not change the velocity and acceleration parameters.</li> </ul> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100):\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): New motor homing velocity in percentage of max velocity. Defaults to 100.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): New motor movement acceleration in percentage of max acceleration. Defaults to 100.\n\n    Note:\n        - Because of the piezo control, this function does not change the velocity and acceleration parameters.\n    \"\"\"\n    if vel_homing &lt;= 0 or vel_move &lt;= 0 or acc_move &lt;= 0:\n        raise ValueError(\"Velocity and acceleration parameters must be larger than 0%\")\n    if vel_homing &gt; 100 or vel_move &gt; 100 or acc_move &gt; 100:\n        raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n    return\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.stop_move","title":"<code>stop_move()</code>","text":"<p>Stop is NOT AVAILABLE for this device. This is because move_continuous() is also not available. And the move_direct() function is already blocking and waits for the movement to stop.</p> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def stop_move(self):\n    \"\"\"\n    Stop is NOT AVAILABLE for this device. This is because\n    move_continuous() is also not available. And the move_direct() function\n    is already blocking and waits for the movement to stop.\n    \"\"\"\n    print('Stop is not available for piezo devices')\n    return\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.ZController_PFM450.terminate","title":"<code>terminate(error_flag=False)</code>","text":"<p>Terminate the operation. Returns the stage to home and disconnects the device.</p> Source code in <code>iris/controllers/z_stage_controller_pfm450.py</code> <pre><code>def terminate(self,error_flag=False):\n    \"\"\"\n    Terminate the operation. Returns the stage to home and disconnects the device.\n    \"\"\"\n\n    # Return the stage to Home\n    # if not error_flag:\n    #     self.homing_n_coor_calibration()\n\n    # Stop polling and disconnects the device\n    self._channel.StopPolling()\n    self._dev.Disconnect()\n\n    # Terminates the simulation (if it is a simulation, automatic detection)\n    if self._issimulation:\n        print(\"&gt;&gt;&gt;&gt;&gt; TERMINATING SIMULATION STOPPED &lt;&lt;&lt;&lt;&lt;\")\n        SimulationManager.Instance.UninitializeSimulations()\n    self._running = False\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_pfm450/#iris.controllers.z_stage_controller_pfm450.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/","title":"z_stage_controller_z825b","text":"<p>A class that allows the control of the Z825B Thorlabs stage. This implementation is based on the .NET Kinesis Libraries to connect to and control the stage.</p>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B","title":"<code>ZController_Z825B</code>","text":"<p>               Bases: <code>Class_ZController</code></p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>class ZController_Z825B(Class_ZController):\n    def __init__(self,sim=False) -&gt; None:\n        self.serial_no = ControllerSpecificConfigEnum.Z825B_SERIAL.value\n\n        self.dev = None             # Stores the device object\n        self.dev_info = None        # Stores the device information\n\n        self.mdev_config = None         # Stores the motor config of the device\n        self.mdev_homing = None         # Motor homing parameters object for coordinate calibration\n        self._isrunning_motor = False   # Running state of the motor. True: running, False: stopped\n\n        self.unit_converter = None      # Unit converter for motor\n        self.convert_type_length = None # Type of conversion for length\n\n        self.dict_ctrl_remap = {\n            'zfwd':ControllerDirectionEnum.ZFWD.value,\n            'zrev':ControllerDirectionEnum.ZREV.value\n        }   # Dictionary to remap the controls\n\n        self._jog_step = None       # Stores the jog step size in [mm]\n        self._jog_vel = None        # Stores the jog velocity in [mm/s]\n        self._jog_acc = None        # Stores the jog acceleration in [mm/s^2]\n        self._jog_step_min = 0.0002 # Minimum jog step size in [mm]\n\n        self._vel_max = float(2.3)  # Maximum velocity of the motor\n        self._vel_min = float(0.1)  # Minimum velocity of the motor\n        self._acc_max = float(4.0)  # Maximum acceleration of the motor\n        self._acc_min = float(0.1)  # Minimum acceleration of the motor\n\n        self.vel_homing = float(2.3)    # Homing velocity\n        self.vel_move = float(2.3)      # Other movement velocity (everything else other than homing operation)\n        self.acc_move = float(4.0)      # Other movement acceleration (^^^^^ as above ^^^^^)\n        self.timeout_move_fast = 20000  # Waiting time for movements to finish (in milisecond, integer)\n        self.timeout_move_slow = 60000  # Waiting time for longer movements to finish (in milisecond, integer)\n        self.stoptime = 0.85            # Waiting time to stop the motor [sec] &gt; 0.75 otherwise error\n\n        self.issimulation = sim     # True: To use when interacting with 'Kinesis Simulator'\n        self.running = False        # Indicate the start and finish of the program.\n                                    # True for start (initialization) and False for finish (termination)\n\n\n        # Start by initializing the connection, device, motors, and their parameters\n        self._identifier = None\n        try:\n            self.initialisation()\n        except Exception as e:\n            print('Run ABORTED due to error in intialization:')\n            print(e)\n            self.terminate(error_flag=True)\n\n        # Continue by setting up the motors and initializing (calibrating) the coordinate system of the motors\n        try:\n            self._set_vel_acc()\n            if self.dev.NeedsHoming:\n                self.homing_n_coor_calibration()\n        except Exception as e:\n            print('Coordinate calibration has failed:')\n            print(e)\n            self.terminate(error_flag=True)\n\n    def get_identifier(self) -&gt; str:\n        if self._identifier is None:\n            self._identifier = self._get_hardware_identifier()\n        return self._identifier\n\n    def _get_hardware_identifier(self) -&gt; str:\n        \"\"\"\n        Returns the hardware identifier of the stage.\n\n        Returns:\n            str: The hardware identifier of the stage\n        \"\"\"\n        return f\"Z825B, S/N:{self.serial_no}\"\n\n    def initialisation(self):\n        \"\"\"\n        Initialises the device, setup the connection, channels, motors and their parameters, etc.\n        \"\"\"\n        if self.issimulation:\n            print(\"&gt;&gt;&gt;&gt;&gt; INITIALISING SIMULATION &lt;&lt;&lt;&lt;&lt;\")\n            SimulationManager.Instance.InitializeSimulations()\n            print(\"&lt;&lt;&lt;&lt;&lt; Simulation Initialised &gt;&gt;&gt;&gt;&gt;\")\n        else:\n            print(\"&lt;&lt;&lt;&lt;&lt; NOT A SIMULATION &gt;&gt;&gt;&gt;&gt;\")\n\n        DeviceManagerCLI.BuildDeviceList()\n\n        # Creates the device object, based on the serial number we have\n        self.dev = TCubeDCServo.CreateTCubeDCServo(self.serial_no)\n\n        # Connect, begin polling, and enable\n        self.dev.Connect(self.serial_no)\n        time.sleep(0.25)  # wait statements are important to allow settings to be sent to the device\n\n        # Start polling and enables the device\n        self.dev.StartPolling(250)\n        time.sleep(0.25)  # wait statements are important to allow settings to be sent to the device\n        self.dev.EnableDevice()\n        time.sleep(0.25)  # Wait for device to enable\n\n        # Get Device Information and display description\n        self.dev_info = self.dev.GetDeviceInfo()\n        print('Connected to: ' + self.dev_info.Description)\n\n        # Check that the settings are initialised, else error.\n        if not self.dev.IsSettingsInitialized():\n        # if not x_channel.IsSettingsInitialized():\n            self.dev.WaitForSettingsInitialized(10000)  # 10 second timeout\n            assert self.dev.IsSettingsInitialized() is True\n\n        # Load the motor configuration on the channel\n        self.mdev_config = self.dev.LoadMotorConfiguration(self.serial_no,DeviceConfiguration.DeviceSettingsUseOptionType.UseFileSettings)\n        self.mdev_config.DeviceSettingsName = \"Z825B\"\n        print('fix device config info here')\n        self.mdev_config.UpdateCurrentConfiguration()\n        self.dev.SetSettings(self.dev.MotorDeviceSettings, True, False)\n        ...\n        # Get the Homing Params for coordinate calibration(ccal)\n        self.mdev_homing = self.dev.GetHomingParams()\n\n        # Set the movement velocity and acceleration parameters\n        self.mdev_mvmt = self.dev.GetVelocityParams()\n\n        print('\\n&lt;&lt;&lt;&lt;&lt; Device and motor initialisation complete &gt;&gt;&gt;&gt;&gt;')\n        self.running = True\n\n        # Set the motor unit converter for coordinate retrieval\n        self.unit_converter = self.dev.UnitConverter\n        self.convert_type_length = self.unit_converter.UnitType(0)\n\n    def get_vel_acc_relative(self):\n        \"\"\"\n        Returns the current velocity and acceleration parameters of the motors\n\n        Returns:\n            tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n        \"\"\"\n        # Get the Homing Params for coordinate calibration(ccal)\n        self.mdev_homing = self.dev.GetHomingParams()\n\n        # Set the movement velocity and acceleration parameters\n        self.mdev_mvmt = self.dev.GetVelocityParams()\n\n        # Get the maximum velocity and acceleration of the motors\n        self._vel_homing = float(str(self.mdev_homing.Velocity))\n        self._vel_move = float(str(self.mdev_mvmt.MaxVelocity))\n        self._acc_move = float(str(self.mdev_mvmt.Acceleration))\n\n        # Convert the actual value to percentage\n        vel_homing = self._vel_homing * 100 / self._vel_max\n        vel_move = self._vel_move * 100 / self._vel_max\n        acc_move = self._acc_move * 100 / self._acc_max\n\n        return (vel_homing, vel_move, acc_move)\n\n    def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100):\n        \"\"\"\n        Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n        Args:\n            vel_homing (int, optional): New motor homing velocity in percentage of max velocity. Defaults to 100.\n            vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n            acc_move (int, optional): New motor movement acceleration in percentage of max acceleration. Defaults to 100.\n        \"\"\"\n        if vel_homing &lt;= 0 or vel_move &lt;= 0 or acc_move &lt;= 0:\n            raise ValueError(\"Velocity and acceleration parameters must be larger than 0%\")\n        if vel_homing &gt; 100 or vel_move &gt; 100 or acc_move &gt; 100:\n            raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n        # Convert the percentage to the actual value\n        vel_homing = self._vel_max * vel_homing / 100\n        vel_move = self._vel_max * vel_move / 100\n        acc_move = self._acc_max * acc_move / 100\n\n        self._set_vel_acc(vel_homing, vel_move, acc_move)\n\n    def _set_vel_acc(self,vel_homing:float=None, vel_move:float=None, acc_move:float=None):\n        \"\"\"\n        Function to setup the velocity and acceleration parameters of the motors\n        for both homing and typical movements. Will be applied equally to both x and y motors\n\n        Args:\n            vel_homing (float, optional): New motor homing velocity. Defaults to None.\n            vel_move (float, optional): New motor movement velocity. Defaults to None.\n            acc_move (float, optional): New motor movement acceleration. Defaults to None.\n        \"\"\"\n\n        if vel_homing == None and vel_move == None and acc_move == None:\n            vel_homing = self.vel_homing\n            vel_move = self.vel_move\n            acc_move = self.acc_move\n\n        # Modify the homing velocity if requested\n        if vel_homing is not None:\n            if not isinstance(vel_homing, float):\n                raise ValueError(\"Velocity must be a float\")\n\n            # Set a hard limit to protect the motor\n            if vel_homing &gt; self._vel_max:\n                print(\"Maximum device velocity is {}\".format(self._vel_max))\n                vel_homing = self._vel_max\n\n            # Updates the stored value\n            self._vel_homing = float(vel_homing)\n            vel_homing = Decimal(vel_homing)\n\n            # Modify the value in the motors\n            self.mdev_homing.Velocity = vel_homing\n\n        # Modify the movement velocity and acceleration parameters if requested\n        if vel_move is not None:\n            if not isinstance(vel_move, float) or isinstance(vel_move, int):\n                raise ValueError(\"Velocity must be a float\")\n\n            if vel_move &gt; self._vel_max:\n                print(\"Maximum device velocity is {}\".format(self._vel_max))\n                vel_move = self._vel_max\n\n            # Updates the stored value\n            self._vel_move = float(vel_move)\n            vel_move = Decimal(vel_move)\n\n            # Modify the value in the motors\n            self.mdev_mvmt.MaxVelocity = vel_move\n\n        if acc_move is not None:\n            if not isinstance(acc_move, float):\n                raise ValueError(\"Velocity must be a float\")\n\n            if acc_move &gt; self._acc_max:\n                print(\"Maximum device velocity is {}\".format(self._acc_max))\n                acc_move = self._acc_max\n\n            # Updates the stored value\n            self._acc_move = float(acc_move)\n            acc_move = Decimal(acc_move)\n\n            # Modify the value in the motors\n            self.mdev_mvmt.Acceleration = acc_move\n\n        # Assign the set parameters to the motors\n        self.dev.SetHomingParams(self.mdev_homing)\n\n        # Assign the velocity and acceleration parameters to the motors\n        self.dev.SetVelocityParams(self.mdev_mvmt)\n\n    def get_coordinates_old(self):\n        \"\"\"\n        Returns the current motor coordinate. Does not work for ~0.5 seconds after a movement command.\n        DO NOT USE THIS FUNCTION. USE get_coordinates() INSTEAD.\n        Kept here for reference.\n\n        Returns:\n            float: motor coordinate\n        \"\"\"\n        coor = float(str(self.dev.Position))\n        return coor\n\n    def homing_n_coor_calibration(self):\n        \"\"\"\n        A function to recalibrate the coordinate system of the device.\n        - Also called as 'homing'\n        \"\"\"\n        if self._isrunning_motor == True:\n            print('!!!!! Motor is running, homing request BLOCKED !!!!!')\n            return\n\n        print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n        self._isrunning_motor = True\n        timeout_rel = int(self.timeout_move_slow * self._vel_max/self._vel_homing)\n        self.dev.Home(timeout_rel)\n        self._isrunning_motor = False\n        print(\"&lt;&lt;&lt;&lt;&lt; Coordinate calibration/Homing finished &gt;&gt;&gt;&gt;&gt;\")\n\n    def terminate(self,error_flag=False):\n        \"\"\"\n        Terminate the operation. Returns the stage to home and disconnects the device.\n        \"\"\"\n\n        # Return the stage to Home\n        # if not error_flag:\n        #     self.homing_n_coor_calibration()\n\n        # Stop polling and disconnects the device\n        self.dev.StopPolling()\n        self.dev.Disconnect()\n\n        # Terminates the simulation (if it is a simulation, automatic detection)\n        if self.issimulation:\n            print(\"&gt;&gt;&gt;&gt;&gt; TERMINATING SIMULATION STOPPED &lt;&lt;&lt;&lt;&lt;\")\n            SimulationManager.Instance.UninitializeSimulations()\n        self.running = False\n\n    def move_direct(self,coor_abs):\n        \"\"\"\n        Function to direct the motors to move at the same time towards a certain coordinate.\n\n        Args:\n            coor_abs (Decimal): coordinate of the destination\n        \"\"\"\n        # Convert the coordinates to decimals if floats are received\n        if type(coor_abs) is float:\n            coor_abs= Decimal(coor_abs)\n\n        if self._isrunning_motor == True:\n            print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n            return\n\n        self._isrunning_motor = True\n\n        timeout_rel = int(self.timeout_move_fast * self._vel_max/self._vel_move)\n        self.dev.MoveTo(coor_abs,timeout_rel)\n        self._isrunning_motor = False\n        time.sleep(0.85)\n\n    def move_continuous(self,dir):\n        \"\"\"\n        Moves the motor with a continuous motion until a stop command\n\n        Args:\n            dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n        if self._isrunning_motor == True:\n            print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n            return\n\n        dir = self.dict_ctrl_remap[dir] # Remap the controls\n\n        if dir == 'zfwd':\n            direction = MotorDirection.Forward\n        elif dir == 'zrev':\n            direction = MotorDirection.Backward\n\n        try:\n            self.dev.MoveContinuous(direction)\n            # Update the motor running state\n            self._isrunning_motor = True\n        except Exception as errormessage:\n            print(errormessage)\n\n    def get_jog(self):\n        \"\"\"\n        Get the jog parameters for the motor\n\n        Returns:\n            tuple of floats: 3 elements: (jog_step, jog_vel, jog_acc)\n        \"\"\"\n        JogParams = self.dev.GetJogParams()\n        self._jog_step = float(str(JogParams.StepSize))\n        VelocityParams = JogParams.VelocityParams\n        self._jog_vel = float(str(VelocityParams.MaxVelocity))\n        self._jog_acc = float(str(VelocityParams.Acceleration))\n\n\n        print('z_stage_controller.get_jog() is NOT TESTED yet')\n\n        return (self._jog_step, self._jog_vel, self._jog_acc)\n\n    def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n        \"\"\"\n        Set the jog parameters for the motor\n\n        Args:\n            dist_mm (float): distance to jog in mm\n            vel_rel (int, optional): velocity in percentage of max velocity. Defaults to 100.\n            acc_rel (int, optional): acceleration in percentage of max acceleration. Defaults to 100.\n        \"\"\"\n        if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n            raise ValueError(\"Distance must be a float\")\n\n        if dist_mm &lt; self._jog_step_min:\n            raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n        dist_mm = float(dist_mm)\n\n        JogParams = self.dev.GetJogParams()\n        VelocityParams = JogParams.VelocityParams\n\n        if not isinstance(vel_rel, int) or isinstance(vel_rel, float):\n            raise ValueError(\"Velocity must be an integer\")\n        if not isinstance(acc_rel, int) or isinstance(acc_rel, float):\n            raise ValueError(\"Acceleration must be an integer\")\n        VelocityParams.MaxVelocity = Decimal(self._vel_max * vel_rel / 100)\n        VelocityParams.Acceleration = Decimal(self._acc_max * acc_rel / 100)\n\n        JogParams.StepSize = Decimal(dist_mm)\n        self.dev.SetJogParams(JogParams)\n\n        print('z_stage_controller.set_jog() is NOT TESTED yet')\n        pass\n\n    def move_jog(self,direction:str):\n        \"\"\"\n        Moves the motor with a single/continuous jogging motion until a stop command.\n\n        Args:\n            direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n        \"\"\"\n        timeout_rel = int(self.timeout_move_fast * self._vel_max/self._vel_move)\n\n        if not isinstance(direction, str):\n            raise ValueError(\"Direction must be a string\")\n        if direction not in ['zfwd', 'zrev']:\n            raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n        if self._isrunning_motor == True:\n            print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n            return\n\n        direction = self.dict_ctrl_remap[direction] # Remap the controls\n\n        self._isrunning_motor = True\n        if direction == 'zfwd':\n            self.dev.MoveJog(MotorDirection.Forward,timeout_rel)\n        elif direction == 'zrev':\n            self.dev.MoveJog(MotorDirection.Backward,timeout_rel)\n        self._isrunning_motor = False\n\n    def stop_move(self):\n        \"\"\"\n        Stops all motor movement\n        \"\"\"\n        self.dev.Stop(0)\n        time.sleep(self.stoptime)   # Wait to allow the motors to stop completely\n        self._isrunning_motor = False         # Update the motor state\n\n    def MoveTestAbsolute(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        distances = np.arange(0, 25, 2)\n        for i,distance in enumerate(distances):\n            print(i, distance)\n            self.move_direct(float(distance))\n\n    def MoveTestJog(self):\n        \"\"\"\n        Test the motor movement\n        \"\"\"\n        # Stops at every few points\n        jog_step = 2 # [mm]\n        self.set_jog(jog_step)\n        for i in range(5):\n            print(self.get_coordinates())\n            self.move_jog('fwd')\n\n        jog_step = 1 # [mm]\n        self.set_jog(jog_step)\n        for i in range(10):\n            print(self.get_coordinates())\n            self.move_jog('rev')\n\n    def get_coordinates(self):\n        \"\"\"\n        Get the coordinates of the motor\n        \"\"\"\n        position = Decimal(self.dev.GetPositionCounter())\n        coor = float(str(self.unit_converter.DeviceUnitToReal(position,self.convert_type_length)))\n        return coor\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.MoveTestAbsolute","title":"<code>MoveTestAbsolute()</code>","text":"<p>Test the motor movement</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def MoveTestAbsolute(self):\n    \"\"\"\n    Test the motor movement\n    \"\"\"\n    # Stops at every few points\n    distances = np.arange(0, 25, 2)\n    for i,distance in enumerate(distances):\n        print(i, distance)\n        self.move_direct(float(distance))\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.MoveTestJog","title":"<code>MoveTestJog()</code>","text":"<p>Test the motor movement</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def MoveTestJog(self):\n    \"\"\"\n    Test the motor movement\n    \"\"\"\n    # Stops at every few points\n    jog_step = 2 # [mm]\n    self.set_jog(jog_step)\n    for i in range(5):\n        print(self.get_coordinates())\n        self.move_jog('fwd')\n\n    jog_step = 1 # [mm]\n    self.set_jog(jog_step)\n    for i in range(10):\n        print(self.get_coordinates())\n        self.move_jog('rev')\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.get_coordinates","title":"<code>get_coordinates()</code>","text":"<p>Get the coordinates of the motor</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def get_coordinates(self):\n    \"\"\"\n    Get the coordinates of the motor\n    \"\"\"\n    position = Decimal(self.dev.GetPositionCounter())\n    coor = float(str(self.unit_converter.DeviceUnitToReal(position,self.convert_type_length)))\n    return coor\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.get_coordinates_old","title":"<code>get_coordinates_old()</code>","text":"<p>Returns the current motor coordinate. Does not work for ~0.5 seconds after a movement command. DO NOT USE THIS FUNCTION. USE get_coordinates() INSTEAD. Kept here for reference.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>motor coordinate</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def get_coordinates_old(self):\n    \"\"\"\n    Returns the current motor coordinate. Does not work for ~0.5 seconds after a movement command.\n    DO NOT USE THIS FUNCTION. USE get_coordinates() INSTEAD.\n    Kept here for reference.\n\n    Returns:\n        float: motor coordinate\n    \"\"\"\n    coor = float(str(self.dev.Position))\n    return coor\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.get_jog","title":"<code>get_jog()</code>","text":"<p>Get the jog parameters for the motor</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (jog_step, jog_vel, jog_acc)</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def get_jog(self):\n    \"\"\"\n    Get the jog parameters for the motor\n\n    Returns:\n        tuple of floats: 3 elements: (jog_step, jog_vel, jog_acc)\n    \"\"\"\n    JogParams = self.dev.GetJogParams()\n    self._jog_step = float(str(JogParams.StepSize))\n    VelocityParams = JogParams.VelocityParams\n    self._jog_vel = float(str(VelocityParams.MaxVelocity))\n    self._jog_acc = float(str(VelocityParams.Acceleration))\n\n\n    print('z_stage_controller.get_jog() is NOT TESTED yet')\n\n    return (self._jog_step, self._jog_vel, self._jog_acc)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.get_vel_acc_relative","title":"<code>get_vel_acc_relative()</code>","text":"<p>Returns the current velocity and acceleration parameters of the motors</p> <p>Returns:</p> Type Description <p>tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def get_vel_acc_relative(self):\n    \"\"\"\n    Returns the current velocity and acceleration parameters of the motors\n\n    Returns:\n        tuple of floats: 3 elements: (vel_homing, vel_move, acc_move)\n    \"\"\"\n    # Get the Homing Params for coordinate calibration(ccal)\n    self.mdev_homing = self.dev.GetHomingParams()\n\n    # Set the movement velocity and acceleration parameters\n    self.mdev_mvmt = self.dev.GetVelocityParams()\n\n    # Get the maximum velocity and acceleration of the motors\n    self._vel_homing = float(str(self.mdev_homing.Velocity))\n    self._vel_move = float(str(self.mdev_mvmt.MaxVelocity))\n    self._acc_move = float(str(self.mdev_mvmt.Acceleration))\n\n    # Convert the actual value to percentage\n    vel_homing = self._vel_homing * 100 / self._vel_max\n    vel_move = self._vel_move * 100 / self._vel_max\n    acc_move = self._acc_move * 100 / self._acc_max\n\n    return (vel_homing, vel_move, acc_move)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.homing_n_coor_calibration","title":"<code>homing_n_coor_calibration()</code>","text":"<p>A function to recalibrate the coordinate system of the device. - Also called as 'homing'</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def homing_n_coor_calibration(self):\n    \"\"\"\n    A function to recalibrate the coordinate system of the device.\n    - Also called as 'homing'\n    \"\"\"\n    if self._isrunning_motor == True:\n        print('!!!!! Motor is running, homing request BLOCKED !!!!!')\n        return\n\n    print(\"\\n!!!!! Coordinate calibration/Homing starting !!!!!\")\n    self._isrunning_motor = True\n    timeout_rel = int(self.timeout_move_slow * self._vel_max/self._vel_homing)\n    self.dev.Home(timeout_rel)\n    self._isrunning_motor = False\n    print(\"&lt;&lt;&lt;&lt;&lt; Coordinate calibration/Homing finished &gt;&gt;&gt;&gt;&gt;\")\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.initialisation","title":"<code>initialisation()</code>","text":"<p>Initialises the device, setup the connection, channels, motors and their parameters, etc.</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def initialisation(self):\n    \"\"\"\n    Initialises the device, setup the connection, channels, motors and their parameters, etc.\n    \"\"\"\n    if self.issimulation:\n        print(\"&gt;&gt;&gt;&gt;&gt; INITIALISING SIMULATION &lt;&lt;&lt;&lt;&lt;\")\n        SimulationManager.Instance.InitializeSimulations()\n        print(\"&lt;&lt;&lt;&lt;&lt; Simulation Initialised &gt;&gt;&gt;&gt;&gt;\")\n    else:\n        print(\"&lt;&lt;&lt;&lt;&lt; NOT A SIMULATION &gt;&gt;&gt;&gt;&gt;\")\n\n    DeviceManagerCLI.BuildDeviceList()\n\n    # Creates the device object, based on the serial number we have\n    self.dev = TCubeDCServo.CreateTCubeDCServo(self.serial_no)\n\n    # Connect, begin polling, and enable\n    self.dev.Connect(self.serial_no)\n    time.sleep(0.25)  # wait statements are important to allow settings to be sent to the device\n\n    # Start polling and enables the device\n    self.dev.StartPolling(250)\n    time.sleep(0.25)  # wait statements are important to allow settings to be sent to the device\n    self.dev.EnableDevice()\n    time.sleep(0.25)  # Wait for device to enable\n\n    # Get Device Information and display description\n    self.dev_info = self.dev.GetDeviceInfo()\n    print('Connected to: ' + self.dev_info.Description)\n\n    # Check that the settings are initialised, else error.\n    if not self.dev.IsSettingsInitialized():\n    # if not x_channel.IsSettingsInitialized():\n        self.dev.WaitForSettingsInitialized(10000)  # 10 second timeout\n        assert self.dev.IsSettingsInitialized() is True\n\n    # Load the motor configuration on the channel\n    self.mdev_config = self.dev.LoadMotorConfiguration(self.serial_no,DeviceConfiguration.DeviceSettingsUseOptionType.UseFileSettings)\n    self.mdev_config.DeviceSettingsName = \"Z825B\"\n    print('fix device config info here')\n    self.mdev_config.UpdateCurrentConfiguration()\n    self.dev.SetSettings(self.dev.MotorDeviceSettings, True, False)\n    ...\n    # Get the Homing Params for coordinate calibration(ccal)\n    self.mdev_homing = self.dev.GetHomingParams()\n\n    # Set the movement velocity and acceleration parameters\n    self.mdev_mvmt = self.dev.GetVelocityParams()\n\n    print('\\n&lt;&lt;&lt;&lt;&lt; Device and motor initialisation complete &gt;&gt;&gt;&gt;&gt;')\n    self.running = True\n\n    # Set the motor unit converter for coordinate retrieval\n    self.unit_converter = self.dev.UnitConverter\n    self.convert_type_length = self.unit_converter.UnitType(0)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.move_continuous","title":"<code>move_continuous(dir)</code>","text":"<p>Moves the motor with a continuous motion until a stop command</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def move_continuous(self,dir):\n    \"\"\"\n    Moves the motor with a continuous motion until a stop command\n\n    Args:\n        dir (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n    if self._isrunning_motor == True:\n        print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n        return\n\n    dir = self.dict_ctrl_remap[dir] # Remap the controls\n\n    if dir == 'zfwd':\n        direction = MotorDirection.Forward\n    elif dir == 'zrev':\n        direction = MotorDirection.Backward\n\n    try:\n        self.dev.MoveContinuous(direction)\n        # Update the motor running state\n        self._isrunning_motor = True\n    except Exception as errormessage:\n        print(errormessage)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.move_direct","title":"<code>move_direct(coor_abs)</code>","text":"<p>Function to direct the motors to move at the same time towards a certain coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coor_abs</code> <code>Decimal</code> <p>coordinate of the destination</p> required Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def move_direct(self,coor_abs):\n    \"\"\"\n    Function to direct the motors to move at the same time towards a certain coordinate.\n\n    Args:\n        coor_abs (Decimal): coordinate of the destination\n    \"\"\"\n    # Convert the coordinates to decimals if floats are received\n    if type(coor_abs) is float:\n        coor_abs= Decimal(coor_abs)\n\n    if self._isrunning_motor == True:\n        print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n        return\n\n    self._isrunning_motor = True\n\n    timeout_rel = int(self.timeout_move_fast * self._vel_max/self._vel_move)\n    self.dev.MoveTo(coor_abs,timeout_rel)\n    self._isrunning_motor = False\n    time.sleep(0.85)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.move_jog","title":"<code>move_jog(direction)</code>","text":"<p>Moves the motor with a single/continuous jogging motion until a stop command.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>'zfwd' forward and 'zrev' for reverse/backward</p> required Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def move_jog(self,direction:str):\n    \"\"\"\n    Moves the motor with a single/continuous jogging motion until a stop command.\n\n    Args:\n        direction (str): 'zfwd' forward and 'zrev' for reverse/backward\n    \"\"\"\n    timeout_rel = int(self.timeout_move_fast * self._vel_max/self._vel_move)\n\n    if not isinstance(direction, str):\n        raise ValueError(\"Direction must be a string\")\n    if direction not in ['zfwd', 'zrev']:\n        raise ValueError(\"Direction must be 'zfwd' or 'zrev'\")\n\n    if self._isrunning_motor == True:\n        print('!!!!! Motor is running, movement request BLOCKED !!!!!')\n        return\n\n    direction = self.dict_ctrl_remap[direction] # Remap the controls\n\n    self._isrunning_motor = True\n    if direction == 'zfwd':\n        self.dev.MoveJog(MotorDirection.Forward,timeout_rel)\n    elif direction == 'zrev':\n        self.dev.MoveJog(MotorDirection.Backward,timeout_rel)\n    self._isrunning_motor = False\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.set_jog","title":"<code>set_jog(dist_mm, vel_rel=100, acc_rel=100)</code>","text":"<p>Set the jog parameters for the motor</p> <p>Parameters:</p> Name Type Description Default <code>dist_mm</code> <code>float</code> <p>distance to jog in mm</p> required <code>vel_rel</code> <code>int</code> <p>velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_rel</code> <code>int</code> <p>acceleration in percentage of max acceleration. Defaults to 100.</p> <code>100</code> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def set_jog(self,dist_mm:float,vel_rel:int=100,acc_rel:int=100):\n    \"\"\"\n    Set the jog parameters for the motor\n\n    Args:\n        dist_mm (float): distance to jog in mm\n        vel_rel (int, optional): velocity in percentage of max velocity. Defaults to 100.\n        acc_rel (int, optional): acceleration in percentage of max acceleration. Defaults to 100.\n    \"\"\"\n    if not isinstance(dist_mm, float) and not isinstance(dist_mm, int):\n        raise ValueError(\"Distance must be a float\")\n\n    if dist_mm &lt; self._jog_step_min:\n        raise ValueError(\"Minimum jog step size is {}\".format(self._jog_step_min))\n\n    dist_mm = float(dist_mm)\n\n    JogParams = self.dev.GetJogParams()\n    VelocityParams = JogParams.VelocityParams\n\n    if not isinstance(vel_rel, int) or isinstance(vel_rel, float):\n        raise ValueError(\"Velocity must be an integer\")\n    if not isinstance(acc_rel, int) or isinstance(acc_rel, float):\n        raise ValueError(\"Acceleration must be an integer\")\n    VelocityParams.MaxVelocity = Decimal(self._vel_max * vel_rel / 100)\n    VelocityParams.Acceleration = Decimal(self._acc_max * acc_rel / 100)\n\n    JogParams.StepSize = Decimal(dist_mm)\n    self.dev.SetJogParams(JogParams)\n\n    print('z_stage_controller.set_jog() is NOT TESTED yet')\n    pass\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.set_vel_acc_relative","title":"<code>set_vel_acc_relative(vel_homing=100, vel_move=100, acc_move=100)</code>","text":"<p>Set the velocity and acceleration parameters of the motors for both homing and typical movements.</p> <p>Parameters:</p> Name Type Description Default <code>vel_homing</code> <code>int</code> <p>New motor homing velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>vel_move</code> <code>int</code> <p>New motor movement velocity in percentage of max velocity. Defaults to 100.</p> <code>100</code> <code>acc_move</code> <code>int</code> <p>New motor movement acceleration in percentage of max acceleration. Defaults to 100.</p> <code>100</code> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def set_vel_acc_relative(self,vel_homing:int=100, vel_move:int=100, acc_move:int=100):\n    \"\"\"\n    Set the velocity and acceleration parameters of the motors for both homing and typical movements.\n\n    Args:\n        vel_homing (int, optional): New motor homing velocity in percentage of max velocity. Defaults to 100.\n        vel_move (int, optional): New motor movement velocity in percentage of max velocity. Defaults to 100.\n        acc_move (int, optional): New motor movement acceleration in percentage of max acceleration. Defaults to 100.\n    \"\"\"\n    if vel_homing &lt;= 0 or vel_move &lt;= 0 or acc_move &lt;= 0:\n        raise ValueError(\"Velocity and acceleration parameters must be larger than 0%\")\n    if vel_homing &gt; 100 or vel_move &gt; 100 or acc_move &gt; 100:\n        raise ValueError(\"Velocity and acceleration parameters must be less than 100%\")\n\n    # Convert the percentage to the actual value\n    vel_homing = self._vel_max * vel_homing / 100\n    vel_move = self._vel_max * vel_move / 100\n    acc_move = self._acc_max * acc_move / 100\n\n    self._set_vel_acc(vel_homing, vel_move, acc_move)\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.stop_move","title":"<code>stop_move()</code>","text":"<p>Stops all motor movement</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def stop_move(self):\n    \"\"\"\n    Stops all motor movement\n    \"\"\"\n    self.dev.Stop(0)\n    time.sleep(self.stoptime)   # Wait to allow the motors to stop completely\n    self._isrunning_motor = False         # Update the motor state\n</code></pre>"},{"location":"reference/iris/controllers/z_stage_controller_z825b/#iris.controllers.z_stage_controller_z825b.ZController_Z825B.terminate","title":"<code>terminate(error_flag=False)</code>","text":"<p>Terminate the operation. Returns the stage to home and disconnects the device.</p> Source code in <code>iris/controllers/z_stage_controller_z825b.py</code> <pre><code>def terminate(self,error_flag=False):\n    \"\"\"\n    Terminate the operation. Returns the stage to home and disconnects the device.\n    \"\"\"\n\n    # Return the stage to Home\n    # if not error_flag:\n    #     self.homing_n_coor_calibration()\n\n    # Stop polling and disconnects the device\n    self.dev.StopPolling()\n    self.dev.Disconnect()\n\n    # Terminates the simulation (if it is a simulation, automatic detection)\n    if self.issimulation:\n        print(\"&gt;&gt;&gt;&gt;&gt; TERMINATING SIMULATION STOPPED &lt;&lt;&lt;&lt;&lt;\")\n        SimulationManager.Instance.UninitializeSimulations()\n    self.running = False\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/","title":"calibration_objective","text":"<p>NOTE: - FLIPNOTE: Sometimes, there will be a *= -1 multiplier when calculating or converting the coordinate between the     stage and the camera frame of reference (FoR). This is because the stage FoR and the camera FoR are     opposite to each other. i.e., when we see that a feature moves in a certain direction in the camera,     the stage is actually moving in the oppsite direction. Think about it, when we see that a feature     moves to the right in the camera, the stage is actually moving to the left.</p>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal","title":"<code>ImgMea_Cal</code>  <code>dataclass</code>","text":"Source code in <code>iris/data/calibration_objective.py</code> <pre><code>@dataclass\nclass ImgMea_Cal:\n    id: str = None                      # Calibration ID\n    scale_x_pixelPerMm: float = None    # Scale in pixels per mm in the x direction\n    scale_y_pixelPerMm: float = None    # Scale in pixels per mm in the y direction\n    flip_y: int = -1                    # Flip the y-axis of the image (-1: flip, 1: no flip)\n    rotation_rad: float = 0             # Rotation in radians (-pi &lt; rot &lt;= pi)\n    laser_coor_x_mm: float = None       # Laser coordinate x in mm from the image's center frame of reference\n    laser_coor_y_mm: float = None       # Laser coordinate y in mm from the image's center frame of reference\n\n    mat_M_stg2img: arr = None           # Transformation matrix from the camera frame of reference to the stage frame of reference\n    mat_M_inv_img2stg: arr = None       # Inverse transformation matrix from the stage frame of reference to the camera frame of reference\n\n    def check_calibration_set(self,exclude_laser:bool=False) -&gt; bool:\n        \"\"\"\n        Checks if all the calibration parameters are set\n\n        Args:\n            exclude_laser (bool): Exclude the laser coordinate from the check\n\n        Returns:\n            bool: True if all the calibration parameters are set, False otherwise\n        \"\"\"\n        if exclude_laser:\n            laser_x = self.laser_coor_x_mm\n            laser_y = self.laser_coor_y_mm\n            self.laser_coor_x_mm = 0.0\n            self.laser_coor_y_mm = 0.0\n\n        dict_self = asdict(self)\n        ret = not any([v is None for v in dict_self.values()])\n\n        if exclude_laser:\n            self.laser_coor_x_mm = laser_x\n            self.laser_coor_y_mm = laser_y\n\n        return ret\n\n    def _check_reshape(self,coor:arr) -&gt; arr:\n        \"\"\"\n        Reshapes the coordinate if it is not of shape (2,1)\n\n        Args:\n            coor(np.ndarray): Coordinate\n\n        Returns:\n            np.ndarray: Reshaped coordinate (2,1)\n        \"\"\"\n        if not coor.shape == (2,1):\n            try: coor = coor.reshape((2,1))\n            except: raise AssertionError('Coordinate must be of shape (2,1) and cannot be reshaped to this shape')\n        return coor\n\n    def convert_stg2mea(self,coor_stg:arr) -&gt; arr:\n        \"\"\"\n        Converts the stage coordinate to the measurement coordinate\n\n        Args:\n            coor_stg(np.ndarray): Stage coordinate\n\n        Returns:\n            np.ndarray: Measurement coordinate (flattened 1D array (x,y))\n        \"\"\"\n        assert self.check_calibration_set(), 'Calibration parameters are not set'\n        assert isinstance(coor_stg, arr), 'Stage coordinate must be a numpy array'\n        coor_stg = self._check_reshape(coor_stg)\n\n        laser_coor = np.array([[self.laser_coor_x_mm],[self.laser_coor_y_mm]])\n        ret = coor_stg + laser_coor\n        return ret.reshape([-1])\n\n    def convert_mea2stg(self,coor_mea:arr) -&gt; arr:\n        \"\"\"\n        Converts the measurement coordinate to the stage coordinate\n\n        Args:\n            coor_mea(np.ndarray): Measurement coordinate\n\n        Returns:\n            np.ndarray: Stage coordinate (flattened 1D array (x,y))\n        \"\"\"\n        assert self.check_calibration_set(), 'Calibration parameters are not set'\n        assert isinstance(coor_mea, arr), 'Measurement coordinate must be a numpy array'\n        coor_mea = self._check_reshape(coor_mea)\n\n        laser_coor = np.array([[self.laser_coor_x_mm],[self.laser_coor_y_mm]])\n        ret = coor_mea - laser_coor\n        return ret.reshape([-1])\n\n    def convert_stg2imgpt(self,coor_stg_mm:arr,coor_point_mm:arr) -&gt; arr:\n        \"\"\"\n        Converts the stage coordinate to the coordinate in the camera frame of reference\n\n        Args:\n            coor_stg(np.ndarray): Stage coordinate\n            coor_point_mm(np.ndarray): Point coordinate in the stage frame of reference\n\n        Returns:\n            np.ndarray: Image coordinate (flattened 1D array (x,y))\n        \"\"\"\n        assert self.check_calibration_set(exclude_laser=True), 'Calibration parameters are not set'\n        assert isinstance(coor_stg_mm, arr), 'Stage coordinate must be a numpy array'\n        coor_stg_mm = self._check_reshape(coor_stg_mm)\n        assert isinstance(coor_point_mm, arr), 'Point coordinate must be a numpy array'\n        coor_point_mm = self._check_reshape(coor_point_mm)\n\n        ret = self.mat_M_stg2img @ (coor_point_mm - coor_stg_mm)\n\n        return ret.reshape([-1])\n\n    def convert_imgpt2stg(self,coor_img_pixel:arr,coor_stage_mm:arr) -&gt; arr:\n        \"\"\"\n        Converts coordinate of a point in the camera frame of refernece\n        to the coordinate in the stage frame of reference\n\n        Args:\n            coor_img_pixel(np.ndarray): Image coordinate\n            coor_stage_mm(np.ndarray): Stage coordinate\n\n        Returns:\n            np.ndarray: Stage coordinate (flattened 1D array (x,y))\n        \"\"\"\n        assert self.check_calibration_set(exclude_laser=True), 'Calibration parameters are not set'\n        assert isinstance(coor_img_pixel, arr), 'Image coordinate must be a numpy array'\n        coor_img_pixel = self._check_reshape(coor_img_pixel)\n        assert isinstance(coor_stage_mm, arr), 'Stage coordinate must be a numpy array'\n        coor_stage_mm = self._check_reshape(coor_stage_mm)\n\n        ret = self.mat_M_inv_img2stg @ coor_img_pixel + coor_stage_mm\n\n        return ret.reshape([-1])\n\n    def set_calibration_params(self,scale_x_pixelPerMm:float,scale_y_pixelPerMm:float,laser_coor_x_mm:float,laser_coor_y_mm:float,\n                               rotation_rad:float,flip_y:int|None=None) -&gt; None:\n        \"\"\"\n        Sets the calibration parameters manually\n\n        Args:\n            scale_x_pixelPerMm (float): Scale in pixels per mm in the x direction\n            scale_y_pixelPerMm (float): Scale in pixels per mm in the y direction\n            laser_coor_x_mm (float): Laser coordinate x in mm from the image's origin frame of reference\n            laser_coor_y_mm (float): Laser coordinate y in mm from the image's origin frame of reference\n            rotation_rad (float): Rotation in radians (-pi &lt; rot &lt;= pi)\n            flip_y (int): Flip the y-axis of the image (-1: flip, 1: no flip). If None, the flip is unchanged\n        \"\"\"\n        assert all([isinstance(v,float) for v in [scale_x_pixelPerMm,scale_y_pixelPerMm,laser_coor_x_mm,laser_coor_y_mm,rotation_rad]]),\\\n            'Calibration parameters must be floats'\n\n        self.scale_x_pixelPerMm = scale_x_pixelPerMm\n        self.scale_y_pixelPerMm = scale_y_pixelPerMm\n        self.laser_coor_x_mm = laser_coor_x_mm\n        self.laser_coor_y_mm = laser_coor_y_mm\n        self.rotation_rad = rotation_rad\n        if flip_y is not None: self.flip_y = flip_y\n\n        sx = self.scale_x_pixelPerMm\n        sy = self.scale_y_pixelPerMm\n        f = self.flip_y\n        theta = self.rotation_rad\n\n        # Calculate the transformation matrix\n        mat_S = np.array(   # Scale matrix [pixel/mm]\n            [[sx, 0],\n             [0, sy]]\n        )\n\n        mat_F = np.array(   # Flip matrix [a.u.]\n            [[1, 0],\n             [0, f]]\n        )\n\n        mat_R = np.array(   # Rotation matrix [a.u.]\n            [[np.cos(theta), -np.sin(theta)],\n             [np.sin(theta), np.cos(theta)]]\n        )\n\n        self.mat_M_stg2img = mat_R @ mat_F @ mat_S # [pixel/mm]\n        self.mat_M_inv_img2stg = np.linalg.inv(self.mat_M_stg2img)\n\n\n    def set_calibration_vector(self,v1s:arr,v2s:arr,v3s:arr,v1c:arr,v2c:arr,v3c:arr,vlc:arr) -&gt; None:\n        \"\"\"\n        Sets the calibration parameters from the vectors of the tracked features in the image\n        and their corresponding stage coordinates (vector 1, 2, 3) and laser coordinate\n\n        Args:\n            v1s(np.ndarray): Vector 1 (stage frame of reference (FoR)) [mm]\n            v2s(np.ndarray): Vector 2 (stage FoR), must have the same x coordinate as v1s [mm]\n            v3s(np.ndarray): Vector 3 (stage FoR), must have the same y coordinate as v1s [mm]\n            v1c(np.ndarray): Vector 1 (camera FoR) corresponding to v1s [pixel]\n            v2c(np.ndarray): Vector 2 (camera FoR) corresponding to v2s [pixel]\n            v3c(np.ndarray): Vector 3 (camera FoR) corresponding to v3s [pixel]\n            vlc(np.ndarray): Vector of the laser coordinate in the camera FoR [pixel]\n        \"\"\"\n        assert all([isinstance(v, arr) for v in [v1s,v2s,v3s,v1c,v2c,v3c,vlc]]), 'Vectors must be numpy arrays'\n        v1s,v2s,v3s,v1c,v2c,v3c,vlc = [self._check_reshape(v) for v in [v1s,v2s,v3s,v1c,v2c,v3c,vlc]]\n\n        # assert np.allclose(v1s[1],v2s[1]), 'Vector 2 must have the same y coordinate as vector 1'\n        # assert np.allclose(v2s[0],v3s[0]), 'Vector 3 must have the same x coordinate as vector 2'\n\n        v1s*= -1\n        v2s*= -1\n        v3s*= -1\n\n        # Calculate the vector distances\n        dvs_12 = v2s - v1s  # Vector 1 to 2 in the stage frame of reference\n        dvs_23 = v3s - v2s  # Vector 2 to 3 in the stage frame of reference\n\n        dvc_12 = v2c - v1c  # Vector 1 to 2 in the camera frame of reference\n        dvc_23 = v3c - v2c  # Vector 2 to 3 in the camera frame of reference\n\n        theta_sign = np.sign(dvs_12[0][0])\n        # Calculate the rotation angle in radians, float\n        theta = np.arctan2(dvc_12[1][0]*theta_sign,dvc_12[0][0]*theta_sign)\n\n        # Calculate the scale in pixels per mm in the x direction\n        sx = dvc_12[0][0]/(dvs_12[0][0]*np.cos(theta)) # [pixel/mm]\n\n        # Calculate the y-axis flip\n        f = np.sign(dvc_23[1][0]/(dvs_23[1][0]*np.cos(theta)))\n\n        # Calculate the scale in pixels per mm in the y direction\n        sy = (dvc_23[1][0]/(dvs_23[1][0]*f*np.cos(theta))) # [pixel/mm]\n\n        if abs(theta) &gt; np.pi/2:\n            theta -= np.sign(theta)*np.pi\n            sx *= -1\n            sy *= -1\n\n        # Calculate the transformation matrix\n        mat_S = np.array(   # Scale matrix [pixel/mm]\n            [[sx, 0],\n             [0, sy]]\n        )\n\n        mat_F = np.array(   # Flip matrix [a.u.]\n            [[1, 0],\n             [0, f]]\n        )\n\n        mat_R = np.array(   # Rotation matrix [a.u.]\n            [[np.cos(theta), -np.sin(theta)],\n             [np.sin(theta), np.cos(theta)]]\n        )\n\n        self.mat_M_stg2img = mat_R @ mat_F @ mat_S # [pixel/mm]\n        self.mat_M_inv_img2stg = np.linalg.inv(self.mat_M_stg2img)\n\n        self.scale_x_pixelPerMm = sx\n        self.scale_y_pixelPerMm = sy\n        self.flip_y = f\n        self.rotation_rad = theta\n\n        self.set_laser_coor(vlc)\n\n    def set_laser_coor(self,coor_laser_pixel:arr) -&gt; None:\n        \"\"\"\n        Sets the laser coordinate in the camera frame of reference\n\n        Args:\n            coor_laser_pixel (arr): Laser coordinate in the camera frame of reference [pixel]\n        \"\"\"\n        assert self.check_calibration_set(exclude_laser=True), 'Calibration parameters are not set'\n        assert isinstance(coor_laser_pixel, arr), 'Laser coordinate must be a numpy array'\n        coor_laser_pixel = self._check_reshape(coor_laser_pixel)\n\n        coor_laser_stage = self.convert_imgpt2stg(coor_laser_pixel,np.array([0,0]))\n\n        self.laser_coor_x_mm = coor_laser_stage[0]\n        self.laser_coor_y_mm = coor_laser_stage[1]\n\n    def save_calibration_json(self,path:str) -&gt; None:\n        \"\"\"\n        Saves the calibration parameters to a JSON file\n\n        Args:\n            path (str): Path to save the JSON file\n        \"\"\"\n        assert self.check_calibration_set(), 'Calibration parameters are not set'\n        if not path.endswith('.json'): path += '.json'\n        if not os.path.exists(os.path.dirname(path)): os.makedirs(os.path.dirname(path))\n        assert not os.path.exists(path), 'File already exists'\n\n        self.mat_M_inv_img2stg = self.mat_M_inv_img2stg.tolist()\n        self.mat_M_stg2img = self.mat_M_stg2img.tolist()\n\n        with open(path,'w') as f:\n            json.dump(asdict(self),f)\n\n        self.mat_M_inv_img2stg = np.array(self.mat_M_inv_img2stg)\n        self.mat_M_stg2img = np.array(self.mat_M_stg2img)\n\n        return\n\n    def load_calibration_json(self,path:str) -&gt; None:\n        \"\"\"\n        Loads the calibration parameters from a JSON file\n\n        Args:\n            path (str): Path to the JSON file\n\n        Raises:\n            AssertionError: Path does not exist\n            AssertionError: File must be a JSON file\n            ValueError: Error loading the JSON file\n        \"\"\"\n        assert os.path.exists(path), 'Path does not exist'\n        assert path.endswith('.json'), 'File must be a JSON file'\n\n        try:\n            if not os.path.isabs(path): path = os.path.abspath(path)\n            dict = json.load(open(path,'r'))\n            id = os.path.basename(path).split('.')[0]\n            self.set_calibration_fromfile_legacy(id,dict)\n        except KeyError: pass\n        except Exception as e: raise ValueError(f'Error loading the JSON file (legacy): {e}')\n\n        try:\n            with open(path,'r') as f:\n                dict_cal = json.load(f)\n\n            [self.__setattr__(key,dict_cal[key]) for key in dict_cal.keys()]\n\n            self.mat_M_inv_img2stg = np.array(self.mat_M_inv_img2stg)\n            self.mat_M_stg2img = np.array(self.mat_M_stg2img)\n        except Exception as e: raise ValueError(f'Error loading the JSON file: {e}')\n\n    def set_calibration_fromfile_legacy(self,cal_id:str,dict_calibration:dict) -&gt; None:\n        \"\"\"\n        Sets the calibration parameters from a dictionary (legacy)\n\n        Args:\n            cal_id (str): Calibration ID\n            dict_calibration (dict): Calibration parameters dictionary\n        \"\"\"\n        keys = set([\n            'scale_x_mmPerPixel',    # Float: Scale in mm per pixel in the x direction\n            'scale_y_mmPerPixel',    # Float: Scale in mm per pixel in the y direction\n            'laser_coor_x_mm',       # float: Laser coordinate x in mm from the image's center frame of reference\n            'laser_coor_y_mm',       # float: Laser coordinate y in mm from the image's center frame of reference\n        ])\n\n        keys_type = {\n            'scale_x_mmPerPixel': float,\n            'scale_y_mmPerPixel': float,\n            'laser_coor_x_mm': (tuple,list),\n            'laser_coor_y_mm': (tuple,list)\n        }\n\n        assert isinstance(cal_id,str), 'Calibration ID must be a string'\n        assert isinstance(dict_calibration, dict), 'Calibration parameters must be a dictionary'\n        if not all([key in keys for key in dict_calibration.keys()]): raise KeyError('Dictionary keys must match the calibration keys')\n        assert all([isinstance(dict_calibration[key], keys_type[key]) for key in list(dict_calibration.keys())]),\\\n            'Calibration parameters must be float or integers'\n\n        self.id = cal_id\n        # Assign the calibration parameters\n        sx_pixelPerMm = 1/dict_calibration['scale_x_mmPerPixel']\n        sy_pixelPerMm = 1/dict_calibration['scale_y_mmPerPixel']\n\n        self.scale_x_pixelPerMm = sx_pixelPerMm\n        self.scale_y_pixelPerMm = sy_pixelPerMm\n        self.flip_y = -1\n        self.rotation_rad = 0\n        self.laser_coor_x_mm = dict_calibration['laser_coor_x_mm']\n        self.laser_coor_y_mm = dict_calibration['laser_coor_y_mm']\n\n        S_inv = np.array(\n            [[sx_pixelPerMm, 0],\n             [0, sy_pixelPerMm]]\n        )\n\n        F_inv = np.array(\n            [[1, 0],\n             [0, self.flip_y]]\n        )\n\n        R_inv = np.array(\n            [[np.cos(self.rotation_rad), -np.sin(self.rotation_rad)],\n             [np.sin(self.rotation_rad), np.cos(self.rotation_rad)]]\n        )\n\n        self.mat_M_inv_img2stg = S_inv @ F_inv @ R_inv\n        self.mat_M_stg2img = np.linalg.inv(self.mat_M_inv_img2stg)\n\n        return\n\n    def get_calibration_asdict(self) -&gt; dict:\n        \"\"\"\n        Returns the calibration parameters as a dictionary\n\n        Returns:\n            dict: Calibration parameters dictionary\n        \"\"\"\n        self.mat_M_inv_img2stg = self.mat_M_inv_img2stg.tolist()\n        self.mat_M_stg2img = self.mat_M_stg2img.tolist()\n\n        dict_ret = asdict(self)\n\n        self.mat_M_inv_img2stg = np.array(self.mat_M_inv_img2stg)\n        self.mat_M_stg2img = np.array(self.mat_M_stg2img)\n        return dict_ret\n\n    def set_calibration_fromdict(self,cal_id:str,dict_calibration:dict) -&gt; None:\n        \"\"\"\n        Sets the calibration parameters from a dictionary\n\n        Args:\n            cal_id (str): Calibration ID\n            dict_calibration (dict): Calibration parameters dictionary\n        \"\"\"\n        if not all([key in asdict(self).keys() for key in dict_calibration.keys()]): \n            try: self.set_calibration_fromfile_legacy(cal_id,dict_calibration)\n            except: raise ImportError('Legacy: Dictionary keys must match the calibration keys')\n\n        [self.__setattr__(key,dict_calibration[key]) for key in dict_calibration.keys()]\n\n        self.mat_M_inv_img2stg = np.array(self.mat_M_inv_img2stg)\n        self.mat_M_stg2img = np.array(self.mat_M_stg2img)\n\n        return\n\n    def get_calibration_only_tuple(self) -&gt; NotImplementedError:\n        raise NotImplementedError('This method is not implemented')\n\n    def generate_dummy_params(self):\n        \"\"\"\n        Generates a dummy calibration parameters for testing purposes\n        \"\"\"\n        self.id = 'dummy'\n        self.scale_x_pixelPerMm = 19\n        self.scale_y_pixelPerMm = 24\n        self.laser_coor_x_mm = 0.03\n        self.laser_coor_y_mm = 0.02\n        self.rotation_rad = 0.02\n        self.flip_y = -1\n\n        S_inv = np.array(\n            [[self.scale_x_pixelPerMm, 0],\n             [0, self.scale_y_pixelPerMm]]\n        )\n\n        F_inv = np.array(\n            [[1, 0],\n             [0, self.flip_y]]\n        )\n\n        R_inv = np.array(\n            [[np.cos(self.rotation_rad), -np.sin(self.rotation_rad)],\n             [np.sin(self.rotation_rad), np.cos(self.rotation_rad)]]\n        )\n\n        self.mat_M_inv_img2stg = S_inv @ F_inv @ R_inv\n        self.mat_M_stg2img = np.linalg.inv(self.mat_M_inv_img2stg)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.check_calibration_set","title":"<code>check_calibration_set(exclude_laser=False)</code>","text":"<p>Checks if all the calibration parameters are set</p> <p>Parameters:</p> Name Type Description Default <code>exclude_laser</code> <code>bool</code> <p>Exclude the laser coordinate from the check</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all the calibration parameters are set, False otherwise</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def check_calibration_set(self,exclude_laser:bool=False) -&gt; bool:\n    \"\"\"\n    Checks if all the calibration parameters are set\n\n    Args:\n        exclude_laser (bool): Exclude the laser coordinate from the check\n\n    Returns:\n        bool: True if all the calibration parameters are set, False otherwise\n    \"\"\"\n    if exclude_laser:\n        laser_x = self.laser_coor_x_mm\n        laser_y = self.laser_coor_y_mm\n        self.laser_coor_x_mm = 0.0\n        self.laser_coor_y_mm = 0.0\n\n    dict_self = asdict(self)\n    ret = not any([v is None for v in dict_self.values()])\n\n    if exclude_laser:\n        self.laser_coor_x_mm = laser_x\n        self.laser_coor_y_mm = laser_y\n\n    return ret\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.convert_imgpt2stg","title":"<code>convert_imgpt2stg(coor_img_pixel, coor_stage_mm)</code>","text":"<p>Converts coordinate of a point in the camera frame of refernece to the coordinate in the stage frame of reference</p> <p>Parameters:</p> Name Type Description Default <code>coor_img_pixel</code> <code>ndarray</code> <p>Image coordinate</p> required <code>coor_stage_mm</code> <code>ndarray</code> <p>Stage coordinate</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Stage coordinate (flattened 1D array (x,y))</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def convert_imgpt2stg(self,coor_img_pixel:arr,coor_stage_mm:arr) -&gt; arr:\n    \"\"\"\n    Converts coordinate of a point in the camera frame of refernece\n    to the coordinate in the stage frame of reference\n\n    Args:\n        coor_img_pixel(np.ndarray): Image coordinate\n        coor_stage_mm(np.ndarray): Stage coordinate\n\n    Returns:\n        np.ndarray: Stage coordinate (flattened 1D array (x,y))\n    \"\"\"\n    assert self.check_calibration_set(exclude_laser=True), 'Calibration parameters are not set'\n    assert isinstance(coor_img_pixel, arr), 'Image coordinate must be a numpy array'\n    coor_img_pixel = self._check_reshape(coor_img_pixel)\n    assert isinstance(coor_stage_mm, arr), 'Stage coordinate must be a numpy array'\n    coor_stage_mm = self._check_reshape(coor_stage_mm)\n\n    ret = self.mat_M_inv_img2stg @ coor_img_pixel + coor_stage_mm\n\n    return ret.reshape([-1])\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.convert_mea2stg","title":"<code>convert_mea2stg(coor_mea)</code>","text":"<p>Converts the measurement coordinate to the stage coordinate</p> <p>Parameters:</p> Name Type Description Default <code>coor_mea</code> <code>ndarray</code> <p>Measurement coordinate</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Stage coordinate (flattened 1D array (x,y))</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def convert_mea2stg(self,coor_mea:arr) -&gt; arr:\n    \"\"\"\n    Converts the measurement coordinate to the stage coordinate\n\n    Args:\n        coor_mea(np.ndarray): Measurement coordinate\n\n    Returns:\n        np.ndarray: Stage coordinate (flattened 1D array (x,y))\n    \"\"\"\n    assert self.check_calibration_set(), 'Calibration parameters are not set'\n    assert isinstance(coor_mea, arr), 'Measurement coordinate must be a numpy array'\n    coor_mea = self._check_reshape(coor_mea)\n\n    laser_coor = np.array([[self.laser_coor_x_mm],[self.laser_coor_y_mm]])\n    ret = coor_mea - laser_coor\n    return ret.reshape([-1])\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.convert_stg2imgpt","title":"<code>convert_stg2imgpt(coor_stg_mm, coor_point_mm)</code>","text":"<p>Converts the stage coordinate to the coordinate in the camera frame of reference</p> <p>Parameters:</p> Name Type Description Default <code>coor_stg</code> <code>ndarray</code> <p>Stage coordinate</p> required <code>coor_point_mm</code> <code>ndarray</code> <p>Point coordinate in the stage frame of reference</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Image coordinate (flattened 1D array (x,y))</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def convert_stg2imgpt(self,coor_stg_mm:arr,coor_point_mm:arr) -&gt; arr:\n    \"\"\"\n    Converts the stage coordinate to the coordinate in the camera frame of reference\n\n    Args:\n        coor_stg(np.ndarray): Stage coordinate\n        coor_point_mm(np.ndarray): Point coordinate in the stage frame of reference\n\n    Returns:\n        np.ndarray: Image coordinate (flattened 1D array (x,y))\n    \"\"\"\n    assert self.check_calibration_set(exclude_laser=True), 'Calibration parameters are not set'\n    assert isinstance(coor_stg_mm, arr), 'Stage coordinate must be a numpy array'\n    coor_stg_mm = self._check_reshape(coor_stg_mm)\n    assert isinstance(coor_point_mm, arr), 'Point coordinate must be a numpy array'\n    coor_point_mm = self._check_reshape(coor_point_mm)\n\n    ret = self.mat_M_stg2img @ (coor_point_mm - coor_stg_mm)\n\n    return ret.reshape([-1])\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.convert_stg2mea","title":"<code>convert_stg2mea(coor_stg)</code>","text":"<p>Converts the stage coordinate to the measurement coordinate</p> <p>Parameters:</p> Name Type Description Default <code>coor_stg</code> <code>ndarray</code> <p>Stage coordinate</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Measurement coordinate (flattened 1D array (x,y))</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def convert_stg2mea(self,coor_stg:arr) -&gt; arr:\n    \"\"\"\n    Converts the stage coordinate to the measurement coordinate\n\n    Args:\n        coor_stg(np.ndarray): Stage coordinate\n\n    Returns:\n        np.ndarray: Measurement coordinate (flattened 1D array (x,y))\n    \"\"\"\n    assert self.check_calibration_set(), 'Calibration parameters are not set'\n    assert isinstance(coor_stg, arr), 'Stage coordinate must be a numpy array'\n    coor_stg = self._check_reshape(coor_stg)\n\n    laser_coor = np.array([[self.laser_coor_x_mm],[self.laser_coor_y_mm]])\n    ret = coor_stg + laser_coor\n    return ret.reshape([-1])\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.generate_dummy_params","title":"<code>generate_dummy_params()</code>","text":"<p>Generates a dummy calibration parameters for testing purposes</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def generate_dummy_params(self):\n    \"\"\"\n    Generates a dummy calibration parameters for testing purposes\n    \"\"\"\n    self.id = 'dummy'\n    self.scale_x_pixelPerMm = 19\n    self.scale_y_pixelPerMm = 24\n    self.laser_coor_x_mm = 0.03\n    self.laser_coor_y_mm = 0.02\n    self.rotation_rad = 0.02\n    self.flip_y = -1\n\n    S_inv = np.array(\n        [[self.scale_x_pixelPerMm, 0],\n         [0, self.scale_y_pixelPerMm]]\n    )\n\n    F_inv = np.array(\n        [[1, 0],\n         [0, self.flip_y]]\n    )\n\n    R_inv = np.array(\n        [[np.cos(self.rotation_rad), -np.sin(self.rotation_rad)],\n         [np.sin(self.rotation_rad), np.cos(self.rotation_rad)]]\n    )\n\n    self.mat_M_inv_img2stg = S_inv @ F_inv @ R_inv\n    self.mat_M_stg2img = np.linalg.inv(self.mat_M_inv_img2stg)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.get_calibration_asdict","title":"<code>get_calibration_asdict()</code>","text":"<p>Returns the calibration parameters as a dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Calibration parameters dictionary</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def get_calibration_asdict(self) -&gt; dict:\n    \"\"\"\n    Returns the calibration parameters as a dictionary\n\n    Returns:\n        dict: Calibration parameters dictionary\n    \"\"\"\n    self.mat_M_inv_img2stg = self.mat_M_inv_img2stg.tolist()\n    self.mat_M_stg2img = self.mat_M_stg2img.tolist()\n\n    dict_ret = asdict(self)\n\n    self.mat_M_inv_img2stg = np.array(self.mat_M_inv_img2stg)\n    self.mat_M_stg2img = np.array(self.mat_M_stg2img)\n    return dict_ret\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.load_calibration_json","title":"<code>load_calibration_json(path)</code>","text":"<p>Loads the calibration parameters from a JSON file</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the JSON file</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>Path does not exist</p> <code>AssertionError</code> <p>File must be a JSON file</p> <code>ValueError</code> <p>Error loading the JSON file</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def load_calibration_json(self,path:str) -&gt; None:\n    \"\"\"\n    Loads the calibration parameters from a JSON file\n\n    Args:\n        path (str): Path to the JSON file\n\n    Raises:\n        AssertionError: Path does not exist\n        AssertionError: File must be a JSON file\n        ValueError: Error loading the JSON file\n    \"\"\"\n    assert os.path.exists(path), 'Path does not exist'\n    assert path.endswith('.json'), 'File must be a JSON file'\n\n    try:\n        if not os.path.isabs(path): path = os.path.abspath(path)\n        dict = json.load(open(path,'r'))\n        id = os.path.basename(path).split('.')[0]\n        self.set_calibration_fromfile_legacy(id,dict)\n    except KeyError: pass\n    except Exception as e: raise ValueError(f'Error loading the JSON file (legacy): {e}')\n\n    try:\n        with open(path,'r') as f:\n            dict_cal = json.load(f)\n\n        [self.__setattr__(key,dict_cal[key]) for key in dict_cal.keys()]\n\n        self.mat_M_inv_img2stg = np.array(self.mat_M_inv_img2stg)\n        self.mat_M_stg2img = np.array(self.mat_M_stg2img)\n    except Exception as e: raise ValueError(f'Error loading the JSON file: {e}')\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.save_calibration_json","title":"<code>save_calibration_json(path)</code>","text":"<p>Saves the calibration parameters to a JSON file</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to save the JSON file</p> required Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def save_calibration_json(self,path:str) -&gt; None:\n    \"\"\"\n    Saves the calibration parameters to a JSON file\n\n    Args:\n        path (str): Path to save the JSON file\n    \"\"\"\n    assert self.check_calibration_set(), 'Calibration parameters are not set'\n    if not path.endswith('.json'): path += '.json'\n    if not os.path.exists(os.path.dirname(path)): os.makedirs(os.path.dirname(path))\n    assert not os.path.exists(path), 'File already exists'\n\n    self.mat_M_inv_img2stg = self.mat_M_inv_img2stg.tolist()\n    self.mat_M_stg2img = self.mat_M_stg2img.tolist()\n\n    with open(path,'w') as f:\n        json.dump(asdict(self),f)\n\n    self.mat_M_inv_img2stg = np.array(self.mat_M_inv_img2stg)\n    self.mat_M_stg2img = np.array(self.mat_M_stg2img)\n\n    return\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.set_calibration_fromdict","title":"<code>set_calibration_fromdict(cal_id, dict_calibration)</code>","text":"<p>Sets the calibration parameters from a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>cal_id</code> <code>str</code> <p>Calibration ID</p> required <code>dict_calibration</code> <code>dict</code> <p>Calibration parameters dictionary</p> required Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def set_calibration_fromdict(self,cal_id:str,dict_calibration:dict) -&gt; None:\n    \"\"\"\n    Sets the calibration parameters from a dictionary\n\n    Args:\n        cal_id (str): Calibration ID\n        dict_calibration (dict): Calibration parameters dictionary\n    \"\"\"\n    if not all([key in asdict(self).keys() for key in dict_calibration.keys()]): \n        try: self.set_calibration_fromfile_legacy(cal_id,dict_calibration)\n        except: raise ImportError('Legacy: Dictionary keys must match the calibration keys')\n\n    [self.__setattr__(key,dict_calibration[key]) for key in dict_calibration.keys()]\n\n    self.mat_M_inv_img2stg = np.array(self.mat_M_inv_img2stg)\n    self.mat_M_stg2img = np.array(self.mat_M_stg2img)\n\n    return\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.set_calibration_fromfile_legacy","title":"<code>set_calibration_fromfile_legacy(cal_id, dict_calibration)</code>","text":"<p>Sets the calibration parameters from a dictionary (legacy)</p> <p>Parameters:</p> Name Type Description Default <code>cal_id</code> <code>str</code> <p>Calibration ID</p> required <code>dict_calibration</code> <code>dict</code> <p>Calibration parameters dictionary</p> required Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def set_calibration_fromfile_legacy(self,cal_id:str,dict_calibration:dict) -&gt; None:\n    \"\"\"\n    Sets the calibration parameters from a dictionary (legacy)\n\n    Args:\n        cal_id (str): Calibration ID\n        dict_calibration (dict): Calibration parameters dictionary\n    \"\"\"\n    keys = set([\n        'scale_x_mmPerPixel',    # Float: Scale in mm per pixel in the x direction\n        'scale_y_mmPerPixel',    # Float: Scale in mm per pixel in the y direction\n        'laser_coor_x_mm',       # float: Laser coordinate x in mm from the image's center frame of reference\n        'laser_coor_y_mm',       # float: Laser coordinate y in mm from the image's center frame of reference\n    ])\n\n    keys_type = {\n        'scale_x_mmPerPixel': float,\n        'scale_y_mmPerPixel': float,\n        'laser_coor_x_mm': (tuple,list),\n        'laser_coor_y_mm': (tuple,list)\n    }\n\n    assert isinstance(cal_id,str), 'Calibration ID must be a string'\n    assert isinstance(dict_calibration, dict), 'Calibration parameters must be a dictionary'\n    if not all([key in keys for key in dict_calibration.keys()]): raise KeyError('Dictionary keys must match the calibration keys')\n    assert all([isinstance(dict_calibration[key], keys_type[key]) for key in list(dict_calibration.keys())]),\\\n        'Calibration parameters must be float or integers'\n\n    self.id = cal_id\n    # Assign the calibration parameters\n    sx_pixelPerMm = 1/dict_calibration['scale_x_mmPerPixel']\n    sy_pixelPerMm = 1/dict_calibration['scale_y_mmPerPixel']\n\n    self.scale_x_pixelPerMm = sx_pixelPerMm\n    self.scale_y_pixelPerMm = sy_pixelPerMm\n    self.flip_y = -1\n    self.rotation_rad = 0\n    self.laser_coor_x_mm = dict_calibration['laser_coor_x_mm']\n    self.laser_coor_y_mm = dict_calibration['laser_coor_y_mm']\n\n    S_inv = np.array(\n        [[sx_pixelPerMm, 0],\n         [0, sy_pixelPerMm]]\n    )\n\n    F_inv = np.array(\n        [[1, 0],\n         [0, self.flip_y]]\n    )\n\n    R_inv = np.array(\n        [[np.cos(self.rotation_rad), -np.sin(self.rotation_rad)],\n         [np.sin(self.rotation_rad), np.cos(self.rotation_rad)]]\n    )\n\n    self.mat_M_inv_img2stg = S_inv @ F_inv @ R_inv\n    self.mat_M_stg2img = np.linalg.inv(self.mat_M_inv_img2stg)\n\n    return\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.set_calibration_params","title":"<code>set_calibration_params(scale_x_pixelPerMm, scale_y_pixelPerMm, laser_coor_x_mm, laser_coor_y_mm, rotation_rad, flip_y=None)</code>","text":"<p>Sets the calibration parameters manually</p> <p>Parameters:</p> Name Type Description Default <code>scale_x_pixelPerMm</code> <code>float</code> <p>Scale in pixels per mm in the x direction</p> required <code>scale_y_pixelPerMm</code> <code>float</code> <p>Scale in pixels per mm in the y direction</p> required <code>laser_coor_x_mm</code> <code>float</code> <p>Laser coordinate x in mm from the image's origin frame of reference</p> required <code>laser_coor_y_mm</code> <code>float</code> <p>Laser coordinate y in mm from the image's origin frame of reference</p> required <code>rotation_rad</code> <code>float</code> <p>Rotation in radians (-pi &lt; rot &lt;= pi)</p> required <code>flip_y</code> <code>int</code> <p>Flip the y-axis of the image (-1: flip, 1: no flip). If None, the flip is unchanged</p> <code>None</code> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def set_calibration_params(self,scale_x_pixelPerMm:float,scale_y_pixelPerMm:float,laser_coor_x_mm:float,laser_coor_y_mm:float,\n                           rotation_rad:float,flip_y:int|None=None) -&gt; None:\n    \"\"\"\n    Sets the calibration parameters manually\n\n    Args:\n        scale_x_pixelPerMm (float): Scale in pixels per mm in the x direction\n        scale_y_pixelPerMm (float): Scale in pixels per mm in the y direction\n        laser_coor_x_mm (float): Laser coordinate x in mm from the image's origin frame of reference\n        laser_coor_y_mm (float): Laser coordinate y in mm from the image's origin frame of reference\n        rotation_rad (float): Rotation in radians (-pi &lt; rot &lt;= pi)\n        flip_y (int): Flip the y-axis of the image (-1: flip, 1: no flip). If None, the flip is unchanged\n    \"\"\"\n    assert all([isinstance(v,float) for v in [scale_x_pixelPerMm,scale_y_pixelPerMm,laser_coor_x_mm,laser_coor_y_mm,rotation_rad]]),\\\n        'Calibration parameters must be floats'\n\n    self.scale_x_pixelPerMm = scale_x_pixelPerMm\n    self.scale_y_pixelPerMm = scale_y_pixelPerMm\n    self.laser_coor_x_mm = laser_coor_x_mm\n    self.laser_coor_y_mm = laser_coor_y_mm\n    self.rotation_rad = rotation_rad\n    if flip_y is not None: self.flip_y = flip_y\n\n    sx = self.scale_x_pixelPerMm\n    sy = self.scale_y_pixelPerMm\n    f = self.flip_y\n    theta = self.rotation_rad\n\n    # Calculate the transformation matrix\n    mat_S = np.array(   # Scale matrix [pixel/mm]\n        [[sx, 0],\n         [0, sy]]\n    )\n\n    mat_F = np.array(   # Flip matrix [a.u.]\n        [[1, 0],\n         [0, f]]\n    )\n\n    mat_R = np.array(   # Rotation matrix [a.u.]\n        [[np.cos(theta), -np.sin(theta)],\n         [np.sin(theta), np.cos(theta)]]\n    )\n\n    self.mat_M_stg2img = mat_R @ mat_F @ mat_S # [pixel/mm]\n    self.mat_M_inv_img2stg = np.linalg.inv(self.mat_M_stg2img)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.set_calibration_vector","title":"<code>set_calibration_vector(v1s, v2s, v3s, v1c, v2c, v3c, vlc)</code>","text":"<p>Sets the calibration parameters from the vectors of the tracked features in the image and their corresponding stage coordinates (vector 1, 2, 3) and laser coordinate</p> <p>Parameters:</p> Name Type Description Default <code>v1s</code> <code>ndarray</code> <p>Vector 1 (stage frame of reference (FoR)) [mm]</p> required <code>v2s</code> <code>ndarray</code> <p>Vector 2 (stage FoR), must have the same x coordinate as v1s [mm]</p> required <code>v3s</code> <code>ndarray</code> <p>Vector 3 (stage FoR), must have the same y coordinate as v1s [mm]</p> required <code>v1c</code> <code>ndarray</code> <p>Vector 1 (camera FoR) corresponding to v1s [pixel]</p> required <code>v2c</code> <code>ndarray</code> <p>Vector 2 (camera FoR) corresponding to v2s [pixel]</p> required <code>v3c</code> <code>ndarray</code> <p>Vector 3 (camera FoR) corresponding to v3s [pixel]</p> required <code>vlc</code> <code>ndarray</code> <p>Vector of the laser coordinate in the camera FoR [pixel]</p> required Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def set_calibration_vector(self,v1s:arr,v2s:arr,v3s:arr,v1c:arr,v2c:arr,v3c:arr,vlc:arr) -&gt; None:\n    \"\"\"\n    Sets the calibration parameters from the vectors of the tracked features in the image\n    and their corresponding stage coordinates (vector 1, 2, 3) and laser coordinate\n\n    Args:\n        v1s(np.ndarray): Vector 1 (stage frame of reference (FoR)) [mm]\n        v2s(np.ndarray): Vector 2 (stage FoR), must have the same x coordinate as v1s [mm]\n        v3s(np.ndarray): Vector 3 (stage FoR), must have the same y coordinate as v1s [mm]\n        v1c(np.ndarray): Vector 1 (camera FoR) corresponding to v1s [pixel]\n        v2c(np.ndarray): Vector 2 (camera FoR) corresponding to v2s [pixel]\n        v3c(np.ndarray): Vector 3 (camera FoR) corresponding to v3s [pixel]\n        vlc(np.ndarray): Vector of the laser coordinate in the camera FoR [pixel]\n    \"\"\"\n    assert all([isinstance(v, arr) for v in [v1s,v2s,v3s,v1c,v2c,v3c,vlc]]), 'Vectors must be numpy arrays'\n    v1s,v2s,v3s,v1c,v2c,v3c,vlc = [self._check_reshape(v) for v in [v1s,v2s,v3s,v1c,v2c,v3c,vlc]]\n\n    # assert np.allclose(v1s[1],v2s[1]), 'Vector 2 must have the same y coordinate as vector 1'\n    # assert np.allclose(v2s[0],v3s[0]), 'Vector 3 must have the same x coordinate as vector 2'\n\n    v1s*= -1\n    v2s*= -1\n    v3s*= -1\n\n    # Calculate the vector distances\n    dvs_12 = v2s - v1s  # Vector 1 to 2 in the stage frame of reference\n    dvs_23 = v3s - v2s  # Vector 2 to 3 in the stage frame of reference\n\n    dvc_12 = v2c - v1c  # Vector 1 to 2 in the camera frame of reference\n    dvc_23 = v3c - v2c  # Vector 2 to 3 in the camera frame of reference\n\n    theta_sign = np.sign(dvs_12[0][0])\n    # Calculate the rotation angle in radians, float\n    theta = np.arctan2(dvc_12[1][0]*theta_sign,dvc_12[0][0]*theta_sign)\n\n    # Calculate the scale in pixels per mm in the x direction\n    sx = dvc_12[0][0]/(dvs_12[0][0]*np.cos(theta)) # [pixel/mm]\n\n    # Calculate the y-axis flip\n    f = np.sign(dvc_23[1][0]/(dvs_23[1][0]*np.cos(theta)))\n\n    # Calculate the scale in pixels per mm in the y direction\n    sy = (dvc_23[1][0]/(dvs_23[1][0]*f*np.cos(theta))) # [pixel/mm]\n\n    if abs(theta) &gt; np.pi/2:\n        theta -= np.sign(theta)*np.pi\n        sx *= -1\n        sy *= -1\n\n    # Calculate the transformation matrix\n    mat_S = np.array(   # Scale matrix [pixel/mm]\n        [[sx, 0],\n         [0, sy]]\n    )\n\n    mat_F = np.array(   # Flip matrix [a.u.]\n        [[1, 0],\n         [0, f]]\n    )\n\n    mat_R = np.array(   # Rotation matrix [a.u.]\n        [[np.cos(theta), -np.sin(theta)],\n         [np.sin(theta), np.cos(theta)]]\n    )\n\n    self.mat_M_stg2img = mat_R @ mat_F @ mat_S # [pixel/mm]\n    self.mat_M_inv_img2stg = np.linalg.inv(self.mat_M_stg2img)\n\n    self.scale_x_pixelPerMm = sx\n    self.scale_y_pixelPerMm = sy\n    self.flip_y = f\n    self.rotation_rad = theta\n\n    self.set_laser_coor(vlc)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal.set_laser_coor","title":"<code>set_laser_coor(coor_laser_pixel)</code>","text":"<p>Sets the laser coordinate in the camera frame of reference</p> <p>Parameters:</p> Name Type Description Default <code>coor_laser_pixel</code> <code>ndarray</code> <p>Laser coordinate in the camera frame of reference [pixel]</p> required Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def set_laser_coor(self,coor_laser_pixel:arr) -&gt; None:\n    \"\"\"\n    Sets the laser coordinate in the camera frame of reference\n\n    Args:\n        coor_laser_pixel (arr): Laser coordinate in the camera frame of reference [pixel]\n    \"\"\"\n    assert self.check_calibration_set(exclude_laser=True), 'Calibration parameters are not set'\n    assert isinstance(coor_laser_pixel, arr), 'Laser coordinate must be a numpy array'\n    coor_laser_pixel = self._check_reshape(coor_laser_pixel)\n\n    coor_laser_stage = self.convert_imgpt2stg(coor_laser_pixel,np.array([0,0]))\n\n    self.laser_coor_x_mm = coor_laser_stage[0]\n    self.laser_coor_y_mm = coor_laser_stage[1]\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub","title":"<code>ImgMea_Cal_Hub</code>","text":"<p>A class to manage the calibration parameters loaded in a session</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>class ImgMea_Cal_Hub():\n    \"\"\"\n    A class to manage the calibration parameters loaded in a session\n    \"\"\"\n\n    def __init__(self):\n        self._dict_calibrations = {\n            'calibration_id':[],\n            'calibration':[]\n        }\n        self._last_path = None\n\n        self._list_observers = []\n\n    def add_observer(self,callback_func) -&gt; None:\n        \"\"\"\n        Adds an observer callback function to be notified when the calibration hub is updated\n\n        Args:\n            callback_func (function): Callback function to be called when the calibration hub is updated\n        \"\"\"\n        assert callable(callback_func), 'Callback function must be callable'\n        self._list_observers.append(callback_func)\n\n    def remove_observer(self,callback_func) -&gt; None:\n        \"\"\"\n        Removes an observer callback function\n\n        Args:\n            callback_func (function): Callback function to be removed\n        \"\"\"\n        assert callable(callback_func), 'Callback function must be callable'\n        try: self._list_observers.remove(callback_func)\n        except Exception as e: print(f'Error removing observer (ImgCalHub): {e}')\n\n    def notify_observers(self) -&gt; None:\n        \"\"\"\n        Notifies all observers that the calibration hub has been updated\n        \"\"\"\n        for callback in self._list_observers:\n            try: callback()\n            except Exception as e: print(f'Error notifying observer (ImgCalHub): {e}')\n\n    def load_calibration_folder(self, uselastpath:bool=False) -&gt; None:\n        \"\"\"\n        Prompts the user to select a folder to load the calibration files\n\n        Args:\n            uselastpath (bool): Use the last dir path. Default is False\n\n        Raises:\n            AssertionError: No directory selection is made\n        \"\"\"\n        if uselastpath:\n            try: self.load_calibration_folder(self._last_path); return\n            except: pass\n\n        path_folder = filedialog.askdirectory(title='Choose a folder to load the calibration files from')\n        assert path_folder != '', 'No directory selection is made'\n\n        self.load_calibrations(path_folder)\n\n    def load_calibrations(self,path_folder:str) -&gt; None:\n        \"\"\"\n        Loads all the calibration files from a folder\n\n        Args:\n            path_folder (str): Path to the folder containing the calibration files\n\n        Raises:\n            AssertionError: Path is not a directory\n            AssertionError: Path does not exist\n        \"\"\"\n        assert os.path.exists(path_folder), 'Path does not exist'\n        assert os.path.isdir(path_folder), 'Path is not a directory'\n\n        self.reset_calibrations()\n\n        list_json = glob.glob(os.path.join(path_folder,'*.json'))\n\n        for path in list_json:\n            try:\n                cal = ImgMea_Cal()\n                cal.load_calibration_json(path)\n                cal_id = cal.id\n\n                self._dict_calibrations['calibration_id'].append(cal_id)\n                self._dict_calibrations['calibration'].append(cal)\n            except: pass\n\n        self._last_path = path_folder\n\n    def reset_calibrations(self) -&gt; None:\n        \"\"\"\n        Empty the stored calibrations\n        \"\"\"\n        self._dict_calibrations['calibration_id'].clear()\n        self._dict_calibrations['calibration'].clear()\n\n    def get_calibration(self,cal_id:str) -&gt; ImgMea_Cal:\n        \"\"\"\n        Returns the calibration parameters\n\n        Args:\n            cal_id (str): Calibration ID\n\n        Returns:\n            ImageMeasurement_Calibration: Calibration parameters\n        \"\"\"\n        assert cal_id in self._dict_calibrations['calibration_id'], 'Calibration ID does not exist'\n\n        idx = self._dict_calibrations['calibration_id'].index(cal_id)\n        return self._dict_calibrations['calibration'][idx]\n\n    def get_calibration_ids(self) -&gt; list[str]:\n        \"\"\"\n        Returns the list of calibration IDs\n\n        Returns:\n            list[str]: List of calibration IDs\n        \"\"\"\n        return self._dict_calibrations['calibration_id']\n\n    def generate_dummy_calibrations(self, n:int=1) -&gt; None:\n        \"\"\"\n        Generates dummy calibration parameters for testing purposes\n\n        Args:\n            n (int): Number of dummy calibrations to generate. Default is 1\n        \"\"\"\n        for i in range(n):\n            cal = ImgMea_Cal()\n            cal.generate_dummy_params()\n            cal_id = f'dummy_{i}'\n\n            self._dict_calibrations['calibration_id'].append(cal_id)\n            self._dict_calibrations['calibration'].append(cal)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub.add_observer","title":"<code>add_observer(callback_func)</code>","text":"<p>Adds an observer callback function to be notified when the calibration hub is updated</p> <p>Parameters:</p> Name Type Description Default <code>callback_func</code> <code>function</code> <p>Callback function to be called when the calibration hub is updated</p> required Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def add_observer(self,callback_func) -&gt; None:\n    \"\"\"\n    Adds an observer callback function to be notified when the calibration hub is updated\n\n    Args:\n        callback_func (function): Callback function to be called when the calibration hub is updated\n    \"\"\"\n    assert callable(callback_func), 'Callback function must be callable'\n    self._list_observers.append(callback_func)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub.generate_dummy_calibrations","title":"<code>generate_dummy_calibrations(n=1)</code>","text":"<p>Generates dummy calibration parameters for testing purposes</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of dummy calibrations to generate. Default is 1</p> <code>1</code> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def generate_dummy_calibrations(self, n:int=1) -&gt; None:\n    \"\"\"\n    Generates dummy calibration parameters for testing purposes\n\n    Args:\n        n (int): Number of dummy calibrations to generate. Default is 1\n    \"\"\"\n    for i in range(n):\n        cal = ImgMea_Cal()\n        cal.generate_dummy_params()\n        cal_id = f'dummy_{i}'\n\n        self._dict_calibrations['calibration_id'].append(cal_id)\n        self._dict_calibrations['calibration'].append(cal)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub.get_calibration","title":"<code>get_calibration(cal_id)</code>","text":"<p>Returns the calibration parameters</p> <p>Parameters:</p> Name Type Description Default <code>cal_id</code> <code>str</code> <p>Calibration ID</p> required <p>Returns:</p> Name Type Description <code>ImageMeasurement_Calibration</code> <code>ImgMea_Cal</code> <p>Calibration parameters</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def get_calibration(self,cal_id:str) -&gt; ImgMea_Cal:\n    \"\"\"\n    Returns the calibration parameters\n\n    Args:\n        cal_id (str): Calibration ID\n\n    Returns:\n        ImageMeasurement_Calibration: Calibration parameters\n    \"\"\"\n    assert cal_id in self._dict_calibrations['calibration_id'], 'Calibration ID does not exist'\n\n    idx = self._dict_calibrations['calibration_id'].index(cal_id)\n    return self._dict_calibrations['calibration'][idx]\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub.get_calibration_ids","title":"<code>get_calibration_ids()</code>","text":"<p>Returns the list of calibration IDs</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of calibration IDs</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def get_calibration_ids(self) -&gt; list[str]:\n    \"\"\"\n    Returns the list of calibration IDs\n\n    Returns:\n        list[str]: List of calibration IDs\n    \"\"\"\n    return self._dict_calibrations['calibration_id']\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub.load_calibration_folder","title":"<code>load_calibration_folder(uselastpath=False)</code>","text":"<p>Prompts the user to select a folder to load the calibration files</p> <p>Parameters:</p> Name Type Description Default <code>uselastpath</code> <code>bool</code> <p>Use the last dir path. Default is False</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>No directory selection is made</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def load_calibration_folder(self, uselastpath:bool=False) -&gt; None:\n    \"\"\"\n    Prompts the user to select a folder to load the calibration files\n\n    Args:\n        uselastpath (bool): Use the last dir path. Default is False\n\n    Raises:\n        AssertionError: No directory selection is made\n    \"\"\"\n    if uselastpath:\n        try: self.load_calibration_folder(self._last_path); return\n        except: pass\n\n    path_folder = filedialog.askdirectory(title='Choose a folder to load the calibration files from')\n    assert path_folder != '', 'No directory selection is made'\n\n    self.load_calibrations(path_folder)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub.load_calibrations","title":"<code>load_calibrations(path_folder)</code>","text":"<p>Loads all the calibration files from a folder</p> <p>Parameters:</p> Name Type Description Default <code>path_folder</code> <code>str</code> <p>Path to the folder containing the calibration files</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>Path is not a directory</p> <code>AssertionError</code> <p>Path does not exist</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def load_calibrations(self,path_folder:str) -&gt; None:\n    \"\"\"\n    Loads all the calibration files from a folder\n\n    Args:\n        path_folder (str): Path to the folder containing the calibration files\n\n    Raises:\n        AssertionError: Path is not a directory\n        AssertionError: Path does not exist\n    \"\"\"\n    assert os.path.exists(path_folder), 'Path does not exist'\n    assert os.path.isdir(path_folder), 'Path is not a directory'\n\n    self.reset_calibrations()\n\n    list_json = glob.glob(os.path.join(path_folder,'*.json'))\n\n    for path in list_json:\n        try:\n            cal = ImgMea_Cal()\n            cal.load_calibration_json(path)\n            cal_id = cal.id\n\n            self._dict_calibrations['calibration_id'].append(cal_id)\n            self._dict_calibrations['calibration'].append(cal)\n        except: pass\n\n    self._last_path = path_folder\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub.notify_observers","title":"<code>notify_observers()</code>","text":"<p>Notifies all observers that the calibration hub has been updated</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def notify_observers(self) -&gt; None:\n    \"\"\"\n    Notifies all observers that the calibration hub has been updated\n    \"\"\"\n    for callback in self._list_observers:\n        try: callback()\n        except Exception as e: print(f'Error notifying observer (ImgCalHub): {e}')\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub.remove_observer","title":"<code>remove_observer(callback_func)</code>","text":"<p>Removes an observer callback function</p> <p>Parameters:</p> Name Type Description Default <code>callback_func</code> <code>function</code> <p>Callback function to be removed</p> required Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def remove_observer(self,callback_func) -&gt; None:\n    \"\"\"\n    Removes an observer callback function\n\n    Args:\n        callback_func (function): Callback function to be removed\n    \"\"\"\n    assert callable(callback_func), 'Callback function must be callable'\n    try: self._list_observers.remove(callback_func)\n    except Exception as e: print(f'Error removing observer (ImgCalHub): {e}')\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.ImgMea_Cal_Hub.reset_calibrations","title":"<code>reset_calibrations()</code>","text":"<p>Empty the stored calibrations</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def reset_calibrations(self) -&gt; None:\n    \"\"\"\n    Empty the stored calibrations\n    \"\"\"\n    self._dict_calibrations['calibration_id'].clear()\n    self._dict_calibrations['calibration'].clear()\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.generate_dummy_calibrationHub","title":"<code>generate_dummy_calibrationHub()</code>","text":"<p>Generates a dummy calibration hub with dummy calibration parameters for testing purposes. A dummy calibration is created and appended to the calibration hub.</p> <p>Returns:</p> Name Type Description <code>ImageMeasurement_Calibration_Hub</code> <code>ImgMea_Cal_Hub</code> <p>Dummy calibration hub with dummy calibration parameters</p> Source code in <code>iris/data/calibration_objective.py</code> <pre><code>def generate_dummy_calibrationHub() -&gt; ImgMea_Cal_Hub:\n    \"\"\"\n    Generates a dummy calibration hub with dummy calibration parameters for testing purposes.\n    A dummy calibration is created and appended to the calibration hub.\n\n    Returns:\n        ImageMeasurement_Calibration_Hub: Dummy calibration hub with dummy calibration parameters\n    \"\"\"\n    calhub = ImgMea_Cal_Hub()\n    calhub.reset_calibrations()\n\n    cal = ImgMea_Cal()\n    cal.generate_dummy_params()\n\n    calhub._dict_calibrations['calibration_id'].append(cal.id)\n    calhub._dict_calibrations['calibration'].append(cal)\n\n    return calhub\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/data/calibration_objective/#iris.data.calibration_objective.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/","title":"measurement_Raman","text":"<p>A class that processes the measurement data from a Raman spectrometer (spectra_dummy for an example file format)</p> <p>Designed around the QE Pro spectrometer from Ocean Insight.</p> Note <p>Note that the timestamp is meant to indicate the time the measurement was taken.     - Only 1 timestamp can be saved even if there are multiple raw spectra saved.     - In such case, it is recommended to use multiple measurement instances instead.     - The multiple really are only intended for background measurements and multi-acquisition measurements.</p> <p>Operations such as background subtraction, calibration, etc. are done externally and their results should  be saved separately as a new measurement instance.</p>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman","title":"<code>MeaRaman</code>","text":"<p>Analyses the data given a dataset and plot it</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>class MeaRaman():\n    \"\"\"Analyses the data given a dataset and plot it\n    \"\"\"\n    def __init__(self,\n                 timestamp:int|None=None,\n                 int_time_ms:int|None=None,\n                 laserPower_mW:float|None=None,\n                 laserWavelength_nm:float|None=None,\n                 extra_metadata:dict={},\n                 reconstruct:bool=False) -&gt; None:\n        \"\"\"\n        Initialises the raman measurement.\n\n        Args:\n            timestamp (int): measurement timestamp in integer [microsec]\n            int_time (int): integration time used for the measurement\n            laserPower_mW (float, optional): laser power in mW\n            laserWavelength_nm (float, optional): laser wavelength in nm\n            dict_extra_metadata (dict, optional): extra metadata to be stored. Defaults to None.\n            reconstruct (bool, optional): reconstruct the measurement from a saved file. Defaults to False.\n\n        Note:\n            - If reconstruct is True, the parameter checks are bypassed\n        \"\"\"\n        if not reconstruct: assert all([isinstance(timestamp,(int,float)),isinstance(int_time_ms,(int,float)),isinstance(laserPower_mW,(int,float)),\n            isinstance(laserWavelength_nm,(int,float)),isinstance(extra_metadata,(dict,type(None)))]),\\\n            'Timestamp, integration time, and laser power, and laser wavelength should be integers, integers, and floats respectively'\n\n    # &gt;&gt;&gt; Class version &lt;&lt;&lt;\n        self.version = '0.2.0_2024.08.22'  # Version of the class\n\n    # &gt;&gt;&gt; Measurement storage &lt;&lt;&lt;\n        self._measurement_time = timestamp       # Created instance time\n        self._integration_time_ms:int = int_time_ms    # Integration time used for the measuremrent in milliseconds\n\n        self._spectrum_rawlist:list[pd.DataFrame] = []      # list of pandas df (of the raw measurements): for storage\n\n        self._spectrum_analysed:pd.DataFrame|None = None            # pandas df: stores the averaged spectrum\n\n    # &gt;&gt;&gt; Name parameters &lt;&lt;&lt;\n        self.label_wavelength = DataAnalysisConfigEnum.WAVELENGTH_LABEL.value\n        self.label_intensity = DataAnalysisConfigEnum.INTENSITY_LABEL.value\n\n    # &gt;&gt;&gt; Analysis parameters &lt;&lt;&lt;\n        self._tolerance = DataAnalysisConfigEnum.SIMILARITY_THRESHOLD.value  # Tolerance to see if a wavelength is close to another for operations\n\n    # &gt;&gt;&gt; Data verification related &lt;&lt;&lt;\n        self._flg_uptodate = True    # Indicates if the stored background averaged spectrum is up to date with the raw_list measurements\n\n    # &gt;&gt;&gt; Offloading/storage &lt;&lt;&lt;\n        self._dict_metadata = {\n            'integration_time_ms':self._integration_time_ms,\n            'accumulation':0,\n            'laser_power_milliwatt': laserPower_mW,\n            'laser_wavelength_nm': laserWavelength_nm,\n            'version': self.version\n        }\n\n        self._noneditable_metadata_keys = ['version','integration_time_ms','accumulation']\n        assert all([key in self._dict_metadata.keys() for key in self._noneditable_metadata_keys]), 'Non-editable metadata keys are not in the metadata dictionary'\n\n        assert all([key not in self._dict_metadata.keys() for key in extra_metadata.keys()]),\\\n            'Extra metadata keys should not overlap with the default metadata keys'\n        self._dict_metadata.update(extra_metadata) # Add extra metadata if any\n\n    def reconstruct(self,measurement_id:int,metadata:dict,spec_analysed:pd.DataFrame,spec_rawlist:list[pd.DataFrame]|None=None):\n        \"\"\"\n        Reconstructs the measurement from a saved file\n\n        Args:\n            measurement_id (int): ID of the measurement, usually the timestamp [microsec] in integer\n            metadata (dict): metadata of the measurement\n            spec_analysed (pd.DataFrame): analysed spectrum\n            spec_rawlist (list[pd.DataFrame], optional): raw measurements. Defaults to None.\n\n        Note:\n            Since the rawlist is rarely used, it can be skipped if not needed\n        \"\"\"\n        # For backward compatibility. 'acquisition_number' is changed to 'accumulation' in version 2.4.0\n        if 'acquisition_number' in list(metadata.keys()):\n            metadata['accumulation'] = metadata['acquisition_number']\n            metadata.pop('acquisition_number')\n\n        assert all([isinstance(measurement_id,int),isinstance(metadata,dict),isinstance(spec_analysed,pd.DataFrame),isinstance(spec_rawlist,(type(None),list))]),\\\n            'metadata should be a dictionary, spec_analysed should be a pandas DataFrame, and spec_rawlist should be a list of pandas DataFrames'\n        assert all([key in metadata.keys() for key in self._dict_metadata.keys()]), 'The metadata keys are not the same'\n        assert all([key in spec_analysed.columns for key in [self.label_wavelength,self.label_intensity]]),\\\n            'The analysed spectrum columns does not contain the required columns'\n\n        self._dict_metadata = metadata\n        self._spectrum_analysed = spec_analysed\n        self._measurement_time = measurement_id\n        self._integration_time_ms = metadata['integration_time_ms']\n        if spec_rawlist:\n            self._spectrum_rawlist = spec_rawlist\n\n    def get_latest_timestamp(self) -&gt; int:\n        \"\"\"\n        Returns the latest timestamp of the measurement\n\n        Returns:\n            int: latest timestamp\n        \"\"\"\n        return self._measurement_time\n\n    def update_editable_metadata(self,key:str,value):\n        \"\"\"\n        Updates the editable metadata\n\n        Args:\n            key (str): key to update\n            value: value to update\n        \"\"\"\n        assert key in self._dict_metadata.keys(), 'The key is not in the metadata dictionary'\n        assert key not in self._noneditable_metadata_keys, 'The key is non-editable'\n        self._dict_metadata[key] = value\n\n    def get_editable_metadata_keys(self) -&gt; list[str]:\n        \"\"\"\n        Returns the editable metadata keys\n\n        Returns:\n            list: list of editable metadata keys\n        \"\"\"\n        list_keys = [key for key in self._dict_metadata.keys() if key not in self._noneditable_metadata_keys]\n        return list_keys\n\n    def get_measurements(self) -&gt; tuple[list[pd.DataFrame],pd.DataFrame]:\n        \"\"\"\n        Returns the stored measurements\n\n        Returns:\n            tuple[list[pd.DataFrame],pd.DataFrame]: list of raw measurements, averaged spectrum\n        \"\"\"\n        return self._spectrum_rawlist,self._spectrum_analysed\n\n    def check_measurement_exist(self) -&gt; bool:\n        \"\"\"\n        Checks if the measurement data exists\n\n        Returns:\n            bool: True if the measurement data exists, False otherwise\n        \"\"\"\n        if len(self._spectrum_rawlist) == 0 and not isinstance(self._spectrum_analysed,pd.DataFrame): return False\n        self.check_uptodate(autoupdate=True)\n        return True\n\n    def print_reports(self):\n        \"\"\"\n        Prints the reports of the recorded measurements so far\n        \"\"\"\n        print('Measurement time:',self._measurement_time)\n        print('Integration time:',self._integration_time_ms)\n        print('Collected measurements:',len(self._spectrum_rawlist))\n\n    def get_laser_params(self) -&gt; tuple[float,float]:\n        \"\"\"\n        Returns the laser parameters\n\n        Returns:\n            tuple[float,float]: laser power, laser wavelength\n        \"\"\"\n        return self._dict_metadata['laser_power_milliwatt'],self._dict_metadata['laser_wavelength_nm']\n\n    def get_laserMetadata_key(self) -&gt; tuple[str,str]:\n        \"\"\"\n        Returns the keys of the laser metadata\n\n        Returns:\n            tuple[str]: keys of the laser metadata (laser power, laser wavelength)\n        \"\"\"\n        return ('laser_power_milliwatt','laser_wavelength_nm')\n\n    def get_metadata(self):\n        \"\"\"\n        Returns the metadata of the measurement\n\n        Returns:\n            dict: metadata\n        \"\"\"\n        self.check_uptodate(autoupdate=True)\n        return self._dict_metadata\n\n    def check_uptodate(self,autoupdate=True):\n        \"\"\"\n        Checks if the analysed variables (avg and sub) are up-to-date and\n        automatically updates them. Also updates the metadata.\n\n        Returns:\n            bool: final state of the variables (up-to-date or not)\n        \"\"\"\n        # Updates the metadata first\n        self._dict_metadata['accumulation'] = len(self._spectrum_rawlist)\n\n        if autoupdate and not self._flg_uptodate:\n            self._spectrum_analysed = self.average(self._spectrum_rawlist)\n            self._flg_uptodate = True\n        return self._flg_uptodate\n\n    def get_intensity(self, wavelength:float|None=None, raman_shift:float|None=None) -&gt; float:\n        \"\"\"\n        Retrieves the intensity at a specific wavelength.\n\n        Args:\n            wavelength (float | None, optional): The wavelength to search for. Defaults to None.\n            raman_shift (float | None, optional): The Raman shift value to retrieve. Defaults to None.\n\n        Returns:\n            float: The intensity at the specified wavelength.\n        \"\"\"\n        if not any([isinstance(wavelength,(type(None),int,float)),isinstance(raman_shift,(type(None),int,float))]):\n            raise ValueError(\"Either 'wavelength' or 'raman_shift' must be provided\")\n        if all([isinstance(wavelength,(int,float)),isinstance(raman_shift,(int,float))]):\n            raise ValueError(\"Only one of 'wavelength' or 'raman_shift' should be provided\")\n\n        if raman_shift is not None:\n            # If raman_shift is provided, convert it to wavelength\n            wavelength = convert_ramanshift_to_wavelength(raman_shift, self.get_laser_params()[1])\n\n        idx = self.get_wavelength_index(wavelength)\n\n        idx_start = self._spectrum_analysed.index[0]\n        intensity = self._spectrum_analysed[self.label_intensity][idx+idx_start]\n\n        return intensity\n\n    def get_wavelength_index(self,wavelength:float) -&gt; int:\n        \"\"\"\n        Returns the index of the given wavelength in the spectrum (if it does not exist, returns the closest index)\n\n        Args:\n            wavelength (float): wavelength to search for\n\n        Returns:\n            int: index of the wavelength in the spectrum\n        \"\"\"\n        assert isinstance(wavelength,(int,float)), 'wavelength should be an integer or float'\n        if len(self._spectrum_rawlist) == 0 and len(self._spectrum_analysed) == 0: raise ValueError('No measurements have been taken yet')\n\n        if len(self._spectrum_rawlist) == 0: spectrum = self._spectrum_analysed\n        else: spectrum = self._spectrum_rawlist[0]\n\n        # Get the wavelength list\n        wavelength_list = spectrum[self.label_wavelength].values\n        # Get the index of the closest wavelength\n        idx = bisect.bisect_left(wavelength_list,wavelength)\n\n        # Convert idx to the closest wavelength\n        if idx == 0 or idx == len(wavelength_list):\n            idx = idx\n        # Check if the wavelength is closer to the current or the next one\n        elif abs(wavelength_list[idx-1]-wavelength) &lt; abs(wavelength_list[idx]-wavelength):\n            idx = idx-1\n        return idx\n\n    def get_raw_list(self):\n        \"\"\"\n        Returns the raw list of measurements\n\n        Returns:\n            list: pd.df of raw measurements\n        \"\"\"\n        return self._spectrum_rawlist\n\n    def set_raw_list(self,df_mea:pd.DataFrame,timestamp_int:int,max_accumulation:int=1000) -&gt; list[pd.DataFrame]:\n        \"\"\"\n        Adds a measurement dataframe to the stored list of continuous measurements\n\n        Args:\n            df_mea (pd.DataFrame, optional): df of the measurement. Defaults to None.\n            timestamp_int (int, optional): timestamp of the measurement in integer [microsec].\n            If none, takes the current timestamp. Defaults to None.\n        \"\"\"\n        assert isinstance(df_mea,pd.DataFrame), \"'df_mea' should be a pandas DataFrame\"\n        assert isinstance(timestamp_int,int), \"'timestamp_int' should be an integer\"\n\n        self._measurement_time = timestamp_int\n\n        # Updates the flag to let the class know that a new measurement has been added to the list\n        self._flg_uptodate = False\n\n        if len(self._spectrum_rawlist) &lt; max_accumulation:\n            self._spectrum_rawlist.append(df_mea)\n        else:\n            self._spectrum_rawlist.pop(0)\n            self._spectrum_rawlist.append(df_mea)\n        return self._spectrum_rawlist\n\n    def get_average_rawlist(self,spectrum_rawlist) -&gt; pd.DataFrame:\n        \"\"\"\n        Updates the value of the averaged and background substracted \n        spectra of the multimeasurement\n\n        Args:\n            spectrum_rawlist (list): list of raw measurements (pd.df)\n\n        Returns:\n            pd.df: averaged spectrum\n        \"\"\"\n        spectrum_avg = self.average(spectrum_rawlist)\n        return spectrum_avg\n\n    def calculate_analysed(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Calculates the analysed values (averaged and subtracted)\n\n        Returns:\n            pd.DataFrame: analysed spectra\n        \"\"\"\n        spectrum_analysed = self.average(self._spectrum_rawlist)\n        self._flg_uptodate = True\n        self._spectrum_analysed = spectrum_analysed\n        return spectrum_analysed\n\n    def set_analysed(self,spectrum_analysed:pd.DataFrame|np.ndarray):\n        \"\"\"\n        Sets the analysed values (averaged and subtracted)\n\n        Args:\n            spectrum_analysed (pd.DataFrame|np.ndarray): analysed spectra\n        \"\"\"\n        if not isinstance(spectrum_analysed,(pd.DataFrame,np.ndarray)):\n            raise TypeError(\"'spectrum_analysed' should be a pandas DataFrame or numpy array\")\n        self._flg_uptodate = True\n        if isinstance(spectrum_analysed,pd.DataFrame): self._spectrum_analysed = spectrum_analysed\n        else:\n            if not spectrum_analysed.shape[1] == 2: raise ValueError(\"'spectrum_analysed' should have 2 columns (wavelength, intensity)\")\n            self._spectrum_analysed = pd.DataFrame(spectrum_analysed, columns=[self.label_wavelength, self.label_intensity])\n\n    def get_analysed(self, type:Literal['DataFrame','array']='DataFrame') -&gt; pd.DataFrame|np.ndarray|None:\n        \"\"\"\n        Get the analysed spectra.\n\n        Args:\n            type (Literal['DataFrame', 'array']): The type of the output\n\n        Returns:\n            pd.DataFrame|np.ndarray|None: analysed spectra or None if not available\n        \"\"\"\n        if not self._flg_uptodate: print('!!!!! Returned analysed spectra are NOT UP-TO-DATE !!!!!')\n        if not isinstance(self._spectrum_analysed, pd.DataFrame): return None\n\n        if type == 'DataFrame': ret = self._spectrum_analysed\n        else: ret = self._spectrum_analysed.to_numpy()\n\n        return ret\n\n    def _get_any_measurement(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Returns a dataframe, either from the analysed or the rawlist\n\n        Returns:\n            pd.DataFrame: Dataframe of the measurement.\n        \"\"\"\n        assert self.check_measurement_exist(), 'No valid measurement exists to get Raman shift array.'\n        if not isinstance(self._spectrum_analysed, pd.DataFrame):\n            return self._spectrum_rawlist[-1]\n        elif isinstance(self._spectrum_analysed, pd.DataFrame):\n            return self._spectrum_analysed\n        else: raise ValueError('Analysed spectra is not in a valid format')\n\n    def get_arr_wavelength(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns the wavelength array of the analysed spectra\n\n        Returns:\n            np.ndarray: Wavelength array\n        \"\"\"\n        df = self._get_any_measurement()\n        return df[self.label_wavelength].to_numpy()\n\n    def get_arr_ramanshift(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns the Raman shift array of the analysed spectra\n\n        Returns:\n            np.ndarray: Raman shift array\n        \"\"\"\n        df = self._get_any_measurement()\n\n        laser_wavelength = self.get_laser_params()[1]\n        wavelength_array = df[self.label_wavelength].to_numpy()\n        ramanshift_array = convert_wavelength_to_ramanshift(wavelength_array, laser_wavelength)\n\n        return ramanshift_array # type: ignore ; It's definitely a np.ndarray\n\n    def get_arr_intensity(self, mea_type:Literal['analysed','raw','any']='analysed') -&gt; np.ndarray:\n        \"\"\"\n        Returns the intensity array of the analysed or raw spectra\n\n        Args:\n            mea_type (Literal['analysed','raw'], optional): Type of spectra to get the intensity from. Defaults to 'analysed'.\n\n        Returns:\n            np.ndarray: Intensity array\n        \"\"\"\n        assert mea_type in ['analysed','raw','any'], \"'type' should be either 'analysed', 'raw', or 'any'\"\n        assert self.check_measurement_exist(), 'No valid measurement exists to get intensity array.'\n        if mea_type == 'analysed': df = self._spectrum_analysed\n        elif mea_type == 'raw': df = self._spectrum_rawlist[-1]\n        elif mea_type == 'any': df = self._get_any_measurement()\n        df:pd.DataFrame\n        return df[self.label_intensity].to_numpy()\n\n    @staticmethod\n    def average(spectra_list:list[pd.DataFrame]) -&gt; pd.DataFrame:\n        \"\"\"\n        Averages a given spectra list. Refer to the wavelenght_name and intensity_name\n        for the required column names in the input dataframes.\n\n        The program also checks if the spectra being averaged the same up to 0.1nm\n\n        Args:\n            spectra_list (list): List of spectra dataframes in the same form as the one for plot\n\n        Returns:\n            Dataframe: Average spectra in the same form as the input\n        \"\"\"\n        lbl_wvl = DataAnalysisConfigEnum.WAVELENGTH_LABEL.value\n        lbl_int = DataAnalysisConfigEnum.INTENSITY_LABEL.value\n        intensity_list = [spectra[lbl_int].values for spectra in spectra_list]\n        wavelength_list = [spectra[lbl_wvl].values for spectra in spectra_list]\n        tolerance = DataAnalysisConfigEnum.SIMILARITY_THRESHOLD.value\n\n        def wavelength_similarity_check(wavelength_list):\n            def check(wl1, wl2):\n                return all(abs(w1 - w2) &lt;= tolerance for w1, w2 in zip(wl1, wl2))\n            similar = all(check(wl, wavelength_list[0]) for wl in wavelength_list[1:])\n            return similar\n\n        # Check if the wavelengths are similar and warns the user if they're different\n        if not wavelength_similarity_check(wavelength_list):\n            print(\"!!!!! SPECTRA WITH DIFFERENT WAVELENGTHS BEING AVERAGED !!!!!\")\n\n        # Calculate the average spectrum, extract the wavelengths, and put on the current timestamp\n        all_intensities = np.vstack([intensity_list[i] for i in range(len(intensity_list))])\n        avg_intensity = np.mean(all_intensities, axis=0)\n        wavelength = spectra_list[0][lbl_wvl]\n\n        # Write the average spectrum dataframe\n        avg_spectra = pd.DataFrame({\n            lbl_wvl: wavelength,\n            lbl_int: avg_intensity\n        })\n        return avg_spectra\n\n    def copy(self) -&gt; Self: # type: ignore\n        \"\"\"\n        Creates a copy of the current MeaRaman instance.\n\n        Returns:\n            MeaRaman: A new copy of the current instance.\n        \"\"\"\n        new_copy = MeaRaman(reconstruct=True)\n        if not self.check_measurement_exist():\n            raise ValueError(\"No valid measurement exists to copy.\")\n\n        new_copy.reconstruct(\n            measurement_id=self._measurement_time,\n            metadata=self._dict_metadata.copy(),\n            spec_analysed=self._spectrum_analysed.copy(),\n            spec_rawlist=self._spectrum_rawlist.copy()\n        )\n\n    def self_report(self):\n        \"\"\"\n        Prints out all the attributes of the class\n        \"\"\"\n        print('Class attributes:')\n        attributes = vars(self)\n        for attr, value in attributes.items():\n            print(f\"{attr}: {value}\")\n        print()\n\n    def test_generate_dummy(self):\n        \"\"\"\n        Generates a dummy spectra for testing purposes\n        \"\"\"\n        # Set the parameters\n        timestamp = get_timestamp_us_int()\n        int_time = 51.163\n        laser_power = 24.5\n        laser_wavelength = 785.123\n\n        # Generate the dummy spectra\n        wavelength = np.linspace(400, 800, 100)\n        intensity = np.random.rand(100)\n        df = pd.DataFrame({\n            self.label_wavelength: wavelength,\n            self.label_intensity: intensity\n        })\n\n        # Set the parameters\n        self._measurement_time = timestamp\n        self._integration_time_ms = int_time\n        self._dict_metadata['integration_time_ms'] = int_time\n        self._dict_metadata['laser_power_milliwatt'] = laser_power\n        self._dict_metadata['laser_wavelength_nm'] = laser_wavelength\n\n        # Set the raw list\n        self.set_raw_list(df,timestamp)\n        self.check_uptodate(autoupdate=True)\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.__init__","title":"<code>__init__(timestamp=None, int_time_ms=None, laserPower_mW=None, laserWavelength_nm=None, extra_metadata={}, reconstruct=False)</code>","text":"<p>Initialises the raman measurement.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>measurement timestamp in integer [microsec]</p> <code>None</code> <code>int_time</code> <code>int</code> <p>integration time used for the measurement</p> required <code>laserPower_mW</code> <code>float</code> <p>laser power in mW</p> <code>None</code> <code>laserWavelength_nm</code> <code>float</code> <p>laser wavelength in nm</p> <code>None</code> <code>dict_extra_metadata</code> <code>dict</code> <p>extra metadata to be stored. Defaults to None.</p> required <code>reconstruct</code> <code>bool</code> <p>reconstruct the measurement from a saved file. Defaults to False.</p> <code>False</code> Note <ul> <li>If reconstruct is True, the parameter checks are bypassed</li> </ul> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def __init__(self,\n             timestamp:int|None=None,\n             int_time_ms:int|None=None,\n             laserPower_mW:float|None=None,\n             laserWavelength_nm:float|None=None,\n             extra_metadata:dict={},\n             reconstruct:bool=False) -&gt; None:\n    \"\"\"\n    Initialises the raman measurement.\n\n    Args:\n        timestamp (int): measurement timestamp in integer [microsec]\n        int_time (int): integration time used for the measurement\n        laserPower_mW (float, optional): laser power in mW\n        laserWavelength_nm (float, optional): laser wavelength in nm\n        dict_extra_metadata (dict, optional): extra metadata to be stored. Defaults to None.\n        reconstruct (bool, optional): reconstruct the measurement from a saved file. Defaults to False.\n\n    Note:\n        - If reconstruct is True, the parameter checks are bypassed\n    \"\"\"\n    if not reconstruct: assert all([isinstance(timestamp,(int,float)),isinstance(int_time_ms,(int,float)),isinstance(laserPower_mW,(int,float)),\n        isinstance(laserWavelength_nm,(int,float)),isinstance(extra_metadata,(dict,type(None)))]),\\\n        'Timestamp, integration time, and laser power, and laser wavelength should be integers, integers, and floats respectively'\n\n# &gt;&gt;&gt; Class version &lt;&lt;&lt;\n    self.version = '0.2.0_2024.08.22'  # Version of the class\n\n# &gt;&gt;&gt; Measurement storage &lt;&lt;&lt;\n    self._measurement_time = timestamp       # Created instance time\n    self._integration_time_ms:int = int_time_ms    # Integration time used for the measuremrent in milliseconds\n\n    self._spectrum_rawlist:list[pd.DataFrame] = []      # list of pandas df (of the raw measurements): for storage\n\n    self._spectrum_analysed:pd.DataFrame|None = None            # pandas df: stores the averaged spectrum\n\n# &gt;&gt;&gt; Name parameters &lt;&lt;&lt;\n    self.label_wavelength = DataAnalysisConfigEnum.WAVELENGTH_LABEL.value\n    self.label_intensity = DataAnalysisConfigEnum.INTENSITY_LABEL.value\n\n# &gt;&gt;&gt; Analysis parameters &lt;&lt;&lt;\n    self._tolerance = DataAnalysisConfigEnum.SIMILARITY_THRESHOLD.value  # Tolerance to see if a wavelength is close to another for operations\n\n# &gt;&gt;&gt; Data verification related &lt;&lt;&lt;\n    self._flg_uptodate = True    # Indicates if the stored background averaged spectrum is up to date with the raw_list measurements\n\n# &gt;&gt;&gt; Offloading/storage &lt;&lt;&lt;\n    self._dict_metadata = {\n        'integration_time_ms':self._integration_time_ms,\n        'accumulation':0,\n        'laser_power_milliwatt': laserPower_mW,\n        'laser_wavelength_nm': laserWavelength_nm,\n        'version': self.version\n    }\n\n    self._noneditable_metadata_keys = ['version','integration_time_ms','accumulation']\n    assert all([key in self._dict_metadata.keys() for key in self._noneditable_metadata_keys]), 'Non-editable metadata keys are not in the metadata dictionary'\n\n    assert all([key not in self._dict_metadata.keys() for key in extra_metadata.keys()]),\\\n        'Extra metadata keys should not overlap with the default metadata keys'\n    self._dict_metadata.update(extra_metadata) # Add extra metadata if any\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.average","title":"<code>average(spectra_list)</code>  <code>staticmethod</code>","text":"<p>Averages a given spectra list. Refer to the wavelenght_name and intensity_name for the required column names in the input dataframes.</p> <p>The program also checks if the spectra being averaged the same up to 0.1nm</p> <p>Parameters:</p> Name Type Description Default <code>spectra_list</code> <code>list</code> <p>List of spectra dataframes in the same form as the one for plot</p> required <p>Returns:</p> Name Type Description <code>Dataframe</code> <code>DataFrame</code> <p>Average spectra in the same form as the input</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>@staticmethod\ndef average(spectra_list:list[pd.DataFrame]) -&gt; pd.DataFrame:\n    \"\"\"\n    Averages a given spectra list. Refer to the wavelenght_name and intensity_name\n    for the required column names in the input dataframes.\n\n    The program also checks if the spectra being averaged the same up to 0.1nm\n\n    Args:\n        spectra_list (list): List of spectra dataframes in the same form as the one for plot\n\n    Returns:\n        Dataframe: Average spectra in the same form as the input\n    \"\"\"\n    lbl_wvl = DataAnalysisConfigEnum.WAVELENGTH_LABEL.value\n    lbl_int = DataAnalysisConfigEnum.INTENSITY_LABEL.value\n    intensity_list = [spectra[lbl_int].values for spectra in spectra_list]\n    wavelength_list = [spectra[lbl_wvl].values for spectra in spectra_list]\n    tolerance = DataAnalysisConfigEnum.SIMILARITY_THRESHOLD.value\n\n    def wavelength_similarity_check(wavelength_list):\n        def check(wl1, wl2):\n            return all(abs(w1 - w2) &lt;= tolerance for w1, w2 in zip(wl1, wl2))\n        similar = all(check(wl, wavelength_list[0]) for wl in wavelength_list[1:])\n        return similar\n\n    # Check if the wavelengths are similar and warns the user if they're different\n    if not wavelength_similarity_check(wavelength_list):\n        print(\"!!!!! SPECTRA WITH DIFFERENT WAVELENGTHS BEING AVERAGED !!!!!\")\n\n    # Calculate the average spectrum, extract the wavelengths, and put on the current timestamp\n    all_intensities = np.vstack([intensity_list[i] for i in range(len(intensity_list))])\n    avg_intensity = np.mean(all_intensities, axis=0)\n    wavelength = spectra_list[0][lbl_wvl]\n\n    # Write the average spectrum dataframe\n    avg_spectra = pd.DataFrame({\n        lbl_wvl: wavelength,\n        lbl_int: avg_intensity\n    })\n    return avg_spectra\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.calculate_analysed","title":"<code>calculate_analysed()</code>","text":"<p>Calculates the analysed values (averaged and subtracted)</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: analysed spectra</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def calculate_analysed(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the analysed values (averaged and subtracted)\n\n    Returns:\n        pd.DataFrame: analysed spectra\n    \"\"\"\n    spectrum_analysed = self.average(self._spectrum_rawlist)\n    self._flg_uptodate = True\n    self._spectrum_analysed = spectrum_analysed\n    return spectrum_analysed\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.check_measurement_exist","title":"<code>check_measurement_exist()</code>","text":"<p>Checks if the measurement data exists</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the measurement data exists, False otherwise</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def check_measurement_exist(self) -&gt; bool:\n    \"\"\"\n    Checks if the measurement data exists\n\n    Returns:\n        bool: True if the measurement data exists, False otherwise\n    \"\"\"\n    if len(self._spectrum_rawlist) == 0 and not isinstance(self._spectrum_analysed,pd.DataFrame): return False\n    self.check_uptodate(autoupdate=True)\n    return True\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.check_uptodate","title":"<code>check_uptodate(autoupdate=True)</code>","text":"<p>Checks if the analysed variables (avg and sub) are up-to-date and automatically updates them. Also updates the metadata.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>final state of the variables (up-to-date or not)</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def check_uptodate(self,autoupdate=True):\n    \"\"\"\n    Checks if the analysed variables (avg and sub) are up-to-date and\n    automatically updates them. Also updates the metadata.\n\n    Returns:\n        bool: final state of the variables (up-to-date or not)\n    \"\"\"\n    # Updates the metadata first\n    self._dict_metadata['accumulation'] = len(self._spectrum_rawlist)\n\n    if autoupdate and not self._flg_uptodate:\n        self._spectrum_analysed = self.average(self._spectrum_rawlist)\n        self._flg_uptodate = True\n    return self._flg_uptodate\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.copy","title":"<code>copy()</code>","text":"<p>Creates a copy of the current MeaRaman instance.</p> <p>Returns:</p> Name Type Description <code>MeaRaman</code> <code>Self</code> <p>A new copy of the current instance.</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def copy(self) -&gt; Self: # type: ignore\n    \"\"\"\n    Creates a copy of the current MeaRaman instance.\n\n    Returns:\n        MeaRaman: A new copy of the current instance.\n    \"\"\"\n    new_copy = MeaRaman(reconstruct=True)\n    if not self.check_measurement_exist():\n        raise ValueError(\"No valid measurement exists to copy.\")\n\n    new_copy.reconstruct(\n        measurement_id=self._measurement_time,\n        metadata=self._dict_metadata.copy(),\n        spec_analysed=self._spectrum_analysed.copy(),\n        spec_rawlist=self._spectrum_rawlist.copy()\n    )\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_analysed","title":"<code>get_analysed(type='DataFrame')</code>","text":"<p>Get the analysed spectra.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['DataFrame', 'array']</code> <p>The type of the output</p> <code>'DataFrame'</code> <p>Returns:</p> Type Description <code>DataFrame | ndarray | None</code> <p>pd.DataFrame|np.ndarray|None: analysed spectra or None if not available</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_analysed(self, type:Literal['DataFrame','array']='DataFrame') -&gt; pd.DataFrame|np.ndarray|None:\n    \"\"\"\n    Get the analysed spectra.\n\n    Args:\n        type (Literal['DataFrame', 'array']): The type of the output\n\n    Returns:\n        pd.DataFrame|np.ndarray|None: analysed spectra or None if not available\n    \"\"\"\n    if not self._flg_uptodate: print('!!!!! Returned analysed spectra are NOT UP-TO-DATE !!!!!')\n    if not isinstance(self._spectrum_analysed, pd.DataFrame): return None\n\n    if type == 'DataFrame': ret = self._spectrum_analysed\n    else: ret = self._spectrum_analysed.to_numpy()\n\n    return ret\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_arr_intensity","title":"<code>get_arr_intensity(mea_type='analysed')</code>","text":"<p>Returns the intensity array of the analysed or raw spectra</p> <p>Parameters:</p> Name Type Description Default <code>mea_type</code> <code>Literal['analysed', 'raw']</code> <p>Type of spectra to get the intensity from. Defaults to 'analysed'.</p> <code>'analysed'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Intensity array</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_arr_intensity(self, mea_type:Literal['analysed','raw','any']='analysed') -&gt; np.ndarray:\n    \"\"\"\n    Returns the intensity array of the analysed or raw spectra\n\n    Args:\n        mea_type (Literal['analysed','raw'], optional): Type of spectra to get the intensity from. Defaults to 'analysed'.\n\n    Returns:\n        np.ndarray: Intensity array\n    \"\"\"\n    assert mea_type in ['analysed','raw','any'], \"'type' should be either 'analysed', 'raw', or 'any'\"\n    assert self.check_measurement_exist(), 'No valid measurement exists to get intensity array.'\n    if mea_type == 'analysed': df = self._spectrum_analysed\n    elif mea_type == 'raw': df = self._spectrum_rawlist[-1]\n    elif mea_type == 'any': df = self._get_any_measurement()\n    df:pd.DataFrame\n    return df[self.label_intensity].to_numpy()\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_arr_ramanshift","title":"<code>get_arr_ramanshift()</code>","text":"<p>Returns the Raman shift array of the analysed spectra</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Raman shift array</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_arr_ramanshift(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns the Raman shift array of the analysed spectra\n\n    Returns:\n        np.ndarray: Raman shift array\n    \"\"\"\n    df = self._get_any_measurement()\n\n    laser_wavelength = self.get_laser_params()[1]\n    wavelength_array = df[self.label_wavelength].to_numpy()\n    ramanshift_array = convert_wavelength_to_ramanshift(wavelength_array, laser_wavelength)\n\n    return ramanshift_array # type: ignore ; It's definitely a np.ndarray\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_arr_wavelength","title":"<code>get_arr_wavelength()</code>","text":"<p>Returns the wavelength array of the analysed spectra</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wavelength array</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_arr_wavelength(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns the wavelength array of the analysed spectra\n\n    Returns:\n        np.ndarray: Wavelength array\n    \"\"\"\n    df = self._get_any_measurement()\n    return df[self.label_wavelength].to_numpy()\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_average_rawlist","title":"<code>get_average_rawlist(spectrum_rawlist)</code>","text":"<p>Updates the value of the averaged and background substracted  spectra of the multimeasurement</p> <p>Parameters:</p> Name Type Description Default <code>spectrum_rawlist</code> <code>list</code> <p>list of raw measurements (pd.df)</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.df: averaged spectrum</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_average_rawlist(self,spectrum_rawlist) -&gt; pd.DataFrame:\n    \"\"\"\n    Updates the value of the averaged and background substracted \n    spectra of the multimeasurement\n\n    Args:\n        spectrum_rawlist (list): list of raw measurements (pd.df)\n\n    Returns:\n        pd.df: averaged spectrum\n    \"\"\"\n    spectrum_avg = self.average(spectrum_rawlist)\n    return spectrum_avg\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_editable_metadata_keys","title":"<code>get_editable_metadata_keys()</code>","text":"<p>Returns the editable metadata keys</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[str]</code> <p>list of editable metadata keys</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_editable_metadata_keys(self) -&gt; list[str]:\n    \"\"\"\n    Returns the editable metadata keys\n\n    Returns:\n        list: list of editable metadata keys\n    \"\"\"\n    list_keys = [key for key in self._dict_metadata.keys() if key not in self._noneditable_metadata_keys]\n    return list_keys\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_intensity","title":"<code>get_intensity(wavelength=None, raman_shift=None)</code>","text":"<p>Retrieves the intensity at a specific wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | None</code> <p>The wavelength to search for. Defaults to None.</p> <code>None</code> <code>raman_shift</code> <code>float | None</code> <p>The Raman shift value to retrieve. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The intensity at the specified wavelength.</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_intensity(self, wavelength:float|None=None, raman_shift:float|None=None) -&gt; float:\n    \"\"\"\n    Retrieves the intensity at a specific wavelength.\n\n    Args:\n        wavelength (float | None, optional): The wavelength to search for. Defaults to None.\n        raman_shift (float | None, optional): The Raman shift value to retrieve. Defaults to None.\n\n    Returns:\n        float: The intensity at the specified wavelength.\n    \"\"\"\n    if not any([isinstance(wavelength,(type(None),int,float)),isinstance(raman_shift,(type(None),int,float))]):\n        raise ValueError(\"Either 'wavelength' or 'raman_shift' must be provided\")\n    if all([isinstance(wavelength,(int,float)),isinstance(raman_shift,(int,float))]):\n        raise ValueError(\"Only one of 'wavelength' or 'raman_shift' should be provided\")\n\n    if raman_shift is not None:\n        # If raman_shift is provided, convert it to wavelength\n        wavelength = convert_ramanshift_to_wavelength(raman_shift, self.get_laser_params()[1])\n\n    idx = self.get_wavelength_index(wavelength)\n\n    idx_start = self._spectrum_analysed.index[0]\n    intensity = self._spectrum_analysed[self.label_intensity][idx+idx_start]\n\n    return intensity\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_laserMetadata_key","title":"<code>get_laserMetadata_key()</code>","text":"<p>Returns the keys of the laser metadata</p> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str]: keys of the laser metadata (laser power, laser wavelength)</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_laserMetadata_key(self) -&gt; tuple[str,str]:\n    \"\"\"\n    Returns the keys of the laser metadata\n\n    Returns:\n        tuple[str]: keys of the laser metadata (laser power, laser wavelength)\n    \"\"\"\n    return ('laser_power_milliwatt','laser_wavelength_nm')\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_laser_params","title":"<code>get_laser_params()</code>","text":"<p>Returns the laser parameters</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float,float]: laser power, laser wavelength</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_laser_params(self) -&gt; tuple[float,float]:\n    \"\"\"\n    Returns the laser parameters\n\n    Returns:\n        tuple[float,float]: laser power, laser wavelength\n    \"\"\"\n    return self._dict_metadata['laser_power_milliwatt'],self._dict_metadata['laser_wavelength_nm']\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_latest_timestamp","title":"<code>get_latest_timestamp()</code>","text":"<p>Returns the latest timestamp of the measurement</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>latest timestamp</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_latest_timestamp(self) -&gt; int:\n    \"\"\"\n    Returns the latest timestamp of the measurement\n\n    Returns:\n        int: latest timestamp\n    \"\"\"\n    return self._measurement_time\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_measurements","title":"<code>get_measurements()</code>","text":"<p>Returns the stored measurements</p> <p>Returns:</p> Type Description <code>tuple[list[DataFrame], DataFrame]</code> <p>tuple[list[pd.DataFrame],pd.DataFrame]: list of raw measurements, averaged spectrum</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_measurements(self) -&gt; tuple[list[pd.DataFrame],pd.DataFrame]:\n    \"\"\"\n    Returns the stored measurements\n\n    Returns:\n        tuple[list[pd.DataFrame],pd.DataFrame]: list of raw measurements, averaged spectrum\n    \"\"\"\n    return self._spectrum_rawlist,self._spectrum_analysed\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_metadata","title":"<code>get_metadata()</code>","text":"<p>Returns the metadata of the measurement</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>metadata</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_metadata(self):\n    \"\"\"\n    Returns the metadata of the measurement\n\n    Returns:\n        dict: metadata\n    \"\"\"\n    self.check_uptodate(autoupdate=True)\n    return self._dict_metadata\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_raw_list","title":"<code>get_raw_list()</code>","text":"<p>Returns the raw list of measurements</p> <p>Returns:</p> Name Type Description <code>list</code> <p>pd.df of raw measurements</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_raw_list(self):\n    \"\"\"\n    Returns the raw list of measurements\n\n    Returns:\n        list: pd.df of raw measurements\n    \"\"\"\n    return self._spectrum_rawlist\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.get_wavelength_index","title":"<code>get_wavelength_index(wavelength)</code>","text":"<p>Returns the index of the given wavelength in the spectrum (if it does not exist, returns the closest index)</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>wavelength to search for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>index of the wavelength in the spectrum</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_wavelength_index(self,wavelength:float) -&gt; int:\n    \"\"\"\n    Returns the index of the given wavelength in the spectrum (if it does not exist, returns the closest index)\n\n    Args:\n        wavelength (float): wavelength to search for\n\n    Returns:\n        int: index of the wavelength in the spectrum\n    \"\"\"\n    assert isinstance(wavelength,(int,float)), 'wavelength should be an integer or float'\n    if len(self._spectrum_rawlist) == 0 and len(self._spectrum_analysed) == 0: raise ValueError('No measurements have been taken yet')\n\n    if len(self._spectrum_rawlist) == 0: spectrum = self._spectrum_analysed\n    else: spectrum = self._spectrum_rawlist[0]\n\n    # Get the wavelength list\n    wavelength_list = spectrum[self.label_wavelength].values\n    # Get the index of the closest wavelength\n    idx = bisect.bisect_left(wavelength_list,wavelength)\n\n    # Convert idx to the closest wavelength\n    if idx == 0 or idx == len(wavelength_list):\n        idx = idx\n    # Check if the wavelength is closer to the current or the next one\n    elif abs(wavelength_list[idx-1]-wavelength) &lt; abs(wavelength_list[idx]-wavelength):\n        idx = idx-1\n    return idx\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.print_reports","title":"<code>print_reports()</code>","text":"<p>Prints the reports of the recorded measurements so far</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def print_reports(self):\n    \"\"\"\n    Prints the reports of the recorded measurements so far\n    \"\"\"\n    print('Measurement time:',self._measurement_time)\n    print('Integration time:',self._integration_time_ms)\n    print('Collected measurements:',len(self._spectrum_rawlist))\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.reconstruct","title":"<code>reconstruct(measurement_id, metadata, spec_analysed, spec_rawlist=None)</code>","text":"<p>Reconstructs the measurement from a saved file</p> <p>Parameters:</p> Name Type Description Default <code>measurement_id</code> <code>int</code> <p>ID of the measurement, usually the timestamp [microsec] in integer</p> required <code>metadata</code> <code>dict</code> <p>metadata of the measurement</p> required <code>spec_analysed</code> <code>DataFrame</code> <p>analysed spectrum</p> required <code>spec_rawlist</code> <code>list[DataFrame]</code> <p>raw measurements. Defaults to None.</p> <code>None</code> Note <p>Since the rawlist is rarely used, it can be skipped if not needed</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def reconstruct(self,measurement_id:int,metadata:dict,spec_analysed:pd.DataFrame,spec_rawlist:list[pd.DataFrame]|None=None):\n    \"\"\"\n    Reconstructs the measurement from a saved file\n\n    Args:\n        measurement_id (int): ID of the measurement, usually the timestamp [microsec] in integer\n        metadata (dict): metadata of the measurement\n        spec_analysed (pd.DataFrame): analysed spectrum\n        spec_rawlist (list[pd.DataFrame], optional): raw measurements. Defaults to None.\n\n    Note:\n        Since the rawlist is rarely used, it can be skipped if not needed\n    \"\"\"\n    # For backward compatibility. 'acquisition_number' is changed to 'accumulation' in version 2.4.0\n    if 'acquisition_number' in list(metadata.keys()):\n        metadata['accumulation'] = metadata['acquisition_number']\n        metadata.pop('acquisition_number')\n\n    assert all([isinstance(measurement_id,int),isinstance(metadata,dict),isinstance(spec_analysed,pd.DataFrame),isinstance(spec_rawlist,(type(None),list))]),\\\n        'metadata should be a dictionary, spec_analysed should be a pandas DataFrame, and spec_rawlist should be a list of pandas DataFrames'\n    assert all([key in metadata.keys() for key in self._dict_metadata.keys()]), 'The metadata keys are not the same'\n    assert all([key in spec_analysed.columns for key in [self.label_wavelength,self.label_intensity]]),\\\n        'The analysed spectrum columns does not contain the required columns'\n\n    self._dict_metadata = metadata\n    self._spectrum_analysed = spec_analysed\n    self._measurement_time = measurement_id\n    self._integration_time_ms = metadata['integration_time_ms']\n    if spec_rawlist:\n        self._spectrum_rawlist = spec_rawlist\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.self_report","title":"<code>self_report()</code>","text":"<p>Prints out all the attributes of the class</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def self_report(self):\n    \"\"\"\n    Prints out all the attributes of the class\n    \"\"\"\n    print('Class attributes:')\n    attributes = vars(self)\n    for attr, value in attributes.items():\n        print(f\"{attr}: {value}\")\n    print()\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.set_analysed","title":"<code>set_analysed(spectrum_analysed)</code>","text":"<p>Sets the analysed values (averaged and subtracted)</p> <p>Parameters:</p> Name Type Description Default <code>spectrum_analysed</code> <code>DataFrame | ndarray</code> <p>analysed spectra</p> required Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def set_analysed(self,spectrum_analysed:pd.DataFrame|np.ndarray):\n    \"\"\"\n    Sets the analysed values (averaged and subtracted)\n\n    Args:\n        spectrum_analysed (pd.DataFrame|np.ndarray): analysed spectra\n    \"\"\"\n    if not isinstance(spectrum_analysed,(pd.DataFrame,np.ndarray)):\n        raise TypeError(\"'spectrum_analysed' should be a pandas DataFrame or numpy array\")\n    self._flg_uptodate = True\n    if isinstance(spectrum_analysed,pd.DataFrame): self._spectrum_analysed = spectrum_analysed\n    else:\n        if not spectrum_analysed.shape[1] == 2: raise ValueError(\"'spectrum_analysed' should have 2 columns (wavelength, intensity)\")\n        self._spectrum_analysed = pd.DataFrame(spectrum_analysed, columns=[self.label_wavelength, self.label_intensity])\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.set_raw_list","title":"<code>set_raw_list(df_mea, timestamp_int, max_accumulation=1000)</code>","text":"<p>Adds a measurement dataframe to the stored list of continuous measurements</p> <p>Parameters:</p> Name Type Description Default <code>df_mea</code> <code>DataFrame</code> <p>df of the measurement. Defaults to None.</p> required <code>timestamp_int</code> <code>int</code> <p>timestamp of the measurement in integer [microsec].</p> required Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def set_raw_list(self,df_mea:pd.DataFrame,timestamp_int:int,max_accumulation:int=1000) -&gt; list[pd.DataFrame]:\n    \"\"\"\n    Adds a measurement dataframe to the stored list of continuous measurements\n\n    Args:\n        df_mea (pd.DataFrame, optional): df of the measurement. Defaults to None.\n        timestamp_int (int, optional): timestamp of the measurement in integer [microsec].\n        If none, takes the current timestamp. Defaults to None.\n    \"\"\"\n    assert isinstance(df_mea,pd.DataFrame), \"'df_mea' should be a pandas DataFrame\"\n    assert isinstance(timestamp_int,int), \"'timestamp_int' should be an integer\"\n\n    self._measurement_time = timestamp_int\n\n    # Updates the flag to let the class know that a new measurement has been added to the list\n    self._flg_uptodate = False\n\n    if len(self._spectrum_rawlist) &lt; max_accumulation:\n        self._spectrum_rawlist.append(df_mea)\n    else:\n        self._spectrum_rawlist.pop(0)\n        self._spectrum_rawlist.append(df_mea)\n    return self._spectrum_rawlist\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.test_generate_dummy","title":"<code>test_generate_dummy()</code>","text":"<p>Generates a dummy spectra for testing purposes</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def test_generate_dummy(self):\n    \"\"\"\n    Generates a dummy spectra for testing purposes\n    \"\"\"\n    # Set the parameters\n    timestamp = get_timestamp_us_int()\n    int_time = 51.163\n    laser_power = 24.5\n    laser_wavelength = 785.123\n\n    # Generate the dummy spectra\n    wavelength = np.linspace(400, 800, 100)\n    intensity = np.random.rand(100)\n    df = pd.DataFrame({\n        self.label_wavelength: wavelength,\n        self.label_intensity: intensity\n    })\n\n    # Set the parameters\n    self._measurement_time = timestamp\n    self._integration_time_ms = int_time\n    self._dict_metadata['integration_time_ms'] = int_time\n    self._dict_metadata['laser_power_milliwatt'] = laser_power\n    self._dict_metadata['laser_wavelength_nm'] = laser_wavelength\n\n    # Set the raw list\n    self.set_raw_list(df,timestamp)\n    self.check_uptodate(autoupdate=True)\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman.update_editable_metadata","title":"<code>update_editable_metadata(key, value)</code>","text":"<p>Updates the editable metadata</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key to update</p> required <code>value</code> <p>value to update</p> required Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def update_editable_metadata(self,key:str,value):\n    \"\"\"\n    Updates the editable metadata\n\n    Args:\n        key (str): key to update\n        value: value to update\n    \"\"\"\n    assert key in self._dict_metadata.keys(), 'The key is not in the metadata dictionary'\n    assert key not in self._noneditable_metadata_keys, 'The key is non-editable'\n    self._dict_metadata[key] = value\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman_Handler","title":"<code>MeaRaman_Handler</code>","text":"<p>Saves the measurement data into a file (from the class raman_measurement)</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>class MeaRaman_Handler():\n    \"\"\"\n    Saves the measurement data into a file (from the class raman_measurement)\n    \"\"\"\n    def save_measurement_to_txt(self,measurement:MeaRaman,filepath:str,save_raw:bool=False):\n        \"\"\"\n        Saves the measurement data into a text file\n\n        Args:\n            measurement (raman_measurement): measurement data\n            filepath (str): path to save the file\n            save_raw (bool, optional): save the raw measurements. Defaults to False.\n        \"\"\"\n        try:    \n            with open(filepath, 'w') as file:\n                file.write('# Timestamp: '+str(measurement.get_latest_timestamp())+'\\n')\n                file.write('# Integration time: '+str(measurement._integration_time_ms)+'\\n')\n                file.write('# Laser power: '+str(measurement.get_laser_params()[0])+'\\n')\n                file.write('# Laser wavelength: '+str(measurement.get_laser_params()[1])+'\\n')\n                file.write('# Accumulation: '+str(len(measurement.get_raw_list()))+'\\n')\n                file.write('# Version: '+measurement.version+'\\n')\n\n                # Write the analysed measurements\n                file.write('\\n# Analysed measurements:\\n')\n                df = measurement.get_analysed()\n                header = df.columns\n                file.write('# {}\\n'.format('\\t'.join(header)))\n                rows = df.values\n                [file.write('\\t'.join([str(val) for val in row])+'\\n') for row in rows]\n\n                if save_raw:\n                    # Write the raw measurements\n                    file.write('\\n# Raw measurements:\\n')\n                    list_df = measurement.get_raw_list()\n                    df = list_df[0]\n                    header = df.columns\n                    file.write('# {}\\n'.format('\\t'.join(header)))\n                    for df in list_df:\n                        rows = df.values\n                        [file.write('\\t'.join([str(val) for val in row])+'\\n') for row in rows]\n                        if not df.equals(list_df[-1]): file.write('\\n')\n\n        except Exception as e: print('Error: save_measurement_to_txt\\n',e)\n\n    def save_measurement_to_pickle(self,measurement:MeaRaman,filepath:str,savename:str):\n        \"\"\"\n        Saves the measurement data into a pickle file\n\n        Args:\n            measurement (raman_measurement): measurement data\n            filepath (str): path to save the file\n\n        Returns:\n            str: path to the saved file\n        \"\"\"\n        # Check if filepath is a directory\n        if os.path.isdir(filepath):\n            # Add a default filename\n            filepath = os.path.join(filepath, savename+'.pkl')\n\n        with open(filepath, 'wb') as file:\n            pickle.dump(measurement, file)\n        return filepath\n\n    def load_measurement_from_pickle(self,filepath:str):\n        \"\"\"\n        Loads the measurement data from a pickle file\n\n        Args:\n            filepath (str): path to the file\n\n        Returns:\n            raman_measurement: measurement data\n        \"\"\"\n        with open(filepath, 'rb') as file:\n            measurement = pickle.load(file)\n        return measurement\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman_Handler.load_measurement_from_pickle","title":"<code>load_measurement_from_pickle(filepath)</code>","text":"<p>Loads the measurement data from a pickle file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>path to the file</p> required <p>Returns:</p> Name Type Description <code>raman_measurement</code> <p>measurement data</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def load_measurement_from_pickle(self,filepath:str):\n    \"\"\"\n    Loads the measurement data from a pickle file\n\n    Args:\n        filepath (str): path to the file\n\n    Returns:\n        raman_measurement: measurement data\n    \"\"\"\n    with open(filepath, 'rb') as file:\n        measurement = pickle.load(file)\n    return measurement\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman_Handler.save_measurement_to_pickle","title":"<code>save_measurement_to_pickle(measurement, filepath, savename)</code>","text":"<p>Saves the measurement data into a pickle file</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>raman_measurement</code> <p>measurement data</p> required <code>filepath</code> <code>str</code> <p>path to save the file</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>path to the saved file</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def save_measurement_to_pickle(self,measurement:MeaRaman,filepath:str,savename:str):\n    \"\"\"\n    Saves the measurement data into a pickle file\n\n    Args:\n        measurement (raman_measurement): measurement data\n        filepath (str): path to save the file\n\n    Returns:\n        str: path to the saved file\n    \"\"\"\n    # Check if filepath is a directory\n    if os.path.isdir(filepath):\n        # Add a default filename\n        filepath = os.path.join(filepath, savename+'.pkl')\n\n    with open(filepath, 'wb') as file:\n        pickle.dump(measurement, file)\n    return filepath\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman_Handler.save_measurement_to_txt","title":"<code>save_measurement_to_txt(measurement, filepath, save_raw=False)</code>","text":"<p>Saves the measurement data into a text file</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>raman_measurement</code> <p>measurement data</p> required <code>filepath</code> <code>str</code> <p>path to save the file</p> required <code>save_raw</code> <code>bool</code> <p>save the raw measurements. Defaults to False.</p> <code>False</code> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def save_measurement_to_txt(self,measurement:MeaRaman,filepath:str,save_raw:bool=False):\n    \"\"\"\n    Saves the measurement data into a text file\n\n    Args:\n        measurement (raman_measurement): measurement data\n        filepath (str): path to save the file\n        save_raw (bool, optional): save the raw measurements. Defaults to False.\n    \"\"\"\n    try:    \n        with open(filepath, 'w') as file:\n            file.write('# Timestamp: '+str(measurement.get_latest_timestamp())+'\\n')\n            file.write('# Integration time: '+str(measurement._integration_time_ms)+'\\n')\n            file.write('# Laser power: '+str(measurement.get_laser_params()[0])+'\\n')\n            file.write('# Laser wavelength: '+str(measurement.get_laser_params()[1])+'\\n')\n            file.write('# Accumulation: '+str(len(measurement.get_raw_list()))+'\\n')\n            file.write('# Version: '+measurement.version+'\\n')\n\n            # Write the analysed measurements\n            file.write('\\n# Analysed measurements:\\n')\n            df = measurement.get_analysed()\n            header = df.columns\n            file.write('# {}\\n'.format('\\t'.join(header)))\n            rows = df.values\n            [file.write('\\t'.join([str(val) for val in row])+'\\n') for row in rows]\n\n            if save_raw:\n                # Write the raw measurements\n                file.write('\\n# Raw measurements:\\n')\n                list_df = measurement.get_raw_list()\n                df = list_df[0]\n                header = df.columns\n                file.write('# {}\\n'.format('\\t'.join(header)))\n                for df in list_df:\n                    rows = df.values\n                    [file.write('\\t'.join([str(val) for val in row])+'\\n') for row in rows]\n                    if not df.equals(list_df[-1]): file.write('\\n')\n\n    except Exception as e: print('Error: save_measurement_to_txt\\n',e)\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman_Plotter","title":"<code>MeaRaman_Plotter</code>","text":"<p>A class for plotting Raman spectra from a RamanMeasurement instance</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>class MeaRaman_Plotter():\n    \"\"\"\n    A class for plotting Raman spectra from a RamanMeasurement instance\n    \"\"\"\n    def __init__(self, plt_size:list|None=None) -&gt; None:\n        # &gt;&gt;&gt; Plot parameters &lt;&lt;&lt;\n        self.plt_size = AppPlotEnum.PLT_SIZE_1D_PIXEL.value      # Plot size in [pixel x pixel]\n\n        self.wavelength_name = DataAnalysisConfigEnum.WAVELENGTH_LABEL.value     # The wavelength column name\n        self.intensity_name = DataAnalysisConfigEnum.INTENSITY_LABEL.value       # The spectra intensity column name\n        self.ramanshift_name = DataAnalysisConfigEnum.RAMANSHIFT_LABEL.value     # The Raman shift column name\n\n        self._fig, self._ax = plt.subplots(figsize=plt_size)\n\n    def get_fig_ax(self) -&gt; tuple[Figure, Axes]:\n        \"\"\"\n        Returns the figure and axes used for plotting\n\n        Returns:\n            tuple[Figure, Axes]: figure and axes\n        \"\"\"\n        return self._fig, self._ax\n\n    def plot(\n        self,\n        measurement:MeaRaman,\n        title='Spectra',\n        flg_plot_ramanshift=False,\n        plot_raw:bool=False,\n        limits:tuple[float|None,float|None,float|None,float|None]=(None,None,None,None),\n        ) -&gt; None:\n        \"\"\"\n        Plot a given Ramanmeasurement into the internal figure.\n\n        Args:\n            measurement (RamanMeasurement): Measurement instance to plot.\n            title (str, optional): Title of the plot. Defaults to 'Spectra'.\n            showplot (bool, optional): Show the plot with a matplotlib window. Defaults to False.\n            flg_plot_ramanshift (bool, optional): Plot the Raman shift instead of the wavelength. Defaults to False.\n            plot_raw (bool, optional): Plot the raw data instead of the analysed data. Defaults to False.\n            limits (tuple[float,float,float,float], optional): Limits of the plot (xmin,xmax,ymin,ymax). Defaults to (None,None,None,None).\n        \"\"\"\n        assert isinstance(measurement,MeaRaman), \"'measurement' should be a RamanMeasurement instance\"\n        assert measurement.check_measurement_exist(), \"No valid measurement exists to plot.\"\n\n        fig,ax = self.get_fig_ax()\n        ax.clear()\n\n        if not plot_raw: mea_type = 'analysed'\n        else: mea_type = 'raw'\n\n        if flg_plot_ramanshift: arr_specpos = measurement.get_arr_ramanshift()\n        else: arr_specpos = measurement.get_arr_wavelength()\n\n        arr_intensity = measurement.get_arr_intensity(mea_type=mea_type)\n\n        ax.plot(arr_specpos, arr_intensity)\n        ax.set_xlabel(self.ramanshift_name if flg_plot_ramanshift else self.wavelength_name)\n        ax.set_ylabel(self.intensity_name)\n        ax.set_title(title)\n        ax.set_xlim(limits[0], limits[1])\n        ax.set_ylim(limits[2], limits[3])\n\n    def plot_scatter(\n            self,\n            measurement:MeaRaman|None,\n            title='Spectra',\n            list_scatter_wavelength:list=[],\n            list_scatter_intensity:list=[],\n            flg_plot_ramanshift=False,\n            limits:tuple[float,float,float,float]|tuple[None,None,None,None]=(None,None,None,None)\n            ) -&gt; None:\n        \"\"\"\n        Plots a given spectra with scatter points.\n\n        Args:\n            measurement (RamanMeasurement): Measurement instance to plot.\n            title (str, optional): Title of the plot. Defaults to 'Spectra'.\n            list_scatter_wavelength (list, optional): List of scatter points' wavelengths. Defaults to [].\n            list_scatter_intensity (list, optional): List of scatter points' intensities. Defaults to [].\n            flg_plot_ramanshift (bool, optional): Plot the Raman shift instead of the wavelength. Defaults to False.\n            limits (tuple[float,float,float,float], optional): Limits of the plot (xmin,xmax,ymin,ymax). Defaults to (None,None,None,None).\n\n        Returns:\n            None\n\n        Note:\n            - If the given 'spectra' variable is not a pandas DataFrame, a white image will be returned.\n            - The plot will be resized based on the specified plt_size or the default plt_size if not provided.\n        \"\"\"\n        fig = self._fig\n        ax = self._ax\n\n        # Initialises the plot\n        if isinstance(fig,type(None)) and isinstance(ax,type(None)):\n            fig,ax = plt.subplots()\n        elif isinstance(fig,type(None)) or isinstance(ax,type(None)):\n            raise ValueError('Both fig and ax should be given')\n\n        # Check if the given 'spectra' variable is a measurement. Otherwise, returns an white image\n        if not isinstance(measurement,MeaRaman): return\n\n        # Extracts the data\n        df = measurement.get_analysed()\n        list_wavelength = df[measurement.label_wavelength]\n        list_intensity = df[measurement.label_intensity]\n\n        # Convert to Raman shift if required\n        if flg_plot_ramanshift:\n            laser_wavelength = measurement.get_laser_params()[1]\n            list_SpectraPosition = [convert_wavelength_to_ramanshift(wavelength,laser_wavelength) for wavelength in list_wavelength]\n            list_SpectraPosition_scatter = [convert_wavelength_to_ramanshift(wavelength,laser_wavelength) for wavelength in list_scatter_wavelength]\n            xlabel = self.ramanshift_name\n        else:\n            list_SpectraPosition = list_wavelength\n            list_SpectraPosition_scatter = list_scatter_wavelength\n            xlabel = self.wavelength_name\n\n        assert len(list_SpectraPosition) == len(list_intensity), 'The length of the wavelength and intensity should be the same'\n\n        # Slice the list spectral position based on the given x limits\n        if isinstance(limits[0],float):\n            idx_start = bisect.bisect_left(list_SpectraPosition,limits[0])\n            list_SpectraPosition = list_SpectraPosition[idx_start:]\n            list_intensity = list_intensity[idx_start:]\n            idx_start_scatter = bisect.bisect_left(list_SpectraPosition_scatter,limits[0])\n            list_SpectraPosition_scatter = list_SpectraPosition_scatter[idx_start_scatter:]\n            list_scatter_intensity = list_scatter_intensity[idx_start_scatter:]\n        if isinstance(limits[1],float):\n            idx_end = bisect.bisect_right(list_SpectraPosition,limits[1])\n            list_SpectraPosition = list_SpectraPosition[:idx_end]\n            list_intensity = list_intensity[:idx_end]\n            idx_end_scatter = bisect.bisect_right(list_SpectraPosition_scatter,limits[1])\n            list_SpectraPosition_scatter = list_SpectraPosition_scatter[:idx_end_scatter]\n            list_scatter_intensity = list_scatter_intensity[:idx_end_scatter]\n\n        list_label_scatter = ['{:.1f}'.format(val) for val in list_SpectraPosition_scatter]\n        list_SpectraPosition_scatter = [float(val) for val in list_SpectraPosition_scatter]\n        list_scatter_intensity = [float(val) for val in list_scatter_intensity]\n\n        ax.clear()\n        ax.plot(list_SpectraPosition, list_intensity)\n        if len(list_scatter_intensity) &gt; 0: ax.scatter(list_SpectraPosition_scatter,list_scatter_intensity,color='red')\n        for i, txt in enumerate(list_label_scatter): ax.annotate(txt, (list_SpectraPosition_scatter[i], list_scatter_intensity[i]))\n\n        xmin = limits[0] if limits[0] else None\n        xmax = limits[1] if limits[1] else None\n        ymin = limits[2] if limits[2] else None\n        ymax = limits[3] if limits[3] else None\n        ax.set_xlim(xmin,xmax)\n        ax.set_ylim(ymin,ymax)\n\n        ax.set_xlabel(xlabel)\n        ax.set_ylabel(self.intensity_name)\n        ax.set_title(title)\n        # ax.legend()\n\n        fig.tight_layout()\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman_Plotter.get_fig_ax","title":"<code>get_fig_ax()</code>","text":"<p>Returns the figure and axes used for plotting</p> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>tuple[Figure, Axes]: figure and axes</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def get_fig_ax(self) -&gt; tuple[Figure, Axes]:\n    \"\"\"\n    Returns the figure and axes used for plotting\n\n    Returns:\n        tuple[Figure, Axes]: figure and axes\n    \"\"\"\n    return self._fig, self._ax\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman_Plotter.plot","title":"<code>plot(measurement, title='Spectra', flg_plot_ramanshift=False, plot_raw=False, limits=(None, None, None, None))</code>","text":"<p>Plot a given Ramanmeasurement into the internal figure.</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>RamanMeasurement</code> <p>Measurement instance to plot.</p> required <code>title</code> <code>str</code> <p>Title of the plot. Defaults to 'Spectra'.</p> <code>'Spectra'</code> <code>showplot</code> <code>bool</code> <p>Show the plot with a matplotlib window. Defaults to False.</p> required <code>flg_plot_ramanshift</code> <code>bool</code> <p>Plot the Raman shift instead of the wavelength. Defaults to False.</p> <code>False</code> <code>plot_raw</code> <code>bool</code> <p>Plot the raw data instead of the analysed data. Defaults to False.</p> <code>False</code> <code>limits</code> <code>tuple[float, float, float, float]</code> <p>Limits of the plot (xmin,xmax,ymin,ymax). Defaults to (None,None,None,None).</p> <code>(None, None, None, None)</code> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def plot(\n    self,\n    measurement:MeaRaman,\n    title='Spectra',\n    flg_plot_ramanshift=False,\n    plot_raw:bool=False,\n    limits:tuple[float|None,float|None,float|None,float|None]=(None,None,None,None),\n    ) -&gt; None:\n    \"\"\"\n    Plot a given Ramanmeasurement into the internal figure.\n\n    Args:\n        measurement (RamanMeasurement): Measurement instance to plot.\n        title (str, optional): Title of the plot. Defaults to 'Spectra'.\n        showplot (bool, optional): Show the plot with a matplotlib window. Defaults to False.\n        flg_plot_ramanshift (bool, optional): Plot the Raman shift instead of the wavelength. Defaults to False.\n        plot_raw (bool, optional): Plot the raw data instead of the analysed data. Defaults to False.\n        limits (tuple[float,float,float,float], optional): Limits of the plot (xmin,xmax,ymin,ymax). Defaults to (None,None,None,None).\n    \"\"\"\n    assert isinstance(measurement,MeaRaman), \"'measurement' should be a RamanMeasurement instance\"\n    assert measurement.check_measurement_exist(), \"No valid measurement exists to plot.\"\n\n    fig,ax = self.get_fig_ax()\n    ax.clear()\n\n    if not plot_raw: mea_type = 'analysed'\n    else: mea_type = 'raw'\n\n    if flg_plot_ramanshift: arr_specpos = measurement.get_arr_ramanshift()\n    else: arr_specpos = measurement.get_arr_wavelength()\n\n    arr_intensity = measurement.get_arr_intensity(mea_type=mea_type)\n\n    ax.plot(arr_specpos, arr_intensity)\n    ax.set_xlabel(self.ramanshift_name if flg_plot_ramanshift else self.wavelength_name)\n    ax.set_ylabel(self.intensity_name)\n    ax.set_title(title)\n    ax.set_xlim(limits[0], limits[1])\n    ax.set_ylim(limits[2], limits[3])\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.MeaRaman_Plotter.plot_scatter","title":"<code>plot_scatter(measurement, title='Spectra', list_scatter_wavelength=[], list_scatter_intensity=[], flg_plot_ramanshift=False, limits=(None, None, None, None))</code>","text":"<p>Plots a given spectra with scatter points.</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>RamanMeasurement</code> <p>Measurement instance to plot.</p> required <code>title</code> <code>str</code> <p>Title of the plot. Defaults to 'Spectra'.</p> <code>'Spectra'</code> <code>list_scatter_wavelength</code> <code>list</code> <p>List of scatter points' wavelengths. Defaults to [].</p> <code>[]</code> <code>list_scatter_intensity</code> <code>list</code> <p>List of scatter points' intensities. Defaults to [].</p> <code>[]</code> <code>flg_plot_ramanshift</code> <code>bool</code> <p>Plot the Raman shift instead of the wavelength. Defaults to False.</p> <code>False</code> <code>limits</code> <code>tuple[float, float, float, float]</code> <p>Limits of the plot (xmin,xmax,ymin,ymax). Defaults to (None,None,None,None).</p> <code>(None, None, None, None)</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Note <ul> <li>If the given 'spectra' variable is not a pandas DataFrame, a white image will be returned.</li> <li>The plot will be resized based on the specified plt_size or the default plt_size if not provided.</li> </ul> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def plot_scatter(\n        self,\n        measurement:MeaRaman|None,\n        title='Spectra',\n        list_scatter_wavelength:list=[],\n        list_scatter_intensity:list=[],\n        flg_plot_ramanshift=False,\n        limits:tuple[float,float,float,float]|tuple[None,None,None,None]=(None,None,None,None)\n        ) -&gt; None:\n    \"\"\"\n    Plots a given spectra with scatter points.\n\n    Args:\n        measurement (RamanMeasurement): Measurement instance to plot.\n        title (str, optional): Title of the plot. Defaults to 'Spectra'.\n        list_scatter_wavelength (list, optional): List of scatter points' wavelengths. Defaults to [].\n        list_scatter_intensity (list, optional): List of scatter points' intensities. Defaults to [].\n        flg_plot_ramanshift (bool, optional): Plot the Raman shift instead of the wavelength. Defaults to False.\n        limits (tuple[float,float,float,float], optional): Limits of the plot (xmin,xmax,ymin,ymax). Defaults to (None,None,None,None).\n\n    Returns:\n        None\n\n    Note:\n        - If the given 'spectra' variable is not a pandas DataFrame, a white image will be returned.\n        - The plot will be resized based on the specified plt_size or the default plt_size if not provided.\n    \"\"\"\n    fig = self._fig\n    ax = self._ax\n\n    # Initialises the plot\n    if isinstance(fig,type(None)) and isinstance(ax,type(None)):\n        fig,ax = plt.subplots()\n    elif isinstance(fig,type(None)) or isinstance(ax,type(None)):\n        raise ValueError('Both fig and ax should be given')\n\n    # Check if the given 'spectra' variable is a measurement. Otherwise, returns an white image\n    if not isinstance(measurement,MeaRaman): return\n\n    # Extracts the data\n    df = measurement.get_analysed()\n    list_wavelength = df[measurement.label_wavelength]\n    list_intensity = df[measurement.label_intensity]\n\n    # Convert to Raman shift if required\n    if flg_plot_ramanshift:\n        laser_wavelength = measurement.get_laser_params()[1]\n        list_SpectraPosition = [convert_wavelength_to_ramanshift(wavelength,laser_wavelength) for wavelength in list_wavelength]\n        list_SpectraPosition_scatter = [convert_wavelength_to_ramanshift(wavelength,laser_wavelength) for wavelength in list_scatter_wavelength]\n        xlabel = self.ramanshift_name\n    else:\n        list_SpectraPosition = list_wavelength\n        list_SpectraPosition_scatter = list_scatter_wavelength\n        xlabel = self.wavelength_name\n\n    assert len(list_SpectraPosition) == len(list_intensity), 'The length of the wavelength and intensity should be the same'\n\n    # Slice the list spectral position based on the given x limits\n    if isinstance(limits[0],float):\n        idx_start = bisect.bisect_left(list_SpectraPosition,limits[0])\n        list_SpectraPosition = list_SpectraPosition[idx_start:]\n        list_intensity = list_intensity[idx_start:]\n        idx_start_scatter = bisect.bisect_left(list_SpectraPosition_scatter,limits[0])\n        list_SpectraPosition_scatter = list_SpectraPosition_scatter[idx_start_scatter:]\n        list_scatter_intensity = list_scatter_intensity[idx_start_scatter:]\n    if isinstance(limits[1],float):\n        idx_end = bisect.bisect_right(list_SpectraPosition,limits[1])\n        list_SpectraPosition = list_SpectraPosition[:idx_end]\n        list_intensity = list_intensity[:idx_end]\n        idx_end_scatter = bisect.bisect_right(list_SpectraPosition_scatter,limits[1])\n        list_SpectraPosition_scatter = list_SpectraPosition_scatter[:idx_end_scatter]\n        list_scatter_intensity = list_scatter_intensity[:idx_end_scatter]\n\n    list_label_scatter = ['{:.1f}'.format(val) for val in list_SpectraPosition_scatter]\n    list_SpectraPosition_scatter = [float(val) for val in list_SpectraPosition_scatter]\n    list_scatter_intensity = [float(val) for val in list_scatter_intensity]\n\n    ax.clear()\n    ax.plot(list_SpectraPosition, list_intensity)\n    if len(list_scatter_intensity) &gt; 0: ax.scatter(list_SpectraPosition_scatter,list_scatter_intensity,color='red')\n    for i, txt in enumerate(list_label_scatter): ax.annotate(txt, (list_SpectraPosition_scatter[i], list_scatter_intensity[i]))\n\n    xmin = limits[0] if limits[0] else None\n    xmax = limits[1] if limits[1] else None\n    ymin = limits[2] if limits[2] else None\n    ymax = limits[3] if limits[3] else None\n    ax.set_xlim(xmin,xmax)\n    ax.set_ylim(ymin,ymax)\n\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(self.intensity_name)\n    ax.set_title(title)\n    # ax.legend()\n\n    fig.tight_layout()\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.test","title":"<code>test()</code>","text":"<p>Test the RamanMeasurement class</p> Source code in <code>iris/data/measurement_Raman.py</code> <pre><code>def test():\n    \"\"\"\n    Test the RamanMeasurement class\n    \"\"\"\n    # Initialises the class\n    raman = MeaRaman(reconstruct=True)\n    raman.test_generate_dummy()\n    raman.self_report()\n</code></pre>"},{"location":"reference/iris/data/measurement_Raman/#iris.data.measurement_Raman.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/","title":"measurement_RamanMap","text":"<p>This module provides structured data management and analysis capabilities for mapping measurements.</p>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler","title":"<code>MeaRMap_Handler</code>","text":"<p>Handles the mapping measurement data storage and retrieval.</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>class MeaRMap_Handler():\n    \"\"\"\n    Handles the mapping measurement data storage and retrieval.\n    \"\"\"\n    def __init__(self):\n        self._version = '0.1.0-2024.05.24'\n\n        self._dict_default_save_parameters = {\n            'meta_table': 'metadata',           # Table name for the metadata in the database\n        }\n\n        # Save parameters\n        self._unit_id_key = SaveParamsEnum.DATABASE_ID_KEY.value\n        self._unit_name_key = SaveParamsEnum.DATABASE_NAME_KEY.value\n        self._default_SaveDir = SaveParamsEnum.DEFAULT_SAVE_PATH.value\n        self._default_SubFolder = 'data'\n        self._default_separator = '__id__'\n\n        self._table_prefix = SaveParamsEnum.MAPUNIT_DB_PREFIX.value  # Prefix for the database name for the mapping measurement not to interfere with other databases naming system\n        self._table_prefix_load = None # Prefix to support the old naming system\n\n        # Save options\n        self._dict_extensions = {\n            SaveParamsEnum.SAVE_OPTIONS_CSV.value: 'csv files',\n            SaveParamsEnum.SAVE_OPTIONS_TXT.value: 'text files',\n            SaveParamsEnum.SAVE_OPTIONS_PARQUET.value: 'parquet files',\n            SaveParamsEnum.SAVE_OPTIONS_FEATHER.value: 'feather files',\n        }\n\n        self._default_extension = SaveParamsEnum.DEFAULT_SAVE_EXT.value\n        self._default_extension = SaveParamsEnum.SAVE_OPTIONS_CSV.value if self._default_extension not in self._dict_extensions.keys() else self._default_extension\n\n    def _save_MappingMeasurementUnit_metadata_database(self,mappingUnit:MeaRMap_Unit,conn:sql.Connection) -&gt; None:\n        \"\"\"\n        Saves the mappingUnit data into a database.\n\n        Args:\n            mappingUnit (mapping_measurement_unit): mapping_measurement_unit object to be saved\n            conn (sql.Connection): connection to the database\n\n        Raises:\n            AssertionError: If the input data types are not correct or if the measurement data or metadata does not exist.\n            ValueError: If the metadata type is not recognised.\n        \"\"\"\n        assert isinstance(mappingUnit, MeaRMap_Unit), '_save_mapping_measurement_unit_database: The input data type is not correct. Expected mapping_measurement_unit object.'\n        assert mappingUnit.check_measurement_and_metadata_exist(), '_save_mapping_measurement_unit_database: The measurement data or metadata does not exist.'\n        assert isinstance(conn, sql.Connection), '_save_mapping_measurement_unit_database: The input data type is not correct. Expected sql.Connection object.'\n\n        cursor = conn.cursor()\n\n        # Retrieve the metadata\n        labeldb_meta = self._table_prefix + self._dict_default_save_parameters['meta_table']\n        metadata = mappingUnit.get_dict_unit_metadata()\n\n        metadata_key_types = mappingUnit.get_dict_types()[0]\n\n        # Get the list of the unit id and check if it exists in the database metadata table\n        unit_id = mappingUnit.get_unit_id()\n        query = 'SELECT name FROM sqlite_master WHERE type=\"table\" AND name=?'\n        cursor.execute(query, (labeldb_meta,))\n        result = cursor.fetchone()\n        if result is not None:\n            query = 'SELECT * FROM {} WHERE {} = ?'.format(labeldb_meta,self._unit_id_key)\n            cursor.execute(query, (unit_id,))\n            result = cursor.fetchone()\n            if result is not None: return   # If the unit ID already exists, do not overwrite the metadata\n\n        # Create the metadata table\n        query_keys = ''\n        values_metadata = []\n        for key in metadata.keys():\n            if metadata_key_types[key] == str:\n                query_keys += ', {} TEXT'.format(key)\n                values_metadata.append(metadata[key])\n            elif metadata_key_types[key] == float or metadata_key_types[key] == int:\n                query_keys += ', {} REAL'.format(key)\n                values_metadata.append(metadata[key])\n            elif metadata_key_types[key] == dict:\n                query_keys += ', {} TEXT'.format(key)\n                values_metadata.append(json.dumps(metadata[key]))\n            elif metadata_key_types[key] == list:\n                query_keys += ', {} TEXT'.format(key)\n                values_metadata.append(json.dumps(metadata[key]))\n            else:\n                raise ValueError('_save_mapping_measurement_unit_database: The metadata type is not recognised: {}'\\\n                    .format(metadata_key_types[key]))\n\n        query_keys = query_keys[2:] # Remove the first comma and space\n        query = 'CREATE TABLE IF NOT EXISTS {} ({})'.format(labeldb_meta,query_keys)\n        cursor.execute(query)\n\n        # Prepare the values for insertion\n        query_keys = ', '.join(metadata.keys())\n        query_metadata_values = ', '.join(['?' for _ in range(len(values_metadata))])\n        query = 'INSERT INTO {} ({}) VALUES ({})'.format(labeldb_meta,query_keys,query_metadata_values)\n        cursor.execute(query, values_metadata)\n\n        conn.commit()\n        return\n\n    def _save_MappingMeasurementUnit_measurement_database(\n        self,mappingUnit:MeaRMap_Unit,conn:sql.Connection,conn_path:str) -&gt; None:\n        \"\"\"\n        Saves the mapping_measurement_unit data into a database.\n\n        Args:\n            mappingUnit (mapping_measurement_unit): mapping_measurement_unit object to be saved\n            conn (sql.Connection): connection to the database\n            conn_path (str): path to the database\n        \"\"\"\n        assert isinstance(mappingUnit, MeaRMap_Unit), '_save_mapping_measurement_unit_database: The input data type is not correct. Expected mapping_measurement_unit object.'\n        assert mappingUnit.check_measurement_and_metadata_exist(), '_save_mapping_measurement_unit_database: The measurement data does not exist.'\n        assert isinstance(conn, sql.Connection), '_save_mapping_measurement_unit_database: The input data type is not correct. Expected sql.Connection object.'\n\n        cursor = conn.cursor()\n\n        # Retrieve the id and measurement data\n        mea_id_key = mappingUnit.get_key_measurementId()\n        unit_id = mappingUnit.get_unit_id()\n        table_name = self._table_prefix + unit_id\n        unit_dict = mappingUnit.get_dict_measurements()\n        unit_key_types = mappingUnit.get_dict_types()[1]\n\n        # Create the measurement table\n        query_keys = ''\n        for key in unit_dict.keys():\n            type_key = unit_key_types[key]\n            if type_key == str or type_key == pd.DataFrame or type_key == list[pd.DataFrame]:\n                query_keys += ', {} TEXT'.format(key)\n            elif type_key == float or type_key == int:\n                query_keys += ', {} REAL'.format(key)\n            else:\n                raise ValueError('_save_mapping_measurement_unit_database: The measurement type is not recognised: {}'\\\n                    .format(type_key))\n\n        query_keys = query_keys[2:] # Remove the first comma and space\n        cursor.execute('CREATE TABLE IF NOT EXISTS {} ({})'.format(table_name,query_keys))\n\n        # Prepare the values for insertion\n        len_entries = len(unit_dict[key])\n        query_keys = ', '.join(unit_dict.keys())\n        query_values = ', '.join(['?' for _ in range(len(unit_dict))])\n\n\n        # Storage for the data\n        list_avgdf = []\n        list_rawlistdf = []\n\n        # Prepare the save directory and file paths\n        save_timestamp = get_timestamp_us_str()\n        conn_dir = os.path.dirname(conn_path)\n        subsavedir = os.path.join(conn_dir,self._default_SubFolder)\n        avgdf_savepath = os.path.join(subsavedir,get_timestamp_us_str()+'_avg.parquet')\n        rawlistdf_savepath = os.path.join(subsavedir,get_timestamp_us_str()+'_rawlist.parquet')\n        avgdf_savepath_rel = os.path.relpath(avgdf_savepath,conn_dir)\n        rawlistdf_savepath_rel = os.path.relpath(rawlistdf_savepath,conn_dir)\n        if not os.path.exists(subsavedir): os.makedirs(subsavedir)\n        if os.path.exists(avgdf_savepath): os.remove(avgdf_savepath)\n        if os.path.exists(rawlistdf_savepath): os.remove(rawlistdf_savepath)\n        separator = self._default_separator\n\n        # Get the list of timestamps in the database table\n        cursor.execute('SELECT {} FROM {}'.format(mea_id_key,table_name))\n        existing_ids = [str(int(row[0])) for row in cursor.fetchall()]        \n        values = []\n        for i in range(len_entries):\n            entry_values = []\n            mea_id = str(unit_dict[mea_id_key][i])\n            if str(int(mea_id)) in existing_ids: continue\n            for key in unit_dict.keys():\n                if unit_dict[key][i] is None:\n                    entry_values.append(None)\n                elif unit_key_types[key] == pd.DataFrame:\n                    list_avgdf.append((mea_id,unit_dict[key][i]))\n                    entry_values.append(avgdf_savepath_rel)\n                elif unit_key_types[key] == list[pd.DataFrame]:\n                    rawlistdf = unit_dict[key][i]\n                    list_rawlistdf.extend([(mea_id+separator+str(j),df) for j,df in enumerate(rawlistdf)])\n                    entry_values.append(rawlistdf_savepath_rel)\n                else:\n                    entry_values.append(unit_dict[key][i])\n            values.append(tuple(entry_values))\n\n        # Form the df and save them\n        df_avg = pd.concat([df for _,df in list_avgdf],keys=[mea_id for mea_id,_ in list_avgdf],axis=0)\n        if len(list_rawlistdf) &gt; 0: df_rawlist = pd.concat([df for _,df in list_rawlistdf],keys=[mea_id for mea_id,_ in list_rawlistdf],axis=0)\n        else: df_rawlist = pd.DataFrame()\n        df_avg.to_parquet(avgdf_savepath)\n        df_rawlist.to_parquet(rawlistdf_savepath)\n\n        cursor.executemany('INSERT INTO {} ({}) VALUES ({})'.format(table_name, query_keys, query_values), values)\n\n        conn.commit()\n\n    def save_MappingUnit_ext_prompt(self,mappingUnit:MeaRMap_Unit,flg_saveraw:bool) -&gt; threading.Thread|None:\n        \"\"\"\n        Saves a given MappingMeasurement_Unit object into a file extension of the user's choosing\n\n        Raises:\n            AssertionError: If the input data type is not correct or the measurement data does not exist.\n\n        Args:\n            mappingUnit (MappingMeasurement_Unit): The MappingUnit to be saved\n            flg_saveraw (bool): flag to save the raw data. Defaults to False.\n\n        Returns:\n            threading.Thread|None: thread of the saving process or None if the user cancels the saving process\n        \"\"\"\n        assert isinstance(mappingUnit, MeaRMap_Unit), 'save_mapping_unit_txt: The input data type is not correct. Expected mapping_measurement_unit object.'\n        assert mappingUnit.check_measurement_and_metadata_exist(), 'save_mapping_unit_txt: The measurement data does not exist.'\n\n        # Prepare the file dialog\n        list_extensions = [(value, '*.'+key) for key,value in self._dict_extensions.items()]\n        default_extension = '.' + self._default_extension\n\n        # Ask for the file path\n        unit_name = mappingUnit.get_unit_name()\n        if not isinstance(unit_name,str) or unit_name == '':\n            unit_name = 'unit_'+get_timestamp_us_str()\n\n        filepath = filedialog.asksaveasfilename(defaultextension=default_extension,filetypes=list_extensions,\n                                                initialfile=unit_name+default_extension)\n        extension = os.path.splitext(filepath)[1]\n\n        if extension == '': return None\n        if filepath == '': return None\n\n        extension = extension[1:]   # Remove the dot (e.g., .txt -&gt; txt)\n\n        return self.save_MappingUnit_ext(mappingUnit,filepath,flg_saveraw,extension)\n\n    def get_dict_extensions(self) -&gt; dict:\n        \"\"\"\n        Returns the dictionary of supported file extensions and their descriptions.\n\n        Returns:\n            dict: dictionary of supported file extensions and their descriptions\n        \"\"\"\n        return self._dict_extensions.copy()\n\n    @thread_assign\n    def save_MappingUnit_ext(self,mappingUnit:MeaRMap_Unit,filepath:str,flg_saveraw:bool,extension:str)\\\n        -&gt; threading.Thread:\n        \"\"\"\n        Saves a given MappingMeasurement_Unit object into a tab delimited .csv file.\n\n        Raises:\n            AssertionError: If the input data type is not correct or the measurement data does not exist.\n\n        Args:\n            mappingUnit (MappingMeasurement_Unit): The MappingUnit to be saved\n            filepath (str): path to the file to be saved\n            flg_saveraw (bool): flag to save the raw data. Defaults to False.\n            extension (str): extension of the file to be saved\n\n        Returns:\n            threading.Thread: thread of the saving process\n        \"\"\"\n        assert isinstance(mappingUnit, MeaRMap_Unit), 'save_mapping_unit_txt: The input data type is not correct. Expected mapping_measurement_unit object.'\n        assert mappingUnit.check_measurement_and_metadata_exist(), 'save_mapping_unit_txt: The measurement data does not exist.'\n\n        dict_meta = mappingUnit.get_dict_unit_metadata().copy()\n        dict_mea_ori = mappingUnit.get_dict_measurements()\n        dict_mea = dict_mea_ori.copy()\n        _,dict_meatypes = mappingUnit.get_dict_types()\n        dict_meatypes = dict_meatypes.copy()\n\n        _,_,_,lbl_wavelength,lbl_intensity = mappingUnit.get_labels()\n\n        # Remove the list of dataframes from the output\n        list_pop = []\n        for key in dict_mea.keys():\n            if dict_meatypes[key] == list[pd.DataFrame]:\n                list_pop.append(key)\n                list_mea_key = key\n            elif dict_meatypes[key] == pd.DataFrame:\n                list_pop.append(key)\n                mea_key = key\n\n        [dict_mea.pop(key) for key in list_pop]\n        [dict_meatypes.pop(key) for key in list_pop]\n\n        list_df = []\n        num_measurements = mappingUnit.get_numMeasurements()\n        for i in range(num_measurements):\n            # &gt; Create a new dataframe for the combined measurements\n            mea_combined = pd.DataFrame()\n            size = dict_mea_ori[mea_key][i].shape[0]\n            for key, value_list in dict_mea_ori.items():\n                if key != mea_key and key != list_mea_key:\n                    mea_combined[key] = [value_list[i]] * size\n\n            # &gt; Add the wavelength and intensity columns from each raw measurements\n            if flg_saveraw:\n                # &gt; Extract the raw measurements\n                list_mea = dict_mea_ori[list_mea_key][i]\n\n                size = list_mea[0].shape[0]\n\n                mea_combined[lbl_wavelength] = list_mea[0][lbl_wavelength]\n                for j,mea in enumerate(list_mea):\n                    lbl_intensity_mod = lbl_intensity + f'_{j+1}'\n                    mea_combined[lbl_intensity_mod] = mea[lbl_intensity]\n            else:\n                mea_combined[lbl_wavelength] = dict_mea_ori[mea_key][i][lbl_wavelength]\n                mea_combined[lbl_intensity] = dict_mea_ori[mea_key][i][lbl_intensity]\n\n            list_df.append(mea_combined)\n\n            # Progress bar report\n            # print('Percentage of conversion: {}%'.format(i/num_measurements*100))\n            if i % 1000 == 0:\n                print('Save to .txt progress: Conversion {}% {} of {}'.format(int(i/num_measurements*100),i,num_measurements))\n\n        print('Save to .txt progress: Conversion 100% {} of {}'.format(num_measurements,num_measurements))\n        print('Save to .txt progress: Concatenating the dataframes')\n\n        df_save = pd.concat(list_df, axis=0, ignore_index=True)\n\n        print('Save to .txt progress: Saving the data')\n        def report_save(flg:threading.Event,filepath):\n            while not flg.is_set():\n                print(f'{time.ctime()} - Still saving the data to {filepath}')\n                time.sleep(5)\n\n        flg_done = threading.Event()\n        threading.Thread(target=report_save, args=(flg_done,filepath)).start()\n\n        if extension != SaveParamsEnum.SAVE_OPTIONS_CSV.value and extension != SaveParamsEnum.SAVE_OPTIONS_TXT.value:\n            filepath_metadata = os.path.splitext(filepath)[0] + '_metadata.txt'\n        else:\n            filepath_metadata = filepath\n\n        # Save the metadata\n        with open(filepath_metadata, 'w') as f:\n            f.write('METADATA\\n')\n            for key, value in dict_meta.items():\n                f.write(f'{key}: {value}\\n')\n            f.write('\\n')\n\n        # Save the data via pandas\n        time1 = time.time()\n\n        if extension == SaveParamsEnum.SAVE_OPTIONS_CSV.value or extension == SaveParamsEnum.SAVE_OPTIONS_TXT.value:\n            df_save.to_csv(filepath, mode='a', sep='\\t', index=False)\n        elif extension == SaveParamsEnum.SAVE_OPTIONS_PARQUET.value:\n            df_save.to_parquet(filepath)\n        elif extension == SaveParamsEnum.SAVE_OPTIONS_FEATHER.value:\n            df_save.to_feather(filepath)\n        else:\n            raise ValueError('save_mapping_unit_txt: The extension is not recognised: {}'.format(extension))\n        flg_done.set()\n\n        print(f'DONE! Saved to {filepath}; Time taken: {time.time()-time1} s')\n        print('-----------------------------------------------------------------\\n')\n\n    def save_MappingMeasurementHub_prompt(self,saveDirPath:str|None=None,savename:str|None=None):\n        \"\"\"\n        Prompts the user to save the data into a database or pickle file\n\n        Args:\n            saveDirPath (str): directory path to save the data. Defaults to None.\n            savename (str): name of the file to save. Defaults to None.\n\n        Returns:\n            tuple: directory path to save the data, name of the file, and extension of the file,\n            noting that the savepath is the directory path\n        \"\"\"\n        assert isinstance(saveDirPath, (str,type(None))), 'save_mapping_measurement: The input data type is not correct. Expected a string.'\n        assert isinstance(savename, (str,type(None))), 'save_mapping_measurement: The input data type is not correct. Expected a string.'\n\n        filetypes = [('Database files','*.db'),('Pickle files','*.pkl')]\n        if saveDirPath is None: saveDirPath = self._default_SaveDir\n        saveDirPath = filedialog.asksaveasfilename(defaultextension='.db',filetypes=filetypes,initialfile=savename)\n\n        # Check the extension\n        savename,extension = os.path.splitext(os.path.basename(saveDirPath))\n        saveDirPath = os.path.dirname(saveDirPath)\n        return (saveDirPath,savename,extension)\n\n    def save_MappingMeasurementHub_choose(self,mappingHub:MeaRMap_Hub,\n        saveDirPath:str|None=None,savename:str|None=None,extension:str|None=None)\\\n        -&gt; threading.Thread:\n        \"\"\"\n        Choose to either save to database or pickle file.\n\n        Args:\n            mappingHub (MappingMeasurement_Hub): mapping_measurement_hub object to be saved\n            saveDirPath (str): path to save the data. Defaults to None.\n            savename (str): name of the file to save. Defaults to None.\n            extension (str): extension of the file to save: '.db' or '.pkl'. Defaults to None.\n\n        Returns:\n            threading.Thread: thread of the saving process\n        \"\"\"\n        assert isinstance(mappingHub, MeaRMap_Hub), 'save_mapping_measurement: The input data type is not correct. Expected mapping_measurement_new object.'\n        if any([isinstance(saveDirPath, type(None)), isinstance(savename, type(None)), isinstance(extension, type(None))]):\n            saveDirPath,savename,extension = self.save_MappingMeasurementHub_prompt()\n\n        # Check the extension and save accordingly\n        if extension == '.db':\n            thread = self.save_MappingHub_database(mappingHub,saveDirPath,savename)\n        else:\n            thread = self.save_MappingHub_pickle(mappingHub,saveDirPath,savename)\n        savename = savename + extension\n        return thread\n\n    @thread_assign\n    def save_MappingHub_database(self,mappingHub:MeaRMap_Hub,savedirpath:str,savename:str) -&gt; threading.Thread:\n        \"\"\"\n        Saves the mapping measurement data into a database.\n\n        Args:\n            mappingHub (mapping_measurement_new): mapping_measurement_new object to be saved\n            savepath (str): path to save the data. Defaults to None.\n        \"\"\"\n        assert isinstance(mappingHub, MeaRMap_Hub), 'save_mapping_measurement: The input data type is not correct. Expected mapping_measurement_new object.'\n        assert mappingHub.check_measurement_exist(), 'save_mapping_measurement: The measurement data does not exist.'\n        assert os.path.exists(savedirpath) and os.path.isdir(savedirpath), 'save_mapping_measurement: The input savedirpath is not correct. Expected a valid directory path.'\n        assert isinstance(savename,str) and savename != '', 'save_mapping_measurement: The input savename is not correct. Expected a valid filename.'\n\n        if savename[-3:] != '.db': savename += '.db'\n        savepath = os.path.join(savedirpath,savename)\n\n        # Connect to the database\n        conn:sql.Connection = sql.connect(savepath)\n\n        # Save the mapping_measurement_unit metadata and measurement data\n        list_unit_ids = mappingHub.get_list_MappingUnit_ids()\n        list_measurement_units = [mappingHub.get_MappingUnit(id) for id in list_unit_ids]\n        for measurement_unit in list_measurement_units:\n            self._save_MappingMeasurementUnit_metadata_database(measurement_unit,conn)    \n            self._save_MappingMeasurementUnit_measurement_database(measurement_unit,conn,savepath)\n\n        conn.close()\n\n    @thread_assign\n    def save_MappingHub_pickle(self,mappingHub:MeaRMap_Hub,savedirpath:str,\n                               savename:str,q_return:queue.Queue=None) -&gt; threading.Thread:\n        \"\"\"\n        Saves the mapping measurement data into a database or pickle file.\n\n        Args:\n            mappingHub (mapping_measurement_new): mapping_measurement_new object to be saved\n            savepath (str): path to save the data. Defaults to None.\n            savepath (str): path to save the data. Defaults to None.\n            q_return (queue.Queue): queue to return the saved path. Defaults to None.\n        \"\"\"\n        assert isinstance(mappingHub, MeaRMap_Hub), 'save_mapping_measurement: The input data type is not correct. Expected mapping_measurement_new object.'\n        assert mappingHub.check_measurement_exist(), 'save_mapping_measurement: The measurement data does not exist.'\n        assert os.path.exists(savedirpath) and os.path.isdir(savedirpath), 'save_mapping_measurement: The input savedirpath is not correct. Expected a valid directory path.'\n        assert isinstance(savename,str) and savename != '', 'save_mapping_measurement: The input savename is not correct. Expected a valid filename.'\n\n        if savename[-4:] != '.pkl': savename += '.pkl'\n        savepath = os.path.join(savedirpath,savename)\n\n        try:\n            with open(savepath, 'wb') as file:\n                dill.dump(mappingHub, file)\n        except Exception as e:\n            print('save_mapping_measurement: Error in saving the data: {}'.format(e))\n            savepath = None\n\n        if q_return is not None: q_return.put(savepath)\n\n    def _load_MappingMeasurementUnit_metadata_database(self,unit_id:str,conn:sql.Connection,\n                                                       mappingUnit:MeaRMap_Unit) -&gt; MeaRMap_Unit:\n        \"\"\"\n        Loads the mapping_measurement_unit metadata data from a database.\n\n        Args:\n            unit_id (str): measurement ID corresponding to the database table name\n            conn (sql.Connection): connection to the database\n\n        Returns:\n            mapping_measurement_unit: mapping_measurement_unit object with metadata loaded\n        \"\"\"\n        assert isinstance(unit_id, str), '_load_mappingMeasurementUnit_metadata_database: The input data type is not correct. Expected a string.'\n        assert isinstance(conn, sql.Connection), '_load_mappingMeasurementUnit_metadata_database: The input data type is not correct. Expected sql.Connection object.'\n\n        conn.row_factory = sql.Row  # To access the column names\n        cursor = conn.cursor()\n\n        # Search for the metadata row corresponding to the measurement_id in the metadata table\n        assert self._table_prefix_load is not None, '_load_mappingMeasurementUnit_metadata_database: The table prefix is not set.'\n        labeldb_meta = self._table_prefix_load + self._dict_default_save_parameters['meta_table']\n\n        cursor.execute('SELECT * FROM {} WHERE {}=\"{}\"'.format(labeldb_meta,self._unit_id_key,unit_id))\n        row:sql.Row = cursor.fetchone()\n\n        types_metadata = mappingUnit.get_dict_types()[0]\n        dict_unit_metadata = {}\n        for key in row.keys():\n            if types_metadata[key] == dict:\n                dict_unit_metadata[key] = json.loads(row[key])\n            else:\n                dict_unit_metadata[key] = row[key]\n\n        mappingUnit.set_dict_metadata(dict_unit_metadata) # Set the metadata and automatically set the unit name and id\n\n        return mappingUnit\n\n    def _load_MappingMeasurementUnit_measurement_database(self,unit_id:str,conn:sql.Connection,conn_path:str,\n        mappingUnit:MeaRMap_Unit,flg_readraw:bool) -&gt; MeaRMap_Unit:\n        \"\"\"\n        Loads the mapping_measurement_unit measurement data from a database.\n\n        Args:\n            unit_id (str): measurement ID corresponding to the database table name\n            conn (sql.Connection): connection to the database\n            conn_path (str): path to the database\n            mappingUnit (MappingMeasurement_Unit): mapping_measurement_unit object to be loaded\n            flg_readraw (bool): flag to read the raw data. Defaults to False.\n\n        Returns:\n            mapping_measurement_unit: mapping_measurement_unit object with measurement data loadeds\n        \"\"\"\n        assert isinstance(unit_id, str), '_load_mappingMeasurementUnit_measurement_database: The input data type is not correct. Expected a string.'\n        assert isinstance(conn, sql.Connection), '_load_mappingMeasurementUnit_measurement_database: The input data type is not correct. Expected sql.Connection object.'\n        assert os.path.exists(conn_path) and os.path.isfile(conn_path), '_load_mappingMeasurementUnit_measurement_database: The input conn_path is not correct. Expected a valid file path.'\n\n        conn.row_factory = sql.Row  # To access the column names\n        cursor = conn.cursor()\n        conn_dirpath = os.path.dirname(conn_path)\n\n        # &gt; Search for the measurement data corresponding to the measurement_id in the measurement table\n        # Modify the table name to include the prefix\n        assert self._table_prefix_load is not None, '_load_mappingMeasurementUnit_measurement_database: The table prefix is not set.'\n        load_unit_id = self._table_prefix_load + unit_id\n        cursor.execute('SELECT * FROM {}'.format(load_unit_id))\n        rows = cursor.fetchall()\n        if len(rows) == 0: return mappingUnit\n\n        value_types = mappingUnit.get_dict_types()[1]\n        assert all([key in value_types.keys() for key in rows[0].keys()]),\\\n            '_load_mappingMeasurementUnit_measurement_database: The keys in the database do not match the expected keys.'\n\n        # Load the data into the measurement_unit object\n        mea_id_key = mappingUnit.get_key_measurementId()\n        separator = self._default_separator\n        path_avg = None\n        path_rawlist = None\n        for row in rows:\n            row:sql.Row\n            dict_row = {}\n            mea_id = str(int(row[mea_id_key]))\n            for key in row.keys():\n                if row[key] is None:\n                    dict_row[key] = None\n                elif value_types[key] == str:\n                    dict_row[key] = row[key]\n                elif value_types[key] == float:\n                    dict_row[key] = float(row[key])\n                elif value_types[key] == int:\n                    dict_row[key] = int(float(row[key]))\n                elif value_types[key] == pd.DataFrame:\n                    path = row[key]\n                    path = os.path.join(conn_dirpath,path)\n                    if platform.system() == 'Windows':\n                        path = path.replace('/', '\\\\')\n                    elif platform.system() == 'Darwin':  # macOS\n                        path = path.replace('\\\\', '/')\n                    if path != path_avg:\n                        path_avg = path\n                        avg_df_read = pd.read_parquet(path_avg)\n                    avg_df = avg_df_read.loc[mea_id]\n                    dict_row[key] = avg_df\n                elif value_types[key] == list[pd.DataFrame]:\n                    if not flg_readraw: dict_row[key] = []; continue\n                    path = row[key]\n                    path = os.path.join(conn_dirpath,path)\n                    if platform.system() == 'Windows':\n                        path = path.replace('/', '\\\\')\n                    elif platform.system() == 'Darwin':  # macOS\n                        path = path.replace('\\\\', '/')\n                    if path != path_rawlist:\n                        path_rawlist = path\n                        rawlist_df_read = pd.read_parquet(path_rawlist)\n                        keys = rawlist_df_read.index.get_level_values(0).unique()\n                        list_id = [key.split(separator)[0] for key in keys]\n                        list_df_combined = [rawlist_df_read.loc[key] for key in keys]\n                    list_df = [df for df_id,df in zip(list_id,list_df_combined) if df_id == mea_id]\n                    dict_row[key] = list_df\n                else:\n                    raise ValueError('_load_mappingMeasurementUnit_measurement_database: The value type is not recognised: {}'\\\n                        .format(value_types[key]))\n            mappingUnit.append_dict_measurement_data(dict_row)\n\n        return mappingUnit\n\n    def load_MappingMeasurementHub_database(self,hub:MeaRMap_Hub,loadpath:str,\n        flg_readraw:bool=True) -&gt; MeaRMap_Hub:\n        \"\"\"\n        Loads the mapping measurement data from a database.\n\n        Args:\n            hub (MappingMeasurement_Hub): mapping_measurement_hub object to be loaded into\n            loadpath (str): path to load the data\n            flg_readraw (bool): flag to read the raw data (in addition to the averaged spectrum). Defaults to False.\n\n        Returns:\n            mapping_measurement_new: mapping_measurement object\n        \"\"\"\n        assert os.path.exists(loadpath) and os.path.isfile(loadpath), 'load_mappingMeasurement_database: The input loadpath is not correct. Expected a valid file path.'\n        assert loadpath[-3:] == '.db', 'load_mappingMeasurement_database: The input loadpath is not correct. Expected a valid database file.'\n\n        # Connect to the database\n        conn:sql.Connection = sql.connect(loadpath)\n        conn.row_factory = sql.Row  # To access the column names\n        cursor = conn.cursor()\n\n        # Query the sqlite_schema table to get table names\n        # Check if the any of the metadata table names exist (check for with and without prefix)\n        acceptable_metaTableNames = []\n        acceptable_metaTableNames.append(self._dict_default_save_parameters['meta_table'])\n        acceptable_metaTableNames.append(self._table_prefix + self._dict_default_save_parameters['meta_table'])\n\n        cursor.execute(\"SELECT name FROM sqlite_schema WHERE type='table';\")\n        found_tableNames = [row[0] for row in cursor.fetchall()]\n        found_metaTableNames = [table_name for table_name in acceptable_metaTableNames if table_name in found_tableNames]\n        assert len(found_metaTableNames) == 1, ('load_mappingMeasurement_database: The database does not contain the mapping metadata '\n            'table OR more than 1 mapping metadata table found. Metadata table(s) found: {}'.format(found_metaTableNames))\n        db_tableName_meta:str = found_metaTableNames[0]\n        self._table_prefix_load = self._table_prefix if db_tableName_meta.startswith(self._table_prefix) else ''\n\n        # Get the metadata table and store it as a dictionary\n        dict_unit_id_to_name = {}\n        cursor.execute('SELECT * FROM {}'.format(db_tableName_meta))\n        rows = cursor.fetchall()\n        for row in rows:\n            row: sql.Row\n            unit_id = row[self._unit_id_key]\n            unit_name = row[self._unit_name_key]\n            dict_unit_id_to_name[unit_id] = unit_name\n\n        # Load the metadata and measurement data\n        # mapping_measurement = MappingMeasurement_Hub()\n        mapping_measurement = hub\n        for unit_id in dict_unit_id_to_name.keys():\n            table_name = self._table_prefix + unit_id\n            unit_name = dict_unit_id_to_name[unit_id]\n            mappingUnit = MeaRMap_Unit(unit_name=unit_name,unit_id=unit_id)\n            mappingUnit = self._load_MappingMeasurementUnit_metadata_database(unit_id,conn,mappingUnit)\n            mappingUnit = self._load_MappingMeasurementUnit_measurement_database(unit_id,conn,loadpath,mappingUnit,flg_readraw)\n            mapping_measurement.append_mapping_unit(mappingUnit)\n        return mapping_measurement\n\n    def load_MappingMeasurement_pickle(self,hub:MeaRMap_Hub,loadpath:str) -&gt; MeaRMap_Hub:\n        \"\"\"\n        Loads the mapping measurement data from a pickle file.\n\n        Args:\n            hub (MappingMeasurement_Hub): mapping_measurement_hub object to be loaded into\n            loadpath (str): path to load the data\n\n        Returns:\n            mapping_measurement_new: mapping_measurement object\n        \"\"\"\n        assert os.path.exists(loadpath) and os.path.isfile(loadpath), 'load_mappingMeasurement_pickle: The input loadpath is not correct. Expected a valid file path.'\n        assert loadpath[-4:] == '.pkl', 'load_mappingMeasurement_pickle: The input loadpath is not correct. Expected a valid pickle file.'\n\n        with open(loadpath, 'rb') as file:\n            mapping_measurement:MeaRMap_Hub = dill.load(file)\n\n        for unitid in mapping_measurement.get_list_MappingUnit_ids():\n            hub.append_mapping_unit(mapping_measurement.get_MappingUnit(unitid))\n\n    def load_choose(self,mappingHub:MeaRMap_Hub,callback_fast:Callable|None=None,\n                    callback:Callable|None=None) -&gt; threading.Thread:\n        \"\"\"\n        Choose to either load from database or pickle file.\n\n        Args:\n            mappingHub (MappingMeasurement_Hub): mapping_measurement_hub object to be loaded into\n            callback_fast (Callable): callback function to run after the filedialog. Defaults to None.\n            callback (Callable): callback function to run after the loading process. Defaults to None.\n\n        Returns:\n            threading.Thread: thread of the loading process\n\n        Note:\n            - The loaded data will be returned in the queue q_out as a tuple of:\n                (loaded_measurement,loadpath)\n        \"\"\"\n        loadpath = filedialog.askopenfilename(defaultextension='.db',filetypes=[('Database files','*.db'),('Pickle files','*.pkl')])\n\n        if loadpath == '':\n            if callback is not None: callback()\n            return None\n\n        if callback_fast is not None: callback_fast()\n\n        if loadpath.endswith('.db'):\n            self.load_MappingMeasurementHub_database(mappingHub,loadpath)\n        elif loadpath.endswith('.pkl'):\n            self.load_MappingMeasurement_pickle(mappingHub,loadpath)\n\n        if callback is not None: callback()\n\n    def test_database_save_load(self,hub:MeaRMap_Hub):\n        \"\"\"\n        Test the saving and loading of the mapping measurement data into and from a database\n\n        Args:\n            hub (MappingMeasurement_Hub): mapping_measurement_hub object to be used in the test\n        \"\"\"\n        print('&gt;&gt;&gt;&gt;&gt; Testing the database save and load &lt;&lt;&lt;&lt;&lt;')\n        savedirpath = './sandbox'\n        savename = 'test - Copy'\n        savepath = os.path.join(savedirpath,savename+'.db')\n        thread = self.save_MappingHub_database(hub,savedirpath=savedirpath,savename=savename)\n        thread.join()\n        hub = MeaRMap_Hub()\n        mapping_measurement_loaded = self.load_MappingMeasurementHub_database(hub,savepath)\n\n        savename2 = 'test - Copy2'\n        thread = self.save_MappingHub_database(mapping_measurement_loaded,savedirpath=savedirpath,savename=savename2)\n        thread.join()\n        print('&gt;&gt;&gt;&gt;&gt; Testing the database save and load: Done &lt;&lt;&lt;&lt;&lt;')\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.get_dict_extensions","title":"<code>get_dict_extensions()</code>","text":"<p>Returns the dictionary of supported file extensions and their descriptions.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary of supported file extensions and their descriptions</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_dict_extensions(self) -&gt; dict:\n    \"\"\"\n    Returns the dictionary of supported file extensions and their descriptions.\n\n    Returns:\n        dict: dictionary of supported file extensions and their descriptions\n    \"\"\"\n    return self._dict_extensions.copy()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.load_MappingMeasurementHub_database","title":"<code>load_MappingMeasurementHub_database(hub, loadpath, flg_readraw=True)</code>","text":"<p>Loads the mapping measurement data from a database.</p> <p>Parameters:</p> Name Type Description Default <code>hub</code> <code>MappingMeasurement_Hub</code> <p>mapping_measurement_hub object to be loaded into</p> required <code>loadpath</code> <code>str</code> <p>path to load the data</p> required <code>flg_readraw</code> <code>bool</code> <p>flag to read the raw data (in addition to the averaged spectrum). Defaults to False.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mapping_measurement_new</code> <code>MeaRMap_Hub</code> <p>mapping_measurement object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def load_MappingMeasurementHub_database(self,hub:MeaRMap_Hub,loadpath:str,\n    flg_readraw:bool=True) -&gt; MeaRMap_Hub:\n    \"\"\"\n    Loads the mapping measurement data from a database.\n\n    Args:\n        hub (MappingMeasurement_Hub): mapping_measurement_hub object to be loaded into\n        loadpath (str): path to load the data\n        flg_readraw (bool): flag to read the raw data (in addition to the averaged spectrum). Defaults to False.\n\n    Returns:\n        mapping_measurement_new: mapping_measurement object\n    \"\"\"\n    assert os.path.exists(loadpath) and os.path.isfile(loadpath), 'load_mappingMeasurement_database: The input loadpath is not correct. Expected a valid file path.'\n    assert loadpath[-3:] == '.db', 'load_mappingMeasurement_database: The input loadpath is not correct. Expected a valid database file.'\n\n    # Connect to the database\n    conn:sql.Connection = sql.connect(loadpath)\n    conn.row_factory = sql.Row  # To access the column names\n    cursor = conn.cursor()\n\n    # Query the sqlite_schema table to get table names\n    # Check if the any of the metadata table names exist (check for with and without prefix)\n    acceptable_metaTableNames = []\n    acceptable_metaTableNames.append(self._dict_default_save_parameters['meta_table'])\n    acceptable_metaTableNames.append(self._table_prefix + self._dict_default_save_parameters['meta_table'])\n\n    cursor.execute(\"SELECT name FROM sqlite_schema WHERE type='table';\")\n    found_tableNames = [row[0] for row in cursor.fetchall()]\n    found_metaTableNames = [table_name for table_name in acceptable_metaTableNames if table_name in found_tableNames]\n    assert len(found_metaTableNames) == 1, ('load_mappingMeasurement_database: The database does not contain the mapping metadata '\n        'table OR more than 1 mapping metadata table found. Metadata table(s) found: {}'.format(found_metaTableNames))\n    db_tableName_meta:str = found_metaTableNames[0]\n    self._table_prefix_load = self._table_prefix if db_tableName_meta.startswith(self._table_prefix) else ''\n\n    # Get the metadata table and store it as a dictionary\n    dict_unit_id_to_name = {}\n    cursor.execute('SELECT * FROM {}'.format(db_tableName_meta))\n    rows = cursor.fetchall()\n    for row in rows:\n        row: sql.Row\n        unit_id = row[self._unit_id_key]\n        unit_name = row[self._unit_name_key]\n        dict_unit_id_to_name[unit_id] = unit_name\n\n    # Load the metadata and measurement data\n    # mapping_measurement = MappingMeasurement_Hub()\n    mapping_measurement = hub\n    for unit_id in dict_unit_id_to_name.keys():\n        table_name = self._table_prefix + unit_id\n        unit_name = dict_unit_id_to_name[unit_id]\n        mappingUnit = MeaRMap_Unit(unit_name=unit_name,unit_id=unit_id)\n        mappingUnit = self._load_MappingMeasurementUnit_metadata_database(unit_id,conn,mappingUnit)\n        mappingUnit = self._load_MappingMeasurementUnit_measurement_database(unit_id,conn,loadpath,mappingUnit,flg_readraw)\n        mapping_measurement.append_mapping_unit(mappingUnit)\n    return mapping_measurement\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.load_MappingMeasurement_pickle","title":"<code>load_MappingMeasurement_pickle(hub, loadpath)</code>","text":"<p>Loads the mapping measurement data from a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>hub</code> <code>MappingMeasurement_Hub</code> <p>mapping_measurement_hub object to be loaded into</p> required <code>loadpath</code> <code>str</code> <p>path to load the data</p> required <p>Returns:</p> Name Type Description <code>mapping_measurement_new</code> <code>MeaRMap_Hub</code> <p>mapping_measurement object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def load_MappingMeasurement_pickle(self,hub:MeaRMap_Hub,loadpath:str) -&gt; MeaRMap_Hub:\n    \"\"\"\n    Loads the mapping measurement data from a pickle file.\n\n    Args:\n        hub (MappingMeasurement_Hub): mapping_measurement_hub object to be loaded into\n        loadpath (str): path to load the data\n\n    Returns:\n        mapping_measurement_new: mapping_measurement object\n    \"\"\"\n    assert os.path.exists(loadpath) and os.path.isfile(loadpath), 'load_mappingMeasurement_pickle: The input loadpath is not correct. Expected a valid file path.'\n    assert loadpath[-4:] == '.pkl', 'load_mappingMeasurement_pickle: The input loadpath is not correct. Expected a valid pickle file.'\n\n    with open(loadpath, 'rb') as file:\n        mapping_measurement:MeaRMap_Hub = dill.load(file)\n\n    for unitid in mapping_measurement.get_list_MappingUnit_ids():\n        hub.append_mapping_unit(mapping_measurement.get_MappingUnit(unitid))\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.load_choose","title":"<code>load_choose(mappingHub, callback_fast=None, callback=None)</code>","text":"<p>Choose to either load from database or pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>mappingHub</code> <code>MappingMeasurement_Hub</code> <p>mapping_measurement_hub object to be loaded into</p> required <code>callback_fast</code> <code>Callable</code> <p>callback function to run after the filedialog. Defaults to None.</p> <code>None</code> <code>callback</code> <code>Callable</code> <p>callback function to run after the loading process. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Thread</code> <p>threading.Thread: thread of the loading process</p> Note <ul> <li>The loaded data will be returned in the queue q_out as a tuple of:     (loaded_measurement,loadpath)</li> </ul> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def load_choose(self,mappingHub:MeaRMap_Hub,callback_fast:Callable|None=None,\n                callback:Callable|None=None) -&gt; threading.Thread:\n    \"\"\"\n    Choose to either load from database or pickle file.\n\n    Args:\n        mappingHub (MappingMeasurement_Hub): mapping_measurement_hub object to be loaded into\n        callback_fast (Callable): callback function to run after the filedialog. Defaults to None.\n        callback (Callable): callback function to run after the loading process. Defaults to None.\n\n    Returns:\n        threading.Thread: thread of the loading process\n\n    Note:\n        - The loaded data will be returned in the queue q_out as a tuple of:\n            (loaded_measurement,loadpath)\n    \"\"\"\n    loadpath = filedialog.askopenfilename(defaultextension='.db',filetypes=[('Database files','*.db'),('Pickle files','*.pkl')])\n\n    if loadpath == '':\n        if callback is not None: callback()\n        return None\n\n    if callback_fast is not None: callback_fast()\n\n    if loadpath.endswith('.db'):\n        self.load_MappingMeasurementHub_database(mappingHub,loadpath)\n    elif loadpath.endswith('.pkl'):\n        self.load_MappingMeasurement_pickle(mappingHub,loadpath)\n\n    if callback is not None: callback()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.save_MappingHub_database","title":"<code>save_MappingHub_database(mappingHub, savedirpath, savename)</code>","text":"<p>Saves the mapping measurement data into a database.</p> <p>Parameters:</p> Name Type Description Default <code>mappingHub</code> <code>mapping_measurement_new</code> <p>mapping_measurement_new object to be saved</p> required <code>savepath</code> <code>str</code> <p>path to save the data. Defaults to None.</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>@thread_assign\ndef save_MappingHub_database(self,mappingHub:MeaRMap_Hub,savedirpath:str,savename:str) -&gt; threading.Thread:\n    \"\"\"\n    Saves the mapping measurement data into a database.\n\n    Args:\n        mappingHub (mapping_measurement_new): mapping_measurement_new object to be saved\n        savepath (str): path to save the data. Defaults to None.\n    \"\"\"\n    assert isinstance(mappingHub, MeaRMap_Hub), 'save_mapping_measurement: The input data type is not correct. Expected mapping_measurement_new object.'\n    assert mappingHub.check_measurement_exist(), 'save_mapping_measurement: The measurement data does not exist.'\n    assert os.path.exists(savedirpath) and os.path.isdir(savedirpath), 'save_mapping_measurement: The input savedirpath is not correct. Expected a valid directory path.'\n    assert isinstance(savename,str) and savename != '', 'save_mapping_measurement: The input savename is not correct. Expected a valid filename.'\n\n    if savename[-3:] != '.db': savename += '.db'\n    savepath = os.path.join(savedirpath,savename)\n\n    # Connect to the database\n    conn:sql.Connection = sql.connect(savepath)\n\n    # Save the mapping_measurement_unit metadata and measurement data\n    list_unit_ids = mappingHub.get_list_MappingUnit_ids()\n    list_measurement_units = [mappingHub.get_MappingUnit(id) for id in list_unit_ids]\n    for measurement_unit in list_measurement_units:\n        self._save_MappingMeasurementUnit_metadata_database(measurement_unit,conn)    \n        self._save_MappingMeasurementUnit_measurement_database(measurement_unit,conn,savepath)\n\n    conn.close()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.save_MappingHub_pickle","title":"<code>save_MappingHub_pickle(mappingHub, savedirpath, savename, q_return=None)</code>","text":"<p>Saves the mapping measurement data into a database or pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>mappingHub</code> <code>mapping_measurement_new</code> <p>mapping_measurement_new object to be saved</p> required <code>savepath</code> <code>str</code> <p>path to save the data. Defaults to None.</p> required <code>savepath</code> <code>str</code> <p>path to save the data. Defaults to None.</p> required <code>q_return</code> <code>Queue</code> <p>queue to return the saved path. Defaults to None.</p> <code>None</code> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>@thread_assign\ndef save_MappingHub_pickle(self,mappingHub:MeaRMap_Hub,savedirpath:str,\n                           savename:str,q_return:queue.Queue=None) -&gt; threading.Thread:\n    \"\"\"\n    Saves the mapping measurement data into a database or pickle file.\n\n    Args:\n        mappingHub (mapping_measurement_new): mapping_measurement_new object to be saved\n        savepath (str): path to save the data. Defaults to None.\n        savepath (str): path to save the data. Defaults to None.\n        q_return (queue.Queue): queue to return the saved path. Defaults to None.\n    \"\"\"\n    assert isinstance(mappingHub, MeaRMap_Hub), 'save_mapping_measurement: The input data type is not correct. Expected mapping_measurement_new object.'\n    assert mappingHub.check_measurement_exist(), 'save_mapping_measurement: The measurement data does not exist.'\n    assert os.path.exists(savedirpath) and os.path.isdir(savedirpath), 'save_mapping_measurement: The input savedirpath is not correct. Expected a valid directory path.'\n    assert isinstance(savename,str) and savename != '', 'save_mapping_measurement: The input savename is not correct. Expected a valid filename.'\n\n    if savename[-4:] != '.pkl': savename += '.pkl'\n    savepath = os.path.join(savedirpath,savename)\n\n    try:\n        with open(savepath, 'wb') as file:\n            dill.dump(mappingHub, file)\n    except Exception as e:\n        print('save_mapping_measurement: Error in saving the data: {}'.format(e))\n        savepath = None\n\n    if q_return is not None: q_return.put(savepath)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.save_MappingMeasurementHub_choose","title":"<code>save_MappingMeasurementHub_choose(mappingHub, saveDirPath=None, savename=None, extension=None)</code>","text":"<p>Choose to either save to database or pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>mappingHub</code> <code>MappingMeasurement_Hub</code> <p>mapping_measurement_hub object to be saved</p> required <code>saveDirPath</code> <code>str</code> <p>path to save the data. Defaults to None.</p> <code>None</code> <code>savename</code> <code>str</code> <p>name of the file to save. Defaults to None.</p> <code>None</code> <code>extension</code> <code>str</code> <p>extension of the file to save: '.db' or '.pkl'. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Thread</code> <p>threading.Thread: thread of the saving process</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def save_MappingMeasurementHub_choose(self,mappingHub:MeaRMap_Hub,\n    saveDirPath:str|None=None,savename:str|None=None,extension:str|None=None)\\\n    -&gt; threading.Thread:\n    \"\"\"\n    Choose to either save to database or pickle file.\n\n    Args:\n        mappingHub (MappingMeasurement_Hub): mapping_measurement_hub object to be saved\n        saveDirPath (str): path to save the data. Defaults to None.\n        savename (str): name of the file to save. Defaults to None.\n        extension (str): extension of the file to save: '.db' or '.pkl'. Defaults to None.\n\n    Returns:\n        threading.Thread: thread of the saving process\n    \"\"\"\n    assert isinstance(mappingHub, MeaRMap_Hub), 'save_mapping_measurement: The input data type is not correct. Expected mapping_measurement_new object.'\n    if any([isinstance(saveDirPath, type(None)), isinstance(savename, type(None)), isinstance(extension, type(None))]):\n        saveDirPath,savename,extension = self.save_MappingMeasurementHub_prompt()\n\n    # Check the extension and save accordingly\n    if extension == '.db':\n        thread = self.save_MappingHub_database(mappingHub,saveDirPath,savename)\n    else:\n        thread = self.save_MappingHub_pickle(mappingHub,saveDirPath,savename)\n    savename = savename + extension\n    return thread\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.save_MappingMeasurementHub_prompt","title":"<code>save_MappingMeasurementHub_prompt(saveDirPath=None, savename=None)</code>","text":"<p>Prompts the user to save the data into a database or pickle file</p> <p>Parameters:</p> Name Type Description Default <code>saveDirPath</code> <code>str</code> <p>directory path to save the data. Defaults to None.</p> <code>None</code> <code>savename</code> <code>str</code> <p>name of the file to save. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>directory path to save the data, name of the file, and extension of the file,</p> <p>noting that the savepath is the directory path</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def save_MappingMeasurementHub_prompt(self,saveDirPath:str|None=None,savename:str|None=None):\n    \"\"\"\n    Prompts the user to save the data into a database or pickle file\n\n    Args:\n        saveDirPath (str): directory path to save the data. Defaults to None.\n        savename (str): name of the file to save. Defaults to None.\n\n    Returns:\n        tuple: directory path to save the data, name of the file, and extension of the file,\n        noting that the savepath is the directory path\n    \"\"\"\n    assert isinstance(saveDirPath, (str,type(None))), 'save_mapping_measurement: The input data type is not correct. Expected a string.'\n    assert isinstance(savename, (str,type(None))), 'save_mapping_measurement: The input data type is not correct. Expected a string.'\n\n    filetypes = [('Database files','*.db'),('Pickle files','*.pkl')]\n    if saveDirPath is None: saveDirPath = self._default_SaveDir\n    saveDirPath = filedialog.asksaveasfilename(defaultextension='.db',filetypes=filetypes,initialfile=savename)\n\n    # Check the extension\n    savename,extension = os.path.splitext(os.path.basename(saveDirPath))\n    saveDirPath = os.path.dirname(saveDirPath)\n    return (saveDirPath,savename,extension)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.save_MappingUnit_ext","title":"<code>save_MappingUnit_ext(mappingUnit, filepath, flg_saveraw, extension)</code>","text":"<p>Saves a given MappingMeasurement_Unit object into a tab delimited .csv file.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the input data type is not correct or the measurement data does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>mappingUnit</code> <code>MappingMeasurement_Unit</code> <p>The MappingUnit to be saved</p> required <code>filepath</code> <code>str</code> <p>path to the file to be saved</p> required <code>flg_saveraw</code> <code>bool</code> <p>flag to save the raw data. Defaults to False.</p> required <code>extension</code> <code>str</code> <p>extension of the file to be saved</p> required <p>Returns:</p> Type Description <code>Thread</code> <p>threading.Thread: thread of the saving process</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>@thread_assign\ndef save_MappingUnit_ext(self,mappingUnit:MeaRMap_Unit,filepath:str,flg_saveraw:bool,extension:str)\\\n    -&gt; threading.Thread:\n    \"\"\"\n    Saves a given MappingMeasurement_Unit object into a tab delimited .csv file.\n\n    Raises:\n        AssertionError: If the input data type is not correct or the measurement data does not exist.\n\n    Args:\n        mappingUnit (MappingMeasurement_Unit): The MappingUnit to be saved\n        filepath (str): path to the file to be saved\n        flg_saveraw (bool): flag to save the raw data. Defaults to False.\n        extension (str): extension of the file to be saved\n\n    Returns:\n        threading.Thread: thread of the saving process\n    \"\"\"\n    assert isinstance(mappingUnit, MeaRMap_Unit), 'save_mapping_unit_txt: The input data type is not correct. Expected mapping_measurement_unit object.'\n    assert mappingUnit.check_measurement_and_metadata_exist(), 'save_mapping_unit_txt: The measurement data does not exist.'\n\n    dict_meta = mappingUnit.get_dict_unit_metadata().copy()\n    dict_mea_ori = mappingUnit.get_dict_measurements()\n    dict_mea = dict_mea_ori.copy()\n    _,dict_meatypes = mappingUnit.get_dict_types()\n    dict_meatypes = dict_meatypes.copy()\n\n    _,_,_,lbl_wavelength,lbl_intensity = mappingUnit.get_labels()\n\n    # Remove the list of dataframes from the output\n    list_pop = []\n    for key in dict_mea.keys():\n        if dict_meatypes[key] == list[pd.DataFrame]:\n            list_pop.append(key)\n            list_mea_key = key\n        elif dict_meatypes[key] == pd.DataFrame:\n            list_pop.append(key)\n            mea_key = key\n\n    [dict_mea.pop(key) for key in list_pop]\n    [dict_meatypes.pop(key) for key in list_pop]\n\n    list_df = []\n    num_measurements = mappingUnit.get_numMeasurements()\n    for i in range(num_measurements):\n        # &gt; Create a new dataframe for the combined measurements\n        mea_combined = pd.DataFrame()\n        size = dict_mea_ori[mea_key][i].shape[0]\n        for key, value_list in dict_mea_ori.items():\n            if key != mea_key and key != list_mea_key:\n                mea_combined[key] = [value_list[i]] * size\n\n        # &gt; Add the wavelength and intensity columns from each raw measurements\n        if flg_saveraw:\n            # &gt; Extract the raw measurements\n            list_mea = dict_mea_ori[list_mea_key][i]\n\n            size = list_mea[0].shape[0]\n\n            mea_combined[lbl_wavelength] = list_mea[0][lbl_wavelength]\n            for j,mea in enumerate(list_mea):\n                lbl_intensity_mod = lbl_intensity + f'_{j+1}'\n                mea_combined[lbl_intensity_mod] = mea[lbl_intensity]\n        else:\n            mea_combined[lbl_wavelength] = dict_mea_ori[mea_key][i][lbl_wavelength]\n            mea_combined[lbl_intensity] = dict_mea_ori[mea_key][i][lbl_intensity]\n\n        list_df.append(mea_combined)\n\n        # Progress bar report\n        # print('Percentage of conversion: {}%'.format(i/num_measurements*100))\n        if i % 1000 == 0:\n            print('Save to .txt progress: Conversion {}% {} of {}'.format(int(i/num_measurements*100),i,num_measurements))\n\n    print('Save to .txt progress: Conversion 100% {} of {}'.format(num_measurements,num_measurements))\n    print('Save to .txt progress: Concatenating the dataframes')\n\n    df_save = pd.concat(list_df, axis=0, ignore_index=True)\n\n    print('Save to .txt progress: Saving the data')\n    def report_save(flg:threading.Event,filepath):\n        while not flg.is_set():\n            print(f'{time.ctime()} - Still saving the data to {filepath}')\n            time.sleep(5)\n\n    flg_done = threading.Event()\n    threading.Thread(target=report_save, args=(flg_done,filepath)).start()\n\n    if extension != SaveParamsEnum.SAVE_OPTIONS_CSV.value and extension != SaveParamsEnum.SAVE_OPTIONS_TXT.value:\n        filepath_metadata = os.path.splitext(filepath)[0] + '_metadata.txt'\n    else:\n        filepath_metadata = filepath\n\n    # Save the metadata\n    with open(filepath_metadata, 'w') as f:\n        f.write('METADATA\\n')\n        for key, value in dict_meta.items():\n            f.write(f'{key}: {value}\\n')\n        f.write('\\n')\n\n    # Save the data via pandas\n    time1 = time.time()\n\n    if extension == SaveParamsEnum.SAVE_OPTIONS_CSV.value or extension == SaveParamsEnum.SAVE_OPTIONS_TXT.value:\n        df_save.to_csv(filepath, mode='a', sep='\\t', index=False)\n    elif extension == SaveParamsEnum.SAVE_OPTIONS_PARQUET.value:\n        df_save.to_parquet(filepath)\n    elif extension == SaveParamsEnum.SAVE_OPTIONS_FEATHER.value:\n        df_save.to_feather(filepath)\n    else:\n        raise ValueError('save_mapping_unit_txt: The extension is not recognised: {}'.format(extension))\n    flg_done.set()\n\n    print(f'DONE! Saved to {filepath}; Time taken: {time.time()-time1} s')\n    print('-----------------------------------------------------------------\\n')\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.save_MappingUnit_ext_prompt","title":"<code>save_MappingUnit_ext_prompt(mappingUnit, flg_saveraw)</code>","text":"<p>Saves a given MappingMeasurement_Unit object into a file extension of the user's choosing</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the input data type is not correct or the measurement data does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>mappingUnit</code> <code>MappingMeasurement_Unit</code> <p>The MappingUnit to be saved</p> required <code>flg_saveraw</code> <code>bool</code> <p>flag to save the raw data. Defaults to False.</p> required <p>Returns:</p> Type Description <code>Thread | None</code> <p>threading.Thread|None: thread of the saving process or None if the user cancels the saving process</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def save_MappingUnit_ext_prompt(self,mappingUnit:MeaRMap_Unit,flg_saveraw:bool) -&gt; threading.Thread|None:\n    \"\"\"\n    Saves a given MappingMeasurement_Unit object into a file extension of the user's choosing\n\n    Raises:\n        AssertionError: If the input data type is not correct or the measurement data does not exist.\n\n    Args:\n        mappingUnit (MappingMeasurement_Unit): The MappingUnit to be saved\n        flg_saveraw (bool): flag to save the raw data. Defaults to False.\n\n    Returns:\n        threading.Thread|None: thread of the saving process or None if the user cancels the saving process\n    \"\"\"\n    assert isinstance(mappingUnit, MeaRMap_Unit), 'save_mapping_unit_txt: The input data type is not correct. Expected mapping_measurement_unit object.'\n    assert mappingUnit.check_measurement_and_metadata_exist(), 'save_mapping_unit_txt: The measurement data does not exist.'\n\n    # Prepare the file dialog\n    list_extensions = [(value, '*.'+key) for key,value in self._dict_extensions.items()]\n    default_extension = '.' + self._default_extension\n\n    # Ask for the file path\n    unit_name = mappingUnit.get_unit_name()\n    if not isinstance(unit_name,str) or unit_name == '':\n        unit_name = 'unit_'+get_timestamp_us_str()\n\n    filepath = filedialog.asksaveasfilename(defaultextension=default_extension,filetypes=list_extensions,\n                                            initialfile=unit_name+default_extension)\n    extension = os.path.splitext(filepath)[1]\n\n    if extension == '': return None\n    if filepath == '': return None\n\n    extension = extension[1:]   # Remove the dot (e.g., .txt -&gt; txt)\n\n    return self.save_MappingUnit_ext(mappingUnit,filepath,flg_saveraw,extension)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Handler.test_database_save_load","title":"<code>test_database_save_load(hub)</code>","text":"<p>Test the saving and loading of the mapping measurement data into and from a database</p> <p>Parameters:</p> Name Type Description Default <code>hub</code> <code>MappingMeasurement_Hub</code> <p>mapping_measurement_hub object to be used in the test</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def test_database_save_load(self,hub:MeaRMap_Hub):\n    \"\"\"\n    Test the saving and loading of the mapping measurement data into and from a database\n\n    Args:\n        hub (MappingMeasurement_Hub): mapping_measurement_hub object to be used in the test\n    \"\"\"\n    print('&gt;&gt;&gt;&gt;&gt; Testing the database save and load &lt;&lt;&lt;&lt;&lt;')\n    savedirpath = './sandbox'\n    savename = 'test - Copy'\n    savepath = os.path.join(savedirpath,savename+'.db')\n    thread = self.save_MappingHub_database(hub,savedirpath=savedirpath,savename=savename)\n    thread.join()\n    hub = MeaRMap_Hub()\n    mapping_measurement_loaded = self.load_MappingMeasurementHub_database(hub,savepath)\n\n    savename2 = 'test - Copy2'\n    thread = self.save_MappingHub_database(mapping_measurement_loaded,savedirpath=savedirpath,savename=savename2)\n    thread.join()\n    print('&gt;&gt;&gt;&gt;&gt; Testing the database save and load: Done &lt;&lt;&lt;&lt;&lt;')\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub","title":"<code>MeaRMap_Hub</code>","text":"<p>This is a class to store all the measurement data, savepaths, etc during a mapping measurement. It also has methods to selectively retrive measurement data, and save the metadata of the mapping measurement.</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>class MeaRMap_Hub():\n    \"\"\"This is a class to store all the measurement data, savepaths, etc during a mapping\n    measurement. It also has methods to selectively retrive measurement data, and save the\n    metadata of the mapping measurement.\n    \"\"\"\n    def __init__(self) -&gt; None:\n    # &gt;&gt;&gt; Label initialisation &lt;&lt;&lt;\n        # Dataframe storing the measurement\n        self._version = '0.1.0-2024.05.24'  # Version of the data storage format\n\n        self._unit_id_key = SaveParamsEnum.DATABASE_ID_KEY.value  # Key for the measurement ID in the metadata dictionary\n\n        self._dict_mappingMeasurementUnits = {   # Dictionary to store the mapping_measurement_unit objects\n            'version': self._version,   # Version of the data storage format\n            self._unit_id_key: [],      # measurement_id from the mapping_measurement_unit object\n            'measurement_unit': []      # mapping_measurement_unit object\n            }\n\n        self._dict_mappingUnit_NameID = {}  # Dictionary to store the mapping of the unit name and unit ID with the name as the key\n\n        self._list_callbacks = []  # List of callbacks to be called when the mapping measurement is updated\n\n        self._last_update_timestamp:int = get_timestamp_us_int()\n\n    def add_observer(self,callback:Callable) -&gt; None:\n        \"\"\"\n        Adds a callback to be called when the mapping measurement is updated.\n\n        Args:\n            callback (Callable): callback function to be called\n        \"\"\"\n        assert callable(callback), 'add_callback: The input data type is not correct. Expected a callable.'\n        self._list_callbacks.append(callback)\n\n    def _notify_observers(self) -&gt; None:\n        \"\"\"\n        Runs all the callbacks in the list.\n        \"\"\"\n        for callback in self._list_callbacks:\n            try: callback()\n            except Exception as e: print(f'_run_callbacks: Error in callback: {e}')\n\n    def copy_mapping_unit(self,source_unit_id:str,dest_unit_name:str,appendToHub:False) -&gt; MeaRMap_Unit:\n        \"\"\"\n        Copies the mapping unit data from the source to the destination unit ID\n\n        Args:\n            source_unit_id (str): source unit ID\n            dest_unit_name (str): destination unit name\n            appendToHub (bool): append the copied unit to the hub. Defaults to False.\n\n        Returns:\n            MappingMeasurement_Unit: copied mapping_measurement_unit object\n        \"\"\"\n        assert source_unit_id in self._dict_mappingMeasurementUnits[self._unit_id_key], 'copy_mapping_unit: The source unit ID does not exist.'\n\n        idx = self._dict_mappingMeasurementUnits[self._unit_id_key].index(source_unit_id)\n        source_unit = self._dict_mappingMeasurementUnits['measurement_unit'][idx]\n        source_unit:MeaRMap_Unit\n\n        # Construct the destination unit\n        dest_unit:MeaRMap_Unit = MeaRMap_Unit()\n        dest_unit.set_dict_metadata(deepcopy(source_unit.get_dict_unit_metadata()))\n        dest_unit.set_dict_measurements(deepcopy(source_unit.get_dict_measurements()))\n        dest_unit.set_unitName_and_unitID(dest_unit_name)\n\n        if appendToHub:\n            self.append_mapping_unit(dest_unit)\n\n        return dest_unit\n\n    def validate_new_unit_name(self,unit_name:str) -&gt; bool:\n        \"\"\"\n        Validates if the new unit name is valid (i.e., does not already exist in the hub)\n\n        Args:\n            unit_name (str): unit name to be validated\n\n        Returns:\n            bool: True if the unit name is valid, False otherwise\n        \"\"\"\n        assert isinstance(unit_name, str), 'validate_new_unit_name: The input data type is not correct. Expected a string.'\n        return unit_name not in self._dict_mappingUnit_NameID\n\n    def check_measurement_exist(self):\n        \"\"\"\n        Check if the measurement data exists\n        \"\"\"\n        return len(self._dict_mappingMeasurementUnits[self._unit_id_key]) &gt; 0\n\n    def get_dict_nameToID(self) -&gt; dict:\n        \"\"\"\n        Returns the dictionary of the mapping unit name and ID\n\n        Returns:\n            dict: dictionary of the mapping unit name and ID. {unit_name: unit_id}\n        \"\"\"\n        return self._dict_mappingUnit_NameID\n\n    def get_list_MappingUnit_names(self) -&gt; list[str]:\n        \"\"\"\n        Returns the list of measurement names stored in the mapping_measurements dictionary.\n\n        Returns:\n            list: list of measurement names\n        \"\"\"\n        return list(self._dict_mappingUnit_NameID.keys())\n\n    def get_list_MappingUnit_ids(self) -&gt; list[str]:\n        \"\"\"\n        Returns the list of measurement IDs stored in the mapping_measurements dictionary.\n\n        Returns:\n            list: list of measurement IDs\n        \"\"\"\n        return self._dict_mappingMeasurementUnits[self._unit_id_key]\n\n    def get_list_MappingUnit(self) -&gt; list[MeaRMap_Unit]:\n        \"\"\"\n        Returns the list of mapping measurement units stored in the hub.\n\n        Returns:\n            list[MappingMeasurement_Unit]: list of mapping measurement units\n        \"\"\"\n        return self._dict_mappingMeasurementUnits['measurement_unit']\n\n    def get_summary_units(self) -&gt; tuple[list[str],list[str],list[dict],list[int]]:\n        \"\"\"\n        Returns a  summarises all the stored units and their metadata.\n\n        Returns:\n            tuple: list of unit IDs, list of unit names,\n                list of metadata dictionaries,\n                list of number of measurements in the unit\n        \"\"\"\n        list_ids = self._dict_mappingMeasurementUnits[self._unit_id_key]\n        list_names = []\n        list_metadata = []\n        list_num_measurements = []\n        for unit in self._dict_mappingMeasurementUnits['measurement_unit']:\n            unit:MeaRMap_Unit\n            list_metadata.append(unit.get_dict_measurement_metadata())\n            list_num_measurements.append(unit.get_numMeasurements())\n            list_names.append(unit.get_unit_name())\n\n        return (list_ids,list_names,list_metadata,list_num_measurements)\n\n    def get_MappingUnit(self,unit_id:str|None=None, unit_name:str|None=None) -&gt; MeaRMap_Unit:\n        \"\"\"\n        Returns the mapping_measurement_unit object based on the measurement_id.\n\n        Args:\n            unit_id (str|None): MappingMeasurement_Unit ID to be retrieved. If None, the unit_name will be used.\n            unit_name (str|None): MappingMeasurement_Unit name to be retrieved. If None, the unit_id will be used.\n\n        Raises:\n            ValueError: If both unit_id and unit_name are None.\n\n        Returns:\n            mapping_measurement_unit: mapping_measurement_unit object\n        \"\"\"\n        if unit_id is None and unit_name is None:\n            raise ValueError('get_mapping_measurement_unit: Either unit_id or unit_name must be provided.')\n        if unit_id is not None and unit_name is not None:\n            raise ValueError('get_mapping_measurement_unit: Only one of unit_id or unit_name can be provided.')\n        if unit_id is not None and unit_id not in self.get_list_MappingUnit_ids():\n            raise ValueError('get_mapping_measurement_unit: The unit_id does not exist.')\n        if unit_name is not None and unit_name not in self.get_list_MappingUnit_names():\n            raise ValueError('get_mapping_measurement_unit: The unit_name does not exist.')\n\n        if unit_name is not None:\n            unit_id = self._dict_mappingUnit_NameID[unit_name]\n\n        idx = self._dict_mappingMeasurementUnits[self._unit_id_key].index(unit_id)\n        return self._dict_mappingMeasurementUnits['measurement_unit'][idx]\n\n    def append_mapping_unit(self,mapping_unit:MeaRMap_Unit,notify:bool=True) -&gt; None:\n        \"\"\"\n        Appends a mapping_measurement_unit object into the mapping_measurements dictionary.\n\n        Args:\n            mapping_unit (MappingMeasurement_Unit): MappingMeasurement_Unit object to be stored\n            notify (bool): Flag to indicate if observers should be notified. Default is True.\n        \"\"\"\n        assert isinstance(mapping_unit, MeaRMap_Unit), 'append_mapping_measurement_unit: The input data type is not correct. Expected mapping_measurement_unit object.'\n        # assert measurement_unit.check_measurement_and_metadata_exist(), 'append_mapping_measurement_unit: The measurement data or metadata does not exist.'\n\n        unitID = mapping_unit.get_unit_id()\n        unitName = mapping_unit.get_unit_name()\n        if unitID in self._dict_mappingMeasurementUnits[self._unit_id_key]: raise FileExistsError('append_mapping_measurement_unit: The measurement ID already exists.')\n        if unitName in self._dict_mappingUnit_NameID: raise FileExistsError('append_mapping_measurement_unit: The measurement name already exists.')\n\n        self._dict_mappingMeasurementUnits[self._unit_id_key].append(unitID)\n        self._dict_mappingMeasurementUnits['measurement_unit'].append(mapping_unit)\n\n        self._dict_mappingUnit_NameID[mapping_unit.get_unit_name()] = mapping_unit.get_unit_id()\n\n        mapping_unit.add_observer(self._notify_observers)\n\n        if notify: self._notify_observers()\n\n    def extend_mapping_unit(self,list_mapping_unit:list[MeaRMap_Unit]) -&gt; None:\n        \"\"\"\n        Extends the mapping_measurement_unit objects in the mapping_measurements dictionary.\n\n        Args:\n            list_mapping_unit (list[MeaRMap_Unit]): List of MappingMeasurement_Unit objects to be added.\n        \"\"\"\n        [self.append_mapping_unit(unit, notify=False) for unit in list_mapping_unit]\n        self._notify_observers()\n\n    def rename_mapping_unit(self,unit_id:str,new_name:str) -&gt; None:\n        \"\"\"\n        Renames the mapping_measurement_unit object in the mapping_measurements dictionary\n\n        Args:\n            unit_id (str): MappingMeasurement_Unit ID to be renamed\n            new_name (str): New name for the mapping_measurement_unit\n        \"\"\"\n        assert unit_id in self._dict_mappingMeasurementUnits[self._unit_id_key], 'rename_mapping_measurement_unit: The measurement ID does not exist.'\n        assert new_name not in self._dict_mappingUnit_NameID, 'rename_mapping_measurement_unit: The new name already exists.'\n\n        unit_idx = self._dict_mappingMeasurementUnits[self._unit_id_key].index(unit_id)\n        unit:MeaRMap_Unit = self._dict_mappingMeasurementUnits['measurement_unit'][unit_idx]\n\n        old_name = unit.get_unit_name()\n        unit.set_unitName(new_name)\n        self._dict_mappingUnit_NameID[new_name] = unit_id\n        del self._dict_mappingUnit_NameID[old_name]\n\n        self._notify_observers()\n\n    def remove_mapping_unit_name(self,unit_name:str) -&gt; None:\n        \"\"\"\n        Removes a mapping_measurement_unit object from the mapping_measurements dictionary.\n\n        Args:\n            unit_name (str): MappingMeasurement_Unit name to be removed\n        \"\"\"\n        assert unit_name in self._dict_mappingUnit_NameID, 'remove_mapping_measurement_unit: The measurement name does not exist.'\n        unit_id = self._dict_mappingUnit_NameID[unit_name]\n        self.remove_mapping_unit_id(unit_id)\n\n        self._notify_observers()\n\n    def remove_mapping_unit_id(self,unit_id:str) -&gt; None:\n        \"\"\"\n        Removes a mapping_measurement_unit object from the mapping_measurements dictionary.\n\n        Args:\n            unit_id (str): MappingMeasurement_Unit ID to be removed\n        \"\"\"\n        assert unit_id in self._dict_mappingMeasurementUnits[self._unit_id_key], 'remove_mapping_measurement_unit: The measurement ID does not exist.'\n\n        unit_idx = self._dict_mappingMeasurementUnits[self._unit_id_key].index(unit_id)\n        unit_name = self._dict_mappingMeasurementUnits['measurement_unit'][unit_idx].get_unit_name()\n        del self._dict_mappingMeasurementUnits[self._unit_id_key][unit_idx]\n        del self._dict_mappingUnit_NameID[unit_name]\n\n        # Delete the object itself and all of its references\n        unit:MeaRMap_Unit = self._dict_mappingMeasurementUnits['measurement_unit'][unit_idx]\n        try: unit.remove_observer(self._notify_observers)\n        except Exception as e: print(f\"Error in remove_mapping_unit_id: {e}\")\n        unit.delete_self()\n        del self._dict_mappingMeasurementUnits['measurement_unit'][unit_idx]\n\n        # # Force the garbage collector to collect the deleted object\n        # gc.collect()\n\n        self._notify_observers()\n\n    def delete_all_mapping_units(self) -&gt; None:\n        \"\"\"\n        Deletes all mapping_measurement_unit objects from the mapping_measurements dictionary.\n        \"\"\"\n        list_units = self._dict_mappingMeasurementUnits['measurement_unit']\n        for unit in list_units:\n            try: unit.remove_observer(self._notify_observers)\n            except Exception as e: print(f\"Error in delete_all_mapping_units: {e}\")\n            unit.delete_self()\n        self._dict_mappingMeasurementUnits[self._unit_id_key].clear()\n        self._dict_mappingMeasurementUnits['measurement_unit'].clear()\n        self._dict_mappingUnit_NameID.clear()\n        self._notify_observers()\n\n    def shift_xycoordinate_timestamp(self, unit_id:str, timeshift_us:int) -&gt; str:\n        \"\"\"\n        Shifts the timestamp of the measurement data based on the given timeshift. The timeshift\n        is used to calculate the new coordinates (linear approximation) based on the stored coordinates\n        and timestamps. The resulting shifted MappingMeasurement_Unit object is stored in the\n        mapping_measurements dictionary once the shift is completed.\n\n        Args:\n            unit_id (str): MappingMeasurement_Unit ID to be shifted\n            timeshift_us (int): Timeshift in microseconds\n\n        Returns:\n            str: new unit name of the shifted MappingMeasurement\n        \"\"\"\n        assert unit_id in self._dict_mappingMeasurementUnits[self._unit_id_key], 'shift_coordinate_timestamp: The measurement ID does not exist.'\n        assert isinstance(timeshift_us, int), 'shift_coordinate_timestamp: The input data type is not correct. Expected an integer.'\n        unit = self.get_MappingUnit(unit_id)\n        unit_name_init = unit.get_unit_name()\n        unit_name_shift = unit_name_init + f'_shift {timeshift_us/1000}ms'\n\n        dict_mea = unit.get_dict_measurements()\n        lbl_ts,lbl_x,lbl_y,_,_,_ = unit.get_keys_dict_measurement()\n\n        arr_init_ts_coor = np.array([dict_mea[lbl_ts],dict_mea[lbl_x],dict_mea[lbl_y]])\n        arr_init_ts_coor = arr_init_ts_coor.T\n\n        arr_shifted_ts_coor = deepcopy(arr_init_ts_coor)\n        arr_shifted_ts_coor[:,0] += timeshift_us\n\n        def interpolate_coor(init_ts:float, fin_ts:float, init_coor:np.ndarray, fin_coor:np.ndarray, ts:float):\n            coor = init_coor + (fin_coor-init_coor)/(fin_ts-init_ts)*(ts-init_ts)\n            coor_x = coor[0]\n            coor_y = coor[1]\n            return coor_x, coor_y\n\n        direction = np.sign(timeshift_us)\n        direction = 1 if direction == 0 else direction\n\n        for idx,ts in enumerate(arr_shifted_ts_coor[:,0]):\n            idx_before = idx\n            while True:\n                if idx_before&lt;0: idx_before = 0; break\n                if idx_before&gt;=len(arr_init_ts_coor): idx_before = len(arr_init_ts_coor)-1; break\n\n                ts_before = arr_init_ts_coor[idx_before,0]\n                if ts_before*direction &lt; ts*direction: break\n                if ts_before == ts: break\n                idx_before += direction\n\n            idx_after = idx_before + direction\n            if idx_after&lt;0: idx_before = 0; idx_after = 1\n            if idx_after&gt;=len(arr_init_ts_coor): idx_after = len(arr_init_ts_coor)-1; idx_before = len(arr_init_ts_coor)-2\n\n            idx_before = int(idx_before)\n            idx_after = int(idx_after)\n\n            init_coor = np.array([arr_init_ts_coor[idx_before,1],arr_init_ts_coor[idx_before,2]])\n            fin_coor = np.array([arr_init_ts_coor[idx_after,1],arr_init_ts_coor[idx_after,2]])\n\n            arr_shifted_ts_coor[idx,1], arr_shifted_ts_coor[idx,2] = interpolate_coor(\n                init_ts=arr_init_ts_coor[idx_before,0],\n                fin_ts=arr_init_ts_coor[idx_after,0],\n                init_coor=init_coor,\n                fin_coor=fin_coor,\n                ts=ts\n            )\n\n        dict_shifted_mea = deepcopy(dict_mea)\n        dict_shifted_mea[lbl_ts] = arr_shifted_ts_coor[:,0].tolist()\n        dict_shifted_mea[lbl_x] = arr_shifted_ts_coor[:,1].tolist()\n        dict_shifted_mea[lbl_y] = arr_shifted_ts_coor[:,2].tolist()\n\n        # Convert the timestamps to integer\n        dict_shifted_mea[lbl_ts] = [int(ts) for ts in dict_shifted_mea[lbl_ts]]\n\n        unit_shift = self.copy_mapping_unit(\n            source_unit_id=unit_id,\n            dest_unit_name=unit_name_shift,\n            appendToHub=True\n        )\n        unit_shift.set_dict_measurements(dict_shifted_mea)\n\n        return unit_name_shift\n\n    def self_report(self):\n        \"\"\"\n        Prints all the attributes of the object\n        \"\"\"\n        print('MappingMeasurement_Hub:')\n        attributes = vars(self)\n        for key in attributes.keys():\n            print(f'{key}: {attributes[key]}')\n        print()\n\n    def test_generate_dummy(self, number:int=10):\n        \"\"\"\n        Generates dummy measurements for testing purposes\n        \"\"\"\n        for i in range(number):\n            unit = MeaRMap_Unit(unit_name='dummy {}'.format(i))\n            unit.test_generate_dummy()\n            self.append_mapping_unit(unit)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.add_observer","title":"<code>add_observer(callback)</code>","text":"<p>Adds a callback to be called when the mapping measurement is updated.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>callback function to be called</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def add_observer(self,callback:Callable) -&gt; None:\n    \"\"\"\n    Adds a callback to be called when the mapping measurement is updated.\n\n    Args:\n        callback (Callable): callback function to be called\n    \"\"\"\n    assert callable(callback), 'add_callback: The input data type is not correct. Expected a callable.'\n    self._list_callbacks.append(callback)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.append_mapping_unit","title":"<code>append_mapping_unit(mapping_unit, notify=True)</code>","text":"<p>Appends a mapping_measurement_unit object into the mapping_measurements dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>mapping_unit</code> <code>MappingMeasurement_Unit</code> <p>MappingMeasurement_Unit object to be stored</p> required <code>notify</code> <code>bool</code> <p>Flag to indicate if observers should be notified. Default is True.</p> <code>True</code> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def append_mapping_unit(self,mapping_unit:MeaRMap_Unit,notify:bool=True) -&gt; None:\n    \"\"\"\n    Appends a mapping_measurement_unit object into the mapping_measurements dictionary.\n\n    Args:\n        mapping_unit (MappingMeasurement_Unit): MappingMeasurement_Unit object to be stored\n        notify (bool): Flag to indicate if observers should be notified. Default is True.\n    \"\"\"\n    assert isinstance(mapping_unit, MeaRMap_Unit), 'append_mapping_measurement_unit: The input data type is not correct. Expected mapping_measurement_unit object.'\n    # assert measurement_unit.check_measurement_and_metadata_exist(), 'append_mapping_measurement_unit: The measurement data or metadata does not exist.'\n\n    unitID = mapping_unit.get_unit_id()\n    unitName = mapping_unit.get_unit_name()\n    if unitID in self._dict_mappingMeasurementUnits[self._unit_id_key]: raise FileExistsError('append_mapping_measurement_unit: The measurement ID already exists.')\n    if unitName in self._dict_mappingUnit_NameID: raise FileExistsError('append_mapping_measurement_unit: The measurement name already exists.')\n\n    self._dict_mappingMeasurementUnits[self._unit_id_key].append(unitID)\n    self._dict_mappingMeasurementUnits['measurement_unit'].append(mapping_unit)\n\n    self._dict_mappingUnit_NameID[mapping_unit.get_unit_name()] = mapping_unit.get_unit_id()\n\n    mapping_unit.add_observer(self._notify_observers)\n\n    if notify: self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.check_measurement_exist","title":"<code>check_measurement_exist()</code>","text":"<p>Check if the measurement data exists</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def check_measurement_exist(self):\n    \"\"\"\n    Check if the measurement data exists\n    \"\"\"\n    return len(self._dict_mappingMeasurementUnits[self._unit_id_key]) &gt; 0\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.copy_mapping_unit","title":"<code>copy_mapping_unit(source_unit_id, dest_unit_name, appendToHub)</code>","text":"<p>Copies the mapping unit data from the source to the destination unit ID</p> <p>Parameters:</p> Name Type Description Default <code>source_unit_id</code> <code>str</code> <p>source unit ID</p> required <code>dest_unit_name</code> <code>str</code> <p>destination unit name</p> required <code>appendToHub</code> <code>bool</code> <p>append the copied unit to the hub. Defaults to False.</p> required <p>Returns:</p> Name Type Description <code>MappingMeasurement_Unit</code> <code>MeaRMap_Unit</code> <p>copied mapping_measurement_unit object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def copy_mapping_unit(self,source_unit_id:str,dest_unit_name:str,appendToHub:False) -&gt; MeaRMap_Unit:\n    \"\"\"\n    Copies the mapping unit data from the source to the destination unit ID\n\n    Args:\n        source_unit_id (str): source unit ID\n        dest_unit_name (str): destination unit name\n        appendToHub (bool): append the copied unit to the hub. Defaults to False.\n\n    Returns:\n        MappingMeasurement_Unit: copied mapping_measurement_unit object\n    \"\"\"\n    assert source_unit_id in self._dict_mappingMeasurementUnits[self._unit_id_key], 'copy_mapping_unit: The source unit ID does not exist.'\n\n    idx = self._dict_mappingMeasurementUnits[self._unit_id_key].index(source_unit_id)\n    source_unit = self._dict_mappingMeasurementUnits['measurement_unit'][idx]\n    source_unit:MeaRMap_Unit\n\n    # Construct the destination unit\n    dest_unit:MeaRMap_Unit = MeaRMap_Unit()\n    dest_unit.set_dict_metadata(deepcopy(source_unit.get_dict_unit_metadata()))\n    dest_unit.set_dict_measurements(deepcopy(source_unit.get_dict_measurements()))\n    dest_unit.set_unitName_and_unitID(dest_unit_name)\n\n    if appendToHub:\n        self.append_mapping_unit(dest_unit)\n\n    return dest_unit\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.delete_all_mapping_units","title":"<code>delete_all_mapping_units()</code>","text":"<p>Deletes all mapping_measurement_unit objects from the mapping_measurements dictionary.</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def delete_all_mapping_units(self) -&gt; None:\n    \"\"\"\n    Deletes all mapping_measurement_unit objects from the mapping_measurements dictionary.\n    \"\"\"\n    list_units = self._dict_mappingMeasurementUnits['measurement_unit']\n    for unit in list_units:\n        try: unit.remove_observer(self._notify_observers)\n        except Exception as e: print(f\"Error in delete_all_mapping_units: {e}\")\n        unit.delete_self()\n    self._dict_mappingMeasurementUnits[self._unit_id_key].clear()\n    self._dict_mappingMeasurementUnits['measurement_unit'].clear()\n    self._dict_mappingUnit_NameID.clear()\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.extend_mapping_unit","title":"<code>extend_mapping_unit(list_mapping_unit)</code>","text":"<p>Extends the mapping_measurement_unit objects in the mapping_measurements dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>list_mapping_unit</code> <code>list[MeaRMap_Unit]</code> <p>List of MappingMeasurement_Unit objects to be added.</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def extend_mapping_unit(self,list_mapping_unit:list[MeaRMap_Unit]) -&gt; None:\n    \"\"\"\n    Extends the mapping_measurement_unit objects in the mapping_measurements dictionary.\n\n    Args:\n        list_mapping_unit (list[MeaRMap_Unit]): List of MappingMeasurement_Unit objects to be added.\n    \"\"\"\n    [self.append_mapping_unit(unit, notify=False) for unit in list_mapping_unit]\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.get_MappingUnit","title":"<code>get_MappingUnit(unit_id=None, unit_name=None)</code>","text":"<p>Returns the mapping_measurement_unit object based on the measurement_id.</p> <p>Parameters:</p> Name Type Description Default <code>unit_id</code> <code>str | None</code> <p>MappingMeasurement_Unit ID to be retrieved. If None, the unit_name will be used.</p> <code>None</code> <code>unit_name</code> <code>str | None</code> <p>MappingMeasurement_Unit name to be retrieved. If None, the unit_id will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both unit_id and unit_name are None.</p> <p>Returns:</p> Name Type Description <code>mapping_measurement_unit</code> <code>MeaRMap_Unit</code> <p>mapping_measurement_unit object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_MappingUnit(self,unit_id:str|None=None, unit_name:str|None=None) -&gt; MeaRMap_Unit:\n    \"\"\"\n    Returns the mapping_measurement_unit object based on the measurement_id.\n\n    Args:\n        unit_id (str|None): MappingMeasurement_Unit ID to be retrieved. If None, the unit_name will be used.\n        unit_name (str|None): MappingMeasurement_Unit name to be retrieved. If None, the unit_id will be used.\n\n    Raises:\n        ValueError: If both unit_id and unit_name are None.\n\n    Returns:\n        mapping_measurement_unit: mapping_measurement_unit object\n    \"\"\"\n    if unit_id is None and unit_name is None:\n        raise ValueError('get_mapping_measurement_unit: Either unit_id or unit_name must be provided.')\n    if unit_id is not None and unit_name is not None:\n        raise ValueError('get_mapping_measurement_unit: Only one of unit_id or unit_name can be provided.')\n    if unit_id is not None and unit_id not in self.get_list_MappingUnit_ids():\n        raise ValueError('get_mapping_measurement_unit: The unit_id does not exist.')\n    if unit_name is not None and unit_name not in self.get_list_MappingUnit_names():\n        raise ValueError('get_mapping_measurement_unit: The unit_name does not exist.')\n\n    if unit_name is not None:\n        unit_id = self._dict_mappingUnit_NameID[unit_name]\n\n    idx = self._dict_mappingMeasurementUnits[self._unit_id_key].index(unit_id)\n    return self._dict_mappingMeasurementUnits['measurement_unit'][idx]\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.get_dict_nameToID","title":"<code>get_dict_nameToID()</code>","text":"<p>Returns the dictionary of the mapping unit name and ID</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary of the mapping unit name and ID. {unit_name: unit_id}</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_dict_nameToID(self) -&gt; dict:\n    \"\"\"\n    Returns the dictionary of the mapping unit name and ID\n\n    Returns:\n        dict: dictionary of the mapping unit name and ID. {unit_name: unit_id}\n    \"\"\"\n    return self._dict_mappingUnit_NameID\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.get_list_MappingUnit","title":"<code>get_list_MappingUnit()</code>","text":"<p>Returns the list of mapping measurement units stored in the hub.</p> <p>Returns:</p> Type Description <code>list[MeaRMap_Unit]</code> <p>list[MappingMeasurement_Unit]: list of mapping measurement units</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_list_MappingUnit(self) -&gt; list[MeaRMap_Unit]:\n    \"\"\"\n    Returns the list of mapping measurement units stored in the hub.\n\n    Returns:\n        list[MappingMeasurement_Unit]: list of mapping measurement units\n    \"\"\"\n    return self._dict_mappingMeasurementUnits['measurement_unit']\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.get_list_MappingUnit_ids","title":"<code>get_list_MappingUnit_ids()</code>","text":"<p>Returns the list of measurement IDs stored in the mapping_measurements dictionary.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[str]</code> <p>list of measurement IDs</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_list_MappingUnit_ids(self) -&gt; list[str]:\n    \"\"\"\n    Returns the list of measurement IDs stored in the mapping_measurements dictionary.\n\n    Returns:\n        list: list of measurement IDs\n    \"\"\"\n    return self._dict_mappingMeasurementUnits[self._unit_id_key]\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.get_list_MappingUnit_names","title":"<code>get_list_MappingUnit_names()</code>","text":"<p>Returns the list of measurement names stored in the mapping_measurements dictionary.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[str]</code> <p>list of measurement names</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_list_MappingUnit_names(self) -&gt; list[str]:\n    \"\"\"\n    Returns the list of measurement names stored in the mapping_measurements dictionary.\n\n    Returns:\n        list: list of measurement names\n    \"\"\"\n    return list(self._dict_mappingUnit_NameID.keys())\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.get_summary_units","title":"<code>get_summary_units()</code>","text":"<p>Returns a  summarises all the stored units and their metadata.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[list[str], list[str], list[dict], list[int]]</code> <p>list of unit IDs, list of unit names, list of metadata dictionaries, list of number of measurements in the unit</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_summary_units(self) -&gt; tuple[list[str],list[str],list[dict],list[int]]:\n    \"\"\"\n    Returns a  summarises all the stored units and their metadata.\n\n    Returns:\n        tuple: list of unit IDs, list of unit names,\n            list of metadata dictionaries,\n            list of number of measurements in the unit\n    \"\"\"\n    list_ids = self._dict_mappingMeasurementUnits[self._unit_id_key]\n    list_names = []\n    list_metadata = []\n    list_num_measurements = []\n    for unit in self._dict_mappingMeasurementUnits['measurement_unit']:\n        unit:MeaRMap_Unit\n        list_metadata.append(unit.get_dict_measurement_metadata())\n        list_num_measurements.append(unit.get_numMeasurements())\n        list_names.append(unit.get_unit_name())\n\n    return (list_ids,list_names,list_metadata,list_num_measurements)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.remove_mapping_unit_id","title":"<code>remove_mapping_unit_id(unit_id)</code>","text":"<p>Removes a mapping_measurement_unit object from the mapping_measurements dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>unit_id</code> <code>str</code> <p>MappingMeasurement_Unit ID to be removed</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def remove_mapping_unit_id(self,unit_id:str) -&gt; None:\n    \"\"\"\n    Removes a mapping_measurement_unit object from the mapping_measurements dictionary.\n\n    Args:\n        unit_id (str): MappingMeasurement_Unit ID to be removed\n    \"\"\"\n    assert unit_id in self._dict_mappingMeasurementUnits[self._unit_id_key], 'remove_mapping_measurement_unit: The measurement ID does not exist.'\n\n    unit_idx = self._dict_mappingMeasurementUnits[self._unit_id_key].index(unit_id)\n    unit_name = self._dict_mappingMeasurementUnits['measurement_unit'][unit_idx].get_unit_name()\n    del self._dict_mappingMeasurementUnits[self._unit_id_key][unit_idx]\n    del self._dict_mappingUnit_NameID[unit_name]\n\n    # Delete the object itself and all of its references\n    unit:MeaRMap_Unit = self._dict_mappingMeasurementUnits['measurement_unit'][unit_idx]\n    try: unit.remove_observer(self._notify_observers)\n    except Exception as e: print(f\"Error in remove_mapping_unit_id: {e}\")\n    unit.delete_self()\n    del self._dict_mappingMeasurementUnits['measurement_unit'][unit_idx]\n\n    # # Force the garbage collector to collect the deleted object\n    # gc.collect()\n\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.remove_mapping_unit_name","title":"<code>remove_mapping_unit_name(unit_name)</code>","text":"<p>Removes a mapping_measurement_unit object from the mapping_measurements dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>unit_name</code> <code>str</code> <p>MappingMeasurement_Unit name to be removed</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def remove_mapping_unit_name(self,unit_name:str) -&gt; None:\n    \"\"\"\n    Removes a mapping_measurement_unit object from the mapping_measurements dictionary.\n\n    Args:\n        unit_name (str): MappingMeasurement_Unit name to be removed\n    \"\"\"\n    assert unit_name in self._dict_mappingUnit_NameID, 'remove_mapping_measurement_unit: The measurement name does not exist.'\n    unit_id = self._dict_mappingUnit_NameID[unit_name]\n    self.remove_mapping_unit_id(unit_id)\n\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.rename_mapping_unit","title":"<code>rename_mapping_unit(unit_id, new_name)</code>","text":"<p>Renames the mapping_measurement_unit object in the mapping_measurements dictionary</p> <p>Parameters:</p> Name Type Description Default <code>unit_id</code> <code>str</code> <p>MappingMeasurement_Unit ID to be renamed</p> required <code>new_name</code> <code>str</code> <p>New name for the mapping_measurement_unit</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def rename_mapping_unit(self,unit_id:str,new_name:str) -&gt; None:\n    \"\"\"\n    Renames the mapping_measurement_unit object in the mapping_measurements dictionary\n\n    Args:\n        unit_id (str): MappingMeasurement_Unit ID to be renamed\n        new_name (str): New name for the mapping_measurement_unit\n    \"\"\"\n    assert unit_id in self._dict_mappingMeasurementUnits[self._unit_id_key], 'rename_mapping_measurement_unit: The measurement ID does not exist.'\n    assert new_name not in self._dict_mappingUnit_NameID, 'rename_mapping_measurement_unit: The new name already exists.'\n\n    unit_idx = self._dict_mappingMeasurementUnits[self._unit_id_key].index(unit_id)\n    unit:MeaRMap_Unit = self._dict_mappingMeasurementUnits['measurement_unit'][unit_idx]\n\n    old_name = unit.get_unit_name()\n    unit.set_unitName(new_name)\n    self._dict_mappingUnit_NameID[new_name] = unit_id\n    del self._dict_mappingUnit_NameID[old_name]\n\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.self_report","title":"<code>self_report()</code>","text":"<p>Prints all the attributes of the object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def self_report(self):\n    \"\"\"\n    Prints all the attributes of the object\n    \"\"\"\n    print('MappingMeasurement_Hub:')\n    attributes = vars(self)\n    for key in attributes.keys():\n        print(f'{key}: {attributes[key]}')\n    print()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.shift_xycoordinate_timestamp","title":"<code>shift_xycoordinate_timestamp(unit_id, timeshift_us)</code>","text":"<p>Shifts the timestamp of the measurement data based on the given timeshift. The timeshift is used to calculate the new coordinates (linear approximation) based on the stored coordinates and timestamps. The resulting shifted MappingMeasurement_Unit object is stored in the mapping_measurements dictionary once the shift is completed.</p> <p>Parameters:</p> Name Type Description Default <code>unit_id</code> <code>str</code> <p>MappingMeasurement_Unit ID to be shifted</p> required <code>timeshift_us</code> <code>int</code> <p>Timeshift in microseconds</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>new unit name of the shifted MappingMeasurement</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def shift_xycoordinate_timestamp(self, unit_id:str, timeshift_us:int) -&gt; str:\n    \"\"\"\n    Shifts the timestamp of the measurement data based on the given timeshift. The timeshift\n    is used to calculate the new coordinates (linear approximation) based on the stored coordinates\n    and timestamps. The resulting shifted MappingMeasurement_Unit object is stored in the\n    mapping_measurements dictionary once the shift is completed.\n\n    Args:\n        unit_id (str): MappingMeasurement_Unit ID to be shifted\n        timeshift_us (int): Timeshift in microseconds\n\n    Returns:\n        str: new unit name of the shifted MappingMeasurement\n    \"\"\"\n    assert unit_id in self._dict_mappingMeasurementUnits[self._unit_id_key], 'shift_coordinate_timestamp: The measurement ID does not exist.'\n    assert isinstance(timeshift_us, int), 'shift_coordinate_timestamp: The input data type is not correct. Expected an integer.'\n    unit = self.get_MappingUnit(unit_id)\n    unit_name_init = unit.get_unit_name()\n    unit_name_shift = unit_name_init + f'_shift {timeshift_us/1000}ms'\n\n    dict_mea = unit.get_dict_measurements()\n    lbl_ts,lbl_x,lbl_y,_,_,_ = unit.get_keys_dict_measurement()\n\n    arr_init_ts_coor = np.array([dict_mea[lbl_ts],dict_mea[lbl_x],dict_mea[lbl_y]])\n    arr_init_ts_coor = arr_init_ts_coor.T\n\n    arr_shifted_ts_coor = deepcopy(arr_init_ts_coor)\n    arr_shifted_ts_coor[:,0] += timeshift_us\n\n    def interpolate_coor(init_ts:float, fin_ts:float, init_coor:np.ndarray, fin_coor:np.ndarray, ts:float):\n        coor = init_coor + (fin_coor-init_coor)/(fin_ts-init_ts)*(ts-init_ts)\n        coor_x = coor[0]\n        coor_y = coor[1]\n        return coor_x, coor_y\n\n    direction = np.sign(timeshift_us)\n    direction = 1 if direction == 0 else direction\n\n    for idx,ts in enumerate(arr_shifted_ts_coor[:,0]):\n        idx_before = idx\n        while True:\n            if idx_before&lt;0: idx_before = 0; break\n            if idx_before&gt;=len(arr_init_ts_coor): idx_before = len(arr_init_ts_coor)-1; break\n\n            ts_before = arr_init_ts_coor[idx_before,0]\n            if ts_before*direction &lt; ts*direction: break\n            if ts_before == ts: break\n            idx_before += direction\n\n        idx_after = idx_before + direction\n        if idx_after&lt;0: idx_before = 0; idx_after = 1\n        if idx_after&gt;=len(arr_init_ts_coor): idx_after = len(arr_init_ts_coor)-1; idx_before = len(arr_init_ts_coor)-2\n\n        idx_before = int(idx_before)\n        idx_after = int(idx_after)\n\n        init_coor = np.array([arr_init_ts_coor[idx_before,1],arr_init_ts_coor[idx_before,2]])\n        fin_coor = np.array([arr_init_ts_coor[idx_after,1],arr_init_ts_coor[idx_after,2]])\n\n        arr_shifted_ts_coor[idx,1], arr_shifted_ts_coor[idx,2] = interpolate_coor(\n            init_ts=arr_init_ts_coor[idx_before,0],\n            fin_ts=arr_init_ts_coor[idx_after,0],\n            init_coor=init_coor,\n            fin_coor=fin_coor,\n            ts=ts\n        )\n\n    dict_shifted_mea = deepcopy(dict_mea)\n    dict_shifted_mea[lbl_ts] = arr_shifted_ts_coor[:,0].tolist()\n    dict_shifted_mea[lbl_x] = arr_shifted_ts_coor[:,1].tolist()\n    dict_shifted_mea[lbl_y] = arr_shifted_ts_coor[:,2].tolist()\n\n    # Convert the timestamps to integer\n    dict_shifted_mea[lbl_ts] = [int(ts) for ts in dict_shifted_mea[lbl_ts]]\n\n    unit_shift = self.copy_mapping_unit(\n        source_unit_id=unit_id,\n        dest_unit_name=unit_name_shift,\n        appendToHub=True\n    )\n    unit_shift.set_dict_measurements(dict_shifted_mea)\n\n    return unit_name_shift\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.test_generate_dummy","title":"<code>test_generate_dummy(number=10)</code>","text":"<p>Generates dummy measurements for testing purposes</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def test_generate_dummy(self, number:int=10):\n    \"\"\"\n    Generates dummy measurements for testing purposes\n    \"\"\"\n    for i in range(number):\n        unit = MeaRMap_Unit(unit_name='dummy {}'.format(i))\n        unit.test_generate_dummy()\n        self.append_mapping_unit(unit)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Hub.validate_new_unit_name","title":"<code>validate_new_unit_name(unit_name)</code>","text":"<p>Validates if the new unit name is valid (i.e., does not already exist in the hub)</p> <p>Parameters:</p> Name Type Description Default <code>unit_name</code> <code>str</code> <p>unit name to be validated</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the unit name is valid, False otherwise</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def validate_new_unit_name(self,unit_name:str) -&gt; bool:\n    \"\"\"\n    Validates if the new unit name is valid (i.e., does not already exist in the hub)\n\n    Args:\n        unit_name (str): unit name to be validated\n\n    Returns:\n        bool: True if the unit name is valid, False otherwise\n    \"\"\"\n    assert isinstance(unit_name, str), 'validate_new_unit_name: The input data type is not correct. Expected a string.'\n    return unit_name not in self._dict_mappingUnit_NameID\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Plotter","title":"<code>MeaRMap_Plotter</code>","text":"<p>Class to plot the mapping measurement data from the MappingMeasurement_Unit object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>class MeaRMap_Plotter:\n    \"\"\"\n    Class to plot the mapping measurement data from the MappingMeasurement_Unit object\n    \"\"\"\n    def __init__(self):\n        self._fig, self._ax = plt.subplots()\n        self._cbar:Colorbar|None = None\n\n    def get_figure_axes(self) -&gt; tuple[Figure,Axes]:\n        \"\"\"\n        Returns the figure and axes of the plotter\n\n        Returns:\n            tuple[Figure,Axes]: figure and axes of the plotter\n        \"\"\"\n        return (self._fig,self._ax)\n\n    def get_plotter_params(self, plotter:PlotterOptions) -&gt; PlotterExtraParamsBase:\n        \"\"\"\n        Returns the parameter dataclass for the given plotter option\n\n        Args:\n            plotter (PlotterOptions): Plotter to get the parameters for\n        \"\"\"\n        if plotter == PlotterOptions.scattering:\n            return PlotterExtParams_Scattering()\n        elif plotter == PlotterOptions.interpolation:\n            return PlotterExtParams_Interpolation()\n        elif plotter == PlotterOptions.empty:\n            return PlotterExtParams_Empty()\n\n    def initialise_empty_plot(self) -&gt; None:\n        \"\"\"\n        Initialises an empty plot\n        \"\"\"\n        empty_params = PlotterParams()\n        self._plot_heatmap_empty(empty_params)\n\n    def plot_heatmap(self, plotter:PlotterOptions, params:PlotterParams, params_extra:PlotterExtraParamsBase|None = None) -&gt; None:\n        \"\"\"\n        Plots a heatmap plot from a mapping unit, given its coordinates, and labels indicating the data column info.\n        \"\"\"\n        if plotter == PlotterOptions.interpolation:\n            self._plot_heatmap_interp(params)\n        elif plotter == PlotterOptions.scattering:\n            params_extra = params_extra if isinstance(params_extra,PlotterExtParams_Scattering) else PlotterExtParams_Scattering()\n            self._plot_heatmap_scatter(params, params_extra)\n        elif plotter == PlotterOptions.empty:\n            self._plot_heatmap_empty(params)\n        else:\n            raise ValueError('plot_heatmap: The plotter option is not recognised: {}'.format(plotter))\n\n    def _plot_heatmap_empty(self,params:PlotterParams,*args, **kwargs) -&gt; None:\n        \"\"\"\n        Plots nothing but returns the figure, axis, and colorbar\n\n        Args:\n            mapping_unit (MappingMeasurement_Unit): MappingMeasurement_Unit object to plot\n            wavelength (float): wavelength to plot the heatmap\n            clim (tuple[float,float], optional): color limit for the heatmap. Defaults to None.\n            title (str, optional): title of the resulting graph. Defaults to '2D Mapping'.\n        \"\"\"\n        mapping_unit = params.mapping_unit\n        wavelength = params.wavelength\n        title = params.title\n        try: x_val, y_val, _ = self._retrieve_heatmap_data(mapping_unit, wavelength)\n        except ValueError:\n            x_val = [0,1]\n            y_val = [0,1]\n\n        x_min = min(x_val)\n        x_max = max(x_val)\n        y_min = min(y_val)\n        y_max = max(y_val)\n\n        if isinstance(self._cbar,Colorbar):\n            self._cbar.remove()\n        self._ax.clear()\n\n        self._ax.set_aspect(AppPlotEnum.PLT_ASPECT.value)\n        self._ax.set_title(title)\n        self._ax.set_xlabel(AppPlotEnum.PLT_LBL_X_AXIS.value)\n        self._ax.set_ylabel(AppPlotEnum.PLT_LBL_Y_AXIS.value)\n\n        self._ax.set_xlim(x_min,x_max)\n        self._ax.set_ylim(y_min,y_max)\n\n    def _plot_heatmap_interp(self, params:PlotterParams, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Plots a heatmap plot from a mapping unit, given its coordinates, and labels indicating the data column info.\n\n        Note:\n            - not providing the mapping_unit will plot and return an empty heatmap\n            - providing a figure and axis will plot the heatmap on the given figure and axis. BOTH fig and ax should be provided.\n            - providing a colorbar will reset the colorbar. If no fig and ax are provided, this option is ignored.\n\n        Args:\n            mapping_unit (MappingMeasurement_Unit): MappingMeasurement_Unit object to plot\n            wavelength (float): wavelength to plot the heatmap\n            clim (tuple[float,float], optional): color limit for the heatmap. Defaults to None.\n            title (str, optional): title of the resulting graph. Defaults to '2D Mapping'.\n        \"\"\"\n        # Do the calculation first for a lower figure off time\n        # (i.e., when the ax is cleared and not yet reassigned)\n        mapping_unit = params.mapping_unit\n        wavelength = params.wavelength\n        clim = params.clim\n        title = params.title\n\n        try: x_val, y_val, intensity = self._retrieve_heatmap_data(mapping_unit, wavelength)\n        except ValueError as e: pass; return\n        except Exception as e: print(f'Error in plot_heatmap_interp: {e}'); return\n\n        try:\n            if isinstance(self._cbar,Colorbar):\n                self._cbar.remove()\n        except Exception as e: print(f'Error in plot_heatmap_interp while removing cbar: {e}')\n\n        try: self._ax.clear()\n        except Exception as e: print(f'Error in plot_heatmap_interp while clearing ax: {e}')\n\n        # Check if the the data can be plot using tripcolor\n        if any([len(intensity) &lt; 3, len(set(x_val)) &lt; 2, len(set(y_val)) &lt; 2]):\n            return\n\n        self._ax.set_aspect(AppPlotEnum.PLT_ASPECT.value)\n\n        # Plot the tripcolor using your existing data\n        # Note we're passing x, y directly, and not using `triangles`\n        self._ax.tripcolor(\n            x_val, y_val, intensity, cmap=AppPlotEnum.PLT_COLOUR_MAP.value,\n            shading=AppPlotEnum.PLT_SHADING.value, edgecolors=AppPlotEnum.PLT_EDGE_COLOUR.value)\n\n        # Add colourbar and labels\n        self._cbar = self._fig.colorbar(self._ax.collections[0], ax=self._ax)\n        self._ax.set_title(title)\n        self._ax.set_xlabel(AppPlotEnum.PLT_LBL_X_AXIS.value)\n        self._ax.set_ylabel(AppPlotEnum.PLT_LBL_Y_AXIS.value)\n\n        # Set the colourbar limits\n        if isinstance(clim,tuple) and len(clim) == 2:\n            if isinstance(clim[0],float) and isinstance(clim[1],float):\n                list(clim).sort()\n            self._cbar.mappable.set_clim(vmin=clim[0],vmax=clim[1])\n\n    def _retrieve_heatmap_data(self, mapping_unit:MeaRMap_Unit|None, wavelength:float|None):\n        if isinstance(mapping_unit,MeaRMap_Unit) and wavelength is not None:    \n            # Retrieve the measurement data\n            df_plot:pd.DataFrame = mapping_unit.get_heatmap_table(wavelength)\n            label_x,label_y,_,_,label_intensity = mapping_unit.get_labels()\n\n            # Convert the x-coordinate and y-coordinate into string to prevent any issues\n            values = df_plot.values\n            x_loc = df_plot.columns.get_loc(label_x)\n            y_loc = df_plot.columns.get_loc(label_y)\n            intensity_loc = df_plot.columns.get_loc(label_intensity)\n\n            x_val = [val for val in values[:,x_loc]]\n            y_val = [val for val in values[:,y_loc]]\n            intensity = values[:,intensity_loc]\n        else: raise ValueError('_retrieve_heatmap_data: Invalid mapping_unit or wavelength input.')\n        return x_val,y_val,intensity\n\n    def _plot_heatmap_scatter(self, params:PlotterParams, params_extra:PlotterExtParams_Scattering|None, *args, **kwargs) -&gt; None:\n        \"\"\"\n        Plots a heatmap plot from a mapping unit, given its coordinates, and labels indicating the data column info.\n\n        Note:\n            - not providing the mapping_unit will plot and return an empty heatmap\n            - providing a figure and axis will plot the heatmap on the given figure and axis. BOTH fig and ax should be provided.\n            - providing a colorbar will reset the colorbar. If no fig and ax are provided, this option is ignored.\n\n        Args:\n            mapping_unit (MappingMeasurement_Unit): MappingMeasurement_Unit object to plot\n            wavelength (float): wavelength to plot the heatmap\n            clim (tuple[float,float], optional): color limit for the heatmap. Defaults to None.\n            title (str, optional): title of the resulting graph. Defaults to '2D Mapping'.\n            size (float, optional): size of the scatter plot. Defaults to None.\n        \"\"\"\n        mapping_unit = params.mapping_unit\n        wavelength = params.wavelength\n        clim = params.clim\n        title = params.title\n        size = params_extra.marker_size\n\n        try: x_val, y_val, intensity = self._retrieve_heatmap_data(mapping_unit, wavelength)\n        except ValueError as e: print(f'Error in plot_heatmap_scatter: {e}'); return\n\n        try:\n            if isinstance(self._cbar,Colorbar):\n                self._cbar.remove()\n        except Exception as e: print(f'Error in plot_heatmap_scatter while clearing ax or cbar: {e}')\n\n        try: self._ax.clear()\n        except Exception as e: print(f'Error in plot_heatmap_scatter while clearing ax: {e}')\n\n        # Check if the the data can be plot using tripcolor\n        if any([len(intensity) &lt; 3, len(set(x_val)) &lt; 2, len(set(y_val)) &lt; 2]): return\n\n        self._ax.set_aspect(AppPlotEnum.PLT_ASPECT.value)\n\n        figsize = self._fig.get_size_inches()\n        number_of_points = len(x_val)\n\n        point_size = (figsize[0]*figsize[1])/number_of_points*750 if not isinstance(size,float) else size\n        self._ax.scatter(x_val, y_val, c=intensity, cmap=AppPlotEnum.PLT_COLOUR_MAP.value, s=point_size, linewidths=0, marker='s')\n\n        # Add colourbar and labels\n        self._cbar = self._fig.colorbar(self._ax.collections[0], ax=self._ax)\n        self._ax.set_title(title)\n        self._ax.set_xlabel(AppPlotEnum.PLT_LBL_X_AXIS.value)\n        self._ax.set_ylabel(AppPlotEnum.PLT_LBL_Y_AXIS.value)\n\n        # Set the colourbar limits\n        if isinstance(clim,tuple) and len(clim) == 2:\n            if isinstance(clim[0],float) and isinstance(clim[1],float):\n                list(clim).sort()\n            self._cbar.mappable.set_clim(vmin=clim[0],vmax=clim[1])\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Plotter.get_figure_axes","title":"<code>get_figure_axes()</code>","text":"<p>Returns the figure and axes of the plotter</p> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>tuple[Figure,Axes]: figure and axes of the plotter</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_figure_axes(self) -&gt; tuple[Figure,Axes]:\n    \"\"\"\n    Returns the figure and axes of the plotter\n\n    Returns:\n        tuple[Figure,Axes]: figure and axes of the plotter\n    \"\"\"\n    return (self._fig,self._ax)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Plotter.get_plotter_params","title":"<code>get_plotter_params(plotter)</code>","text":"<p>Returns the parameter dataclass for the given plotter option</p> <p>Parameters:</p> Name Type Description Default <code>plotter</code> <code>PlotterOptions</code> <p>Plotter to get the parameters for</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_plotter_params(self, plotter:PlotterOptions) -&gt; PlotterExtraParamsBase:\n    \"\"\"\n    Returns the parameter dataclass for the given plotter option\n\n    Args:\n        plotter (PlotterOptions): Plotter to get the parameters for\n    \"\"\"\n    if plotter == PlotterOptions.scattering:\n        return PlotterExtParams_Scattering()\n    elif plotter == PlotterOptions.interpolation:\n        return PlotterExtParams_Interpolation()\n    elif plotter == PlotterOptions.empty:\n        return PlotterExtParams_Empty()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Plotter.initialise_empty_plot","title":"<code>initialise_empty_plot()</code>","text":"<p>Initialises an empty plot</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def initialise_empty_plot(self) -&gt; None:\n    \"\"\"\n    Initialises an empty plot\n    \"\"\"\n    empty_params = PlotterParams()\n    self._plot_heatmap_empty(empty_params)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Plotter.plot_heatmap","title":"<code>plot_heatmap(plotter, params, params_extra=None)</code>","text":"<p>Plots a heatmap plot from a mapping unit, given its coordinates, and labels indicating the data column info.</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def plot_heatmap(self, plotter:PlotterOptions, params:PlotterParams, params_extra:PlotterExtraParamsBase|None = None) -&gt; None:\n    \"\"\"\n    Plots a heatmap plot from a mapping unit, given its coordinates, and labels indicating the data column info.\n    \"\"\"\n    if plotter == PlotterOptions.interpolation:\n        self._plot_heatmap_interp(params)\n    elif plotter == PlotterOptions.scattering:\n        params_extra = params_extra if isinstance(params_extra,PlotterExtParams_Scattering) else PlotterExtParams_Scattering()\n        self._plot_heatmap_scatter(params, params_extra)\n    elif plotter == PlotterOptions.empty:\n        self._plot_heatmap_empty(params)\n    else:\n        raise ValueError('plot_heatmap: The plotter option is not recognised: {}'.format(plotter))\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit","title":"<code>MeaRMap_Unit</code>","text":"<p>This is a class to store a list of measurement data during a mapping measurement. Essentially, it's a subunit of the mapping_measurement class. Use case: - To store a list of raw measurement from a mapping measurement - To store a list calibration/background measurements - To store a list of analysed dataframes</p> <p>A mapping_measurement_unit object can then be appended to a mapping_measurement object, which keeps track of the collection of mapping_measurement_unit objects.</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>class MeaRMap_Unit():\n    \"\"\"\n    This is a class to store a list of measurement data during a mapping measurement.\n    Essentially, it's a subunit of the mapping_measurement class.\n    Use case:\n    - To store a list of raw measurement from a mapping measurement\n    - To store a list calibration/background measurements\n    - To store a list of analysed dataframes\n\n    A mapping_measurement_unit object can then be appended to a mapping_measurement object,\n    which keeps track of the collection of mapping_measurement_unit objects.\n    \"\"\"\n    def __init__(self, unit_name='raw_measurement', unit_id:str|None=None, extra_metadata:dict={}) -&gt; None:\n        # Make sure that mea_id is a valid name for a database table\n        assert isinstance(unit_name, str), 'mapping_measurement_unit: The input data type is not correct. Expected a string.'\n        assert isinstance(extra_metadata, dict), 'mapping_measurement_unit: The input data type is not correct. Expected a dictionary.'\n        if unit_id is None: unit_id = uuid.uuid4().hex\n        else: unit_id = unit_id; assert unit_id.isidentifier, 'mapping_measurement_unit: The input unit_id is not a valid identifier.'\n\n        self._version = '0.1.0-2024.05.24'  # Version of the data storage format\n        self._unit_id = unit_id             # Measurement unit ID to be used for the database\n        self._unit_name = unit_name         # Measurement name (e.g., 'raw_measurement', 'calibration', 'background', 'analysed-1', etc.)\n        self._unit_id_key = SaveParamsEnum.DATABASE_ID_KEY.value # Key for the measurement ID in the metadata dictionary\n        self._unit_name_key = SaveParamsEnum.DATABASE_NAME_KEY.value # Key for the measurement name in the metadata dictionary\n        self._mea_id_key = DAEnum.ID_TIMESTAMP_LABEL.value      # Key for the measurement timestamp in the measurement dictionary\n\n        # Parameters for the database storage\n        self._flg_measurement_exist = False   # Flag to check if the measurement data exists\n        self._flg_metadata_exist = False     # Flag to check if the metadata exists\n\n        # Additional attributes for ease of use in other programs (for reference during plotting)\n        self._label_ts = DAEnum.ID_TIMESTAMP_LABEL.value    # Timestamp column name for the dictionary\n        self._label_x = DAEnum.COORX_LABEL.value            # X-coordinate column name for the dictionary\n        self._label_y = DAEnum.COORY_LABEL.value            # Y-coordinate column name for the dictionary\n        self._label_z = DAEnum.COORZ_LABEL.value            # Z-coordinate column name for the dictionary\n        self._label_listmea = DAEnum.LIST_MEA_LABEL.value   # Key for the list of raw dataframes in the measurement dictionary\n        self._label_avemea = DAEnum.AVE_MEA_LABEL.value     # Key for the averaged dataframe in the measurement dictionary\n\n        # Column names to access the pd.DataFrame values\n        self._dflabel_wavelength = DAEnum.WAVELENGTH_LABEL.value    # Wavelength column name corresponding to the dataframe of the measurements\n        self._dflabel_intensity = DAEnum.INTENSITY_LABEL.value      # Intensity column name corresponding to the dataframe of the measurements\n\n        self._extra_metadata = extra_metadata   # Extra metadata to be stored in the measurement unit\n        self._dict_metadata = {\n            self._unit_id_key: self._unit_id,\n            self._unit_name_key: unit_name,\n            'measurement_metadata': extra_metadata.copy()\n        }\n\n        self._dict_metadata_types = {   # Type definition for loading the metadata from the database\n            self._unit_id_key: str,\n            self._unit_name_key: str,\n            'measurement_metadata': dict\n        }\n\n        assert all([key in self._dict_metadata_types.keys() for key in self._dict_metadata.keys()]),\\\n            'mapping_measurement_unit: The metadata keys are not the same as the metadata types.'\n\n        # Measurement data storage\n        self._dict_measurement = {\n            self._label_ts: [],\n            self._label_x: [],\n            self._label_y: [],\n            self._label_z: [],\n            self._label_listmea: [],      # List of raw dataframes in an accumulation (e.g., background measurements may require multiple acquisitions)\n            self._label_avemea: []   # Averaged dataframe from 'list_df'\n        }\n\n        self._dict_measurement_types = {    # Type definition for loading the measurement data from the database\n            self._label_ts: int,\n            self._label_x: float,\n            self._label_y: float,\n            self._label_z: float,\n            self._label_listmea: list[pd.DataFrame],  # !!! Note that list_df can also be None !!!\n            self._label_avemea: pd.DataFrame\n        }\n\n        self._lock_measurement = threading.RLock()\n\n        assert all([key in self._dict_measurement_types.keys() for key in self._dict_measurement.keys()]),\\\n            'mapping_measurement_unit: The measurement keys are not the same as the measurement types.'\n\n        # Observer setup\n        self._list_observers = []\n\n    def get_laser_params(self) -&gt; tuple[float,float]:\n        \"\"\"\n        Returns the laser wavelength and power metadata\n\n        Returns:\n            tuple: laser power, laser wavelength\n        \"\"\"\n        if not self._flg_metadata_exist: raise ValueError('get_laser_metadata: The metadata does not exist.')\n        metadata = self.get_dict_measurement_metadata()\n        power_key,wavelength_key = MeaRaman(reconstruct=True).get_laserMetadata_key()\n        return (metadata[power_key],metadata[wavelength_key])\n\n    def get_measurementId_from_coor(self, coor:tuple[float,float]) -&gt; str:\n        \"\"\"\n        Retrieves the measurement ID from the coordinates closest to the given coordinates.\n\n        Args:\n            coor (tuple[float,float]): coordinates to retrieve the ID from. (x,y)\n\n        Returns:\n            str: measurement ID\n        \"\"\"\n        assert isinstance(coor,tuple), 'Coordinates should be in a tuple'\n        assert len(coor) == 2, 'Coordinates should be in a tuple of 2 elements'\n        assert all([isinstance(val,(float,int)) for val in coor]), 'Coordinates should be in float or integer'\n\n        list_coor = list(zip(self._dict_measurement[self._label_x],self._dict_measurement[self._label_y]))\n        list_dist = [np.linalg.norm(np.array(coor)-np.array(c)) for c in list_coor]\n        idx_min = np.argmin(list_dist)\n\n        return self._dict_measurement[self._mea_id_key][idx_min]\n\n    def get_keys_dict_measurement(self) -&gt; tuple[str,str,str,str,str,str]:\n        \"\"\"\n        Returns the keys for the measurement data stored in the object\n\n        Returns:\n            tuple: keys for the timestamp, x, y, z, list_df, and averaged_df\n        \"\"\"\n        return (self._mea_id_key,self._label_x,self._label_y,self._label_z,self._label_listmea,self._label_avemea)\n\n    def get_key_measurementId(self) -&gt; str:\n        \"\"\"\n        Returns the key storing the id for the Raman measurement stored in the measurement dictionary\n        \"\"\"\n        return self._mea_id_key\n\n    def set_dict_metadata(self,measurementUnit_metadata:dict):\n        \"\"\"\n        Sets the metadata for the measurement analysis\n\n        Args:\n            measurementUnit_metadata (dict): dictionary of the metadata\n        \"\"\"\n        # For compatibility with previous versions\n        if self._unit_name_key not in measurementUnit_metadata.keys() and self._unit_id_key in measurementUnit_metadata.keys():\n            measurementUnit_metadata[self._unit_name_key] = measurementUnit_metadata[self._unit_id_key]\n\n        # Check the input data type\n        assert isinstance(measurementUnit_metadata, dict), 'set_unit_metadata: The input data type is not correct. Expected a dictionary.'\n        assert all([key in measurementUnit_metadata.keys() for key in self._dict_metadata.keys()]),\\\n            'set_unit_metadata: The metadata keys are not the same as the metadata types.'\n\n        self._set_measurement_metadata(measurementUnit_metadata['measurement_metadata'])\n        self._unit_id = measurementUnit_metadata[self._unit_id_key]\n        self._unit_name = measurementUnit_metadata[self._unit_name_key]\n\n        if self.check_measurement_and_metadata_exist(): self._notify_observers()\n\n    def set_dict_measurements(self,dict_measurement:dict):\n        \"\"\"\n        Sets the measurement data stored in the object.\n\n        Args:\n            dict_measurement (dict): dictionary of the measurement data\n        \"\"\"\n        assert isinstance(dict_measurement, dict), 'set_dict_measurements: The input data type is not correct. Expected a dictionary.'\n        assert all([key in dict_measurement.keys() for key in self._dict_measurement.keys()]),\\\n            'set_dict_measurements: The input dictionary keys are not the same as the stored data keys.'\n\n        self._dict_measurement = dict_measurement\n        self._flg_measurement_exist = True\n\n        if self.check_measurement_and_metadata_exist(): self._notify_observers()\n\n    def get_dict_measurements(self, copy:bool=False) -&gt; dict:\n        \"\"\"\n        Returns the measurement data stored in the object.\n\n        Returns:\n            dict: dictionary of the measurement data\n        \"\"\"\n        if copy:\n            with self._lock_measurement:\n                return {key: list(val) for key, val in self._dict_measurement.items()}\n        else:\n            return self._dict_measurement\n\n    def get_dict_types(self) -&gt; tuple[dict,dict]:\n        \"\"\"\n        Returns the dictionary of the data types stored in the class\n\n        Returns:\n            tuple: dictionary of the metadata types, dictionary of the measurement types\n        \"\"\"\n        return (self._dict_metadata_types, self._dict_measurement_types)\n\n    def check_measurement_and_metadata_exist(self):\n        \"\"\"\n        Check if the measurement data and metadata exist\n        \"\"\"\n        # Note: KeyError and AttributeError are bypassed as there are cases where the object (self)\n        # itself have been deleted but the reference to it still remains in other parts of the program\n        # This would typically trigger KeyError as self._dict_measurement becomes empty. An example of\n        # This issue happens with the heatmap plotter when a unit currently being plot is suddenly\n        # deleted in the mappingHub (e.g., through the dataHub gui).\n        try:\n            if len(self._dict_measurement[self._label_ts]) == 0: self._flg_measurement_exist = False\n        except (KeyError, AttributeError): self._flg_measurement_exist = False\n\n        try:\n            if len(self._dict_metadata) == len(self._extra_metadata): self._flg_metadata_exist = False\n        except (KeyError, AttributeError): self._flg_metadata_exist = False\n\n        return self._flg_measurement_exist and self._flg_metadata_exist\n\n    def set_unitName(self,unit_name:str):\n        \"\"\"\n        Sets the measurement unit name\n\n        Args:\n            unit_name (str): measurement unit name\n        \"\"\"\n        assert isinstance(unit_name, str), 'set_unit_id: The input data type is not correct. Expected a string.'\n\n        self._unit_name = unit_name\n        self._dict_metadata[self._unit_name_key] = unit_name\n\n        if self.check_measurement_and_metadata_exist(): self._notify_observers()\n\n    def set_unitName_and_unitID(self,unit_name:str, unit_id:str|None=None):\n        \"\"\"\n        Sets the measurement unit name and resets the measurement unit id\n\n        Args:\n            unit_name (str): measurement unit name\n            unit_id (str|None): measurement unit id. A new UUID will be generated if None\n        \"\"\"\n        assert isinstance(unit_name, str), 'set_unit_id: The input data type is not correct. Expected a string.'\n\n        self._unit_name = unit_name\n        self._dict_metadata[self._unit_name_key] = unit_name\n\n        if not isinstance(unit_id, str): unit_id = uuid.uuid4().hex\n        self._unit_id = unit_id\n        self._dict_metadata[self._unit_id_key] = self._unit_id\n\n        if self.check_measurement_and_metadata_exist(): self._notify_observers()\n\n    def get_unit_name(self) -&gt; str:\n        \"\"\"\n        Returns the measurement unit name\n\n        Returns:\n            str: measurement unit name\n        \"\"\"\n        return self._unit_name\n\n    def get_unit_id(self) -&gt; str:\n        \"\"\"\n        Returns the measurement unit id\n\n        Returns:\n            str: measurement unit id\n        \"\"\"\n        return self._unit_id\n\n    def get_numMeasurements(self) -&gt; int:\n        \"\"\"\n        Returns the number of measurements stored in the object.\n\n        Returns:\n            int: number of measurements\n        \"\"\"\n        with self._lock_measurement:\n            return len(self._dict_measurement[self._label_ts])\n\n    def get_dict_measurement_metadata(self) -&gt; dict:\n        \"\"\"\n        Returns the measurement metadata of the object.\n\n        Returns:\n            dict: measurement metadata dictionary\n        \"\"\"\n        return self._dict_metadata['measurement_metadata']\n\n    def get_dict_unit_metadata(self) -&gt; dict:\n        \"\"\"\n        Returns the measurement unit id and metadata of the object.\n\n        Returns:\n            dict: measurement unit metadata dictionary\n        \"\"\"\n        return self._dict_metadata\n\n    def generate_unit_metadata(self, unit_id:str|None=None, unit_name:str|None=None) -&gt; dict:\n        \"\"\"\n        Generates a new unit metadata dictionary based on the this unit's metadata but,\n        with a new unit_id and unit_name.\n\n        Args:\n            unit_id (str|None): new unit ID to be used. If None, a new UUID will be generated.\n            unit_name (str|None): new unit name to be used. If None, the unit_name will be set to 'unit_name_copy'.\n\n        Returns:\n            dict: new unit metadata dictionary with a new unit_id and unit_name\n        \"\"\"\n        new_unit_metadata = {}\n\n        if unit_id is None: unit_id = uuid.uuid4().hex\n        if unit_name is None: unit_name = f'{self._unit_name}_copy'\n\n        new_unit_metadata[self._unit_id_key] = unit_id\n        new_unit_metadata[self._unit_name_key] = unit_name\n\n        for key in self._dict_metadata.keys():\n            if key not in [self._unit_id_key, self._unit_name_key]:\n                new_unit_metadata[key] = deepcopy(self._dict_metadata[key])\n\n        return new_unit_metadata\n\n    def _set_measurement_metadata(self,measurement_metadata:dict):\n        \"\"\"\n        Sets the metadata for the measurement analysis\n\n        Args:\n            measurement_metadata (dict): dictionary of the metadata\n\n        Note:\n            Will raise an error if the given metadata is different from the stored metadata.\n        \"\"\"\n        assert isinstance(measurement_metadata, dict), 'set_metadata: The input data type is not correct. Expected a dictionary.'\n\n        if not self._flg_metadata_exist:\n            self._dict_metadata['measurement_metadata'].update(measurement_metadata)\n            self._flg_metadata_exist = True\n        else:\n            assert all([key in self._dict_metadata['measurement_metadata'].keys() for key in measurement_metadata.keys()]),\\\n                'set_metadata: The input metadata is different from the stored metadata.'\n            assert all([val == self._dict_metadata['measurement_metadata'][key] for key,val in measurement_metadata.items()]),\\\n                'set_metadata: The input metadata is different from the stored metadata.'\n\n    def append_dict_measurement_data(self,dict_measurement:dict):\n        \"\"\"\n        Appends the measurement data into the list of stored measurements.\n\n        Args:\n            dict_measurement (dict): dictionary of the measurement data. Has to have the same keys as the stored data.\n        \"\"\"\n        assert isinstance(dict_measurement, dict), 'append_dict_measurement_data: The input data type is not correct. Expected a dictionary.'\n        assert all([key in dict_measurement.keys() for key in self._dict_measurement.keys()]),\\\n            'append_dict_measurement_data: The input dictionary keys are not the same as the stored data keys.'\n\n        for key in dict_measurement.keys():\n            self._dict_measurement[key].append(dict_measurement[key])\n\n        self._flg_measurement_exist = True\n\n        self._notify_observers()\n\n    def append_ramanmeasurement_data(self,timestamp:int,coor:tuple[float,float,float],measurement:MeaRaman):\n        \"\"\"\n        Appends the measurement data into the list of stored measurements.\n\n        Args:\n            timestamp (int): timestamp of the measurement\n            coor (tuple): coordinates of the measurement\n            measurement (raman_measurement): raman measurement data object to be stored\n            autoupdate (bool): automatically update the averaged_df based on the current 'list_df'. Defaults to False.\n        \"\"\"\n        assert isinstance(measurement, MeaRaman), 'append_measurement_data: The input data type is not correct. Expected raman_measurement object.'\n        assert isinstance(coor, (tuple,list)) and len(coor) == 3, 'append_measurement_data: The input coordinate is not correct. Expected a tuple of length 3.'\n        assert all(isinstance(item, (int,float)) for item in coor), 'append_measurement_data: The input coordinate is not correct. Expected a tuple of integers or floats.'\n        assert isinstance(timestamp, int), 'append_measurement_data: The input timestamp is not correct. Expected an integer.'\n        assert measurement.check_measurement_exist(), 'append_measurement_data: The measurement data does not exist.'\n        assert timestamp not in self._dict_measurement[self._label_ts], 'append_measurement_data: The timestamp already exists in the stored data.'\n\n        # Check if the measurement metadata is the same as the stored metadata\n        measurement_metadata = measurement.get_metadata()\n        if not self._flg_metadata_exist: self._set_measurement_metadata(measurement_metadata)\n        elif not all([key in measurement_metadata.keys() for key in self._dict_metadata['measurement_metadata'].keys()]) and \\\n            not all([val == self._dict_metadata['measurement_metadata'][key] for key,val in measurement_metadata.items()]):\n            raise ValueError('append_measurement_data: The measurement metadata does not match the stored metadata.')\n\n        with self._lock_measurement:\n            self._dict_measurement[self._label_ts].append(timestamp)\n            self._dict_measurement[self._label_x].append(coor[0])\n            self._dict_measurement[self._label_y].append(coor[1])\n            self._dict_measurement[self._label_z].append(coor[2])\n            self._dict_measurement[self._label_listmea].append(measurement.get_raw_list())\n            self._dict_measurement[self._label_avemea].append(measurement.get_analysed())\n\n        self._flg_measurement_exist = True\n\n        self._notify_observers()\n\n    def append_dfmeasurement_data(self,timestamp:str,coor:tuple[float,float,float],measurement_df:pd.DataFrame,\n                                  list_df:list[pd.DataFrame]|None=None):\n        \"\"\"\n        Appends the measurement data into the list of stored measurements.\n\n        Args:\n            timestamp (str): timestamp of the measurement\n            coor (tuple): coordinates of the measurement\n            measurement_df (pd.DataFrame): measurement df to be stored\n            list_df (list): list of raw dataframes of the measurement. Defaults to None.\n        \"\"\"\n        assert isinstance(measurement_df, pd.DataFrame), 'append_measurement_data: The input data type is not correct. Expected a pandas.DataFrame.'\n        assert isinstance(coor, tuple) and len(coor) == 3, 'append_measurement_data: The input coordinate is not correct. Expected a tuple of length 3.'\n        assert all(isinstance(item, (int,float)) for item in coor), 'append_measurement_data: The input coordinate is not correct. Expected a tuple of integers or floats.'\n        assert isinstance(timestamp, str), 'append_measurement_data: The input timestamp is not correct. Expected a string.'\n\n        with self._lock_measurement:\n            if list_df is not None:\n                assert isinstance(list_df, list), 'append_measurement_data: The input list_df is not correct. Expected a list of pandas.DataFrame objects.'\n                assert all(isinstance(item, pd.DataFrame) for item in list_df), 'append_measurement_data: The input list_df is not correct. Expected a list of pandas.DataFrame objects.'\n                self._dict_measurement[self._label_listmea].append(list_df)\n            else:\n                self._dict_measurement[self._label_listmea].append(None)\n            self._dict_measurement[self._label_ts].append(timestamp)\n            self._dict_measurement[self._label_x].append(coor[0])\n            self._dict_measurement[self._label_y].append(coor[1])\n            self._dict_measurement[self._label_z].append(coor[2])\n            self._dict_measurement[self._label_avemea].append(measurement_df)\n\n        self._flg_measurement_exist = True\n\n        self._notify_observers()\n\n    def get_RamanMeasurement_df_fromIdx(self,idx:int) -&gt; pd.DataFrame:\n        \"\"\"\n        Grabs the averaged dataframe stored\n\n        Args:\n            idx (int): index of the measurement\n\n        Returns:\n            pd.DataFrame: averaged dataframe of the measurement\n        \"\"\"\n        assert self._flg_measurement_exist, 'get_avg_df: The measurement data does not exist.'\n        assert 0&lt;=idx &lt; len(self._dict_measurement[self._label_ts]), 'get_avg_df: The index is out of range.'\n\n        df = self._dict_measurement[self._label_avemea][idx]\n\n        return df\n\n    def get_dict_RamanMeasurement_summary(self,measurement_id:int|str,exclude_id:bool=False) -&gt; dict:\n        \"\"\"\n        Returns the summary of the measurement data stored in the object.\n        Summarises the measurement data based on the measurement_id and returns\n        all the data in a dictionary that is either a string, integer, or float.\n\n        Args:\n            measurement_id (int|str): timestamp of the measurement in microsec in int or str format\n            exclude_id (bool): exclude the measurement ID from the summary. Defaults to False.\n\n        Returns:\n            dict: dictionary of the measurement data\n        \"\"\"\n        if isinstance(measurement_id,str): measurement_id = int(float(measurement_id))\n        assert measurement_id in self._dict_measurement[self._mea_id_key], 'get_summary: The measurement ID does not exist in the stored data.'\n        assert self._flg_measurement_exist, 'get_summary: The measurement data does not exist.'\n        assert isinstance(exclude_id,bool), 'get_summary: The input data type is not correct. Expected a boolean.'\n\n        dict_mea = {}\n        mea_idx = self._dict_measurement[self._mea_id_key].index(measurement_id)\n        for key in self._dict_measurement.keys():\n            item = self._dict_measurement[key][mea_idx]\n            if exclude_id and key == self._mea_id_key: continue\n            if isinstance(item,(str,int,float)):\n                dict_mea[key] = str(item)\n        return dict_mea\n\n    def get_RamanMeasurement(self,measurement_id:int|str) -&gt; MeaRaman:\n        \"\"\"\n        Retrieves the measurement dataframe from the stored data, reconstruct\n        the RamanMeasurement object, and returns it.\n\n        Args:\n            measurement_id (int|str): timestamp of the measurement in microsec in int or str format\n\n        Returns:\n            RamanMeasurement: reconstructed RamanMeasurement object\n        \"\"\"\n        assert isinstance(measurement_id,(int,str)), 'get_RamanMeasurement: The input data type is not correct. Expected an integer or a string of integer.'\n        if isinstance(measurement_id,str):\n            try: measurement_id = int(float(measurement_id))\n            except: raise ValueError('get_RamanMeasurement: The measurement ID is not an integer.')\n        assert measurement_id in self._dict_measurement[self._mea_id_key],\\\n            'get_RamanMeasurement: The requested measurement does not exist in the stored data.'\n\n        mea_df = self.get_RamanMeasurement_df(measurement_id)\n        mea_metadata = self.get_dict_measurement_metadata()\n        mea = MeaRaman(reconstruct=True)\n        mea.reconstruct(measurement_id=measurement_id,metadata=mea_metadata,spec_analysed=mea_df)\n        return mea\n\n    def get_RamanMeasurement_df(self,measurement_id:int) -&gt; pd.DataFrame:\n        \"\"\"\n        Grabs the averaged dataframe stored\n\n        Args:\n            measurement_id (int): measurement_id of the measurement\n\n        Returns:\n            pd.DataFrame: averaged dataframe of the measurement\n        \"\"\"\n        assert self._flg_measurement_exist, 'get_avg_df: The measurement data does not exist.'\n        assert measurement_id in self._dict_measurement[self._mea_id_key], 'get_avg_df: The timestamp does not exist in the stored data.'\n\n        idx = bisect.bisect_left(self._dict_measurement[self._mea_id_key], measurement_id)\n        df = self._dict_measurement[self._label_avemea][idx]\n\n        return df\n\n    def get_list_RamanMeasurement_ids(self) -&gt; list[int]:\n        \"\"\"\n        Returns the list of timestamps stored in the measurement data\n\n        Returns:\n            list[int]: list of timestamps\n        \"\"\"\n        return self._dict_measurement[self._label_ts]\n\n    def get_list_wavelengths(self) -&gt; list[float]:\n        \"\"\"\n        Returns the list of wavelengths stored in the measurement data\n\n        Returns:\n            list: list of wavelengths\n        \"\"\"\n        # assert self._flg_measurement_exist, 'get_list_wavelengths: The measurement data does not exist.'\n        if not self._flg_measurement_exist: return []\n\n        with self._lock_measurement:\n            df:pd.DataFrame = self._dict_measurement[self._label_avemea][-1]\n            list_wavelengths = df[self._dflabel_wavelength].tolist()\n            return list_wavelengths\n\n    def get_list_Raman_shift(self) -&gt; list[float]:\n        \"\"\"\n        Returns the list of Raman shifts stored in the measurement data\n\n        Returns:\n            list: list of Raman shifts\n        \"\"\"\n        list_wavelengths = self.get_list_wavelengths()\n        list_raman_shift = [convert_wavelength_to_ramanshift(wavelength=wvl,\\\n            excitation_wavelength=self.get_laser_params()[1]) for wvl in list_wavelengths]\n        return list_raman_shift\n\n    def convert(self, wavelength:float|None=None, Raman_shift:float|None=None):\n        \"\"\"\n        Converts between wavelength and Raman shift by giving EITHER one based on\n        the laser params stored internally.\n\n        Args:\n            wavelength (float | None, optional): Wavelength to convert. Defaults to None.\n            Raman_shift (float | None, optional): Raman shift to convert. Defaults to None.\n        \"\"\"\n        if (isinstance(wavelength,(int,float)) and isinstance(Raman_shift,(int,float)))\\\n            or (isinstance(wavelength, type(None)) and isinstance(Raman_shift, type(None))):\n            raise ValueError('convert: Please provide either wavelength or Raman shift, not both or neither.')\n\n        if isinstance(wavelength,(int,float)):\n            return convert_wavelength_to_ramanshift(wavelength,self.get_laser_params()[1])\n        elif isinstance(Raman_shift,(int,float)):\n            return convert_ramanshift_to_wavelength(Raman_shift,self.get_laser_params()[1])\n        else: raise TypeError('Wavelength or Raman shift has to be in integer or float')\n\n    def get_closest_wavelength(self,wavelength:float) -&gt; float:\n        \"\"\"\n        Returns the closest wavelength in the list of wavelengths stored in the measurement data\n\n        Args:\n            wavelength (float): wavelength to be retrieved (closest wavelength will be used)\n\n        Returns:\n            float: closest wavelength in the list of wavelengths\n        \"\"\"\n        assert self._flg_measurement_exist, 'get_closest_wavelength: The measurement data does not exist.'\n        assert isinstance(wavelength, (int, float)), 'get_closest_wavelength: The input data type is not correct. Expected an integer or a float.'\n\n        wavelength_idx = self.get_wavelength_idx(wavelength=wavelength)\n        wavelength = self.get_list_wavelengths()[wavelength_idx]\n\n        return wavelength\n\n    def get_closest_raman_shift(self,raman_shift:float) -&gt; float:\n        \"\"\"\n        Returns the closest Raman shift in the list of Raman shifts stored in the measurement data\n\n        Args:\n            raman_shift (float): Raman shift to be retrieved (closest Raman shift will be used)\n\n        Returns:\n            float: closest Raman shift in the list of Raman shifts\n        \"\"\"\n        assert self._flg_measurement_exist and self._flg_metadata_exist, 'get_closest_raman_shift: The measurement or metadata does not exist.'\n        assert isinstance(raman_shift, (int, float)), 'get_closest_raman_shift: The input data type is not correct. Expected an integer or a float.'\n        return self.get_list_Raman_shift()[self.get_wavelength_idx(convert_ramanshift_to_wavelength(raman_shift,self.get_laser_params()[1]))]\n\n    def get_wavelength_idx(self,wavelength:float) -&gt; int:\n        \"\"\"\n        Returns the index of the wavelength in the list of wavelengths stored in the measurement data\n\n        Args:\n            wavelength (float): wavelength to be retrieved (closest wavelength will be used)\n\n        Returns:\n            int: index of the wavelength in the list of wavelengths\n        \"\"\"\n        assert self._flg_measurement_exist, 'get_wavelength_idx: The measurement data does not exist.'\n        assert isinstance(wavelength, (int, float)), 'get_wavelength_idx: The input data type is not correct. Expected an integer or a float.'\n\n        def find_nearest(array, value):\n            array = np.asarray(array)\n            idx = np.argmin(np.abs(array - value))\n            return array[idx]\n\n        closest_wavelength = find_nearest(self.get_list_wavelengths(),wavelength)\n\n        df:pd.DataFrame = self._dict_measurement[self._label_avemea][-1]\n        wavelength_idx = df[self._dflabel_wavelength].tolist().index(closest_wavelength)\n\n        return wavelength_idx\n\n    def get_raman_shift_idx(self,raman_shift:float) -&gt; int:\n        \"\"\"\n        Returns the index of the Raman shift in the list of Raman shifts stored in the measurement data\n\n        Args:\n            raman_shift (float): Raman shift to be retrieved (closest Raman shift will be used)\n\n        Returns:\n            int: index of the Raman shift in the list of Raman shifts\n        \"\"\"\n        assert self._flg_measurement_exist and self._flg_metadata_exist, 'get_raman_shift_idx: The measurement or metadata does not exist.'\n        assert isinstance(raman_shift, (int, float)), 'get_raman_shift_idx: The input data type is not correct. Expected an integer or a float.'\n        wvl = convert_ramanshift_to_wavelength(raman_shift,self.get_laser_params()[1])\n        return self.get_wavelength_idx(wavelength=wvl)\n\n    def get_labels(self) -&gt; tuple:\n        \"\"\"\n        Returns the labels for the x, y, z coordinates, and the wavelength and intensity keys\n\n        Returns:\n            tuple: (x_label,y_label,z_label,wavelength_label,intensity_label)\n        \"\"\"\n        return (self._label_x,self._label_y,self._label_z,self._dflabel_wavelength,self._dflabel_intensity)\n\n    def get_heatmap_table(self, wavelength: float) -&gt; pd.DataFrame:\n        \"\"\"\n        Returns a dataframe containing the x, y, z coordinates and the intensity\n        values at the specified wavelength for all measurements.\n\n        Args:\n            wavelength (float): Wavelength to extract the intensity values from.\n        \"\"\"\n        if not self._dict_measurement[self._label_avemea]:\n            return pd.DataFrame()\n\n        # 1. Get metadata needed for indexing (usually safe without lock if immutable)\n        wvl_list = self.get_list_wavelengths() \n        closest_wavelength = wvl_list[np.argmin(np.abs(np.array(wvl_list) - wavelength))]\n\n        # 2. THE SNAPSHOT: Hold lock for microseconds only\n        with self._lock_measurement:\n            # We copy the references to the lists. \n            # The DataFrames themselves aren't copied, just the \"list of pointers\"\n            ave_mea_snapshot = list(self._dict_measurement[self._label_avemea])\n            x_coor = list(self._dict_measurement[self._label_x])\n            y_coor = list(self._dict_measurement[self._label_y])\n            z_coor = list(self._dict_measurement[self._label_z])\n\n        # --- LOCK RELEASED HERE --- \n        # The hardware can now append to the internal lists while we process the snapshot\n\n        # 3. Heavy Extraction (Outside the lock)\n        sample_df = ave_mea_snapshot[-1]\n        wvl_idx = sample_df[self._dflabel_wavelength].tolist().index(closest_wavelength)\n        int_col_idx = sample_df.columns.get_loc(self._dflabel_intensity)\n\n        # This loop takes time, but it doesn't block the hardware anymore!\n        intensities = [df.iat[wvl_idx, int_col_idx] for df in ave_mea_snapshot]\n\n        return pd.DataFrame({\n            self._label_x: x_coor,\n            self._label_y: y_coor,\n            self._label_z: z_coor,\n            self._dflabel_wavelength: closest_wavelength,\n            self._dflabel_intensity: intensities\n        })\n\n    def add_observer(self, observer: Callable) -&gt; None:\n        \"\"\"\n        Adds an observer to the list of observers.\n        \"\"\"\n        assert callable(observer), 'add_observer: The input data type is not correct. Expected a callable.'\n        self._list_observers.append(observer)\n\n    def remove_observer(self, observer: Callable) -&gt; None:\n        \"\"\"\n        Removes an observer from the list of observers.\n\n        Raises:\n            ValueError: If the observer could not be removed.\n        \"\"\"\n        try: self._list_observers.remove(observer)\n        # except Exception as e: print(f\"Error removing observer: {e}\")\n        except Exception as e: raise ValueError(f\"remove_observer: The observer could not be removed from the unit. Error: {e}\")\n\n    def _notify_observers(self) -&gt; None:\n        \"\"\"\n        Notifies all observers of a change.\n        \"\"\"\n        for observer in self._list_observers:\n            try: observer()\n            except Exception as e: print(f\"Error notifying observer: {e}\")\n\n    def copy(self, flg_newID:bool=True) -&gt; Self: # type: ignore\n        \"\"\"\n        Creates a copy of the current object.\n\n        Args:\n            flg_newID (bool): Flag to indicate if a new ID should be assigned. Default is True.\n\n        Returns:\n            Self: A copy of the current object.\n        \"\"\"\n        if flg_newID: unit_id = uuid.uuid4().hex\n        else: unit_id = self._unit_id\n\n        new_copy = MeaRMap_Unit(unit_name=self._unit_name,unit_id=unit_id)\n        new_copy.set_dict_measurements(deepcopy(self._dict_measurement))\n        new_copy.set_dict_metadata(deepcopy(self._dict_metadata))\n        return new_copy # type: ignore\n\n    def delete_self(self):\n        \"\"\"\n        A protocol to delete the object to remove the allocated memory, in a proper way.\n        \"\"\"\n        # Removing the metadata dictionary\n        self._dict_metadata.clear()\n        self._dict_metadata.clear()\n\n        # Emptying the measurement dictionary lists\n        for key in self._dict_measurement.keys():\n            try: self._dict_measurement[key].clear()\n            except: pass\n        self._dict_measurement.clear()\n        self._dict_measurement_types.clear()\n\n        self._notify_observers()\n\n    def self_report(self):\n        \"\"\"\n        Prints all the attributes of the object\n        \"\"\"\n        print('MappingMeasurement_Unit:')\n        attributes = vars(self)\n        for key in attributes.keys():\n            print(f'{key}: {attributes[key]}')\n        print()\n\n    def test_generate_dummy(self):\n        \"\"\"\n        Generates dummy data for testing purposes\n        \"\"\"\n        for i in range(10):\n            x = float(np.random.rand(1)[0])\n            y = float(np.random.rand(1)[0])\n            z = float(0)\n            timestamp = get_timestamp_us_int() + i\n            mea = MeaRaman(reconstruct=True)\n            mea.test_generate_dummy()\n\n            self.append_ramanmeasurement_data(\n                timestamp=timestamp,\n                coor=(x,y,z),\n                measurement=mea\n            )\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.add_observer","title":"<code>add_observer(observer)</code>","text":"<p>Adds an observer to the list of observers.</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def add_observer(self, observer: Callable) -&gt; None:\n    \"\"\"\n    Adds an observer to the list of observers.\n    \"\"\"\n    assert callable(observer), 'add_observer: The input data type is not correct. Expected a callable.'\n    self._list_observers.append(observer)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.append_dfmeasurement_data","title":"<code>append_dfmeasurement_data(timestamp, coor, measurement_df, list_df=None)</code>","text":"<p>Appends the measurement data into the list of stored measurements.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>timestamp of the measurement</p> required <code>coor</code> <code>tuple</code> <p>coordinates of the measurement</p> required <code>measurement_df</code> <code>DataFrame</code> <p>measurement df to be stored</p> required <code>list_df</code> <code>list</code> <p>list of raw dataframes of the measurement. Defaults to None.</p> <code>None</code> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def append_dfmeasurement_data(self,timestamp:str,coor:tuple[float,float,float],measurement_df:pd.DataFrame,\n                              list_df:list[pd.DataFrame]|None=None):\n    \"\"\"\n    Appends the measurement data into the list of stored measurements.\n\n    Args:\n        timestamp (str): timestamp of the measurement\n        coor (tuple): coordinates of the measurement\n        measurement_df (pd.DataFrame): measurement df to be stored\n        list_df (list): list of raw dataframes of the measurement. Defaults to None.\n    \"\"\"\n    assert isinstance(measurement_df, pd.DataFrame), 'append_measurement_data: The input data type is not correct. Expected a pandas.DataFrame.'\n    assert isinstance(coor, tuple) and len(coor) == 3, 'append_measurement_data: The input coordinate is not correct. Expected a tuple of length 3.'\n    assert all(isinstance(item, (int,float)) for item in coor), 'append_measurement_data: The input coordinate is not correct. Expected a tuple of integers or floats.'\n    assert isinstance(timestamp, str), 'append_measurement_data: The input timestamp is not correct. Expected a string.'\n\n    with self._lock_measurement:\n        if list_df is not None:\n            assert isinstance(list_df, list), 'append_measurement_data: The input list_df is not correct. Expected a list of pandas.DataFrame objects.'\n            assert all(isinstance(item, pd.DataFrame) for item in list_df), 'append_measurement_data: The input list_df is not correct. Expected a list of pandas.DataFrame objects.'\n            self._dict_measurement[self._label_listmea].append(list_df)\n        else:\n            self._dict_measurement[self._label_listmea].append(None)\n        self._dict_measurement[self._label_ts].append(timestamp)\n        self._dict_measurement[self._label_x].append(coor[0])\n        self._dict_measurement[self._label_y].append(coor[1])\n        self._dict_measurement[self._label_z].append(coor[2])\n        self._dict_measurement[self._label_avemea].append(measurement_df)\n\n    self._flg_measurement_exist = True\n\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.append_dict_measurement_data","title":"<code>append_dict_measurement_data(dict_measurement)</code>","text":"<p>Appends the measurement data into the list of stored measurements.</p> <p>Parameters:</p> Name Type Description Default <code>dict_measurement</code> <code>dict</code> <p>dictionary of the measurement data. Has to have the same keys as the stored data.</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def append_dict_measurement_data(self,dict_measurement:dict):\n    \"\"\"\n    Appends the measurement data into the list of stored measurements.\n\n    Args:\n        dict_measurement (dict): dictionary of the measurement data. Has to have the same keys as the stored data.\n    \"\"\"\n    assert isinstance(dict_measurement, dict), 'append_dict_measurement_data: The input data type is not correct. Expected a dictionary.'\n    assert all([key in dict_measurement.keys() for key in self._dict_measurement.keys()]),\\\n        'append_dict_measurement_data: The input dictionary keys are not the same as the stored data keys.'\n\n    for key in dict_measurement.keys():\n        self._dict_measurement[key].append(dict_measurement[key])\n\n    self._flg_measurement_exist = True\n\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.append_ramanmeasurement_data","title":"<code>append_ramanmeasurement_data(timestamp, coor, measurement)</code>","text":"<p>Appends the measurement data into the list of stored measurements.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>timestamp of the measurement</p> required <code>coor</code> <code>tuple</code> <p>coordinates of the measurement</p> required <code>measurement</code> <code>raman_measurement</code> <p>raman measurement data object to be stored</p> required <code>autoupdate</code> <code>bool</code> <p>automatically update the averaged_df based on the current 'list_df'. Defaults to False.</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def append_ramanmeasurement_data(self,timestamp:int,coor:tuple[float,float,float],measurement:MeaRaman):\n    \"\"\"\n    Appends the measurement data into the list of stored measurements.\n\n    Args:\n        timestamp (int): timestamp of the measurement\n        coor (tuple): coordinates of the measurement\n        measurement (raman_measurement): raman measurement data object to be stored\n        autoupdate (bool): automatically update the averaged_df based on the current 'list_df'. Defaults to False.\n    \"\"\"\n    assert isinstance(measurement, MeaRaman), 'append_measurement_data: The input data type is not correct. Expected raman_measurement object.'\n    assert isinstance(coor, (tuple,list)) and len(coor) == 3, 'append_measurement_data: The input coordinate is not correct. Expected a tuple of length 3.'\n    assert all(isinstance(item, (int,float)) for item in coor), 'append_measurement_data: The input coordinate is not correct. Expected a tuple of integers or floats.'\n    assert isinstance(timestamp, int), 'append_measurement_data: The input timestamp is not correct. Expected an integer.'\n    assert measurement.check_measurement_exist(), 'append_measurement_data: The measurement data does not exist.'\n    assert timestamp not in self._dict_measurement[self._label_ts], 'append_measurement_data: The timestamp already exists in the stored data.'\n\n    # Check if the measurement metadata is the same as the stored metadata\n    measurement_metadata = measurement.get_metadata()\n    if not self._flg_metadata_exist: self._set_measurement_metadata(measurement_metadata)\n    elif not all([key in measurement_metadata.keys() for key in self._dict_metadata['measurement_metadata'].keys()]) and \\\n        not all([val == self._dict_metadata['measurement_metadata'][key] for key,val in measurement_metadata.items()]):\n        raise ValueError('append_measurement_data: The measurement metadata does not match the stored metadata.')\n\n    with self._lock_measurement:\n        self._dict_measurement[self._label_ts].append(timestamp)\n        self._dict_measurement[self._label_x].append(coor[0])\n        self._dict_measurement[self._label_y].append(coor[1])\n        self._dict_measurement[self._label_z].append(coor[2])\n        self._dict_measurement[self._label_listmea].append(measurement.get_raw_list())\n        self._dict_measurement[self._label_avemea].append(measurement.get_analysed())\n\n    self._flg_measurement_exist = True\n\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.check_measurement_and_metadata_exist","title":"<code>check_measurement_and_metadata_exist()</code>","text":"<p>Check if the measurement data and metadata exist</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def check_measurement_and_metadata_exist(self):\n    \"\"\"\n    Check if the measurement data and metadata exist\n    \"\"\"\n    # Note: KeyError and AttributeError are bypassed as there are cases where the object (self)\n    # itself have been deleted but the reference to it still remains in other parts of the program\n    # This would typically trigger KeyError as self._dict_measurement becomes empty. An example of\n    # This issue happens with the heatmap plotter when a unit currently being plot is suddenly\n    # deleted in the mappingHub (e.g., through the dataHub gui).\n    try:\n        if len(self._dict_measurement[self._label_ts]) == 0: self._flg_measurement_exist = False\n    except (KeyError, AttributeError): self._flg_measurement_exist = False\n\n    try:\n        if len(self._dict_metadata) == len(self._extra_metadata): self._flg_metadata_exist = False\n    except (KeyError, AttributeError): self._flg_metadata_exist = False\n\n    return self._flg_measurement_exist and self._flg_metadata_exist\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.convert","title":"<code>convert(wavelength=None, Raman_shift=None)</code>","text":"<p>Converts between wavelength and Raman shift by giving EITHER one based on the laser params stored internally.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | None</code> <p>Wavelength to convert. Defaults to None.</p> <code>None</code> <code>Raman_shift</code> <code>float | None</code> <p>Raman shift to convert. Defaults to None.</p> <code>None</code> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def convert(self, wavelength:float|None=None, Raman_shift:float|None=None):\n    \"\"\"\n    Converts between wavelength and Raman shift by giving EITHER one based on\n    the laser params stored internally.\n\n    Args:\n        wavelength (float | None, optional): Wavelength to convert. Defaults to None.\n        Raman_shift (float | None, optional): Raman shift to convert. Defaults to None.\n    \"\"\"\n    if (isinstance(wavelength,(int,float)) and isinstance(Raman_shift,(int,float)))\\\n        or (isinstance(wavelength, type(None)) and isinstance(Raman_shift, type(None))):\n        raise ValueError('convert: Please provide either wavelength or Raman shift, not both or neither.')\n\n    if isinstance(wavelength,(int,float)):\n        return convert_wavelength_to_ramanshift(wavelength,self.get_laser_params()[1])\n    elif isinstance(Raman_shift,(int,float)):\n        return convert_ramanshift_to_wavelength(Raman_shift,self.get_laser_params()[1])\n    else: raise TypeError('Wavelength or Raman shift has to be in integer or float')\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.copy","title":"<code>copy(flg_newID=True)</code>","text":"<p>Creates a copy of the current object.</p> <p>Parameters:</p> Name Type Description Default <code>flg_newID</code> <code>bool</code> <p>Flag to indicate if a new ID should be assigned. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A copy of the current object.</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def copy(self, flg_newID:bool=True) -&gt; Self: # type: ignore\n    \"\"\"\n    Creates a copy of the current object.\n\n    Args:\n        flg_newID (bool): Flag to indicate if a new ID should be assigned. Default is True.\n\n    Returns:\n        Self: A copy of the current object.\n    \"\"\"\n    if flg_newID: unit_id = uuid.uuid4().hex\n    else: unit_id = self._unit_id\n\n    new_copy = MeaRMap_Unit(unit_name=self._unit_name,unit_id=unit_id)\n    new_copy.set_dict_measurements(deepcopy(self._dict_measurement))\n    new_copy.set_dict_metadata(deepcopy(self._dict_metadata))\n    return new_copy # type: ignore\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.delete_self","title":"<code>delete_self()</code>","text":"<p>A protocol to delete the object to remove the allocated memory, in a proper way.</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def delete_self(self):\n    \"\"\"\n    A protocol to delete the object to remove the allocated memory, in a proper way.\n    \"\"\"\n    # Removing the metadata dictionary\n    self._dict_metadata.clear()\n    self._dict_metadata.clear()\n\n    # Emptying the measurement dictionary lists\n    for key in self._dict_measurement.keys():\n        try: self._dict_measurement[key].clear()\n        except: pass\n    self._dict_measurement.clear()\n    self._dict_measurement_types.clear()\n\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.generate_unit_metadata","title":"<code>generate_unit_metadata(unit_id=None, unit_name=None)</code>","text":"<p>Generates a new unit metadata dictionary based on the this unit's metadata but, with a new unit_id and unit_name.</p> <p>Parameters:</p> Name Type Description Default <code>unit_id</code> <code>str | None</code> <p>new unit ID to be used. If None, a new UUID will be generated.</p> <code>None</code> <code>unit_name</code> <code>str | None</code> <p>new unit name to be used. If None, the unit_name will be set to 'unit_name_copy'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>new unit metadata dictionary with a new unit_id and unit_name</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def generate_unit_metadata(self, unit_id:str|None=None, unit_name:str|None=None) -&gt; dict:\n    \"\"\"\n    Generates a new unit metadata dictionary based on the this unit's metadata but,\n    with a new unit_id and unit_name.\n\n    Args:\n        unit_id (str|None): new unit ID to be used. If None, a new UUID will be generated.\n        unit_name (str|None): new unit name to be used. If None, the unit_name will be set to 'unit_name_copy'.\n\n    Returns:\n        dict: new unit metadata dictionary with a new unit_id and unit_name\n    \"\"\"\n    new_unit_metadata = {}\n\n    if unit_id is None: unit_id = uuid.uuid4().hex\n    if unit_name is None: unit_name = f'{self._unit_name}_copy'\n\n    new_unit_metadata[self._unit_id_key] = unit_id\n    new_unit_metadata[self._unit_name_key] = unit_name\n\n    for key in self._dict_metadata.keys():\n        if key not in [self._unit_id_key, self._unit_name_key]:\n            new_unit_metadata[key] = deepcopy(self._dict_metadata[key])\n\n    return new_unit_metadata\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_RamanMeasurement","title":"<code>get_RamanMeasurement(measurement_id)</code>","text":"<p>Retrieves the measurement dataframe from the stored data, reconstruct the RamanMeasurement object, and returns it.</p> <p>Parameters:</p> Name Type Description Default <code>measurement_id</code> <code>int | str</code> <p>timestamp of the measurement in microsec in int or str format</p> required <p>Returns:</p> Name Type Description <code>RamanMeasurement</code> <code>MeaRaman</code> <p>reconstructed RamanMeasurement object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_RamanMeasurement(self,measurement_id:int|str) -&gt; MeaRaman:\n    \"\"\"\n    Retrieves the measurement dataframe from the stored data, reconstruct\n    the RamanMeasurement object, and returns it.\n\n    Args:\n        measurement_id (int|str): timestamp of the measurement in microsec in int or str format\n\n    Returns:\n        RamanMeasurement: reconstructed RamanMeasurement object\n    \"\"\"\n    assert isinstance(measurement_id,(int,str)), 'get_RamanMeasurement: The input data type is not correct. Expected an integer or a string of integer.'\n    if isinstance(measurement_id,str):\n        try: measurement_id = int(float(measurement_id))\n        except: raise ValueError('get_RamanMeasurement: The measurement ID is not an integer.')\n    assert measurement_id in self._dict_measurement[self._mea_id_key],\\\n        'get_RamanMeasurement: The requested measurement does not exist in the stored data.'\n\n    mea_df = self.get_RamanMeasurement_df(measurement_id)\n    mea_metadata = self.get_dict_measurement_metadata()\n    mea = MeaRaman(reconstruct=True)\n    mea.reconstruct(measurement_id=measurement_id,metadata=mea_metadata,spec_analysed=mea_df)\n    return mea\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_RamanMeasurement_df","title":"<code>get_RamanMeasurement_df(measurement_id)</code>","text":"<p>Grabs the averaged dataframe stored</p> <p>Parameters:</p> Name Type Description Default <code>measurement_id</code> <code>int</code> <p>measurement_id of the measurement</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: averaged dataframe of the measurement</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_RamanMeasurement_df(self,measurement_id:int) -&gt; pd.DataFrame:\n    \"\"\"\n    Grabs the averaged dataframe stored\n\n    Args:\n        measurement_id (int): measurement_id of the measurement\n\n    Returns:\n        pd.DataFrame: averaged dataframe of the measurement\n    \"\"\"\n    assert self._flg_measurement_exist, 'get_avg_df: The measurement data does not exist.'\n    assert measurement_id in self._dict_measurement[self._mea_id_key], 'get_avg_df: The timestamp does not exist in the stored data.'\n\n    idx = bisect.bisect_left(self._dict_measurement[self._mea_id_key], measurement_id)\n    df = self._dict_measurement[self._label_avemea][idx]\n\n    return df\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_RamanMeasurement_df_fromIdx","title":"<code>get_RamanMeasurement_df_fromIdx(idx)</code>","text":"<p>Grabs the averaged dataframe stored</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>index of the measurement</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: averaged dataframe of the measurement</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_RamanMeasurement_df_fromIdx(self,idx:int) -&gt; pd.DataFrame:\n    \"\"\"\n    Grabs the averaged dataframe stored\n\n    Args:\n        idx (int): index of the measurement\n\n    Returns:\n        pd.DataFrame: averaged dataframe of the measurement\n    \"\"\"\n    assert self._flg_measurement_exist, 'get_avg_df: The measurement data does not exist.'\n    assert 0&lt;=idx &lt; len(self._dict_measurement[self._label_ts]), 'get_avg_df: The index is out of range.'\n\n    df = self._dict_measurement[self._label_avemea][idx]\n\n    return df\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_closest_raman_shift","title":"<code>get_closest_raman_shift(raman_shift)</code>","text":"<p>Returns the closest Raman shift in the list of Raman shifts stored in the measurement data</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float</code> <p>Raman shift to be retrieved (closest Raman shift will be used)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>closest Raman shift in the list of Raman shifts</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_closest_raman_shift(self,raman_shift:float) -&gt; float:\n    \"\"\"\n    Returns the closest Raman shift in the list of Raman shifts stored in the measurement data\n\n    Args:\n        raman_shift (float): Raman shift to be retrieved (closest Raman shift will be used)\n\n    Returns:\n        float: closest Raman shift in the list of Raman shifts\n    \"\"\"\n    assert self._flg_measurement_exist and self._flg_metadata_exist, 'get_closest_raman_shift: The measurement or metadata does not exist.'\n    assert isinstance(raman_shift, (int, float)), 'get_closest_raman_shift: The input data type is not correct. Expected an integer or a float.'\n    return self.get_list_Raman_shift()[self.get_wavelength_idx(convert_ramanshift_to_wavelength(raman_shift,self.get_laser_params()[1]))]\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_closest_wavelength","title":"<code>get_closest_wavelength(wavelength)</code>","text":"<p>Returns the closest wavelength in the list of wavelengths stored in the measurement data</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>wavelength to be retrieved (closest wavelength will be used)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>closest wavelength in the list of wavelengths</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_closest_wavelength(self,wavelength:float) -&gt; float:\n    \"\"\"\n    Returns the closest wavelength in the list of wavelengths stored in the measurement data\n\n    Args:\n        wavelength (float): wavelength to be retrieved (closest wavelength will be used)\n\n    Returns:\n        float: closest wavelength in the list of wavelengths\n    \"\"\"\n    assert self._flg_measurement_exist, 'get_closest_wavelength: The measurement data does not exist.'\n    assert isinstance(wavelength, (int, float)), 'get_closest_wavelength: The input data type is not correct. Expected an integer or a float.'\n\n    wavelength_idx = self.get_wavelength_idx(wavelength=wavelength)\n    wavelength = self.get_list_wavelengths()[wavelength_idx]\n\n    return wavelength\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_dict_RamanMeasurement_summary","title":"<code>get_dict_RamanMeasurement_summary(measurement_id, exclude_id=False)</code>","text":"<p>Returns the summary of the measurement data stored in the object. Summarises the measurement data based on the measurement_id and returns all the data in a dictionary that is either a string, integer, or float.</p> <p>Parameters:</p> Name Type Description Default <code>measurement_id</code> <code>int | str</code> <p>timestamp of the measurement in microsec in int or str format</p> required <code>exclude_id</code> <code>bool</code> <p>exclude the measurement ID from the summary. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary of the measurement data</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_dict_RamanMeasurement_summary(self,measurement_id:int|str,exclude_id:bool=False) -&gt; dict:\n    \"\"\"\n    Returns the summary of the measurement data stored in the object.\n    Summarises the measurement data based on the measurement_id and returns\n    all the data in a dictionary that is either a string, integer, or float.\n\n    Args:\n        measurement_id (int|str): timestamp of the measurement in microsec in int or str format\n        exclude_id (bool): exclude the measurement ID from the summary. Defaults to False.\n\n    Returns:\n        dict: dictionary of the measurement data\n    \"\"\"\n    if isinstance(measurement_id,str): measurement_id = int(float(measurement_id))\n    assert measurement_id in self._dict_measurement[self._mea_id_key], 'get_summary: The measurement ID does not exist in the stored data.'\n    assert self._flg_measurement_exist, 'get_summary: The measurement data does not exist.'\n    assert isinstance(exclude_id,bool), 'get_summary: The input data type is not correct. Expected a boolean.'\n\n    dict_mea = {}\n    mea_idx = self._dict_measurement[self._mea_id_key].index(measurement_id)\n    for key in self._dict_measurement.keys():\n        item = self._dict_measurement[key][mea_idx]\n        if exclude_id and key == self._mea_id_key: continue\n        if isinstance(item,(str,int,float)):\n            dict_mea[key] = str(item)\n    return dict_mea\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_dict_measurement_metadata","title":"<code>get_dict_measurement_metadata()</code>","text":"<p>Returns the measurement metadata of the object.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>measurement metadata dictionary</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_dict_measurement_metadata(self) -&gt; dict:\n    \"\"\"\n    Returns the measurement metadata of the object.\n\n    Returns:\n        dict: measurement metadata dictionary\n    \"\"\"\n    return self._dict_metadata['measurement_metadata']\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_dict_measurements","title":"<code>get_dict_measurements(copy=False)</code>","text":"<p>Returns the measurement data stored in the object.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary of the measurement data</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_dict_measurements(self, copy:bool=False) -&gt; dict:\n    \"\"\"\n    Returns the measurement data stored in the object.\n\n    Returns:\n        dict: dictionary of the measurement data\n    \"\"\"\n    if copy:\n        with self._lock_measurement:\n            return {key: list(val) for key, val in self._dict_measurement.items()}\n    else:\n        return self._dict_measurement\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_dict_types","title":"<code>get_dict_types()</code>","text":"<p>Returns the dictionary of the data types stored in the class</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[dict, dict]</code> <p>dictionary of the metadata types, dictionary of the measurement types</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_dict_types(self) -&gt; tuple[dict,dict]:\n    \"\"\"\n    Returns the dictionary of the data types stored in the class\n\n    Returns:\n        tuple: dictionary of the metadata types, dictionary of the measurement types\n    \"\"\"\n    return (self._dict_metadata_types, self._dict_measurement_types)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_dict_unit_metadata","title":"<code>get_dict_unit_metadata()</code>","text":"<p>Returns the measurement unit id and metadata of the object.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>measurement unit metadata dictionary</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_dict_unit_metadata(self) -&gt; dict:\n    \"\"\"\n    Returns the measurement unit id and metadata of the object.\n\n    Returns:\n        dict: measurement unit metadata dictionary\n    \"\"\"\n    return self._dict_metadata\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_heatmap_table","title":"<code>get_heatmap_table(wavelength)</code>","text":"<p>Returns a dataframe containing the x, y, z coordinates and the intensity values at the specified wavelength for all measurements.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>Wavelength to extract the intensity values from.</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_heatmap_table(self, wavelength: float) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns a dataframe containing the x, y, z coordinates and the intensity\n    values at the specified wavelength for all measurements.\n\n    Args:\n        wavelength (float): Wavelength to extract the intensity values from.\n    \"\"\"\n    if not self._dict_measurement[self._label_avemea]:\n        return pd.DataFrame()\n\n    # 1. Get metadata needed for indexing (usually safe without lock if immutable)\n    wvl_list = self.get_list_wavelengths() \n    closest_wavelength = wvl_list[np.argmin(np.abs(np.array(wvl_list) - wavelength))]\n\n    # 2. THE SNAPSHOT: Hold lock for microseconds only\n    with self._lock_measurement:\n        # We copy the references to the lists. \n        # The DataFrames themselves aren't copied, just the \"list of pointers\"\n        ave_mea_snapshot = list(self._dict_measurement[self._label_avemea])\n        x_coor = list(self._dict_measurement[self._label_x])\n        y_coor = list(self._dict_measurement[self._label_y])\n        z_coor = list(self._dict_measurement[self._label_z])\n\n    # --- LOCK RELEASED HERE --- \n    # The hardware can now append to the internal lists while we process the snapshot\n\n    # 3. Heavy Extraction (Outside the lock)\n    sample_df = ave_mea_snapshot[-1]\n    wvl_idx = sample_df[self._dflabel_wavelength].tolist().index(closest_wavelength)\n    int_col_idx = sample_df.columns.get_loc(self._dflabel_intensity)\n\n    # This loop takes time, but it doesn't block the hardware anymore!\n    intensities = [df.iat[wvl_idx, int_col_idx] for df in ave_mea_snapshot]\n\n    return pd.DataFrame({\n        self._label_x: x_coor,\n        self._label_y: y_coor,\n        self._label_z: z_coor,\n        self._dflabel_wavelength: closest_wavelength,\n        self._dflabel_intensity: intensities\n    })\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_key_measurementId","title":"<code>get_key_measurementId()</code>","text":"<p>Returns the key storing the id for the Raman measurement stored in the measurement dictionary</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_key_measurementId(self) -&gt; str:\n    \"\"\"\n    Returns the key storing the id for the Raman measurement stored in the measurement dictionary\n    \"\"\"\n    return self._mea_id_key\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_keys_dict_measurement","title":"<code>get_keys_dict_measurement()</code>","text":"<p>Returns the keys for the measurement data stored in the object</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[str, str, str, str, str, str]</code> <p>keys for the timestamp, x, y, z, list_df, and averaged_df</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_keys_dict_measurement(self) -&gt; tuple[str,str,str,str,str,str]:\n    \"\"\"\n    Returns the keys for the measurement data stored in the object\n\n    Returns:\n        tuple: keys for the timestamp, x, y, z, list_df, and averaged_df\n    \"\"\"\n    return (self._mea_id_key,self._label_x,self._label_y,self._label_z,self._label_listmea,self._label_avemea)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_labels","title":"<code>get_labels()</code>","text":"<p>Returns the labels for the x, y, z coordinates, and the wavelength and intensity keys</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>(x_label,y_label,z_label,wavelength_label,intensity_label)</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_labels(self) -&gt; tuple:\n    \"\"\"\n    Returns the labels for the x, y, z coordinates, and the wavelength and intensity keys\n\n    Returns:\n        tuple: (x_label,y_label,z_label,wavelength_label,intensity_label)\n    \"\"\"\n    return (self._label_x,self._label_y,self._label_z,self._dflabel_wavelength,self._dflabel_intensity)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_laser_params","title":"<code>get_laser_params()</code>","text":"<p>Returns the laser wavelength and power metadata</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[float, float]</code> <p>laser power, laser wavelength</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_laser_params(self) -&gt; tuple[float,float]:\n    \"\"\"\n    Returns the laser wavelength and power metadata\n\n    Returns:\n        tuple: laser power, laser wavelength\n    \"\"\"\n    if not self._flg_metadata_exist: raise ValueError('get_laser_metadata: The metadata does not exist.')\n    metadata = self.get_dict_measurement_metadata()\n    power_key,wavelength_key = MeaRaman(reconstruct=True).get_laserMetadata_key()\n    return (metadata[power_key],metadata[wavelength_key])\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_list_RamanMeasurement_ids","title":"<code>get_list_RamanMeasurement_ids()</code>","text":"<p>Returns the list of timestamps stored in the measurement data</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: list of timestamps</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_list_RamanMeasurement_ids(self) -&gt; list[int]:\n    \"\"\"\n    Returns the list of timestamps stored in the measurement data\n\n    Returns:\n        list[int]: list of timestamps\n    \"\"\"\n    return self._dict_measurement[self._label_ts]\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_list_Raman_shift","title":"<code>get_list_Raman_shift()</code>","text":"<p>Returns the list of Raman shifts stored in the measurement data</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[float]</code> <p>list of Raman shifts</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_list_Raman_shift(self) -&gt; list[float]:\n    \"\"\"\n    Returns the list of Raman shifts stored in the measurement data\n\n    Returns:\n        list: list of Raman shifts\n    \"\"\"\n    list_wavelengths = self.get_list_wavelengths()\n    list_raman_shift = [convert_wavelength_to_ramanshift(wavelength=wvl,\\\n        excitation_wavelength=self.get_laser_params()[1]) for wvl in list_wavelengths]\n    return list_raman_shift\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_list_wavelengths","title":"<code>get_list_wavelengths()</code>","text":"<p>Returns the list of wavelengths stored in the measurement data</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[float]</code> <p>list of wavelengths</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_list_wavelengths(self) -&gt; list[float]:\n    \"\"\"\n    Returns the list of wavelengths stored in the measurement data\n\n    Returns:\n        list: list of wavelengths\n    \"\"\"\n    # assert self._flg_measurement_exist, 'get_list_wavelengths: The measurement data does not exist.'\n    if not self._flg_measurement_exist: return []\n\n    with self._lock_measurement:\n        df:pd.DataFrame = self._dict_measurement[self._label_avemea][-1]\n        list_wavelengths = df[self._dflabel_wavelength].tolist()\n        return list_wavelengths\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_measurementId_from_coor","title":"<code>get_measurementId_from_coor(coor)</code>","text":"<p>Retrieves the measurement ID from the coordinates closest to the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coor</code> <code>tuple[float, float]</code> <p>coordinates to retrieve the ID from. (x,y)</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>measurement ID</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_measurementId_from_coor(self, coor:tuple[float,float]) -&gt; str:\n    \"\"\"\n    Retrieves the measurement ID from the coordinates closest to the given coordinates.\n\n    Args:\n        coor (tuple[float,float]): coordinates to retrieve the ID from. (x,y)\n\n    Returns:\n        str: measurement ID\n    \"\"\"\n    assert isinstance(coor,tuple), 'Coordinates should be in a tuple'\n    assert len(coor) == 2, 'Coordinates should be in a tuple of 2 elements'\n    assert all([isinstance(val,(float,int)) for val in coor]), 'Coordinates should be in float or integer'\n\n    list_coor = list(zip(self._dict_measurement[self._label_x],self._dict_measurement[self._label_y]))\n    list_dist = [np.linalg.norm(np.array(coor)-np.array(c)) for c in list_coor]\n    idx_min = np.argmin(list_dist)\n\n    return self._dict_measurement[self._mea_id_key][idx_min]\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_numMeasurements","title":"<code>get_numMeasurements()</code>","text":"<p>Returns the number of measurements stored in the object.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of measurements</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_numMeasurements(self) -&gt; int:\n    \"\"\"\n    Returns the number of measurements stored in the object.\n\n    Returns:\n        int: number of measurements\n    \"\"\"\n    with self._lock_measurement:\n        return len(self._dict_measurement[self._label_ts])\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_raman_shift_idx","title":"<code>get_raman_shift_idx(raman_shift)</code>","text":"<p>Returns the index of the Raman shift in the list of Raman shifts stored in the measurement data</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float</code> <p>Raman shift to be retrieved (closest Raman shift will be used)</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>index of the Raman shift in the list of Raman shifts</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_raman_shift_idx(self,raman_shift:float) -&gt; int:\n    \"\"\"\n    Returns the index of the Raman shift in the list of Raman shifts stored in the measurement data\n\n    Args:\n        raman_shift (float): Raman shift to be retrieved (closest Raman shift will be used)\n\n    Returns:\n        int: index of the Raman shift in the list of Raman shifts\n    \"\"\"\n    assert self._flg_measurement_exist and self._flg_metadata_exist, 'get_raman_shift_idx: The measurement or metadata does not exist.'\n    assert isinstance(raman_shift, (int, float)), 'get_raman_shift_idx: The input data type is not correct. Expected an integer or a float.'\n    wvl = convert_ramanshift_to_wavelength(raman_shift,self.get_laser_params()[1])\n    return self.get_wavelength_idx(wavelength=wvl)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_unit_id","title":"<code>get_unit_id()</code>","text":"<p>Returns the measurement unit id</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>measurement unit id</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_unit_id(self) -&gt; str:\n    \"\"\"\n    Returns the measurement unit id\n\n    Returns:\n        str: measurement unit id\n    \"\"\"\n    return self._unit_id\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_unit_name","title":"<code>get_unit_name()</code>","text":"<p>Returns the measurement unit name</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>measurement unit name</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_unit_name(self) -&gt; str:\n    \"\"\"\n    Returns the measurement unit name\n\n    Returns:\n        str: measurement unit name\n    \"\"\"\n    return self._unit_name\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.get_wavelength_idx","title":"<code>get_wavelength_idx(wavelength)</code>","text":"<p>Returns the index of the wavelength in the list of wavelengths stored in the measurement data</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>wavelength to be retrieved (closest wavelength will be used)</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>index of the wavelength in the list of wavelengths</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def get_wavelength_idx(self,wavelength:float) -&gt; int:\n    \"\"\"\n    Returns the index of the wavelength in the list of wavelengths stored in the measurement data\n\n    Args:\n        wavelength (float): wavelength to be retrieved (closest wavelength will be used)\n\n    Returns:\n        int: index of the wavelength in the list of wavelengths\n    \"\"\"\n    assert self._flg_measurement_exist, 'get_wavelength_idx: The measurement data does not exist.'\n    assert isinstance(wavelength, (int, float)), 'get_wavelength_idx: The input data type is not correct. Expected an integer or a float.'\n\n    def find_nearest(array, value):\n        array = np.asarray(array)\n        idx = np.argmin(np.abs(array - value))\n        return array[idx]\n\n    closest_wavelength = find_nearest(self.get_list_wavelengths(),wavelength)\n\n    df:pd.DataFrame = self._dict_measurement[self._label_avemea][-1]\n    wavelength_idx = df[self._dflabel_wavelength].tolist().index(closest_wavelength)\n\n    return wavelength_idx\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.remove_observer","title":"<code>remove_observer(observer)</code>","text":"<p>Removes an observer from the list of observers.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the observer could not be removed.</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def remove_observer(self, observer: Callable) -&gt; None:\n    \"\"\"\n    Removes an observer from the list of observers.\n\n    Raises:\n        ValueError: If the observer could not be removed.\n    \"\"\"\n    try: self._list_observers.remove(observer)\n    # except Exception as e: print(f\"Error removing observer: {e}\")\n    except Exception as e: raise ValueError(f\"remove_observer: The observer could not be removed from the unit. Error: {e}\")\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.self_report","title":"<code>self_report()</code>","text":"<p>Prints all the attributes of the object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def self_report(self):\n    \"\"\"\n    Prints all the attributes of the object\n    \"\"\"\n    print('MappingMeasurement_Unit:')\n    attributes = vars(self)\n    for key in attributes.keys():\n        print(f'{key}: {attributes[key]}')\n    print()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.set_dict_measurements","title":"<code>set_dict_measurements(dict_measurement)</code>","text":"<p>Sets the measurement data stored in the object.</p> <p>Parameters:</p> Name Type Description Default <code>dict_measurement</code> <code>dict</code> <p>dictionary of the measurement data</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def set_dict_measurements(self,dict_measurement:dict):\n    \"\"\"\n    Sets the measurement data stored in the object.\n\n    Args:\n        dict_measurement (dict): dictionary of the measurement data\n    \"\"\"\n    assert isinstance(dict_measurement, dict), 'set_dict_measurements: The input data type is not correct. Expected a dictionary.'\n    assert all([key in dict_measurement.keys() for key in self._dict_measurement.keys()]),\\\n        'set_dict_measurements: The input dictionary keys are not the same as the stored data keys.'\n\n    self._dict_measurement = dict_measurement\n    self._flg_measurement_exist = True\n\n    if self.check_measurement_and_metadata_exist(): self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.set_dict_metadata","title":"<code>set_dict_metadata(measurementUnit_metadata)</code>","text":"<p>Sets the metadata for the measurement analysis</p> <p>Parameters:</p> Name Type Description Default <code>measurementUnit_metadata</code> <code>dict</code> <p>dictionary of the metadata</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def set_dict_metadata(self,measurementUnit_metadata:dict):\n    \"\"\"\n    Sets the metadata for the measurement analysis\n\n    Args:\n        measurementUnit_metadata (dict): dictionary of the metadata\n    \"\"\"\n    # For compatibility with previous versions\n    if self._unit_name_key not in measurementUnit_metadata.keys() and self._unit_id_key in measurementUnit_metadata.keys():\n        measurementUnit_metadata[self._unit_name_key] = measurementUnit_metadata[self._unit_id_key]\n\n    # Check the input data type\n    assert isinstance(measurementUnit_metadata, dict), 'set_unit_metadata: The input data type is not correct. Expected a dictionary.'\n    assert all([key in measurementUnit_metadata.keys() for key in self._dict_metadata.keys()]),\\\n        'set_unit_metadata: The metadata keys are not the same as the metadata types.'\n\n    self._set_measurement_metadata(measurementUnit_metadata['measurement_metadata'])\n    self._unit_id = measurementUnit_metadata[self._unit_id_key]\n    self._unit_name = measurementUnit_metadata[self._unit_name_key]\n\n    if self.check_measurement_and_metadata_exist(): self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.set_unitName","title":"<code>set_unitName(unit_name)</code>","text":"<p>Sets the measurement unit name</p> <p>Parameters:</p> Name Type Description Default <code>unit_name</code> <code>str</code> <p>measurement unit name</p> required Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def set_unitName(self,unit_name:str):\n    \"\"\"\n    Sets the measurement unit name\n\n    Args:\n        unit_name (str): measurement unit name\n    \"\"\"\n    assert isinstance(unit_name, str), 'set_unit_id: The input data type is not correct. Expected a string.'\n\n    self._unit_name = unit_name\n    self._dict_metadata[self._unit_name_key] = unit_name\n\n    if self.check_measurement_and_metadata_exist(): self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.set_unitName_and_unitID","title":"<code>set_unitName_and_unitID(unit_name, unit_id=None)</code>","text":"<p>Sets the measurement unit name and resets the measurement unit id</p> <p>Parameters:</p> Name Type Description Default <code>unit_name</code> <code>str</code> <p>measurement unit name</p> required <code>unit_id</code> <code>str | None</code> <p>measurement unit id. A new UUID will be generated if None</p> <code>None</code> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def set_unitName_and_unitID(self,unit_name:str, unit_id:str|None=None):\n    \"\"\"\n    Sets the measurement unit name and resets the measurement unit id\n\n    Args:\n        unit_name (str): measurement unit name\n        unit_id (str|None): measurement unit id. A new UUID will be generated if None\n    \"\"\"\n    assert isinstance(unit_name, str), 'set_unit_id: The input data type is not correct. Expected a string.'\n\n    self._unit_name = unit_name\n    self._dict_metadata[self._unit_name_key] = unit_name\n\n    if not isinstance(unit_id, str): unit_id = uuid.uuid4().hex\n    self._unit_id = unit_id\n    self._dict_metadata[self._unit_id_key] = self._unit_id\n\n    if self.check_measurement_and_metadata_exist(): self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.MeaRMap_Unit.test_generate_dummy","title":"<code>test_generate_dummy()</code>","text":"<p>Generates dummy data for testing purposes</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def test_generate_dummy(self):\n    \"\"\"\n    Generates dummy data for testing purposes\n    \"\"\"\n    for i in range(10):\n        x = float(np.random.rand(1)[0])\n        y = float(np.random.rand(1)[0])\n        z = float(0)\n        timestamp = get_timestamp_us_int() + i\n        mea = MeaRaman(reconstruct=True)\n        mea.test_generate_dummy()\n\n        self.append_ramanmeasurement_data(\n            timestamp=timestamp,\n            coor=(x,y,z),\n            measurement=mea\n        )\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.PlotterExtParams_Empty","title":"<code>PlotterExtParams_Empty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlotterExtraParamsBase</code></p> <p>Dataclass for the empty plotter parameters</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>@dataclass\nclass PlotterExtParams_Empty(PlotterExtraParamsBase):\n    \"\"\"\n    Dataclass for the empty plotter parameters\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.PlotterExtParams_Interpolation","title":"<code>PlotterExtParams_Interpolation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlotterExtraParamsBase</code></p> <p>Dataclass for the interpolation plotter parameters</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>@dataclass\nclass PlotterExtParams_Interpolation(PlotterExtraParamsBase):\n    \"\"\"\n    Dataclass for the interpolation plotter parameters\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.PlotterExtParams_Scattering","title":"<code>PlotterExtParams_Scattering</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlotterExtraParamsBase</code></p> <p>Dataclass for the scattering plotter parameters</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>@dataclass\nclass PlotterExtParams_Scattering(PlotterExtraParamsBase):\n    \"\"\"\n    Dataclass for the scattering plotter parameters\n    \"\"\"\n    marker_size:float = 20.0\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.PlotterExtraParamsBase","title":"<code>PlotterExtraParamsBase</code>  <code>dataclass</code>","text":"<p>Base dataclass for the plotter parameters</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>@dataclass\nclass PlotterExtraParamsBase:\n    \"\"\"\n    Base dataclass for the plotter parameters\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.PlotterOptions","title":"<code>PlotterOptions</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum class for the plotter options</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>class PlotterOptions(Enum):\n    \"\"\"\n    Enum class for the plotter options\n    \"\"\"\n    interpolation = 'Triangle interpolation'\n    scattering = 'Scatter plot'\n    empty = 'Empty plot'\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.PlotterParams","title":"<code>PlotterParams</code>  <code>dataclass</code>","text":"<p>Dataclass for the plotter parameters</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>@dataclass\nclass PlotterParams():\n    \"\"\"\n    Dataclass for the plotter parameters\n    \"\"\"\n    mapping_unit:MeaRMap_Unit|None=None\n    wavelength:float|None=None\n    clim:tuple[float|None,float|None]|None=None\n    title = '2D Mapping'\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.generate_dummy_mappingHub","title":"<code>generate_dummy_mappingHub(numx=6, numy=8, repeat=3)</code>","text":"<p>Generates a dummy mapping measurement data for testing purposes.</p> <p>Parameters:</p> Name Type Description Default <code>numx</code> <code>int</code> <p>number of x-coordinates. Defaults to 6.</p> <code>6</code> <code>numy</code> <code>int</code> <p>number of y-coordinates. Defaults to 8.</p> <code>8</code> <code>repeat</code> <code>int</code> <p>number of repeated measurements. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>mapping_measurement_new</code> <code>MeaRMap_Hub</code> <p>mapping_measurement object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def generate_dummy_mappingHub(numx:int=6,numy:int=8,repeat:int=3) -&gt; MeaRMap_Hub:\n    \"\"\"\n    Generates a dummy mapping measurement data for testing purposes.\n\n    Args:\n        numx (int): number of x-coordinates. Defaults to 6.\n        numy (int): number of y-coordinates. Defaults to 8.\n        repeat (int): number of repeated measurements. Defaults to 3.\n\n    Returns:\n        mapping_measurement_new: mapping_measurement object\n    \"\"\"\n    from iris.controllers.raman_spectrometer_controller_dummy import SpectrometerController_Dummy as raman_spectrometer_controller\n    import numpy as np\n\n    spectrometer = raman_spectrometer_controller()\n\n    print('&gt;&gt;&gt;&gt;&gt; Generating the data &lt;&lt;&lt;&lt;&lt;')\n    z = 2\n    listx = list(np.linspace(0,3,numx))\n    listy = list(np.linspace(0,4,numy))\n    storage_unit = MeaRMap_Unit(unit_name='dummy'+get_timestamp_sec())\n    max_len = len(listx)*len(listy)\n    i=0\n    for x in listx:\n        for y in listy:\n            # Generate the measurements\n            mea_single = MeaRaman(timestamp=get_timestamp_us_int(),int_time_ms=10,\n                laserPower_mW=DAEnum.LASER_POWER_MILLIWATT.value,laserWavelength_nm=DAEnum.LASER_WAVELENGTH_NM.value)\n            for _ in range(repeat):\n                df,_,_ = spectrometer.measure_spectrum()\n                mea_single.set_raw_list(df_mea=df,timestamp_int=get_timestamp_us_int())\n\n            mea_single.check_uptodate(autoupdate=True)\n\n            # Assign the measurement to a storage unit\n            coor = (x,y,z)\n            storage_unit.append_ramanmeasurement_data(get_timestamp_us_int(),coor,mea_single)\n            i+=1\n            print('Generating data: {} of {}'.format(i,max_len))\n\n    # Assign the storage unit to the main storage\n    print('&gt;&gt;&gt;&gt;&gt; Assigning the data to the storage &lt;&lt;&lt;&lt;&lt;')\n    storage_main = MeaRMap_Hub()\n    storage_main.append_mapping_unit(storage_unit)\n\n    return storage_main\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.test_mappingHub","title":"<code>test_mappingHub()</code>","text":"<p>Test the MappingMeasurement_Hub class</p> <p>Returns:</p> Name Type Description <code>MappingMeasurement_Hub</code> <p>dummy hub object</p> Source code in <code>iris/data/measurement_RamanMap.py</code> <pre><code>def test_mappingHub():\n    \"\"\"\n    Test the MappingMeasurement_Hub class\n\n    Returns:\n        MappingMeasurement_Hub: dummy hub object\n    \"\"\"\n    dummy_hub = MeaRMap_Hub()\n    dummy_hub.test_generate_dummy()\n    dummy_hub.self_report()\n    return dummy_hub\n</code></pre>"},{"location":"reference/iris/data/measurement_RamanMap/#iris.data.measurement_RamanMap.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/","title":"measurement_coordinates","text":""},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub","title":"<code>List_MeaCoor_Hub</code>","text":"<p>               Bases: <code>list[MeaCoor_mm]</code></p> <p>A list of mapping coordinates dataclass objects.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>class List_MeaCoor_Hub(list[MeaCoor_mm]):\n    \"\"\"\n    A list of mapping coordinates dataclass objects.\n    \"\"\"\n    def __init__(self, *args):\n        super().__init__(*args)\n        self._list_observers:list[Callable] = []\n\n    def validator_new_name(self, new_name:str) -&gt; bool:\n        \"\"\"\n        Checks if a new mapping unit name is valid (i.e., not already in use).\n\n        Args:\n            new_name (str): The new mapping unit name to check.\n\n        Returns:\n            bool: True if the name is valid, False otherwise.\n        \"\"\"\n        if not isinstance(new_name, str): raise TypeError(f\"Expected str, got {type(new_name)}\")\n        for mapcoor in self:\n            if mapcoor.mappingUnit_name == new_name:\n                return False\n        return True\n\n    def add_observer(self, observer:Callable):\n        \"\"\"\n        Adds an observer to the list of observers.\n\n        Args:\n            observer (Callable): The observer to add.\n        \"\"\"\n        if not callable(observer): raise TypeError(f\"Expected Callable, got {type(observer)}\")\n        self._list_observers.append(observer)\n\n    def _notify_observers(self):\n        \"\"\"\n        Notifies all observers in the list of observers.\n        \"\"\"\n        for observer in self._list_observers:\n            try: observer()\n            except Exception as e: print(f\"Error notifying observer {observer}: {e}\")\n\n    def search_mappingCoor(self, mappingUnit_name:str) -&gt; int|None:\n        \"\"\"\n        Searches for a mapping unit in the list of mapping coordinates and returns its index or None if not found.\n\n        Args:\n            mappingUnit_name (str): The name of the mapping unit to search for.\n\n        Returns:\n            int|None: The index of the mapping unit in the list or None if not found.\n        \"\"\"\n        if not isinstance(mappingUnit_name, str): raise TypeError(f\"Expected str, got {type(mappingUnit_name)}\")\n        list_names = [mapcoor.mappingUnit_name for mapcoor in self]\n        idx = None\n        if mappingUnit_name in list_names: idx =  list_names.index(mappingUnit_name)\n        return idx\n\n    def get_mappingCoor(self, mappingUnit_name:str) -&gt; MeaCoor_mm|None:\n        \"\"\"\n        Gets a mapping coordinates object from the list by its mapping unit name.\n\n        Args:\n            mappingUnit_name (str): The name of the mapping unit to get.\n\n        Returns:\n            MappingCoordinates: The mapping coordinates object, or None if not found.\n        \"\"\"\n        if not isinstance(mappingUnit_name, str): raise TypeError(f\"Expected str, got {type(mappingUnit_name)}\")\n        for mapcoor in self:\n            if mapcoor.mappingUnit_name == mappingUnit_name:\n                return mapcoor\n        return None\n\n    def remove_mappingCoor(self, mappingUnit_name:str):\n        \"\"\"\n        Removes a mapping unit from the list of mapping coordinates.\n\n        Args:\n            mappingUnit_name (str): The name of the mapping unit to remove.\n\n        Raises:\n            TypeError: If the mapping unit name is not a string.\n            KeyError: If the mapping unit name is not found in the list.\n        \"\"\"\n        if not isinstance(mappingUnit_name, str): raise TypeError(f\"Expected str, got {type(mappingUnit_name)}\")\n        idx = self.search_mappingCoor(mappingUnit_name)\n        if idx is not None:\n            self.pop(idx)\n            self._notify_observers()\n        else: raise KeyError(f\"Mapping unit {mappingUnit_name} not found in the list\")\n\n    def rename_mappingCoor(self, old_name:str, new_name:str):\n        \"\"\"\n        Renames a mapping unit in the list of mapping coordinates.\n\n        Args:\n            old_name (str): The current name of the mapping unit.\n            new_name (str): The new name for the mapping unit.\n\n        Raises:\n            TypeError: If the old or new name is not a string.\n            KeyError: If the old name is not found in the list.\n            ValueError: If the new name already exists in the list.\n        \"\"\"\n        if not isinstance(old_name, str) or not isinstance(new_name, str): raise TypeError(f\"Expected str, got {type(old_name)} and {type(new_name)}\")\n        idx = self.search_mappingCoor(old_name)\n        if idx is None: raise KeyError(f\"Mapping unit {old_name} not found in the list\")\n        if old_name == new_name: return\n        if self.search_mappingCoor(new_name) is not None: raise ValueError(f\"Mapping unit {new_name} already exists in the list\")\n\n        self[idx].mappingUnit_name = new_name\n        self._notify_observers()\n\n    def append(self, mapCoor:MeaCoor_mm):\n        \"\"\"\n        Appends a mapping coordinates object to the list.\n\n        Args:\n            mapCoor (MappingCoordinates): The mapping coordinates object to append.\n\n        Raises:\n            TypeError: If the object is not an instance of MappingCoordinates.\n            KeyError: If the mapping unit name already exists in the list.\n        \"\"\"\n        if not isinstance(mapCoor, MeaCoor_mm): raise TypeError(f\"Expected MappingCoordinates, got {type(mapCoor)}\")\n        if self.search_mappingCoor(mapCoor.mappingUnit_name) is not None: raise KeyError(f\"Mapping unit {mapCoor.mappingUnit_name} already exists in the list\")\n\n        super().append(mapCoor)\n        self._notify_observers()\n\n    def extend(self, mapCoor:list[MeaCoor_mm], *args, **kwargs):\n        \"\"\"\n        Extends the list with a list of mapping coordinates objects.\n\n        Args:\n            mapCoor (list[MappingCoordinates]): The list of mapping coordinates objects to extend the list with.\n        \"\"\"\n        if not isinstance(mapCoor, list) or not all(isinstance(coor, MeaCoor_mm) for coor in mapCoor):\n            raise TypeError(f\"Expected list of MappingCoordinates, got {type(mapCoor)}\")\n        super().extend(mapCoor)\n        self._notify_observers()\n\n    def pop(self, idx:int, *args, **kwargs) -&gt; MeaCoor_mm:\n        \"\"\"\n        Pops a mapping coordinates object from the list by index.\n\n        Args:\n            idx (int): The index of the mapping coordinates object to pop.\n\n        Returns:\n            MappingCoordinates: The popped mapping coordinates object.\n\n        Raises:\n            IndexError: If the index is out of range.\n        \"\"\"\n        mappingcoor = super().pop(idx)\n        self._notify_observers()\n        return mappingcoor\n\n    def get_list_MappingCoordinates(self,list_unitNames:list[str]) -&gt; list[MeaCoor_mm]:\n        \"\"\"\n        Returns a list of mapping coordinates objects from the list based on the given unit names.\n\n        Args:\n            list_unitNames (list[str]): The list of unit names to search for.\n\n        Returns:\n            list[MappingCoordinates]: The list of mapping coordinates objects that match the given unit names.\n        \"\"\"\n        if not isinstance(list_unitNames, list) or not all(isinstance(name, str) for name in list_unitNames):\n            raise TypeError(f\"Expected list of str, got {type(list_unitNames)}\")\n\n        list_mapCoor = [self[idx] for idx in range(len(self)) if self[idx].mappingUnit_name in list_unitNames]\n        return list_mapCoor\n\n    def generate_dummy_data(self, num_units:int=5, num_coords:int=10):\n        \"\"\"\n        Generates dummy data for testing purposes.\n\n        Args:\n            num_units (int): The number of mapping units to generate. Defaults to 5.\n            num_coords (int): The number of coordinates per mapping unit. Defaults to 10.\n        \"\"\"\n        for i in range(num_units):\n            mappingUnit_name = f\"Unit_{i+1}\"\n            # Randomise the coordinates between 0 and 1 multiplied by a factor\n            multiplier = 10000\n            mapping_coordinates = [(float(random()*multiplier), float(random()*multiplier), float(random()*multiplier)) for _ in range(num_coords)]\n            mapCoor = MeaCoor_mm(mappingUnit_name=mappingUnit_name, mapping_coordinates=mapping_coordinates)\n            self.append(mapCoor)\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.add_observer","title":"<code>add_observer(observer)</code>","text":"<p>Adds an observer to the list of observers.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>The observer to add.</p> required Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def add_observer(self, observer:Callable):\n    \"\"\"\n    Adds an observer to the list of observers.\n\n    Args:\n        observer (Callable): The observer to add.\n    \"\"\"\n    if not callable(observer): raise TypeError(f\"Expected Callable, got {type(observer)}\")\n    self._list_observers.append(observer)\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.append","title":"<code>append(mapCoor)</code>","text":"<p>Appends a mapping coordinates object to the list.</p> <p>Parameters:</p> Name Type Description Default <code>mapCoor</code> <code>MappingCoordinates</code> <p>The mapping coordinates object to append.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the object is not an instance of MappingCoordinates.</p> <code>KeyError</code> <p>If the mapping unit name already exists in the list.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def append(self, mapCoor:MeaCoor_mm):\n    \"\"\"\n    Appends a mapping coordinates object to the list.\n\n    Args:\n        mapCoor (MappingCoordinates): The mapping coordinates object to append.\n\n    Raises:\n        TypeError: If the object is not an instance of MappingCoordinates.\n        KeyError: If the mapping unit name already exists in the list.\n    \"\"\"\n    if not isinstance(mapCoor, MeaCoor_mm): raise TypeError(f\"Expected MappingCoordinates, got {type(mapCoor)}\")\n    if self.search_mappingCoor(mapCoor.mappingUnit_name) is not None: raise KeyError(f\"Mapping unit {mapCoor.mappingUnit_name} already exists in the list\")\n\n    super().append(mapCoor)\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.extend","title":"<code>extend(mapCoor, *args, **kwargs)</code>","text":"<p>Extends the list with a list of mapping coordinates objects.</p> <p>Parameters:</p> Name Type Description Default <code>mapCoor</code> <code>list[MappingCoordinates]</code> <p>The list of mapping coordinates objects to extend the list with.</p> required Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def extend(self, mapCoor:list[MeaCoor_mm], *args, **kwargs):\n    \"\"\"\n    Extends the list with a list of mapping coordinates objects.\n\n    Args:\n        mapCoor (list[MappingCoordinates]): The list of mapping coordinates objects to extend the list with.\n    \"\"\"\n    if not isinstance(mapCoor, list) or not all(isinstance(coor, MeaCoor_mm) for coor in mapCoor):\n        raise TypeError(f\"Expected list of MappingCoordinates, got {type(mapCoor)}\")\n    super().extend(mapCoor)\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.generate_dummy_data","title":"<code>generate_dummy_data(num_units=5, num_coords=10)</code>","text":"<p>Generates dummy data for testing purposes.</p> <p>Parameters:</p> Name Type Description Default <code>num_units</code> <code>int</code> <p>The number of mapping units to generate. Defaults to 5.</p> <code>5</code> <code>num_coords</code> <code>int</code> <p>The number of coordinates per mapping unit. Defaults to 10.</p> <code>10</code> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def generate_dummy_data(self, num_units:int=5, num_coords:int=10):\n    \"\"\"\n    Generates dummy data for testing purposes.\n\n    Args:\n        num_units (int): The number of mapping units to generate. Defaults to 5.\n        num_coords (int): The number of coordinates per mapping unit. Defaults to 10.\n    \"\"\"\n    for i in range(num_units):\n        mappingUnit_name = f\"Unit_{i+1}\"\n        # Randomise the coordinates between 0 and 1 multiplied by a factor\n        multiplier = 10000\n        mapping_coordinates = [(float(random()*multiplier), float(random()*multiplier), float(random()*multiplier)) for _ in range(num_coords)]\n        mapCoor = MeaCoor_mm(mappingUnit_name=mappingUnit_name, mapping_coordinates=mapping_coordinates)\n        self.append(mapCoor)\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.get_list_MappingCoordinates","title":"<code>get_list_MappingCoordinates(list_unitNames)</code>","text":"<p>Returns a list of mapping coordinates objects from the list based on the given unit names.</p> <p>Parameters:</p> Name Type Description Default <code>list_unitNames</code> <code>list[str]</code> <p>The list of unit names to search for.</p> required <p>Returns:</p> Type Description <code>list[MeaCoor_mm]</code> <p>list[MappingCoordinates]: The list of mapping coordinates objects that match the given unit names.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def get_list_MappingCoordinates(self,list_unitNames:list[str]) -&gt; list[MeaCoor_mm]:\n    \"\"\"\n    Returns a list of mapping coordinates objects from the list based on the given unit names.\n\n    Args:\n        list_unitNames (list[str]): The list of unit names to search for.\n\n    Returns:\n        list[MappingCoordinates]: The list of mapping coordinates objects that match the given unit names.\n    \"\"\"\n    if not isinstance(list_unitNames, list) or not all(isinstance(name, str) for name in list_unitNames):\n        raise TypeError(f\"Expected list of str, got {type(list_unitNames)}\")\n\n    list_mapCoor = [self[idx] for idx in range(len(self)) if self[idx].mappingUnit_name in list_unitNames]\n    return list_mapCoor\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.get_mappingCoor","title":"<code>get_mappingCoor(mappingUnit_name)</code>","text":"<p>Gets a mapping coordinates object from the list by its mapping unit name.</p> <p>Parameters:</p> Name Type Description Default <code>mappingUnit_name</code> <code>str</code> <p>The name of the mapping unit to get.</p> required <p>Returns:</p> Name Type Description <code>MappingCoordinates</code> <code>MeaCoor_mm | None</code> <p>The mapping coordinates object, or None if not found.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def get_mappingCoor(self, mappingUnit_name:str) -&gt; MeaCoor_mm|None:\n    \"\"\"\n    Gets a mapping coordinates object from the list by its mapping unit name.\n\n    Args:\n        mappingUnit_name (str): The name of the mapping unit to get.\n\n    Returns:\n        MappingCoordinates: The mapping coordinates object, or None if not found.\n    \"\"\"\n    if not isinstance(mappingUnit_name, str): raise TypeError(f\"Expected str, got {type(mappingUnit_name)}\")\n    for mapcoor in self:\n        if mapcoor.mappingUnit_name == mappingUnit_name:\n            return mapcoor\n    return None\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.pop","title":"<code>pop(idx, *args, **kwargs)</code>","text":"<p>Pops a mapping coordinates object from the list by index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the mapping coordinates object to pop.</p> required <p>Returns:</p> Name Type Description <code>MappingCoordinates</code> <code>MeaCoor_mm</code> <p>The popped mapping coordinates object.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def pop(self, idx:int, *args, **kwargs) -&gt; MeaCoor_mm:\n    \"\"\"\n    Pops a mapping coordinates object from the list by index.\n\n    Args:\n        idx (int): The index of the mapping coordinates object to pop.\n\n    Returns:\n        MappingCoordinates: The popped mapping coordinates object.\n\n    Raises:\n        IndexError: If the index is out of range.\n    \"\"\"\n    mappingcoor = super().pop(idx)\n    self._notify_observers()\n    return mappingcoor\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.remove_mappingCoor","title":"<code>remove_mappingCoor(mappingUnit_name)</code>","text":"<p>Removes a mapping unit from the list of mapping coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>mappingUnit_name</code> <code>str</code> <p>The name of the mapping unit to remove.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the mapping unit name is not a string.</p> <code>KeyError</code> <p>If the mapping unit name is not found in the list.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def remove_mappingCoor(self, mappingUnit_name:str):\n    \"\"\"\n    Removes a mapping unit from the list of mapping coordinates.\n\n    Args:\n        mappingUnit_name (str): The name of the mapping unit to remove.\n\n    Raises:\n        TypeError: If the mapping unit name is not a string.\n        KeyError: If the mapping unit name is not found in the list.\n    \"\"\"\n    if not isinstance(mappingUnit_name, str): raise TypeError(f\"Expected str, got {type(mappingUnit_name)}\")\n    idx = self.search_mappingCoor(mappingUnit_name)\n    if idx is not None:\n        self.pop(idx)\n        self._notify_observers()\n    else: raise KeyError(f\"Mapping unit {mappingUnit_name} not found in the list\")\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.rename_mappingCoor","title":"<code>rename_mappingCoor(old_name, new_name)</code>","text":"<p>Renames a mapping unit in the list of mapping coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>old_name</code> <code>str</code> <p>The current name of the mapping unit.</p> required <code>new_name</code> <code>str</code> <p>The new name for the mapping unit.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the old or new name is not a string.</p> <code>KeyError</code> <p>If the old name is not found in the list.</p> <code>ValueError</code> <p>If the new name already exists in the list.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def rename_mappingCoor(self, old_name:str, new_name:str):\n    \"\"\"\n    Renames a mapping unit in the list of mapping coordinates.\n\n    Args:\n        old_name (str): The current name of the mapping unit.\n        new_name (str): The new name for the mapping unit.\n\n    Raises:\n        TypeError: If the old or new name is not a string.\n        KeyError: If the old name is not found in the list.\n        ValueError: If the new name already exists in the list.\n    \"\"\"\n    if not isinstance(old_name, str) or not isinstance(new_name, str): raise TypeError(f\"Expected str, got {type(old_name)} and {type(new_name)}\")\n    idx = self.search_mappingCoor(old_name)\n    if idx is None: raise KeyError(f\"Mapping unit {old_name} not found in the list\")\n    if old_name == new_name: return\n    if self.search_mappingCoor(new_name) is not None: raise ValueError(f\"Mapping unit {new_name} already exists in the list\")\n\n    self[idx].mappingUnit_name = new_name\n    self._notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.search_mappingCoor","title":"<code>search_mappingCoor(mappingUnit_name)</code>","text":"<p>Searches for a mapping unit in the list of mapping coordinates and returns its index or None if not found.</p> <p>Parameters:</p> Name Type Description Default <code>mappingUnit_name</code> <code>str</code> <p>The name of the mapping unit to search for.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int|None: The index of the mapping unit in the list or None if not found.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def search_mappingCoor(self, mappingUnit_name:str) -&gt; int|None:\n    \"\"\"\n    Searches for a mapping unit in the list of mapping coordinates and returns its index or None if not found.\n\n    Args:\n        mappingUnit_name (str): The name of the mapping unit to search for.\n\n    Returns:\n        int|None: The index of the mapping unit in the list or None if not found.\n    \"\"\"\n    if not isinstance(mappingUnit_name, str): raise TypeError(f\"Expected str, got {type(mappingUnit_name)}\")\n    list_names = [mapcoor.mappingUnit_name for mapcoor in self]\n    idx = None\n    if mappingUnit_name in list_names: idx =  list_names.index(mappingUnit_name)\n    return idx\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.List_MeaCoor_Hub.validator_new_name","title":"<code>validator_new_name(new_name)</code>","text":"<p>Checks if a new mapping unit name is valid (i.e., not already in use).</p> <p>Parameters:</p> Name Type Description Default <code>new_name</code> <code>str</code> <p>The new mapping unit name to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the name is valid, False otherwise.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def validator_new_name(self, new_name:str) -&gt; bool:\n    \"\"\"\n    Checks if a new mapping unit name is valid (i.e., not already in use).\n\n    Args:\n        new_name (str): The new mapping unit name to check.\n\n    Returns:\n        bool: True if the name is valid, False otherwise.\n    \"\"\"\n    if not isinstance(new_name, str): raise TypeError(f\"Expected str, got {type(new_name)}\")\n    for mapcoor in self:\n        if mapcoor.mappingUnit_name == new_name:\n            return False\n    return True\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.MeaCoor_mm","title":"<code>MeaCoor_mm</code>  <code>dataclass</code>","text":"<p>A dataclass to store the mapping coordinates for the mapping measurement.</p> <p>Attributes:</p> Name Type Description <code>mappingUnit_name</code> <code>str</code> <p>str: The name of the mapping unit.</p> <code>mapping_coordinates</code> <code>list[tuple[float, float, float]]</code> <p>list[tuple[float, float, float]]: The coordinates for the mapping measurement.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>@dataclass\nclass MeaCoor_mm:\n    \"\"\"\n    A dataclass to store the mapping coordinates for the mapping measurement.\n\n    Attributes:\n        mappingUnit_name: str: The name of the mapping unit.\n        mapping_coordinates: list[tuple[float, float, float]]: The coordinates for the mapping measurement.\n    \"\"\"\n    mappingUnit_name: str\n    mapping_coordinates: list[tuple[float, float, float]]\n\n    def __init__(self, mappingUnit_name:str|None=None, mapping_coordinates:list[tuple[float, float, float]]|None=None,\n                 loadpath:str|None=None):\n        \"\"\"\n        Initialises the mapping coordinates dataclass.\n\n        Args:\n            mappingUnit_name (str|None): The name of the mapping unit. Defaults to None.\n            mapping_coordinates (list[tuple[float, float, float]]|None): The coordinates for the mapping measurement. Defaults to None.\n            loadpath (str|None): The path to load the coordinates from. Defaults to None.\n        \"\"\"\n        if loadpath is None:\n            if not isinstance(mappingUnit_name, str): raise TypeError(f\"Expected str, got {type(mappingUnit_name)}\")\n            if not isinstance(mapping_coordinates, list) or not all(isinstance(coord, tuple) and len(coord) == 3 for coord in mapping_coordinates):\n                raise TypeError(f\"Expected list of tuples, got {type(mapping_coordinates)}\")\n\n            self.mappingUnit_name = mappingUnit_name\n            self.mapping_coordinates = mapping_coordinates\n        else:\n            assert os.path.exists(loadpath), f\"File {loadpath} does not exist\"\n            if loadpath.endswith('.csv'):\n                self.load_csv(loadpath)\n            elif loadpath.endswith('.pkl'):\n                self.load_pickle(loadpath)\n\n    def save_csv(self, filename:str):\n        \"\"\"\n        Saves the mapping coordinates to a CSV file.\n\n        Args:\n            filename (str): The name of the file to save the coordinates to.\n        \"\"\"\n        if not isinstance(filename, str): raise TypeError(f\"Expected str, got {type(filename)}\")\n        if not filename.endswith('.csv'): filename += '.csv'\n        df = pd.DataFrame(self.mapping_coordinates, columns=['x', 'y', 'z'])\n        df.to_csv(filename, index=False)\n\n    def load_csv(self, filename:str):\n        \"\"\"\n        Loads the mapping coordinates from a CSV file.\n\n        Args:\n            filename (str): The name of the file to load the coordinates from.\n        \"\"\"\n        if not isinstance(filename, str): raise TypeError(f\"Expected str, got {type(filename)}\")\n        if not filename.endswith('.csv'): filename += '.csv'\n        df = pd.read_csv(filename)\n        if df.shape[1] != 3:\n            raise ValueError(f\"CSV file {filename} does not have exactly 3 columns\")\n        self.mapping_coordinates = [tuple(row) for row in df.to_numpy()]\n        self.mappingUnit_name = os.path.splitext(os.path.basename(filename))[0]\n\n    def save_pickle(self, filename:str):\n        \"\"\"\n        Saves the mapping coordinates to a pickle file.\n\n        Args:\n            filename (str): The name of the file to save the coordinates to.\n        \"\"\"\n        if not isinstance(filename, str): raise TypeError(f\"Expected str, got {type(filename)}\")\n        if not filename.endswith('.pkl'): filename += '.pkl'\n        with open(filename, 'wb') as f:\n            pickle.dump(self, f)\n\n    def load_pickle(self, filename:str):\n        \"\"\"\n        Loads the mapping coordinates from a pickle file.\n\n        Args:\n            filename (str): The name of the file to load the coordinates from.\n        \"\"\"\n        with open(filename, 'rb') as f:\n            data:MeaCoor_mm = pickle.load(f)\n            if not isinstance(data, MeaCoor_mm):\n                raise TypeError(f\"Expected MappingCoordinates, got {type(data)}\")\n            if not hasattr(data, 'mappingUnit_name') or not hasattr(data, 'mapping_coordinates'):\n                raise AttributeError(\"MappingCoordinates object does not have the required attributes\")\n            if not isinstance(data.mappingUnit_name, str):\n                raise TypeError(f\"Expected str, got {type(data.mappingUnit_name)}\")\n            if not isinstance(data.mapping_coordinates, list) or not all(isinstance(coord, tuple) and len(coord) == 3 for coord in data.mapping_coordinates):\n                raise TypeError(f\"Expected list of tuples, got {type(data.mapping_coordinates)}\")\n            if not all(isinstance(coord[0], (int, float)) and isinstance(coord[1], (int, float)) and isinstance(coord[2], (int, float)) for coord in data.mapping_coordinates):\n                raise TypeError(f\"Expected tuple of 3 floats, got {type(data.mapping_coordinates[0])}\")\n            self.mappingUnit_name = data.mappingUnit_name\n            self.mapping_coordinates = data.mapping_coordinates\n\n    def copy(self) -&gt; Self:\n        \"\"\"\n        Returns a copy of the mapping coordinates object.\n\n        Returns:\n            MappingCoordinates_mm: A copy of the mapping coordinates object.\n        \"\"\"\n        return MeaCoor_mm(\n            mappingUnit_name=self.mappingUnit_name,\n            mapping_coordinates=self.mapping_coordinates.copy()\n        ) # type: ignore\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.MeaCoor_mm.__init__","title":"<code>__init__(mappingUnit_name=None, mapping_coordinates=None, loadpath=None)</code>","text":"<p>Initialises the mapping coordinates dataclass.</p> <p>Parameters:</p> Name Type Description Default <code>mappingUnit_name</code> <code>str | None</code> <p>The name of the mapping unit. Defaults to None.</p> <code>None</code> <code>mapping_coordinates</code> <code>list[tuple[float, float, float]] | None</code> <p>The coordinates for the mapping measurement. Defaults to None.</p> <code>None</code> <code>loadpath</code> <code>str | None</code> <p>The path to load the coordinates from. Defaults to None.</p> <code>None</code> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def __init__(self, mappingUnit_name:str|None=None, mapping_coordinates:list[tuple[float, float, float]]|None=None,\n             loadpath:str|None=None):\n    \"\"\"\n    Initialises the mapping coordinates dataclass.\n\n    Args:\n        mappingUnit_name (str|None): The name of the mapping unit. Defaults to None.\n        mapping_coordinates (list[tuple[float, float, float]]|None): The coordinates for the mapping measurement. Defaults to None.\n        loadpath (str|None): The path to load the coordinates from. Defaults to None.\n    \"\"\"\n    if loadpath is None:\n        if not isinstance(mappingUnit_name, str): raise TypeError(f\"Expected str, got {type(mappingUnit_name)}\")\n        if not isinstance(mapping_coordinates, list) or not all(isinstance(coord, tuple) and len(coord) == 3 for coord in mapping_coordinates):\n            raise TypeError(f\"Expected list of tuples, got {type(mapping_coordinates)}\")\n\n        self.mappingUnit_name = mappingUnit_name\n        self.mapping_coordinates = mapping_coordinates\n    else:\n        assert os.path.exists(loadpath), f\"File {loadpath} does not exist\"\n        if loadpath.endswith('.csv'):\n            self.load_csv(loadpath)\n        elif loadpath.endswith('.pkl'):\n            self.load_pickle(loadpath)\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.MeaCoor_mm.copy","title":"<code>copy()</code>","text":"<p>Returns a copy of the mapping coordinates object.</p> <p>Returns:</p> Name Type Description <code>MappingCoordinates_mm</code> <code>Self</code> <p>A copy of the mapping coordinates object.</p> Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"\n    Returns a copy of the mapping coordinates object.\n\n    Returns:\n        MappingCoordinates_mm: A copy of the mapping coordinates object.\n    \"\"\"\n    return MeaCoor_mm(\n        mappingUnit_name=self.mappingUnit_name,\n        mapping_coordinates=self.mapping_coordinates.copy()\n    ) # type: ignore\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.MeaCoor_mm.load_csv","title":"<code>load_csv(filename)</code>","text":"<p>Loads the mapping coordinates from a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to load the coordinates from.</p> required Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def load_csv(self, filename:str):\n    \"\"\"\n    Loads the mapping coordinates from a CSV file.\n\n    Args:\n        filename (str): The name of the file to load the coordinates from.\n    \"\"\"\n    if not isinstance(filename, str): raise TypeError(f\"Expected str, got {type(filename)}\")\n    if not filename.endswith('.csv'): filename += '.csv'\n    df = pd.read_csv(filename)\n    if df.shape[1] != 3:\n        raise ValueError(f\"CSV file {filename} does not have exactly 3 columns\")\n    self.mapping_coordinates = [tuple(row) for row in df.to_numpy()]\n    self.mappingUnit_name = os.path.splitext(os.path.basename(filename))[0]\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.MeaCoor_mm.load_pickle","title":"<code>load_pickle(filename)</code>","text":"<p>Loads the mapping coordinates from a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to load the coordinates from.</p> required Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def load_pickle(self, filename:str):\n    \"\"\"\n    Loads the mapping coordinates from a pickle file.\n\n    Args:\n        filename (str): The name of the file to load the coordinates from.\n    \"\"\"\n    with open(filename, 'rb') as f:\n        data:MeaCoor_mm = pickle.load(f)\n        if not isinstance(data, MeaCoor_mm):\n            raise TypeError(f\"Expected MappingCoordinates, got {type(data)}\")\n        if not hasattr(data, 'mappingUnit_name') or not hasattr(data, 'mapping_coordinates'):\n            raise AttributeError(\"MappingCoordinates object does not have the required attributes\")\n        if not isinstance(data.mappingUnit_name, str):\n            raise TypeError(f\"Expected str, got {type(data.mappingUnit_name)}\")\n        if not isinstance(data.mapping_coordinates, list) or not all(isinstance(coord, tuple) and len(coord) == 3 for coord in data.mapping_coordinates):\n            raise TypeError(f\"Expected list of tuples, got {type(data.mapping_coordinates)}\")\n        if not all(isinstance(coord[0], (int, float)) and isinstance(coord[1], (int, float)) and isinstance(coord[2], (int, float)) for coord in data.mapping_coordinates):\n            raise TypeError(f\"Expected tuple of 3 floats, got {type(data.mapping_coordinates[0])}\")\n        self.mappingUnit_name = data.mappingUnit_name\n        self.mapping_coordinates = data.mapping_coordinates\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.MeaCoor_mm.save_csv","title":"<code>save_csv(filename)</code>","text":"<p>Saves the mapping coordinates to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save the coordinates to.</p> required Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def save_csv(self, filename:str):\n    \"\"\"\n    Saves the mapping coordinates to a CSV file.\n\n    Args:\n        filename (str): The name of the file to save the coordinates to.\n    \"\"\"\n    if not isinstance(filename, str): raise TypeError(f\"Expected str, got {type(filename)}\")\n    if not filename.endswith('.csv'): filename += '.csv'\n    df = pd.DataFrame(self.mapping_coordinates, columns=['x', 'y', 'z'])\n    df.to_csv(filename, index=False)\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.MeaCoor_mm.save_pickle","title":"<code>save_pickle(filename)</code>","text":"<p>Saves the mapping coordinates to a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save the coordinates to.</p> required Source code in <code>iris/data/measurement_coordinates.py</code> <pre><code>def save_pickle(self, filename:str):\n    \"\"\"\n    Saves the mapping coordinates to a pickle file.\n\n    Args:\n        filename (str): The name of the file to save the coordinates to.\n    \"\"\"\n    if not isinstance(filename, str): raise TypeError(f\"Expected str, got {type(filename)}\")\n    if not filename.endswith('.pkl'): filename += '.pkl'\n    with open(filename, 'wb') as f:\n        pickle.dump(self, f)\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/data/measurement_coordinates/#iris.data.measurement_coordinates.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/data/measurement_image/","title":"measurement_image","text":"<p>Note: - When developing this class, keep in mind of the following:         - The image frame of reference is different from the stage frame of reference.         - The display is that of the image frame of reference, whereas the coordinates are in the stage frame of reference             i.e., flipping the conversion factor (mm/pixel) will flip the image, but the coordinates will remain the same.</p> <pre><code>- The flip parameter inverses the image frame of reference (flips the positive and negative directions):\n    - This means that when frame 1 has a stage coor of (x1,y1) and frame 2 has a stage coor of (x2,y2),\n        the difference between the two frames is (x2-x1,y2-y1) in the stage frame of reference and this will\n        stay constant regardless of the flip parameter value. The flip parameter, however, will change how the\n        image is displayed on the screen because the difference in the image frame of reference will be\n        (-(xp2-xp1),-(yp2-yp1)) if the flip parameter is True.\n        (where xp is the pixel coordinate = x/scale*flip parameter). This is important for the image stitching\n        and for the overlay of the ROIs (heatmap measurement results) on the image.\n    - Because the flip parameters heavily depends on the way the image is displayed (i.e., if it is flipped\n        from the get-go), the flip parameters are left as a user-defined parameter to be used by other methods/\n        classes that requires it, e.g., the Frm_HeatmapOverlay class.\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Handler","title":"<code>MeaImg_Handler</code>","text":"<p>Handles the saving of image measurements to a database</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>class MeaImg_Handler():\n    \"\"\"\n    Handles the saving of image measurements to a database\n    \"\"\"\n    def __init__(self):\n        # Save parameters\n        self._save_parameters = {\n            'table_label_measurement':'measurement',    # Label for the measurement table\n            'table_label_calibration':'calibration',    # Label for the calibration table\n            'folder_sublevel':'images'    # Sublevel folder to save the data\n        }\n\n        self._new_save_parameters = {\n            'meta_table':'metadata',    # Label for the metadata table in the database\n            'folder_sublevel':'images', # Sublevel folder to save the data\n        }\n\n        self._table_prefix = SaveParamsEnum.IMGUNIT_DB_PREFIX.value    # Prefix for the database tables\n        # self._defaultDirPath = SaveParamsEnum.DEFAULT_SAVE_PATH.value\n        # assert os.path.exists(self._defaultDirPath), 'Default directory path does not exist'\n        # assert os.path.isdir(self._defaultDirPath), 'Default directory path is not a directory'\n\n    # def load_calibration_json_to_ImgMea(self,measurement:ImageMeasurement_Unit)\\\n    #     -&gt; tuple[ImageMeasurement_Unit,str,str]:\n    #     \"\"\"\n    #     Loads the calibration parameters from a JSON file and sets them to the measurement object\n\n    #     Args:\n    #         measurement (image_measurement): Image measurement object which calibration parameters are to be set\n\n    #     Returns:\n    #         tuple[image_measurement,str,str]: Image measurement object, directory path, and name of the JSON\n    #     \"\"\"\n\n    #     print('!!!!! TO BE MODIFIED !!!!!')\n    #     # Modification idea: to load the calibration file into a handler or to return the\n    #     # ImageMeasurement_Calibration obj instead of loading it into an ImageMeasurement_Unit\n    #     # obj\n\n    #     assert isinstance(measurement, ImageMeasurement_Unit), 'Measurement must be an image measurement object'\n\n    #     savepath = filedialog.askopenfilename(title='Choose a JSON file to load the calibration parameters from',\n    #         filetypes=[('JSON files','*.json')])\n    #     assert savepath != '', 'Load path is empty'\n\n    #     cal = ImageMeasurement_Calibration()\n    #     cal.load_calibration_json(savepath)\n\n    #     saveDirPath = os.path.dirname(savepath)\n    #     savename = os.path.basename(savepath)\n\n    #     # Set the calibration parameters to the measurement object\n    #     measurement.set_calibration_ImageMeasurement_Calibration(cal)\n    #     return measurement, saveDirPath, savename\n\n    def save_calibration_json(self,calibration:ImgMea_Cal) -&gt; tuple[str,str]|None:\n        \"\"\"\n        Saves the calibration parameters to a JSON file\n\n        Args:\n            calibration (ImageMeasurement_Calibration): Calibration parameters object to be saved\n\n        Returns:\n            tuple[str,str]|None: Directory path and name of the saved JSON file or None if failed\n        \"\"\"\n        try:\n            assert isinstance(calibration, ImgMea_Cal), 'Calibration must be an ImageMeasurement_Calibration object'\n            assert calibration.check_calibration_set(), 'Calibration parameters are not set'\n\n            # Open a file dialog to choose the savepath\n            savepath = qw.QFileDialog.getSaveFileName(\n                None,\n                'Choose a JSON file to save the calibration parameters to',\n                calibration.id,\n                'JSON files (*.json)'\n            )[0]\n            assert savepath != '', 'Save path is empty'\n\n            if savepath[-5:] != '.json': savepath += '.json'\n            saveDirPath = os.path.dirname(savepath)\n            savename = os.path.basename(savepath)\n\n            ret = (saveDirPath,savename)\n\n            calibration.save_calibration_json(savepath)\n        except Exception as e:\n            print(f'save_calibration_json ERROR: {e}')\n            ret = None\n\n        return ret\n\n\n    def load_calibration_json(self) -&gt; ImgMea_Cal|None:\n        \"\"\"\n        Loads the calibration parameters from a JSON file\n\n        Returns:\n            ImageMeasurement_Calibration: ImageMeasurement_Calibration object\n        \"\"\"\n        cal = None\n        try:\n            savepath = qw.QFileDialog.getOpenFileName(\n                None,\n                'Choose a JSON file to load the calibration parameters from',\n                '',\n                'JSON files (*.json)'\n            )[0]\n            assert savepath != '', 'Load path is empty'\n\n            cal = ImgMea_Cal()\n            cal.load_calibration_json(savepath)\n\n        except Exception as e:\n            print(f'load_calibration_json ERROR: {e}')\n        finally:\n            return cal\n\n    def save_calibration_json_from_ImgMea(self,measurement:MeaImg_Unit,savename:str|None=None):\n        \"\"\"\n        Saves the calibration parameters to a JSON file\n\n        Args:\n            measurement (image_measurement): Image measurement object which calibration parameters are to be saved\n            savename (str): Name of the JSON file. Default is the ID.\n\n        Returns:\n            tuple[str,str]: Directory path and name of the saved JSON file\n        \"\"\"\n        assert isinstance(measurement, MeaImg_Unit), 'Measurement must be an image measurement object'\n        assert measurement.check_calibration_exist(), 'Calibration parameters are not set'\n\n        # Open a file dialog to choose the savepath\n        savepath = qw.QFileDialog.getSaveFileName(\n            None,\n            'Choose a JSON file to save the calibration parameters to',\n            savename if savename is not None else measurement.get_ImageMeasurement_Calibration().id,\n            'JSON files (*.json)'\n        )[0]\n        assert savepath != '', 'Save path is empty'\n\n        if savepath[-5:] != '.json': savepath += '.json'\n        saveDirPath = os.path.dirname(savepath)\n        savename = os.path.basename(savepath)\n\n        # Rename the calibration id to the savename\n        measurement.get_ImageMeasurement_Calibration().id = savename[:-5]   # Remove the '.json' extension\n\n        # Save the calibration parameters to a JSON file\n        _,dict_calibration = measurement.get_calibration_asdict()\n        with open(savepath,'w') as file:\n            json.dump(dict_calibration,file)\n\n        return saveDirPath, savename\n\n    @thread_assign\n    def save_ImageMeasurementHub_database(self,hub:MeaImg_Hub,initdir:str,savename:str) -&gt; threading.Thread:\n        \"\"\"\n        Saves the measurements to a database\n\n        Args:\n            hub (image_measurement_hub): Image measurement hub object to save\n            initdir (str): Path to the directory\n            savename (str): Name of the database\n\n        Returns:\n            threading.Thread: Thread of the saving process\n\n        Raises:\n            AssertionError: Initial directory path does not exist\n            AssertionError: Initial directory path is not a directory\n            AssertionError: Save name is empty\n\n        Note:\n            If the file already exist, it will still connect into the database and try to write into it\n        \"\"\"\n        assert isinstance(hub, MeaImg_Hub), 'Hub must be an image measurement hub object'\n        assert os.path.exists(initdir), 'Initial directory path does not exist'\n        assert os.path.isdir(initdir), 'Initial directory path is not a directory'\n        assert savename != '', 'Save name is empty'\n        if savename[-3:] != '.db': savename += '.db'\n        savepath = os.path.join(initdir,savename)\n\n        # Connect to the database\n        conn = sql.connect(savepath)\n\n        # Save the measurements to a database\n        list_unitIDs = hub.get_list_ImageUnit_ids()\n\n        for unitID in list_unitIDs:\n            unit = hub.get_ImageMeasurementUnit(unit_id=unitID)\n            self.save_ImageMeasurementUnit_database(unit,conn,savepath)\n\n        conn.close()\n\n    def save_ImageMeasurementUnit_database(\\\n        self,unit:MeaImg_Unit,conn:sql.Connection,conn_path:str):\n        \"\"\"\n        Saves the measurements to a database connected.\n\n        Args:\n            unit (ImageMeasurement_Unit): Unit to be saved\n            conn (sql.Connection): Connection to the database\n            conn_path (str): Path to the database\n        \"\"\"\n        self._save_ImageMeasurementUnit_metadata_database(unit,conn)\n        self._save_ImageMeasurementUnit_measurement_database(unit,conn,conn_path)\n\n    def _save_image_to_png(self,saveDirPath:str,image:Image.Image,id) -&gt; str:\n        \"\"\"\n        Saves an image to a PNG file and returns the relative path\n\n        Args:\n            saveDirPath (str): Path to the directory to save the image\n            image (Image.Image): Image to be saved\n        \"\"\"\n        assert isinstance(saveDirPath, str), 'Save directory path must be a string'\n        assert not os.path.exists(saveDirPath) or (os.path.exists(saveDirPath) and os.path.isdir(saveDirPath)),\\\n            'Save directory path is not a directory'\n        assert isinstance(image, Image.Image), 'Image must be an Image.Image object'\n\n        # Save the image to a PNG file\n        subdirpath = os.path.join(saveDirPath,self._save_parameters['folder_sublevel'])\n        if not os.path.exists(subdirpath): os.makedirs(subdirpath)\n        imagepath = os.path.join(subdirpath,'{}.png'.format(id))\n        image.save(imagepath,bitmap_format='png')\n\n        relpath = os.path.relpath(imagepath,saveDirPath)\n        relpath = r'.\\{}'.format(relpath).replace('\\\\','/')\n\n        return relpath\n\n    def _save_ImageMeasurementUnit_measurement_database(\n        self,unit:MeaImg_Unit,conn:sql.Connection,\n        conn_path:str) -&gt; None:\n        \"\"\"\n        Saves the measurements to a database connected\n\n        Args:\n            unit (ImageMeasurement_Unit): Image measurement unit object to save\n            conn (sql.Connection): Connection to the database\n            conn_path (str): Path to the database\n\n        Raises:\n            AssertionError: Unit is not an ImageMeasurement_Unit object\n            AssertionError: The unit does not contain any measurements and/or calibration parameters\n            AssertionError: Connection is not a sqlite3 connection\n        \"\"\"\n        assert isinstance(unit, MeaImg_Unit), 'Unit must be an image measurement unit object'\n        assert unit.check_measurement_exist(), 'Unit does not contain any measurements'\n        assert unit.check_calibration_exist(), 'Unit does not contain any calibration parameters'\n        assert isinstance(conn, sql.Connection), 'Connection must be a sqlite3 connection'\n\n        saveDirPath = os.path.dirname(conn_path)\n\n        unitID,unitName = unit.get_IdName()\n        table_name = self._table_prefix + unitID\n\n    # &gt;&gt;&gt; Image measurement save to database &lt;&lt;&lt;\n        dict_mea = unit.get_dict_measurement()\n        dict_mea_types = unit.get_dict_measurement_types()\n\n        query_keys = ''\n        for key in dict_mea.keys():\n            if dict_mea_types[key] in [int,float]:\n                query_keys += ', {} REAL'.format(key)\n            elif dict_mea_types[key] == str:\n                query_keys += ', {} TEXT'.format(key)\n            elif dict_mea_types[key] in [list,tuple,dict]:\n                query_keys += ', {} TEXT'.format(key)\n            elif dict_mea_types[key] == Image.Image:\n                query_keys += ', {} TEXT'.format(key)\n            else:\n                raise TypeError('Measurement type not recognized')\n\n        query_keys = query_keys[2:]\n\n        conn.execute('CREATE TABLE IF NOT EXISTS {} ({})'\\\n            .format(table_name,query_keys))\n\n        # Insert the measurements into the table\n        keys = list(dict_mea.keys())\n        for i in range(len(dict_mea[keys[0]])):\n            # Generate a unique id\n            unique_id = '{}_{}'.format(unitName,uuid.uuid4().hex)\n            list_values = []\n            for key in dict_mea.keys():\n                if dict_mea_types[key] in [int,float]:\n                    list_values.append(dict_mea[key][i])\n                elif dict_mea_types[key] == str:\n                    list_values.append(dict_mea[key][i])\n                elif dict_mea_types[key] in [list,tuple,dict]:\n                    list_values.append(json.dumps(dict_mea[key][i]))\n                elif dict_mea_types[key] == Image.Image:\n                    image = dict_mea[key][i]\n                    imagepath = self._save_image_to_png(saveDirPath,image,unique_id)\n                    list_values.append(imagepath)\n                else:\n                    raise TypeError('Measurement type not recognized')\n\n            query_values = ', '.join(['?' for _ in range(len(list_values))])\n            conn.execute('INSERT INTO {} VALUES ({})'.format(table_name,query_values),list_values)\n\n        # Commit the changes and close the connection\n        conn.commit()\n        return\n\n    def _save_ImageMeasurementUnit_metadata_database(self,unit:MeaImg_Unit,conn:sql.Connection) -&gt; None:\n        \"\"\"\n        Saves the metadata to a database connected\n\n        Args:\n            unit (ImageMeasurement_Unit): Image measurement unit object to save\n            conn (sql.Connection): Connection to the database\n\n        Raises:\n            AssertionError: Unit is not an ImageMeasurement_Unit object\n            AssertionError: The unit does not contain any metadata\n            AssertionError: Connection is not a sqlite3 connection\n            TypeError: Metadata type not recognized\n        \"\"\"\n        assert isinstance(unit, MeaImg_Unit), 'Unit must be an image measurement unit object'\n        assert unit.check_calibration_exist(), 'Unit does not contain any metadata'\n        assert isinstance(conn, sql.Connection), 'Connection must be a sqlite3 connection'\n\n        cursor = conn.cursor()\n\n        # Retrieve the metadata\n        meta_dict = unit.get_metadata()\n        meta_types_dict = unit.get_metadata_types()\n        table_metadata = self._table_prefix + self._new_save_parameters['meta_table']\n\n        # Create the table for the metadata and calibration parameters\n        query_keys = ''\n        list_values_metadata = []\n        for key in meta_dict.keys():\n            if meta_types_dict[key] in [int,float]:\n                query_keys += ', {} REAL'.format(key)\n                list_values_metadata.append(meta_dict[key])\n            elif meta_types_dict[key] == str:\n                query_keys += ', {} TEXT'.format(key)\n                list_values_metadata.append(meta_dict[key])\n            elif meta_types_dict[key] in [list,tuple,dict]:\n                query_keys += ', {} TEXT'.format(key)\n                list_values_metadata.append(json.dumps(meta_dict[key]))\n            else:\n                raise TypeError('Metadata type not recognized')\n\n        if query_keys == '': raise AssertionError('No metadata found')\n\n        query_keys = query_keys[2:]\n        cursor.execute('CREATE TABLE IF NOT EXISTS {} ({})'.format(table_metadata,query_keys))\n\n        # Prepare the values for insertion\n        query_keys = ', '.join(meta_dict.keys())\n        query_metadata_values = ', '.join(['?' for _ in range(len(meta_dict.keys()))])\n        query = 'INSERT INTO {} ({}) VALUES ({})'.format(table_metadata,query_keys,query_metadata_values)\n        cursor.execute(query, list_values_metadata)\n\n        conn.commit()\n        return\n\n    def load_ImageMeasurementHub_database(self,loadpath:str,hub:MeaImg_Hub|None=None) -&gt; None:\n        \"\"\"\n        Loads the measurements from a database\n\n        Args:\n            loadpath (str): Path to the database\n            hub (ImageMeasurement_Hub|None): Image measurement hub object, if None, a new hub is created.\n                Defaults to None.\n\n        Returns:\n            ImageMeasurement_Hub: Image measurement hub object\n        \"\"\"\n        assert os.path.exists(loadpath), 'Path does not exist'\n        assert loadpath[-3:] == '.db', 'File is not a database'\n\n        # Initialise the ImageMeasurement_Hub\n        if not isinstance(hub, MeaImg_Hub): hub = MeaImg_Hub()\n\n        # Connect to the database\n        conn = sql.connect(loadpath)\n        conn.row_factory = sql.Row\n\n        # Create a cursor object\n        cursor = conn.cursor()\n\n        # Load the measurements from the database\n        table_metadata = self._table_prefix + self._new_save_parameters['meta_table']\n\n        # Select all the rows in the metadata table\n        cursor.execute('SELECT * FROM {}'.format(table_metadata))\n        rows = cursor.fetchall()\n\n        unit = MeaImg_Unit(None,None,reconstruct=True)\n        metadata_types = unit.get_metadata_types()\n        key_dict = [key for key in metadata_types.keys() if metadata_types[key] == dict]\n\n        for row in rows:\n            row:sql.Row\n            dict_row = dict(row)\n            for key in key_dict:\n                dict_row[key] = json.loads(dict_row[key])\n            unit = MeaImg_Unit(None,None,reconstruct=True)\n            unit.set_metadata_fromfile(dict_row)\n            unit = self.load_ImageMeasurementUnit_database(unit,unit.get_IdName()[0],\n                                                           conn=conn,conn_path=loadpath)\n            hub.append_ImageMeasurementUnit(unit)\n\n    def load_ImageMeasurementUnit_database(self,unit:MeaImg_Unit,\n        unit_id:str,conn:sql.Connection,conn_path:str) -&gt; MeaImg_Unit:\n        \"\"\"\n        Loads the measurements from a database connected\n\n        Args:\n            unit (ImageMeasurement_Unit): Image measurement unit object to load\n            unit_id (str): ID of the ImageMeasurement_Unit\n            conn (sql.Connection): Connection to the database\n            conn_path (str): Path to the database\n\n        Returns:\n            ImageMeasurement_Unit: Image measurement unit object\n        \"\"\"\n        assert isinstance(unit, MeaImg_Unit), 'Unit must be an image measurement unit object'\n        assert isinstance(unit_id, str), 'Unit ID must be a string'\n        assert isinstance(conn, sql.Connection), 'Connection must be a sqlite3 connection'\n\n        conn.row_factory = sql.Row\n        cursor = conn.cursor()\n        table_name = self._table_prefix + unit_id\n\n        # Load the measurements from the database\n        cursor.execute('SELECT * FROM {}'.format(table_name))\n        rows = cursor.fetchall()\n\n        dict_types = unit.get_dict_measurement_types()\n        dict_mea = {}\n        for key in dict_types.keys():\n            dict_mea[key] = []\n\n        for row in rows:\n            row:sql.Row\n            dict_row = dict(row)\n\n            for key in dict_types.keys():\n                if dict_types[key] == int:\n                    dict_mea[key].append(int(float(dict_row[key])))\n                elif dict_types[key] == float:\n                    dict_mea[key].append(float(dict_row[key]))\n                elif dict_types[key] == str:\n                    dict_mea[key].append(str(dict_row[key]))\n                elif dict_types[key] in [list,tuple,dict]:\n                    dict_mea[key].append(json.loads(dict_row[key]))\n                elif dict_types[key] == Image.Image:\n                    imagepath = dict_row[key]\n                    imagepath = os.path.join(os.path.dirname(conn_path),imagepath)\n                    image = Image.open(imagepath)\n                    dict_mea[key].append(image)\n                else:\n                    raise TypeError('Measurement type not recognized')\n\n        unit.set_dict_measurement_fromfile(dict_mea)\n\n        return unit\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Handler.load_ImageMeasurementHub_database","title":"<code>load_ImageMeasurementHub_database(loadpath, hub=None)</code>","text":"<p>Loads the measurements from a database</p> <p>Parameters:</p> Name Type Description Default <code>loadpath</code> <code>str</code> <p>Path to the database</p> required <code>hub</code> <code>ImageMeasurement_Hub | None</code> <p>Image measurement hub object, if None, a new hub is created. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ImageMeasurement_Hub</code> <code>None</code> <p>Image measurement hub object</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def load_ImageMeasurementHub_database(self,loadpath:str,hub:MeaImg_Hub|None=None) -&gt; None:\n    \"\"\"\n    Loads the measurements from a database\n\n    Args:\n        loadpath (str): Path to the database\n        hub (ImageMeasurement_Hub|None): Image measurement hub object, if None, a new hub is created.\n            Defaults to None.\n\n    Returns:\n        ImageMeasurement_Hub: Image measurement hub object\n    \"\"\"\n    assert os.path.exists(loadpath), 'Path does not exist'\n    assert loadpath[-3:] == '.db', 'File is not a database'\n\n    # Initialise the ImageMeasurement_Hub\n    if not isinstance(hub, MeaImg_Hub): hub = MeaImg_Hub()\n\n    # Connect to the database\n    conn = sql.connect(loadpath)\n    conn.row_factory = sql.Row\n\n    # Create a cursor object\n    cursor = conn.cursor()\n\n    # Load the measurements from the database\n    table_metadata = self._table_prefix + self._new_save_parameters['meta_table']\n\n    # Select all the rows in the metadata table\n    cursor.execute('SELECT * FROM {}'.format(table_metadata))\n    rows = cursor.fetchall()\n\n    unit = MeaImg_Unit(None,None,reconstruct=True)\n    metadata_types = unit.get_metadata_types()\n    key_dict = [key for key in metadata_types.keys() if metadata_types[key] == dict]\n\n    for row in rows:\n        row:sql.Row\n        dict_row = dict(row)\n        for key in key_dict:\n            dict_row[key] = json.loads(dict_row[key])\n        unit = MeaImg_Unit(None,None,reconstruct=True)\n        unit.set_metadata_fromfile(dict_row)\n        unit = self.load_ImageMeasurementUnit_database(unit,unit.get_IdName()[0],\n                                                       conn=conn,conn_path=loadpath)\n        hub.append_ImageMeasurementUnit(unit)\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Handler.load_ImageMeasurementUnit_database","title":"<code>load_ImageMeasurementUnit_database(unit, unit_id, conn, conn_path)</code>","text":"<p>Loads the measurements from a database connected</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>ImageMeasurement_Unit</code> <p>Image measurement unit object to load</p> required <code>unit_id</code> <code>str</code> <p>ID of the ImageMeasurement_Unit</p> required <code>conn</code> <code>Connection</code> <p>Connection to the database</p> required <code>conn_path</code> <code>str</code> <p>Path to the database</p> required <p>Returns:</p> Name Type Description <code>ImageMeasurement_Unit</code> <code>MeaImg_Unit</code> <p>Image measurement unit object</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def load_ImageMeasurementUnit_database(self,unit:MeaImg_Unit,\n    unit_id:str,conn:sql.Connection,conn_path:str) -&gt; MeaImg_Unit:\n    \"\"\"\n    Loads the measurements from a database connected\n\n    Args:\n        unit (ImageMeasurement_Unit): Image measurement unit object to load\n        unit_id (str): ID of the ImageMeasurement_Unit\n        conn (sql.Connection): Connection to the database\n        conn_path (str): Path to the database\n\n    Returns:\n        ImageMeasurement_Unit: Image measurement unit object\n    \"\"\"\n    assert isinstance(unit, MeaImg_Unit), 'Unit must be an image measurement unit object'\n    assert isinstance(unit_id, str), 'Unit ID must be a string'\n    assert isinstance(conn, sql.Connection), 'Connection must be a sqlite3 connection'\n\n    conn.row_factory = sql.Row\n    cursor = conn.cursor()\n    table_name = self._table_prefix + unit_id\n\n    # Load the measurements from the database\n    cursor.execute('SELECT * FROM {}'.format(table_name))\n    rows = cursor.fetchall()\n\n    dict_types = unit.get_dict_measurement_types()\n    dict_mea = {}\n    for key in dict_types.keys():\n        dict_mea[key] = []\n\n    for row in rows:\n        row:sql.Row\n        dict_row = dict(row)\n\n        for key in dict_types.keys():\n            if dict_types[key] == int:\n                dict_mea[key].append(int(float(dict_row[key])))\n            elif dict_types[key] == float:\n                dict_mea[key].append(float(dict_row[key]))\n            elif dict_types[key] == str:\n                dict_mea[key].append(str(dict_row[key]))\n            elif dict_types[key] in [list,tuple,dict]:\n                dict_mea[key].append(json.loads(dict_row[key]))\n            elif dict_types[key] == Image.Image:\n                imagepath = dict_row[key]\n                imagepath = os.path.join(os.path.dirname(conn_path),imagepath)\n                image = Image.open(imagepath)\n                dict_mea[key].append(image)\n            else:\n                raise TypeError('Measurement type not recognized')\n\n    unit.set_dict_measurement_fromfile(dict_mea)\n\n    return unit\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Handler.load_calibration_json","title":"<code>load_calibration_json()</code>","text":"<p>Loads the calibration parameters from a JSON file</p> <p>Returns:</p> Name Type Description <code>ImageMeasurement_Calibration</code> <code>ImgMea_Cal | None</code> <p>ImageMeasurement_Calibration object</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def load_calibration_json(self) -&gt; ImgMea_Cal|None:\n    \"\"\"\n    Loads the calibration parameters from a JSON file\n\n    Returns:\n        ImageMeasurement_Calibration: ImageMeasurement_Calibration object\n    \"\"\"\n    cal = None\n    try:\n        savepath = qw.QFileDialog.getOpenFileName(\n            None,\n            'Choose a JSON file to load the calibration parameters from',\n            '',\n            'JSON files (*.json)'\n        )[0]\n        assert savepath != '', 'Load path is empty'\n\n        cal = ImgMea_Cal()\n        cal.load_calibration_json(savepath)\n\n    except Exception as e:\n        print(f'load_calibration_json ERROR: {e}')\n    finally:\n        return cal\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Handler.save_ImageMeasurementHub_database","title":"<code>save_ImageMeasurementHub_database(hub, initdir, savename)</code>","text":"<p>Saves the measurements to a database</p> <p>Parameters:</p> Name Type Description Default <code>hub</code> <code>image_measurement_hub</code> <p>Image measurement hub object to save</p> required <code>initdir</code> <code>str</code> <p>Path to the directory</p> required <code>savename</code> <code>str</code> <p>Name of the database</p> required <p>Returns:</p> Type Description <code>Thread</code> <p>threading.Thread: Thread of the saving process</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>Initial directory path does not exist</p> <code>AssertionError</code> <p>Initial directory path is not a directory</p> <code>AssertionError</code> <p>Save name is empty</p> Note <p>If the file already exist, it will still connect into the database and try to write into it</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>@thread_assign\ndef save_ImageMeasurementHub_database(self,hub:MeaImg_Hub,initdir:str,savename:str) -&gt; threading.Thread:\n    \"\"\"\n    Saves the measurements to a database\n\n    Args:\n        hub (image_measurement_hub): Image measurement hub object to save\n        initdir (str): Path to the directory\n        savename (str): Name of the database\n\n    Returns:\n        threading.Thread: Thread of the saving process\n\n    Raises:\n        AssertionError: Initial directory path does not exist\n        AssertionError: Initial directory path is not a directory\n        AssertionError: Save name is empty\n\n    Note:\n        If the file already exist, it will still connect into the database and try to write into it\n    \"\"\"\n    assert isinstance(hub, MeaImg_Hub), 'Hub must be an image measurement hub object'\n    assert os.path.exists(initdir), 'Initial directory path does not exist'\n    assert os.path.isdir(initdir), 'Initial directory path is not a directory'\n    assert savename != '', 'Save name is empty'\n    if savename[-3:] != '.db': savename += '.db'\n    savepath = os.path.join(initdir,savename)\n\n    # Connect to the database\n    conn = sql.connect(savepath)\n\n    # Save the measurements to a database\n    list_unitIDs = hub.get_list_ImageUnit_ids()\n\n    for unitID in list_unitIDs:\n        unit = hub.get_ImageMeasurementUnit(unit_id=unitID)\n        self.save_ImageMeasurementUnit_database(unit,conn,savepath)\n\n    conn.close()\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Handler.save_ImageMeasurementUnit_database","title":"<code>save_ImageMeasurementUnit_database(unit, conn, conn_path)</code>","text":"<p>Saves the measurements to a database connected.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>ImageMeasurement_Unit</code> <p>Unit to be saved</p> required <code>conn</code> <code>Connection</code> <p>Connection to the database</p> required <code>conn_path</code> <code>str</code> <p>Path to the database</p> required Source code in <code>iris/data/measurement_image.py</code> <pre><code>def save_ImageMeasurementUnit_database(\\\n    self,unit:MeaImg_Unit,conn:sql.Connection,conn_path:str):\n    \"\"\"\n    Saves the measurements to a database connected.\n\n    Args:\n        unit (ImageMeasurement_Unit): Unit to be saved\n        conn (sql.Connection): Connection to the database\n        conn_path (str): Path to the database\n    \"\"\"\n    self._save_ImageMeasurementUnit_metadata_database(unit,conn)\n    self._save_ImageMeasurementUnit_measurement_database(unit,conn,conn_path)\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Handler.save_calibration_json","title":"<code>save_calibration_json(calibration)</code>","text":"<p>Saves the calibration parameters to a JSON file</p> <p>Parameters:</p> Name Type Description Default <code>calibration</code> <code>ImageMeasurement_Calibration</code> <p>Calibration parameters object to be saved</p> required <p>Returns:</p> Type Description <code>tuple[str, str] | None</code> <p>tuple[str,str]|None: Directory path and name of the saved JSON file or None if failed</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def save_calibration_json(self,calibration:ImgMea_Cal) -&gt; tuple[str,str]|None:\n    \"\"\"\n    Saves the calibration parameters to a JSON file\n\n    Args:\n        calibration (ImageMeasurement_Calibration): Calibration parameters object to be saved\n\n    Returns:\n        tuple[str,str]|None: Directory path and name of the saved JSON file or None if failed\n    \"\"\"\n    try:\n        assert isinstance(calibration, ImgMea_Cal), 'Calibration must be an ImageMeasurement_Calibration object'\n        assert calibration.check_calibration_set(), 'Calibration parameters are not set'\n\n        # Open a file dialog to choose the savepath\n        savepath = qw.QFileDialog.getSaveFileName(\n            None,\n            'Choose a JSON file to save the calibration parameters to',\n            calibration.id,\n            'JSON files (*.json)'\n        )[0]\n        assert savepath != '', 'Save path is empty'\n\n        if savepath[-5:] != '.json': savepath += '.json'\n        saveDirPath = os.path.dirname(savepath)\n        savename = os.path.basename(savepath)\n\n        ret = (saveDirPath,savename)\n\n        calibration.save_calibration_json(savepath)\n    except Exception as e:\n        print(f'save_calibration_json ERROR: {e}')\n        ret = None\n\n    return ret\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Handler.save_calibration_json_from_ImgMea","title":"<code>save_calibration_json_from_ImgMea(measurement, savename=None)</code>","text":"<p>Saves the calibration parameters to a JSON file</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>image_measurement</code> <p>Image measurement object which calibration parameters are to be saved</p> required <code>savename</code> <code>str</code> <p>Name of the JSON file. Default is the ID.</p> <code>None</code> <p>Returns:</p> Type Description <p>tuple[str,str]: Directory path and name of the saved JSON file</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def save_calibration_json_from_ImgMea(self,measurement:MeaImg_Unit,savename:str|None=None):\n    \"\"\"\n    Saves the calibration parameters to a JSON file\n\n    Args:\n        measurement (image_measurement): Image measurement object which calibration parameters are to be saved\n        savename (str): Name of the JSON file. Default is the ID.\n\n    Returns:\n        tuple[str,str]: Directory path and name of the saved JSON file\n    \"\"\"\n    assert isinstance(measurement, MeaImg_Unit), 'Measurement must be an image measurement object'\n    assert measurement.check_calibration_exist(), 'Calibration parameters are not set'\n\n    # Open a file dialog to choose the savepath\n    savepath = qw.QFileDialog.getSaveFileName(\n        None,\n        'Choose a JSON file to save the calibration parameters to',\n        savename if savename is not None else measurement.get_ImageMeasurement_Calibration().id,\n        'JSON files (*.json)'\n    )[0]\n    assert savepath != '', 'Save path is empty'\n\n    if savepath[-5:] != '.json': savepath += '.json'\n    saveDirPath = os.path.dirname(savepath)\n    savename = os.path.basename(savepath)\n\n    # Rename the calibration id to the savename\n    measurement.get_ImageMeasurement_Calibration().id = savename[:-5]   # Remove the '.json' extension\n\n    # Save the calibration parameters to a JSON file\n    _,dict_calibration = measurement.get_calibration_asdict()\n    with open(savepath,'w') as file:\n        json.dump(dict_calibration,file)\n\n    return saveDirPath, savename\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub","title":"<code>MeaImg_Hub</code>","text":"<p>A hub to store multiple ImageMeasurement_Units generated in a measurement session</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>class MeaImg_Hub():\n    \"\"\"\n    A hub to store multiple ImageMeasurement_Units generated in a measurement session\n    \"\"\"\n    def __init__(self):\n        self._version = 'v2.5.0-2024.11.04' # Version of the ImageMeasurement_Hub\n        self._dict_ImageUnits = {           # Dictionary to store the ImageMeasurement_Units\n            'version': self._version,\n            'unit_id': [],\n            'image_unit': []\n            }\n\n        self._dict_unit_NameID = {}         # Dictionary to store the unit name and ID relation (name:ID)\n        self._dict_unit_IDName = {}         # Dictionary to store the unit ID and name relation (ID:name)\n\n        self._list_observer = []          # List of observers for the hub\n\n    def check_measurement_exist(self) -&gt; bool:\n        \"\"\"\n        Checks if the measurements are stored\n\n        Returns:\n            bool: True if the measurements are stored, False otherwise\n        \"\"\"\n        return len(self._dict_ImageUnits['unit_id']) &gt; 0\n\n    def get_dict_IDtoName(self) -&gt; dict:\n        \"\"\"\n        Returns the dictionary of the unit ID to name\n\n        Returns:\n            dict: Dictionary of the unit ID to name\n        \"\"\"\n        return self._dict_unit_IDName\n\n    def get_dict_nameToID(self) -&gt; dict:\n        \"\"\"\n        Returns the dictionary of the unit name to ID\n\n        Returns:\n            dict: Dictionary of the unit name to ID\n        \"\"\"\n        return self._dict_unit_NameID\n\n    def get_list_ImageUnit_ids(self) -&gt; list[str]:\n        \"\"\"\n        Returns the list of the ImageMeasurement_Unit IDs\n\n        Returns:\n            list[str]: List of the ImageMeasurement_Unit IDs\n        \"\"\"\n        return self._dict_ImageUnits['unit_id']\n\n    def get_list_ImageUnit_names(self) -&gt; list[str]:\n        \"\"\"\n        Returns the list of the ImageMeasurement_Unit names\n\n        Returns:\n            list[str]: List of the ImageMeasurement_Unit names\n        \"\"\"\n        return list(self._dict_unit_IDName.values())\n\n    def get_summary_units(self) -&gt; tuple[list,list,list,list]:\n        \"\"\"\n        Returns the summary of the ImageMeasurement_Units\n\n        Returns:\n            tuple: list of unit IDs, list of unit names,\n                list of number of measurements in the unit,\n                list of metadata dictionaries\n        \"\"\"\n        list_units:list[MeaImg_Unit] = self._dict_ImageUnits['image_unit']\n\n        list_ids = self._dict_ImageUnits['unit_id']\n        list_names = [self._dict_unit_IDName[id] for id in list_ids]\n        list_numMeasurements = [unit.get_numMeasurements() for unit in list_units]\n        list_metadata = [unit.get_metadata(incl_nameid=False) for unit in list_units]\n\n        return list_ids, list_names, list_numMeasurements, list_metadata\n\n    def append_ImageMeasurementUnit(self,unit:MeaImg_Unit) -&gt; None:\n        \"\"\"\n        Appends an ImageMeasurement_Unit to the hub\n\n        Args:\n            unit (ImageMeasurement_Unit): ImageMeasurement_Unit object to be appended\n        \"\"\"\n        assert isinstance(unit, MeaImg_Unit), 'Unit must be an ImageMeasurement_Unit object'\n        assert unit.get_IdName()[0] not in self._dict_unit_IDName, 'Unit ID already exists'\n        assert unit.get_IdName()[1] not in self._dict_unit_NameID, 'Unit name already exists'\n\n        self._dict_ImageUnits['unit_id'].append(unit.get_IdName()[0])\n        self._dict_ImageUnits['image_unit'].append(unit)\n\n        unitId,unitName = unit.get_IdName()\n        self._dict_unit_NameID[unitName] = unitId\n        self._dict_unit_IDName[unitId] = unitName\n\n        self.notify_observers()\n\n    def reset_ImageMeasurementUnits(self) -&gt; None:\n        \"\"\"\n        Resets the ImageMeasurement_Units in the hub\n        \"\"\"\n        self._dict_ImageUnits['unit_id'].clear()\n        self._dict_ImageUnits['image_unit'].clear()\n        self._dict_unit_NameID.clear()\n        self._dict_unit_IDName.clear()\n\n        self.notify_observers()\n\n    def remove_ImageMeasurementUnit(self,unit_id:str) -&gt; None:\n        \"\"\"\n        Removes an ImageMeasurement_Unit from the hub\n\n        Args:\n            unit_id (str): ID of the ImageMeasurement_Unit to be removed\n        \"\"\"\n        assert unit_id in self._dict_ImageUnits['unit_id'], 'Unit ID does not exist'\n\n        idx = self._dict_ImageUnits['unit_id'].index(unit_id)\n        self._dict_ImageUnits['unit_id'].pop(idx)\n        self._dict_ImageUnits['image_unit'].pop(idx)\n\n        unit_name = self._dict_unit_IDName[unit_id]\n        self._dict_unit_NameID.pop(unit_name)\n        self._dict_unit_IDName.pop(unit_id)\n\n        self.notify_observers()\n\n    def get_ImageMeasurementUnit(self,*,unit_id:str|None=None,unit_name:str|None=None) -&gt; MeaImg_Unit:\n        \"\"\"\n        Returns an ImageMeasurement_Unit from the hub\n\n        Args:\n            unit_id (str): ID of the ImageMeasurement_Unit\n\n        Returns:\n            ImageMeasurement_Unit: ImageMeasurement_Unit object\n        \"\"\"\n        assert (unit_id is not None) or (unit_name is not None), 'Either unit ID or unit name must be provided'\n        assert not (unit_id is not None and unit_name is not None), 'Only one of unit ID or unit name must be provided'\n\n        # Get the unit ID from the unit name if provided\n        if unit_name is not None:\n            assert unit_name in self._dict_unit_NameID, 'Unit name does not exist'\n            unit_id = self._dict_unit_NameID[unit_name]\n\n        assert unit_id in self._dict_ImageUnits['unit_id'], 'Unit ID does not exist'\n\n        idx = self._dict_ImageUnits['unit_id'].index(unit_id)\n        return self._dict_ImageUnits['image_unit'][idx]\n\n    def add_observer(self,observer:Callable) -&gt; None:\n        \"\"\"\n        Adds an observer to the hub\n\n        Args:\n            observer (Callable): Observer function to be added\n        \"\"\"\n        if not isinstance(observer, Callable): raise ValueError('Observer must be a callable function')\n        self._list_observer.append(observer)\n\n    def remove_observer(self,observer:Callable) -&gt; None:\n        \"\"\"\n        Removes an observer from the hub\n\n        Args:\n            observer (Callable): Observer function to be removed\n        \"\"\"\n        if not isinstance(observer, Callable): raise ValueError('Observer must be a callable function')\n        if not observer in self._list_observer: raise ValueError('Observer does not exist in the list')\n        self._list_observer.remove(observer)\n\n    def notify_observers(self) -&gt; None:\n        \"\"\"\n        Notifies all observers of an event\n        \"\"\"\n        for observer in self._list_observer:\n            try: observer()\n            except Exception as e: print(f'Observer notification error: {e}')\n\n    def test_generate_dummy(self):\n        \"\"\"\n        Generates dummy ImageMeasurement_Units for testing purposes\n        \"\"\"\n        cal = ImgMea_Cal()\n        cal.generate_dummy_params()\n        for i in range(5):\n            unit = MeaImg_Unit(reconstruct=True)\n            unit.test_generate_dummy()\n            unit.set_name(f'unit_{i}')\n            unit.set_calibration_ImageMeasurement_Calibration(cal)\n            self.append_ImageMeasurementUnit(unit)\n        return\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.add_observer","title":"<code>add_observer(observer)</code>","text":"<p>Adds an observer to the hub</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>Observer function to be added</p> required Source code in <code>iris/data/measurement_image.py</code> <pre><code>def add_observer(self,observer:Callable) -&gt; None:\n    \"\"\"\n    Adds an observer to the hub\n\n    Args:\n        observer (Callable): Observer function to be added\n    \"\"\"\n    if not isinstance(observer, Callable): raise ValueError('Observer must be a callable function')\n    self._list_observer.append(observer)\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.append_ImageMeasurementUnit","title":"<code>append_ImageMeasurementUnit(unit)</code>","text":"<p>Appends an ImageMeasurement_Unit to the hub</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>ImageMeasurement_Unit</code> <p>ImageMeasurement_Unit object to be appended</p> required Source code in <code>iris/data/measurement_image.py</code> <pre><code>def append_ImageMeasurementUnit(self,unit:MeaImg_Unit) -&gt; None:\n    \"\"\"\n    Appends an ImageMeasurement_Unit to the hub\n\n    Args:\n        unit (ImageMeasurement_Unit): ImageMeasurement_Unit object to be appended\n    \"\"\"\n    assert isinstance(unit, MeaImg_Unit), 'Unit must be an ImageMeasurement_Unit object'\n    assert unit.get_IdName()[0] not in self._dict_unit_IDName, 'Unit ID already exists'\n    assert unit.get_IdName()[1] not in self._dict_unit_NameID, 'Unit name already exists'\n\n    self._dict_ImageUnits['unit_id'].append(unit.get_IdName()[0])\n    self._dict_ImageUnits['image_unit'].append(unit)\n\n    unitId,unitName = unit.get_IdName()\n    self._dict_unit_NameID[unitName] = unitId\n    self._dict_unit_IDName[unitId] = unitName\n\n    self.notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.check_measurement_exist","title":"<code>check_measurement_exist()</code>","text":"<p>Checks if the measurements are stored</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the measurements are stored, False otherwise</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def check_measurement_exist(self) -&gt; bool:\n    \"\"\"\n    Checks if the measurements are stored\n\n    Returns:\n        bool: True if the measurements are stored, False otherwise\n    \"\"\"\n    return len(self._dict_ImageUnits['unit_id']) &gt; 0\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.get_ImageMeasurementUnit","title":"<code>get_ImageMeasurementUnit(*, unit_id=None, unit_name=None)</code>","text":"<p>Returns an ImageMeasurement_Unit from the hub</p> <p>Parameters:</p> Name Type Description Default <code>unit_id</code> <code>str</code> <p>ID of the ImageMeasurement_Unit</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ImageMeasurement_Unit</code> <code>MeaImg_Unit</code> <p>ImageMeasurement_Unit object</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_ImageMeasurementUnit(self,*,unit_id:str|None=None,unit_name:str|None=None) -&gt; MeaImg_Unit:\n    \"\"\"\n    Returns an ImageMeasurement_Unit from the hub\n\n    Args:\n        unit_id (str): ID of the ImageMeasurement_Unit\n\n    Returns:\n        ImageMeasurement_Unit: ImageMeasurement_Unit object\n    \"\"\"\n    assert (unit_id is not None) or (unit_name is not None), 'Either unit ID or unit name must be provided'\n    assert not (unit_id is not None and unit_name is not None), 'Only one of unit ID or unit name must be provided'\n\n    # Get the unit ID from the unit name if provided\n    if unit_name is not None:\n        assert unit_name in self._dict_unit_NameID, 'Unit name does not exist'\n        unit_id = self._dict_unit_NameID[unit_name]\n\n    assert unit_id in self._dict_ImageUnits['unit_id'], 'Unit ID does not exist'\n\n    idx = self._dict_ImageUnits['unit_id'].index(unit_id)\n    return self._dict_ImageUnits['image_unit'][idx]\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.get_dict_IDtoName","title":"<code>get_dict_IDtoName()</code>","text":"<p>Returns the dictionary of the unit ID to name</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the unit ID to name</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_dict_IDtoName(self) -&gt; dict:\n    \"\"\"\n    Returns the dictionary of the unit ID to name\n\n    Returns:\n        dict: Dictionary of the unit ID to name\n    \"\"\"\n    return self._dict_unit_IDName\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.get_dict_nameToID","title":"<code>get_dict_nameToID()</code>","text":"<p>Returns the dictionary of the unit name to ID</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the unit name to ID</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_dict_nameToID(self) -&gt; dict:\n    \"\"\"\n    Returns the dictionary of the unit name to ID\n\n    Returns:\n        dict: Dictionary of the unit name to ID\n    \"\"\"\n    return self._dict_unit_NameID\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.get_list_ImageUnit_ids","title":"<code>get_list_ImageUnit_ids()</code>","text":"<p>Returns the list of the ImageMeasurement_Unit IDs</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of the ImageMeasurement_Unit IDs</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_list_ImageUnit_ids(self) -&gt; list[str]:\n    \"\"\"\n    Returns the list of the ImageMeasurement_Unit IDs\n\n    Returns:\n        list[str]: List of the ImageMeasurement_Unit IDs\n    \"\"\"\n    return self._dict_ImageUnits['unit_id']\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.get_list_ImageUnit_names","title":"<code>get_list_ImageUnit_names()</code>","text":"<p>Returns the list of the ImageMeasurement_Unit names</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of the ImageMeasurement_Unit names</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_list_ImageUnit_names(self) -&gt; list[str]:\n    \"\"\"\n    Returns the list of the ImageMeasurement_Unit names\n\n    Returns:\n        list[str]: List of the ImageMeasurement_Unit names\n    \"\"\"\n    return list(self._dict_unit_IDName.values())\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.get_summary_units","title":"<code>get_summary_units()</code>","text":"<p>Returns the summary of the ImageMeasurement_Units</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[list, list, list, list]</code> <p>list of unit IDs, list of unit names, list of number of measurements in the unit, list of metadata dictionaries</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_summary_units(self) -&gt; tuple[list,list,list,list]:\n    \"\"\"\n    Returns the summary of the ImageMeasurement_Units\n\n    Returns:\n        tuple: list of unit IDs, list of unit names,\n            list of number of measurements in the unit,\n            list of metadata dictionaries\n    \"\"\"\n    list_units:list[MeaImg_Unit] = self._dict_ImageUnits['image_unit']\n\n    list_ids = self._dict_ImageUnits['unit_id']\n    list_names = [self._dict_unit_IDName[id] for id in list_ids]\n    list_numMeasurements = [unit.get_numMeasurements() for unit in list_units]\n    list_metadata = [unit.get_metadata(incl_nameid=False) for unit in list_units]\n\n    return list_ids, list_names, list_numMeasurements, list_metadata\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.notify_observers","title":"<code>notify_observers()</code>","text":"<p>Notifies all observers of an event</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def notify_observers(self) -&gt; None:\n    \"\"\"\n    Notifies all observers of an event\n    \"\"\"\n    for observer in self._list_observer:\n        try: observer()\n        except Exception as e: print(f'Observer notification error: {e}')\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.remove_ImageMeasurementUnit","title":"<code>remove_ImageMeasurementUnit(unit_id)</code>","text":"<p>Removes an ImageMeasurement_Unit from the hub</p> <p>Parameters:</p> Name Type Description Default <code>unit_id</code> <code>str</code> <p>ID of the ImageMeasurement_Unit to be removed</p> required Source code in <code>iris/data/measurement_image.py</code> <pre><code>def remove_ImageMeasurementUnit(self,unit_id:str) -&gt; None:\n    \"\"\"\n    Removes an ImageMeasurement_Unit from the hub\n\n    Args:\n        unit_id (str): ID of the ImageMeasurement_Unit to be removed\n    \"\"\"\n    assert unit_id in self._dict_ImageUnits['unit_id'], 'Unit ID does not exist'\n\n    idx = self._dict_ImageUnits['unit_id'].index(unit_id)\n    self._dict_ImageUnits['unit_id'].pop(idx)\n    self._dict_ImageUnits['image_unit'].pop(idx)\n\n    unit_name = self._dict_unit_IDName[unit_id]\n    self._dict_unit_NameID.pop(unit_name)\n    self._dict_unit_IDName.pop(unit_id)\n\n    self.notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.remove_observer","title":"<code>remove_observer(observer)</code>","text":"<p>Removes an observer from the hub</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>Observer function to be removed</p> required Source code in <code>iris/data/measurement_image.py</code> <pre><code>def remove_observer(self,observer:Callable) -&gt; None:\n    \"\"\"\n    Removes an observer from the hub\n\n    Args:\n        observer (Callable): Observer function to be removed\n    \"\"\"\n    if not isinstance(observer, Callable): raise ValueError('Observer must be a callable function')\n    if not observer in self._list_observer: raise ValueError('Observer does not exist in the list')\n    self._list_observer.remove(observer)\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.reset_ImageMeasurementUnits","title":"<code>reset_ImageMeasurementUnits()</code>","text":"<p>Resets the ImageMeasurement_Units in the hub</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def reset_ImageMeasurementUnits(self) -&gt; None:\n    \"\"\"\n    Resets the ImageMeasurement_Units in the hub\n    \"\"\"\n    self._dict_ImageUnits['unit_id'].clear()\n    self._dict_ImageUnits['image_unit'].clear()\n    self._dict_unit_NameID.clear()\n    self._dict_unit_IDName.clear()\n\n    self.notify_observers()\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Hub.test_generate_dummy","title":"<code>test_generate_dummy()</code>","text":"<p>Generates dummy ImageMeasurement_Units for testing purposes</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def test_generate_dummy(self):\n    \"\"\"\n    Generates dummy ImageMeasurement_Units for testing purposes\n    \"\"\"\n    cal = ImgMea_Cal()\n    cal.generate_dummy_params()\n    for i in range(5):\n        unit = MeaImg_Unit(reconstruct=True)\n        unit.test_generate_dummy()\n        unit.set_name(f'unit_{i}')\n        unit.set_calibration_ImageMeasurement_Calibration(cal)\n        self.append_ImageMeasurementUnit(unit)\n    return\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit","title":"<code>MeaImg_Unit</code>","text":"Handles the storage of image measurements for the ROI definition <ol> <li>Timestamp</li> <li>Stage coordinates (when the image was taken)</li> <li>Image</li> <li>Calibration parameters (mm/pixel, laser coordinate offset)</li> </ol> Source code in <code>iris/data/measurement_image.py</code> <pre><code>class MeaImg_Unit():\n    \"\"\"\n    Handles the storage of image measurements for the ROI definition:\n        1. Timestamp\n        2. Stage coordinates (when the image was taken)\n        3. Image\n        4. Calibration parameters (mm/pixel, laser coordinate offset)\n\n    \"\"\"\n    def __init__(self,unit_name:str|None=None,calibration:ImgMea_Cal|None=None,\n                 reconstruct:bool=False):\n        \"\"\"\n        Initialises the image measurement class\n\n        Args:\n            unit_name (str|None): Name of the image measurement unit. Default is None\n            calibration (ImageMeasurement_Calibration): Calibration parameters\n            reconstruct (bool): Flag to skip all the checks, used for reconstruction from\n                the local disk. Default is False\n\n        Note:\n            If the unit_name or unit_id is None, the timestamp will be used as the unit name and unit ID\n        \"\"\"\n        if not reconstruct:\n            assert isinstance(calibration, ImgMea_Cal), 'Calibration must be an ImageMeasurement_Calibration object'\n            assert calibration.check_calibration_set(), 'Calibration parameters are not set'\n\n        self._unitName:str = unit_name if unit_name != None else get_timestamp_us_str()\n        self._unitID:str = uuid.uuid4().hex\n        self._calibration:ImgMea_Cal|None = calibration\n\n        self._list_metadata_keys = ['id','name','calibration_id','calibration_dict']\n\n        # Stitched image parameters\n        self._flg_mat_calculated:bool = False    # Flag to check if the rotation correction matrix is calculated\n        self._mat_stitch2ori:np.ndarray = np.eye(2)    # Rotation matrix to convert pixel coordinates from the stitched image to the original image\n        self._mat_ori2stitch:np.ndarray = np.eye(2)    # Rotation matrix to convert pixel coordinates from the original image to the stitched image\n        self._lres_scale:float = ImageProcessingParamsEnum.LOW_RESOLUTION_SCALE.value    # Low resolution scale for the images\n\n        # Dictionary to store the measurements\n        self._dict_measurements = {\n            'timestamp':[],\n            'coor_x':[],\n            'coor_y':[],\n            'coor_z':[],\n            'image':[],\n        }\n\n        self._dict_measurements_types = {\n            'timestamp':str,\n            'coor_x':float,\n            'coor_y':float,\n            'coor_z':float,\n            'image':Image.Image,\n        }\n\n        self._list_lowResImg = []   # List to store the low resolution images\n\n        assert set(self._dict_measurements.keys()) == set(self._dict_measurements_types.keys()), 'Measurement keys must match the measurement types'\n\n        self._metadata_types = {\n            'id':str,\n            'name':str,\n            'calibration_id':str,\n            'calibration_dict':dict,\n        }\n\n        self._idname_keys = ['id','name']   # Keys for the ID and name to access the metadata\n\n        if reconstruct: self._metadata = {}\n        else:\n            assert isinstance(self._calibration, ImgMea_Cal), 'Calibration must be an ImageMeasurement_Calibration object'\n            self._metadata = {\n                'id':self._unitID,\n                'name':self._unitName,\n                'calibration_id':self._calibration.id,\n                'calibration_dict':self._calibration.get_calibration_asdict()\n            }\n            assert set(self._metadata.keys()) == set(self._metadata_types.keys()), 'Metadata keys must match the metadata types'\n\n    def set_name(self,unit_name:str) -&gt; None:\n        \"\"\"\n        Sets the name of the ImageMeasurement_Unit\n\n        Args:\n            unit_name (str): Name of the ImageMeasurement_Unit\n        \"\"\"\n        assert isinstance(unit_name,str), 'Name must be a string'\n        self._unitName = unit_name\n        self._metadata['name'] = unit_name\n\n    def get_dict_measurement_types(self) -&gt; dict:\n        \"\"\"\n        Returns the measurements dictionary types\n\n        Returns:\n            dict: Measurements dictionary types\n        \"\"\"\n        return self._dict_measurements_types\n\n    def get_dict_measurement(self) -&gt; dict:\n        \"\"\"\n        Returns the measurements dictionary for saving to local disk\n\n        Returns:\n            dict: Measurements dictionary\n        \"\"\"\n        return self._dict_measurements\n\n    def get_IdName(self) -&gt; tuple[str,str]:\n        \"\"\"\n        Returns the unit ID and name\n\n        Returns:\n            tuple[str,str]: Unit ID, Unit name\n        \"\"\"\n        return self._unitID, self._unitName\n\n    def get_numMeasurements(self) -&gt; int:\n        \"\"\"\n        Returns the number of measurements taken\n\n        Returns:\n            int: Number of measurements taken\n        \"\"\"\n        return len(self._dict_measurements['timestamp'])\n\n    def set_metadata_fromfile(self,dict_meta:dict) -&gt; None:\n        \"\"\"\n        Sets the unit attributes based on the given metadata dictionary\n\n        Args:\n            dict_meta (dict): Metadata dictionary\n        \"\"\"\n        assert all([key in dict_meta.keys() for key in set(self._metadata.keys())]), 'Metadata keys must match the metadata types'\n\n        self._unitID = dict_meta['id']\n        self._unitName = dict_meta['name']\n\n        cal = ImgMea_Cal()\n        cal.set_calibration_fromdict(dict_meta['calibration_id'],dict_meta['calibration_dict'])\n\n        self._calibration = cal\n        self._flg_mat_calculated = False\n\n        self.refresh_metadata()\n\n    def refresh_metadata(self):\n        \"\"\"\n        Resets the metadata using the internally stored values\n        \"\"\"\n        if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n        self._metadata = {\n            'id':self._unitID,\n            'name':self._unitName,\n            'calibration_id':self._calibration.id,\n            'calibration_dict':self._calibration.get_calibration_asdict()\n        }\n\n    def get_metadata_types(self) -&gt; dict:\n        \"\"\"\n        Returns the metadata types\n\n        Returns:\n            dict: Metadata types\n        \"\"\"\n        return self._metadata_types\n\n    def get_metadata(self, incl_nameid:bool=True) -&gt; dict:\n        \"\"\"\n        Returns the metadata of the ImageMeasurement_Unit\n\n        Args:\n            incl_nameid (bool): Include the name and ID in the metadata. Default is True\n\n        Returns:\n            dict: Metadata of the ImageMeasurement_Unit (id, name, calibration_id, calibration_dict)\n        \"\"\"\n        if incl_nameid: return self._metadata\n        else: return {key:self._metadata[key] for key in self._metadata.keys() if key not in self._idname_keys}\n\n    def get_ImageMeasurement_Calibration(self) -&gt; ImgMea_Cal:\n        \"\"\"\n        Returns the ImageMeasurement_Calibration object for the calibration parameters\n        \"\"\"\n        if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n        return self._calibration\n\n    def _calculate_RotationCorrectionMatrix(self) -&gt; None:\n        \"\"\"\n        Calculates the rotation correction matrix for the image stitching\n        \"\"\"\n        assert self.check_calibration_exist(), 'Calibration parameters are not set'\n        if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n\n        rot_rad = self._calibration.rotation_rad\n\n        # Rotate the points counter to the detected rotation angle to align the\n        # image frame of reference with the stage frame of reference\n        self._mat_ori2stitch = np.array([[np.cos(-rot_rad),-np.sin(-rot_rad)],\n                                         [np.sin(-rot_rad),np.cos(-rot_rad)]])\n\n\n        # Rotate the points clockwise to the detected rotation angle to align the\n        # stage frame of reference with the image frame of reference (inverse the\n        # rotation transformation above)\n        self._mat_stitch2ori = np.array([[np.cos(rot_rad),-np.sin(rot_rad)],\n                                         [np.sin(rot_rad),np.cos(rot_rad)]])\n\n        self._flg_mat_calculated = True\n\n\n    def _correctRotationFlip(self,coor_pixel:tuple[int,int],stitch2ori:bool) -&gt; tuple[int,int]:\n        \"\"\"\n        Corrects the rotation of the pixel coordinates due to the image stitching\n\n        Args:\n            coor_pixel (tuple[int,int]): Pixel coordinates (x,y)\n            stitch2ori (bool): Flag to correct the rotation from the stitched image to the original image\n\n        Returns:\n            tuple[int,int]: Corrected pixel coordinates\n        \"\"\"\n        if not self._flg_mat_calculated: self._calculate_RotationCorrectionMatrix()\n\n        if stitch2ori:\n            coor_pixel_arr = self._mat_stitch2ori @ np.array(coor_pixel).reshape(2,1)\n            return coor_pixel_arr.flatten().astype(int).tolist() # pyright: ignore[reportReturnType]\n        else:\n            coor_pixel_arr = self._mat_ori2stitch @ np.array(coor_pixel).reshape(2,1)\n            return coor_pixel_arr.flatten().astype(int).tolist() # pyright: ignore[reportReturnType]\n\n    def get_image_all_stitched(self, low_res:bool=False) -&gt; tuple[Image.Image,tuple[float,float],tuple[float,float]]:\n        \"\"\"\n        Stitches all the images taken\n\n        Args:\n            low_res (bool): Flag to use the low resolution images. Default is False\n\n        Returns:\n            tuple[Image.Image,tuple[float,float],tuple[float,float]]:\n                Stitched image, image min limits in mm (xmin,ymin) [mm],\n                image max limits in mm (xmax,ymax) [mm]\n\n        NOTE:\n            - Note that the shown image is rotated according to the calibration parameters.\n                i.e., the image shown is now aligned with the stage frame of reference's axes\n                such that another coordinate rotation correction needs to be done when converting\n                the coordinats between the image and the stage frame of reference. For this reason,\n                the rotation angle is stored internally.\n        \"\"\"\n        assert len(self._dict_measurements['timestamp']) &gt; 0, 'No images taken'\n        assert self.check_calibration_exist(), 'Calibration parameters are not set'\n        assert isinstance(self._calibration, ImgMea_Cal), 'Calibration is not set'\n\n        cal = self._calibration\n\n    # &gt; Get the measurements\n        if low_res: list_images = self._list_lowResImg\n        else: list_images = self._dict_measurements['image']\n\n        list_coorx_mm = self._dict_measurements['coor_x']\n        list_coory_mm = self._dict_measurements['coor_y']\n\n        # Calculate the rotation angle\n        # print(f'Stored rotation angle [rad]: {cal.rotation_rad}')\n        rot_deg = -cal.rotation_rad*180/np.pi\n        # print(f'Operation rotation angle [deg]: {rot_deg}')\n\n    # &gt; Calculate the crop and the coordinate shift because of the cropping\n        sizex,sizey = list_images[0].size\n        cropx_pixel = abs(int(sizey*np.sin(cal.rotation_rad)))\n        cropy_pixel = abs(int(sizex*np.sin(cal.rotation_rad)))\n        # print(f'Crop size [pixel]: {cropx_pixel,cropy_pixel}')\n\n        # Ensure that the angle is within -180 to 180 degrees\n        while True:\n            if rot_deg &gt; 180: rot_deg -= 360\n            elif rot_deg &lt; -180: rot_deg += 360\n            else: break\n\n        if rot_deg &gt; 0:\n            crop_coor = (0,cropy_pixel,sizex-cropx_pixel,sizey)\n            coor_shift_pixel = (cropx_pixel,0)\n        elif rot_deg &lt; 0:\n            crop_coor = (cropx_pixel,0,sizex,sizey-cropy_pixel)\n            coor_shift_pixel = (0,cropy_pixel)\n        else:\n            crop_coor = (0,0,sizex,sizey)\n            coor_shift_pixel = (0,0)\n\n        coor_shift_stage = self.convert_imgpt2stg(frame_coor_mm=(0,0),\\\n            coor_pixel=coor_shift_pixel,correct_rot=True,low_res=low_res)\n\n        list_coorx_mm = [coor+coor_shift_stage[0] for coor in list_coorx_mm]\n        list_coory_mm = [coor+coor_shift_stage[1] for coor in list_coory_mm]\n\n    # &gt; Rotate and crop the images\n        list_images_converted = []\n        for img in list_images:\n            img_rot_crop:Image.Image = img.copy()\n            img_rot_crop = img_rot_crop.rotate(-rot_deg,expand=False,center=(0,0)) if rot_deg != 0 else img_rot_crop\n            img_rot_crop = img_rot_crop.crop(crop_coor)\n            list_images_converted.append(img_rot_crop)\n\n        list_images = list_images_converted\n\n    # &gt; Stitch the image\n        # Calculate each image location in the stitched image (in pixel coordinates)\n        list_coor_mm = [(coorx_mm,coory_mm) for coorx_mm,coory_mm in zip(list_coorx_mm,list_coory_mm)]\n        list_coor_min_mm = list_coor_mm\n\n        # Flip the coordinates based on the calibration parameters\n        # rot_rad = cal.rotation_rad\n        # flip_rot_x = np.sign(np.cos(rot_rad))\n        # flip_rot_x = 1 if flip_rot_x == 0 else flip_rot_x\n        # flip_rot_y = np.sign(np.sin(rot_rad))\n        # flip_rot_y = 1 if flip_rot_y == 0 else flip_rot_y\n\n        # x_flip = np.sign(cal.scale_x_pixelPerMm*flip_rot_x*-1).astype(int)\n        # y_flip = np.sign(cal.scale_y_pixelPerMm*cal.flip_y*flip_rot_y*-1).astype(int)\n        x_flip = -1\n        y_flip = -1\n        assert x_flip !=0 and y_flip != 0, 'CHECK ERROR: Flip parameters cannot be 0, there must be something unaccounted for'\n\n        list_coor_min_pixel = [self.convert_stg2imgpt(coor_stage_mm=coor,coor_point_mm=(0,0),correct_rot=True,low_res=low_res)\\\n            for coor in list_coor_mm]\n        list_coor_min_pixel = [(coor[0]*x_flip,coor[1]*y_flip) for coor in list_coor_min_pixel]\n\n        img_limit_coor_min_pixel = (min([coor[0] for coor in list_coor_min_pixel]),\\\n            min([coor[1] for coor in list_coor_min_pixel]))\n\n        # Calculate the relative pixel coordinates\n        list_coor_pixel_rel = [(\n            coor[0]-img_limit_coor_min_pixel[0],\\\n            coor[1]-img_limit_coor_min_pixel[1]\n            ) for coor in list_coor_min_pixel]\n\n        # Generate an empty image \n        img_wid = max([abs(coor[0]) for coor in list_coor_pixel_rel]) + img_rot_crop.size[0]\n        img_hei = max([abs(coor[1]) for coor in list_coor_pixel_rel]) + img_rot_crop.size[1]\n        img_stitched = Image.new('RGB',(img_wid,img_hei))\n\n        # Paste the images onto the empty image\n        for i in range(len(list_images)):\n            img = list_images[i]\n            coor_pixel = list_coor_pixel_rel[i]\n            img_stitched.paste(img,coor_pixel)\n\n    # &gt; Calculate the image limits in mm\n        # Note to myself:\n        # The limit is not the minimum coordinates of the image but the coordinate of the 0,0 pixel\n        # of the stitched image in the stage frame of reference\n        # This can be calculated by converting the pixel coordinates of the one of the image \n        # in the list_coor_pixel_rel\n\n        # This minimum coordinate is also the reference coordinate to be returned (i.e., the stage coordinate\n        # of the stitched image, corresponding to the 0,0 pixel of the stitched image)\n\n        # Similarly, the maximum coordinates of the image is the maximum coordinates of the img_rot_crop\n        # i.e., the image shape\n\n        mea_coor = list_coor_min_mm[0]\n        mea_coor_pixel = list_coor_pixel_rel[0]\n        neg = (-mea_coor_pixel[0],-mea_coor_pixel[1])\n        img_limit_coor_min_mm = self.convert_imgpt2stg(frame_coor_mm=mea_coor,coor_pixel=neg,correct_rot=True,\n                                                       low_res=low_res)\n        img_limit_coor_max_mm = self.convert_imgpt2stg(frame_coor_mm=img_limit_coor_min_mm,coor_pixel=(img_wid,img_hei),\n                                                       correct_rot=True,low_res=low_res)\n\n        return img_stitched, img_limit_coor_min_mm, img_limit_coor_max_mm\n\n    def reset_measurement(self):\n        \"\"\"\n        Deletes all stored measurement in the _dict_measurements\n        \"\"\"\n        for key in self._dict_measurements.keys():\n            self._dict_measurements[key].clear()\n\n    def reprocess_lowres_images(self):\n        \"\"\"\n        Reprocesses the low resolution images to be used for the stitching using the original images\n        \"\"\"\n        self._list_lowResImg.clear()\n\n        for img in self._dict_measurements['image']:\n            img_lres = img.copy()\n            img_lres.thumbnail((int(img.size[0]*self._lres_scale),int(img.size[1]*self._lres_scale)))\n            self._list_lowResImg.append(img_lres)\n\n    def set_dict_measurement_fromfile(self,dict_measurements:dict) -&gt; None:\n        \"\"\"\n        Sets the measurements from a dictionary\n\n        Args:\n            dict_measurements (dict): Measurements dictionary\n        \"\"\"\n        assert set(dict_measurements.keys()) == set(self._dict_measurements.keys()), 'Measurement keys must match the measurement types'\n        assert all([isinstance(dict_measurements[key], list) for key in dict_measurements.keys()]), 'Measurement values must be lists'\n        assert all([all([isinstance(val, self._dict_measurements_types[key]) for val in dict_measurements[key]]) for key in dict_measurements.keys()]), 'Measurement values must match the measurement types'\n\n        self._dict_measurements.clear()\n        for key in dict_measurements.keys():\n            self._dict_measurements[key] = dict_measurements[key]\n\n        self.reprocess_lowres_images()\n\n    def add_measurement(self, timestamp:str, x_coor:float, y_coor:float,\n                        z_coor:float, image:Image.Image):\n        \"\"\"\n        Adds a measurement to the dictionary\n\n        Args:\n            timestamp (str): Timestamp of the measurement\n            x_coor (float): X-coordinate of the measurement\n            y_coor (float): Y-coordinate of the measurement\n            z_coor (float): Z-coordinate of the measurement\n            image (Image.Image): Image of the measurement\n        \"\"\"\n        assert isinstance(timestamp, str), 'Timestamp must be a string'\n        assert isinstance(x_coor, float), 'X-coordinate must be a float'\n        assert isinstance(y_coor, float), 'Y-coordinate must be a float'\n        assert isinstance(z_coor, float), 'Z-coordinate must be a float'\n        assert isinstance(image, Image.Image), 'Image must be an Image.Image object'\n\n        # Add the parameters to the dictionary\n        self._dict_measurements['timestamp'].append(timestamp)\n        self._dict_measurements['coor_x'].append(x_coor)\n        self._dict_measurements['coor_y'].append(y_coor)\n        self._dict_measurements['coor_z'].append(z_coor)\n        self._dict_measurements['image'].append(image)\n\n        # Generate the low resolution image and store it\n        image_lres = image.copy()\n        image_lres.thumbnail((int(image.size[0]*self._lres_scale),int(image.size[1]*self._lres_scale)))\n        self._list_lowResImg.append(image_lres)\n\n    def check_readyForProcessing(self):\n        \"\"\"\n        Checks if the image measurement is ready for processing. Checks for:\n            1. If the measurements exist\n            2. If the calibration parameters exist\n            3. If the low resolution images have been generated for all the images taken\n\n        Returns:\n            bool: True if the image measurement is ready for processing, False otherwise\n        \"\"\"\n        flg = True\n        if not self.check_measurement_exist(): flg = False\n        if not self.check_calibration_exist(): flg = False\n        if not len(self._dict_measurements['image']) == len(self._list_lowResImg): flg = False\n        return flg\n\n    def check_measurement_exist(self) -&gt; bool:\n        \"\"\"\n        Checks if the measurements are stored\n\n        Returns:\n            bool: True if the measurements are stored, False otherwise\n        \"\"\"\n        return len(self._dict_measurements['timestamp']) &gt; 0\n\n    def check_calibration_exist(self) -&gt; bool:\n        \"\"\"\n        Checks if the calibration parameters are set\n\n        Returns:\n            bool: True if the calibration parameters are set, False otherwise\n        \"\"\"\n        if not isinstance(self._calibration, ImgMea_Cal): return False\n        return self._calibration.check_calibration_set()\n\n    def convert_imgpt2stg(self, frame_coor_mm:tuple[float,float]|tuple[float,float,float],\n                          coor_pixel:tuple[int,int]|tuple[float,float],\n                          correct_rot:bool, low_res:bool)\\\n        -&gt; tuple[float,float]:\n        \"\"\"\n        Converts the coordinates from pixels to mm based on the stored calibration parameters\n\n        Args:\n            frame_coor_mm (tuple[float,float]): X, Y, Z coordinates or X, Y coordinates in mm of the image frame\n            coor_pixel (tuple[int,int]): X, Y coordinates in pixels\n            correct_rot (bool): Correct for the rotation angle if the shown stitched image is rotated corrected\n            low_res (bool): Set to True if the image being processed is a low resolution (i.e., downsampled) image of the original image.\n\n        Returns:\n            tuple[float,float]: X and Y coordinates in mm\n        \"\"\"\n        if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n\n        if low_res: coor_pixel = (int(coor_pixel[0]/self._lres_scale),int(coor_pixel[1]/self._lres_scale))\n\n        if correct_rot:\n            coor_pixel = (int(coor_pixel[0]),int(coor_pixel[1]))\n            coor_pixel = self._correctRotationFlip(coor_pixel,stitch2ori=True)\n\n        coor_stg_mm = self._calibration.convert_imgpt2stg(\n            coor_img_pixel=np.array(coor_pixel[:2]),\n            coor_stage_mm=np.array(frame_coor_mm[:2])\n        )\n\n        x_mm,y_mm = coor_stg_mm.tolist()\n        return x_mm, y_mm\n\n    def convert_stg2imgpt(self, coor_stage_mm:tuple[float,float,float]|tuple[float,float],\n            coor_point_mm:tuple[float,float,float]|tuple[float,float],correct_rot:bool,low_res:bool) -&gt; tuple[int,int]:\n        \"\"\"\n        Converts the coordinates from mm to pixels based on the stored calibration parameters\n\n        Args:\n            stage_coor_mm (tuple[float,float,float]): X, Y, Z coordinates or X, Y coordinates in mm of the image frame\n            coor_mm (tuple[float,float,float]): X, Y, Z coordinates or X, Y coordinates in mm\n            rot_rad (float): Rotation angle in radians to correct for. Default is 0.0\n            correct_rot (bool): Correct for the rotation angle if the shown stitched image is rotated corrected\n            low_res (bool): Set to True if the image being processed is a low resolution (i.e., downsampled) image of the original image.\n\n        Returns:\n            tuple[int,int]: X and Y coordinates in pixels\n\n        NOTE:\n            - The rotation angle is to correct for the rotation applied of the shown image\n                from the 'get stitched image' method\n            - The rotation angle is in radians and is counter clockwise\n        \"\"\"\n        if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n\n        coor_pixel = self._calibration.convert_stg2imgpt(\n            coor_point_mm=np.array(coor_point_mm[:2]),\n            coor_stg_mm=np.array(coor_stage_mm[:2])\n        )\n\n        if correct_rot:\n            coor_pixel = (int(coor_pixel[0]),int(coor_pixel[1]))\n            coor_pixel = self._correctRotationFlip(coor_pixel,stitch2ori=False)\n\n        x_pixel,y_pixel = [int(coor) for coor in coor_pixel]\n\n        if low_res:\n            x_pixel = int(x_pixel*self._lres_scale)\n            y_pixel = int(y_pixel*self._lres_scale)\n\n        return x_pixel, y_pixel\n\n    def convert_stg2mea(self, coor_stage_mm:tuple[float,float,float]|tuple[float,float])\\\n        -&gt; tuple[float,float,float]|tuple[float,float]:\n        \"\"\"\n        Calculates the measurement coordinates from the stage coordinates based on the laser coordinates\n        stored in the calibration parameters\n\n        Args:\n            stage_coor (tuple[float,float,float]|tuple[float,float]): Stage coordinates (X,Y,Z) in mm or (X,Y) in mm\n\n        Returns:\n            tuple[float,float,float]|tuple[float,float]: Measurement coordinates (X,Y,Z) in mm or (X,Y) in mm\n        \"\"\"\n        if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n\n        coor_stage_mm_arr = np.array(coor_stage_mm[:2])\n        coor_mea_mm = self._calibration.convert_stg2mea(coor_stage_mm_arr)\n\n        x_mm,y_mm = coor_mea_mm.tolist()\n\n        if len(coor_stage_mm) == 2: return x_mm, y_mm\n        if len(coor_stage_mm) &gt;= 2: return x_mm, y_mm, coor_stage_mm[2]\n\n    def convert_mea2stg(self, coor_mea_mm:tuple[float,float,float]|tuple[float,float])\\\n        -&gt; tuple[float,float,float]|tuple[float,float]:\n        \"\"\"\n        Calculates the stage coordinates from the measurement coordinates based on the laser coordinates\n        stored in the calibration parameters\n\n        Args:\n            coor_mea_mm (tuple[float,float,float]|tuple[float,float]): Measurement coordinates (X,Y,Z) in mm or (X,Y) in mm\n\n        Returns:\n            tuple[float,float,float]|tuple[float,float]: Stage coordinates (X,Y,Z) in mm or (X,Y) in mm\n        \"\"\"\n        if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n\n        coor_mea_mm_arr = np.array(coor_mea_mm[:2])\n        coor_stage_mm = self._calibration.convert_mea2stg(coor_mea_mm_arr)\n\n        x_mm,y_mm = coor_stage_mm.tolist()\n\n        if len(coor_mea_mm) == 2:return x_mm, y_mm\n        if len(coor_mea_mm) &gt;= 2: return x_mm, y_mm, coor_mea_mm[2]\n\n    def set_calibration_rel(self, scl_x_mmPerPixel:float, scl_y_mmPerPixel:float,\n            laser_coor_x_mm:float, laser_coor_y_mm:float,flipx:bool,flipy:bool):\n        # REMFLAG: This method now overlaps with another method or with the ImageMeasurement_Calibration object's method. This will be removed.\n        raise NotImplementedError('This method will be removed entirely soon')\n\n    def set_calibration(self, scl_x_mmPerPixel:float, scl_y_mmPerPixel:float,\n                        laser_coor_x_mm:tuple[float,float], laser_coor_y_mm:tuple[float,float],\n                        inverse:bool=False,flipx:bool=False,flipy:bool=False):\n        # REMFLAG: This method now overlaps with another method or with the ImageMeasurement_Calibration object's method. This will be removed.\n        raise NotImplementedError('This method will be removed entirely soon')\n\n    def get_calibration(self, flipx:bool, flipy:bool) -&gt; tuple[float,float,float,float]:\n        # REMFLAG: This method now overlaps with another method or with the ImageMeasurement_Calibration object's method. This will be removed.\n        raise NotImplementedError('This method will be removed entirely soon')\n\n    def get_calibration_asdict(self) -&gt; tuple[str,dict]:\n        \"\"\"\n        Returns the calibration parameters as a dictionary\n\n        Returns:\n            tuple[str,dict]: Calibration ID, calibration parameters\n        \"\"\"\n        if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n        return self._calibration.id, self._calibration.get_calibration_asdict()\n\n    def set_calibration_ImageMeasurement_Calibration(self,calibration:ImgMea_Cal) -&gt; None:\n        \"\"\"\n        Sets the calibration parameters from an ImageMeasurement_Calibration object\n\n        Args:\n            calibration (ImageMeasurement_Calibration): Calibration parameters object\n\n        Raises:\n            AssertionError: Calibration parameters are not set\n            AssertionError: Calibration parameters are not an ImageMeasurement_Calibration object\n        \"\"\"\n        assert isinstance(calibration, ImgMea_Cal), 'Calibration must be an ImageMeasurement_Calibration object'\n        assert calibration.check_calibration_set(), 'Calibration parameters are not set'\n\n        self._calibration = calibration\n        self._flg_mat_calculated = False\n        self.refresh_metadata()\n        return\n\n    def test_generate_dummy(self):\n        \"\"\"\n        Generates dummy measurements for testing purposes\n        \"\"\"\n        for i in range(5):\n            timestamp = get_timestamp_us_str()\n            x_coor = float(np.random.uniform(0,1))\n            y_coor = float(np.random.uniform(0,1))\n            z_coor = float(0)\n            colour = (np.random.randint(0,256),np.random.randint(0,256),np.random.randint(0,256))\n            image = Image.new('RGB',(100,100),color=colour)\n\n            self.add_measurement(timestamp, x_coor, y_coor, z_coor, image)\n        return\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.__init__","title":"<code>__init__(unit_name=None, calibration=None, reconstruct=False)</code>","text":"<p>Initialises the image measurement class</p> <p>Parameters:</p> Name Type Description Default <code>unit_name</code> <code>str | None</code> <p>Name of the image measurement unit. Default is None</p> <code>None</code> <code>calibration</code> <code>ImageMeasurement_Calibration</code> <p>Calibration parameters</p> <code>None</code> <code>reconstruct</code> <code>bool</code> <p>Flag to skip all the checks, used for reconstruction from the local disk. Default is False</p> <code>False</code> Note <p>If the unit_name or unit_id is None, the timestamp will be used as the unit name and unit ID</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def __init__(self,unit_name:str|None=None,calibration:ImgMea_Cal|None=None,\n             reconstruct:bool=False):\n    \"\"\"\n    Initialises the image measurement class\n\n    Args:\n        unit_name (str|None): Name of the image measurement unit. Default is None\n        calibration (ImageMeasurement_Calibration): Calibration parameters\n        reconstruct (bool): Flag to skip all the checks, used for reconstruction from\n            the local disk. Default is False\n\n    Note:\n        If the unit_name or unit_id is None, the timestamp will be used as the unit name and unit ID\n    \"\"\"\n    if not reconstruct:\n        assert isinstance(calibration, ImgMea_Cal), 'Calibration must be an ImageMeasurement_Calibration object'\n        assert calibration.check_calibration_set(), 'Calibration parameters are not set'\n\n    self._unitName:str = unit_name if unit_name != None else get_timestamp_us_str()\n    self._unitID:str = uuid.uuid4().hex\n    self._calibration:ImgMea_Cal|None = calibration\n\n    self._list_metadata_keys = ['id','name','calibration_id','calibration_dict']\n\n    # Stitched image parameters\n    self._flg_mat_calculated:bool = False    # Flag to check if the rotation correction matrix is calculated\n    self._mat_stitch2ori:np.ndarray = np.eye(2)    # Rotation matrix to convert pixel coordinates from the stitched image to the original image\n    self._mat_ori2stitch:np.ndarray = np.eye(2)    # Rotation matrix to convert pixel coordinates from the original image to the stitched image\n    self._lres_scale:float = ImageProcessingParamsEnum.LOW_RESOLUTION_SCALE.value    # Low resolution scale for the images\n\n    # Dictionary to store the measurements\n    self._dict_measurements = {\n        'timestamp':[],\n        'coor_x':[],\n        'coor_y':[],\n        'coor_z':[],\n        'image':[],\n    }\n\n    self._dict_measurements_types = {\n        'timestamp':str,\n        'coor_x':float,\n        'coor_y':float,\n        'coor_z':float,\n        'image':Image.Image,\n    }\n\n    self._list_lowResImg = []   # List to store the low resolution images\n\n    assert set(self._dict_measurements.keys()) == set(self._dict_measurements_types.keys()), 'Measurement keys must match the measurement types'\n\n    self._metadata_types = {\n        'id':str,\n        'name':str,\n        'calibration_id':str,\n        'calibration_dict':dict,\n    }\n\n    self._idname_keys = ['id','name']   # Keys for the ID and name to access the metadata\n\n    if reconstruct: self._metadata = {}\n    else:\n        assert isinstance(self._calibration, ImgMea_Cal), 'Calibration must be an ImageMeasurement_Calibration object'\n        self._metadata = {\n            'id':self._unitID,\n            'name':self._unitName,\n            'calibration_id':self._calibration.id,\n            'calibration_dict':self._calibration.get_calibration_asdict()\n        }\n        assert set(self._metadata.keys()) == set(self._metadata_types.keys()), 'Metadata keys must match the metadata types'\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.add_measurement","title":"<code>add_measurement(timestamp, x_coor, y_coor, z_coor, image)</code>","text":"<p>Adds a measurement to the dictionary</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp of the measurement</p> required <code>x_coor</code> <code>float</code> <p>X-coordinate of the measurement</p> required <code>y_coor</code> <code>float</code> <p>Y-coordinate of the measurement</p> required <code>z_coor</code> <code>float</code> <p>Z-coordinate of the measurement</p> required <code>image</code> <code>Image</code> <p>Image of the measurement</p> required Source code in <code>iris/data/measurement_image.py</code> <pre><code>def add_measurement(self, timestamp:str, x_coor:float, y_coor:float,\n                    z_coor:float, image:Image.Image):\n    \"\"\"\n    Adds a measurement to the dictionary\n\n    Args:\n        timestamp (str): Timestamp of the measurement\n        x_coor (float): X-coordinate of the measurement\n        y_coor (float): Y-coordinate of the measurement\n        z_coor (float): Z-coordinate of the measurement\n        image (Image.Image): Image of the measurement\n    \"\"\"\n    assert isinstance(timestamp, str), 'Timestamp must be a string'\n    assert isinstance(x_coor, float), 'X-coordinate must be a float'\n    assert isinstance(y_coor, float), 'Y-coordinate must be a float'\n    assert isinstance(z_coor, float), 'Z-coordinate must be a float'\n    assert isinstance(image, Image.Image), 'Image must be an Image.Image object'\n\n    # Add the parameters to the dictionary\n    self._dict_measurements['timestamp'].append(timestamp)\n    self._dict_measurements['coor_x'].append(x_coor)\n    self._dict_measurements['coor_y'].append(y_coor)\n    self._dict_measurements['coor_z'].append(z_coor)\n    self._dict_measurements['image'].append(image)\n\n    # Generate the low resolution image and store it\n    image_lres = image.copy()\n    image_lres.thumbnail((int(image.size[0]*self._lres_scale),int(image.size[1]*self._lres_scale)))\n    self._list_lowResImg.append(image_lres)\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.check_calibration_exist","title":"<code>check_calibration_exist()</code>","text":"<p>Checks if the calibration parameters are set</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the calibration parameters are set, False otherwise</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def check_calibration_exist(self) -&gt; bool:\n    \"\"\"\n    Checks if the calibration parameters are set\n\n    Returns:\n        bool: True if the calibration parameters are set, False otherwise\n    \"\"\"\n    if not isinstance(self._calibration, ImgMea_Cal): return False\n    return self._calibration.check_calibration_set()\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.check_measurement_exist","title":"<code>check_measurement_exist()</code>","text":"<p>Checks if the measurements are stored</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the measurements are stored, False otherwise</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def check_measurement_exist(self) -&gt; bool:\n    \"\"\"\n    Checks if the measurements are stored\n\n    Returns:\n        bool: True if the measurements are stored, False otherwise\n    \"\"\"\n    return len(self._dict_measurements['timestamp']) &gt; 0\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.check_readyForProcessing","title":"<code>check_readyForProcessing()</code>","text":"<p>Checks if the image measurement is ready for processing. Checks for:     1. If the measurements exist     2. If the calibration parameters exist     3. If the low resolution images have been generated for all the images taken</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the image measurement is ready for processing, False otherwise</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def check_readyForProcessing(self):\n    \"\"\"\n    Checks if the image measurement is ready for processing. Checks for:\n        1. If the measurements exist\n        2. If the calibration parameters exist\n        3. If the low resolution images have been generated for all the images taken\n\n    Returns:\n        bool: True if the image measurement is ready for processing, False otherwise\n    \"\"\"\n    flg = True\n    if not self.check_measurement_exist(): flg = False\n    if not self.check_calibration_exist(): flg = False\n    if not len(self._dict_measurements['image']) == len(self._list_lowResImg): flg = False\n    return flg\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.convert_imgpt2stg","title":"<code>convert_imgpt2stg(frame_coor_mm, coor_pixel, correct_rot, low_res)</code>","text":"<p>Converts the coordinates from pixels to mm based on the stored calibration parameters</p> <p>Parameters:</p> Name Type Description Default <code>frame_coor_mm</code> <code>tuple[float, float]</code> <p>X, Y, Z coordinates or X, Y coordinates in mm of the image frame</p> required <code>coor_pixel</code> <code>tuple[int, int]</code> <p>X, Y coordinates in pixels</p> required <code>correct_rot</code> <code>bool</code> <p>Correct for the rotation angle if the shown stitched image is rotated corrected</p> required <code>low_res</code> <code>bool</code> <p>Set to True if the image being processed is a low resolution (i.e., downsampled) image of the original image.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float,float]: X and Y coordinates in mm</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def convert_imgpt2stg(self, frame_coor_mm:tuple[float,float]|tuple[float,float,float],\n                      coor_pixel:tuple[int,int]|tuple[float,float],\n                      correct_rot:bool, low_res:bool)\\\n    -&gt; tuple[float,float]:\n    \"\"\"\n    Converts the coordinates from pixels to mm based on the stored calibration parameters\n\n    Args:\n        frame_coor_mm (tuple[float,float]): X, Y, Z coordinates or X, Y coordinates in mm of the image frame\n        coor_pixel (tuple[int,int]): X, Y coordinates in pixels\n        correct_rot (bool): Correct for the rotation angle if the shown stitched image is rotated corrected\n        low_res (bool): Set to True if the image being processed is a low resolution (i.e., downsampled) image of the original image.\n\n    Returns:\n        tuple[float,float]: X and Y coordinates in mm\n    \"\"\"\n    if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n\n    if low_res: coor_pixel = (int(coor_pixel[0]/self._lres_scale),int(coor_pixel[1]/self._lres_scale))\n\n    if correct_rot:\n        coor_pixel = (int(coor_pixel[0]),int(coor_pixel[1]))\n        coor_pixel = self._correctRotationFlip(coor_pixel,stitch2ori=True)\n\n    coor_stg_mm = self._calibration.convert_imgpt2stg(\n        coor_img_pixel=np.array(coor_pixel[:2]),\n        coor_stage_mm=np.array(frame_coor_mm[:2])\n    )\n\n    x_mm,y_mm = coor_stg_mm.tolist()\n    return x_mm, y_mm\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.convert_mea2stg","title":"<code>convert_mea2stg(coor_mea_mm)</code>","text":"<p>Calculates the stage coordinates from the measurement coordinates based on the laser coordinates stored in the calibration parameters</p> <p>Parameters:</p> Name Type Description Default <code>coor_mea_mm</code> <code>tuple[float, float, float] | tuple[float, float]</code> <p>Measurement coordinates (X,Y,Z) in mm or (X,Y) in mm</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float] | tuple[float, float]</code> <p>tuple[float,float,float]|tuple[float,float]: Stage coordinates (X,Y,Z) in mm or (X,Y) in mm</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def convert_mea2stg(self, coor_mea_mm:tuple[float,float,float]|tuple[float,float])\\\n    -&gt; tuple[float,float,float]|tuple[float,float]:\n    \"\"\"\n    Calculates the stage coordinates from the measurement coordinates based on the laser coordinates\n    stored in the calibration parameters\n\n    Args:\n        coor_mea_mm (tuple[float,float,float]|tuple[float,float]): Measurement coordinates (X,Y,Z) in mm or (X,Y) in mm\n\n    Returns:\n        tuple[float,float,float]|tuple[float,float]: Stage coordinates (X,Y,Z) in mm or (X,Y) in mm\n    \"\"\"\n    if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n\n    coor_mea_mm_arr = np.array(coor_mea_mm[:2])\n    coor_stage_mm = self._calibration.convert_mea2stg(coor_mea_mm_arr)\n\n    x_mm,y_mm = coor_stage_mm.tolist()\n\n    if len(coor_mea_mm) == 2:return x_mm, y_mm\n    if len(coor_mea_mm) &gt;= 2: return x_mm, y_mm, coor_mea_mm[2]\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.convert_stg2imgpt","title":"<code>convert_stg2imgpt(coor_stage_mm, coor_point_mm, correct_rot, low_res)</code>","text":"<p>Converts the coordinates from mm to pixels based on the stored calibration parameters</p> <p>Parameters:</p> Name Type Description Default <code>stage_coor_mm</code> <code>tuple[float, float, float]</code> <p>X, Y, Z coordinates or X, Y coordinates in mm of the image frame</p> required <code>coor_mm</code> <code>tuple[float, float, float]</code> <p>X, Y, Z coordinates or X, Y coordinates in mm</p> required <code>rot_rad</code> <code>float</code> <p>Rotation angle in radians to correct for. Default is 0.0</p> required <code>correct_rot</code> <code>bool</code> <p>Correct for the rotation angle if the shown stitched image is rotated corrected</p> required <code>low_res</code> <code>bool</code> <p>Set to True if the image being processed is a low resolution (i.e., downsampled) image of the original image.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int,int]: X and Y coordinates in pixels</p> NOTE <ul> <li>The rotation angle is to correct for the rotation applied of the shown image     from the 'get stitched image' method</li> <li>The rotation angle is in radians and is counter clockwise</li> </ul> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def convert_stg2imgpt(self, coor_stage_mm:tuple[float,float,float]|tuple[float,float],\n        coor_point_mm:tuple[float,float,float]|tuple[float,float],correct_rot:bool,low_res:bool) -&gt; tuple[int,int]:\n    \"\"\"\n    Converts the coordinates from mm to pixels based on the stored calibration parameters\n\n    Args:\n        stage_coor_mm (tuple[float,float,float]): X, Y, Z coordinates or X, Y coordinates in mm of the image frame\n        coor_mm (tuple[float,float,float]): X, Y, Z coordinates or X, Y coordinates in mm\n        rot_rad (float): Rotation angle in radians to correct for. Default is 0.0\n        correct_rot (bool): Correct for the rotation angle if the shown stitched image is rotated corrected\n        low_res (bool): Set to True if the image being processed is a low resolution (i.e., downsampled) image of the original image.\n\n    Returns:\n        tuple[int,int]: X and Y coordinates in pixels\n\n    NOTE:\n        - The rotation angle is to correct for the rotation applied of the shown image\n            from the 'get stitched image' method\n        - The rotation angle is in radians and is counter clockwise\n    \"\"\"\n    if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n\n    coor_pixel = self._calibration.convert_stg2imgpt(\n        coor_point_mm=np.array(coor_point_mm[:2]),\n        coor_stg_mm=np.array(coor_stage_mm[:2])\n    )\n\n    if correct_rot:\n        coor_pixel = (int(coor_pixel[0]),int(coor_pixel[1]))\n        coor_pixel = self._correctRotationFlip(coor_pixel,stitch2ori=False)\n\n    x_pixel,y_pixel = [int(coor) for coor in coor_pixel]\n\n    if low_res:\n        x_pixel = int(x_pixel*self._lres_scale)\n        y_pixel = int(y_pixel*self._lres_scale)\n\n    return x_pixel, y_pixel\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.convert_stg2mea","title":"<code>convert_stg2mea(coor_stage_mm)</code>","text":"<p>Calculates the measurement coordinates from the stage coordinates based on the laser coordinates stored in the calibration parameters</p> <p>Parameters:</p> Name Type Description Default <code>stage_coor</code> <code>tuple[float, float, float] | tuple[float, float]</code> <p>Stage coordinates (X,Y,Z) in mm or (X,Y) in mm</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float] | tuple[float, float]</code> <p>tuple[float,float,float]|tuple[float,float]: Measurement coordinates (X,Y,Z) in mm or (X,Y) in mm</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def convert_stg2mea(self, coor_stage_mm:tuple[float,float,float]|tuple[float,float])\\\n    -&gt; tuple[float,float,float]|tuple[float,float]:\n    \"\"\"\n    Calculates the measurement coordinates from the stage coordinates based on the laser coordinates\n    stored in the calibration parameters\n\n    Args:\n        stage_coor (tuple[float,float,float]|tuple[float,float]): Stage coordinates (X,Y,Z) in mm or (X,Y) in mm\n\n    Returns:\n        tuple[float,float,float]|tuple[float,float]: Measurement coordinates (X,Y,Z) in mm or (X,Y) in mm\n    \"\"\"\n    if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n\n    coor_stage_mm_arr = np.array(coor_stage_mm[:2])\n    coor_mea_mm = self._calibration.convert_stg2mea(coor_stage_mm_arr)\n\n    x_mm,y_mm = coor_mea_mm.tolist()\n\n    if len(coor_stage_mm) == 2: return x_mm, y_mm\n    if len(coor_stage_mm) &gt;= 2: return x_mm, y_mm, coor_stage_mm[2]\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.get_IdName","title":"<code>get_IdName()</code>","text":"<p>Returns the unit ID and name</p> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str,str]: Unit ID, Unit name</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_IdName(self) -&gt; tuple[str,str]:\n    \"\"\"\n    Returns the unit ID and name\n\n    Returns:\n        tuple[str,str]: Unit ID, Unit name\n    \"\"\"\n    return self._unitID, self._unitName\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.get_ImageMeasurement_Calibration","title":"<code>get_ImageMeasurement_Calibration()</code>","text":"<p>Returns the ImageMeasurement_Calibration object for the calibration parameters</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_ImageMeasurement_Calibration(self) -&gt; ImgMea_Cal:\n    \"\"\"\n    Returns the ImageMeasurement_Calibration object for the calibration parameters\n    \"\"\"\n    if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n    return self._calibration\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.get_calibration_asdict","title":"<code>get_calibration_asdict()</code>","text":"<p>Returns the calibration parameters as a dictionary</p> <p>Returns:</p> Type Description <code>tuple[str, dict]</code> <p>tuple[str,dict]: Calibration ID, calibration parameters</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_calibration_asdict(self) -&gt; tuple[str,dict]:\n    \"\"\"\n    Returns the calibration parameters as a dictionary\n\n    Returns:\n        tuple[str,dict]: Calibration ID, calibration parameters\n    \"\"\"\n    if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n    return self._calibration.id, self._calibration.get_calibration_asdict()\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.get_dict_measurement","title":"<code>get_dict_measurement()</code>","text":"<p>Returns the measurements dictionary for saving to local disk</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Measurements dictionary</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_dict_measurement(self) -&gt; dict:\n    \"\"\"\n    Returns the measurements dictionary for saving to local disk\n\n    Returns:\n        dict: Measurements dictionary\n    \"\"\"\n    return self._dict_measurements\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.get_dict_measurement_types","title":"<code>get_dict_measurement_types()</code>","text":"<p>Returns the measurements dictionary types</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Measurements dictionary types</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_dict_measurement_types(self) -&gt; dict:\n    \"\"\"\n    Returns the measurements dictionary types\n\n    Returns:\n        dict: Measurements dictionary types\n    \"\"\"\n    return self._dict_measurements_types\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.get_image_all_stitched","title":"<code>get_image_all_stitched(low_res=False)</code>","text":"<p>Stitches all the images taken</p> <p>Parameters:</p> Name Type Description Default <code>low_res</code> <code>bool</code> <p>Flag to use the low resolution images. Default is False</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[Image, tuple[float, float], tuple[float, float]]</code> <p>tuple[Image.Image,tuple[float,float],tuple[float,float]]: Stitched image, image min limits in mm (xmin,ymin) [mm], image max limits in mm (xmax,ymax) [mm]</p> NOTE <ul> <li>Note that the shown image is rotated according to the calibration parameters.     i.e., the image shown is now aligned with the stage frame of reference's axes     such that another coordinate rotation correction needs to be done when converting     the coordinats between the image and the stage frame of reference. For this reason,     the rotation angle is stored internally.</li> </ul> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_image_all_stitched(self, low_res:bool=False) -&gt; tuple[Image.Image,tuple[float,float],tuple[float,float]]:\n    \"\"\"\n    Stitches all the images taken\n\n    Args:\n        low_res (bool): Flag to use the low resolution images. Default is False\n\n    Returns:\n        tuple[Image.Image,tuple[float,float],tuple[float,float]]:\n            Stitched image, image min limits in mm (xmin,ymin) [mm],\n            image max limits in mm (xmax,ymax) [mm]\n\n    NOTE:\n        - Note that the shown image is rotated according to the calibration parameters.\n            i.e., the image shown is now aligned with the stage frame of reference's axes\n            such that another coordinate rotation correction needs to be done when converting\n            the coordinats between the image and the stage frame of reference. For this reason,\n            the rotation angle is stored internally.\n    \"\"\"\n    assert len(self._dict_measurements['timestamp']) &gt; 0, 'No images taken'\n    assert self.check_calibration_exist(), 'Calibration parameters are not set'\n    assert isinstance(self._calibration, ImgMea_Cal), 'Calibration is not set'\n\n    cal = self._calibration\n\n# &gt; Get the measurements\n    if low_res: list_images = self._list_lowResImg\n    else: list_images = self._dict_measurements['image']\n\n    list_coorx_mm = self._dict_measurements['coor_x']\n    list_coory_mm = self._dict_measurements['coor_y']\n\n    # Calculate the rotation angle\n    # print(f'Stored rotation angle [rad]: {cal.rotation_rad}')\n    rot_deg = -cal.rotation_rad*180/np.pi\n    # print(f'Operation rotation angle [deg]: {rot_deg}')\n\n# &gt; Calculate the crop and the coordinate shift because of the cropping\n    sizex,sizey = list_images[0].size\n    cropx_pixel = abs(int(sizey*np.sin(cal.rotation_rad)))\n    cropy_pixel = abs(int(sizex*np.sin(cal.rotation_rad)))\n    # print(f'Crop size [pixel]: {cropx_pixel,cropy_pixel}')\n\n    # Ensure that the angle is within -180 to 180 degrees\n    while True:\n        if rot_deg &gt; 180: rot_deg -= 360\n        elif rot_deg &lt; -180: rot_deg += 360\n        else: break\n\n    if rot_deg &gt; 0:\n        crop_coor = (0,cropy_pixel,sizex-cropx_pixel,sizey)\n        coor_shift_pixel = (cropx_pixel,0)\n    elif rot_deg &lt; 0:\n        crop_coor = (cropx_pixel,0,sizex,sizey-cropy_pixel)\n        coor_shift_pixel = (0,cropy_pixel)\n    else:\n        crop_coor = (0,0,sizex,sizey)\n        coor_shift_pixel = (0,0)\n\n    coor_shift_stage = self.convert_imgpt2stg(frame_coor_mm=(0,0),\\\n        coor_pixel=coor_shift_pixel,correct_rot=True,low_res=low_res)\n\n    list_coorx_mm = [coor+coor_shift_stage[0] for coor in list_coorx_mm]\n    list_coory_mm = [coor+coor_shift_stage[1] for coor in list_coory_mm]\n\n# &gt; Rotate and crop the images\n    list_images_converted = []\n    for img in list_images:\n        img_rot_crop:Image.Image = img.copy()\n        img_rot_crop = img_rot_crop.rotate(-rot_deg,expand=False,center=(0,0)) if rot_deg != 0 else img_rot_crop\n        img_rot_crop = img_rot_crop.crop(crop_coor)\n        list_images_converted.append(img_rot_crop)\n\n    list_images = list_images_converted\n\n# &gt; Stitch the image\n    # Calculate each image location in the stitched image (in pixel coordinates)\n    list_coor_mm = [(coorx_mm,coory_mm) for coorx_mm,coory_mm in zip(list_coorx_mm,list_coory_mm)]\n    list_coor_min_mm = list_coor_mm\n\n    # Flip the coordinates based on the calibration parameters\n    # rot_rad = cal.rotation_rad\n    # flip_rot_x = np.sign(np.cos(rot_rad))\n    # flip_rot_x = 1 if flip_rot_x == 0 else flip_rot_x\n    # flip_rot_y = np.sign(np.sin(rot_rad))\n    # flip_rot_y = 1 if flip_rot_y == 0 else flip_rot_y\n\n    # x_flip = np.sign(cal.scale_x_pixelPerMm*flip_rot_x*-1).astype(int)\n    # y_flip = np.sign(cal.scale_y_pixelPerMm*cal.flip_y*flip_rot_y*-1).astype(int)\n    x_flip = -1\n    y_flip = -1\n    assert x_flip !=0 and y_flip != 0, 'CHECK ERROR: Flip parameters cannot be 0, there must be something unaccounted for'\n\n    list_coor_min_pixel = [self.convert_stg2imgpt(coor_stage_mm=coor,coor_point_mm=(0,0),correct_rot=True,low_res=low_res)\\\n        for coor in list_coor_mm]\n    list_coor_min_pixel = [(coor[0]*x_flip,coor[1]*y_flip) for coor in list_coor_min_pixel]\n\n    img_limit_coor_min_pixel = (min([coor[0] for coor in list_coor_min_pixel]),\\\n        min([coor[1] for coor in list_coor_min_pixel]))\n\n    # Calculate the relative pixel coordinates\n    list_coor_pixel_rel = [(\n        coor[0]-img_limit_coor_min_pixel[0],\\\n        coor[1]-img_limit_coor_min_pixel[1]\n        ) for coor in list_coor_min_pixel]\n\n    # Generate an empty image \n    img_wid = max([abs(coor[0]) for coor in list_coor_pixel_rel]) + img_rot_crop.size[0]\n    img_hei = max([abs(coor[1]) for coor in list_coor_pixel_rel]) + img_rot_crop.size[1]\n    img_stitched = Image.new('RGB',(img_wid,img_hei))\n\n    # Paste the images onto the empty image\n    for i in range(len(list_images)):\n        img = list_images[i]\n        coor_pixel = list_coor_pixel_rel[i]\n        img_stitched.paste(img,coor_pixel)\n\n# &gt; Calculate the image limits in mm\n    # Note to myself:\n    # The limit is not the minimum coordinates of the image but the coordinate of the 0,0 pixel\n    # of the stitched image in the stage frame of reference\n    # This can be calculated by converting the pixel coordinates of the one of the image \n    # in the list_coor_pixel_rel\n\n    # This minimum coordinate is also the reference coordinate to be returned (i.e., the stage coordinate\n    # of the stitched image, corresponding to the 0,0 pixel of the stitched image)\n\n    # Similarly, the maximum coordinates of the image is the maximum coordinates of the img_rot_crop\n    # i.e., the image shape\n\n    mea_coor = list_coor_min_mm[0]\n    mea_coor_pixel = list_coor_pixel_rel[0]\n    neg = (-mea_coor_pixel[0],-mea_coor_pixel[1])\n    img_limit_coor_min_mm = self.convert_imgpt2stg(frame_coor_mm=mea_coor,coor_pixel=neg,correct_rot=True,\n                                                   low_res=low_res)\n    img_limit_coor_max_mm = self.convert_imgpt2stg(frame_coor_mm=img_limit_coor_min_mm,coor_pixel=(img_wid,img_hei),\n                                                   correct_rot=True,low_res=low_res)\n\n    return img_stitched, img_limit_coor_min_mm, img_limit_coor_max_mm\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.get_metadata","title":"<code>get_metadata(incl_nameid=True)</code>","text":"<p>Returns the metadata of the ImageMeasurement_Unit</p> <p>Parameters:</p> Name Type Description Default <code>incl_nameid</code> <code>bool</code> <p>Include the name and ID in the metadata. Default is True</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Metadata of the ImageMeasurement_Unit (id, name, calibration_id, calibration_dict)</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_metadata(self, incl_nameid:bool=True) -&gt; dict:\n    \"\"\"\n    Returns the metadata of the ImageMeasurement_Unit\n\n    Args:\n        incl_nameid (bool): Include the name and ID in the metadata. Default is True\n\n    Returns:\n        dict: Metadata of the ImageMeasurement_Unit (id, name, calibration_id, calibration_dict)\n    \"\"\"\n    if incl_nameid: return self._metadata\n    else: return {key:self._metadata[key] for key in self._metadata.keys() if key not in self._idname_keys}\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.get_metadata_types","title":"<code>get_metadata_types()</code>","text":"<p>Returns the metadata types</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Metadata types</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_metadata_types(self) -&gt; dict:\n    \"\"\"\n    Returns the metadata types\n\n    Returns:\n        dict: Metadata types\n    \"\"\"\n    return self._metadata_types\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.get_numMeasurements","title":"<code>get_numMeasurements()</code>","text":"<p>Returns the number of measurements taken</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of measurements taken</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def get_numMeasurements(self) -&gt; int:\n    \"\"\"\n    Returns the number of measurements taken\n\n    Returns:\n        int: Number of measurements taken\n    \"\"\"\n    return len(self._dict_measurements['timestamp'])\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.refresh_metadata","title":"<code>refresh_metadata()</code>","text":"<p>Resets the metadata using the internally stored values</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def refresh_metadata(self):\n    \"\"\"\n    Resets the metadata using the internally stored values\n    \"\"\"\n    if not isinstance(self._calibration, ImgMea_Cal): raise ValueError('Calibration is not set')\n    self._metadata = {\n        'id':self._unitID,\n        'name':self._unitName,\n        'calibration_id':self._calibration.id,\n        'calibration_dict':self._calibration.get_calibration_asdict()\n    }\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.reprocess_lowres_images","title":"<code>reprocess_lowres_images()</code>","text":"<p>Reprocesses the low resolution images to be used for the stitching using the original images</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def reprocess_lowres_images(self):\n    \"\"\"\n    Reprocesses the low resolution images to be used for the stitching using the original images\n    \"\"\"\n    self._list_lowResImg.clear()\n\n    for img in self._dict_measurements['image']:\n        img_lres = img.copy()\n        img_lres.thumbnail((int(img.size[0]*self._lres_scale),int(img.size[1]*self._lres_scale)))\n        self._list_lowResImg.append(img_lres)\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.reset_measurement","title":"<code>reset_measurement()</code>","text":"<p>Deletes all stored measurement in the _dict_measurements</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def reset_measurement(self):\n    \"\"\"\n    Deletes all stored measurement in the _dict_measurements\n    \"\"\"\n    for key in self._dict_measurements.keys():\n        self._dict_measurements[key].clear()\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.set_calibration_ImageMeasurement_Calibration","title":"<code>set_calibration_ImageMeasurement_Calibration(calibration)</code>","text":"<p>Sets the calibration parameters from an ImageMeasurement_Calibration object</p> <p>Parameters:</p> Name Type Description Default <code>calibration</code> <code>ImageMeasurement_Calibration</code> <p>Calibration parameters object</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>Calibration parameters are not set</p> <code>AssertionError</code> <p>Calibration parameters are not an ImageMeasurement_Calibration object</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def set_calibration_ImageMeasurement_Calibration(self,calibration:ImgMea_Cal) -&gt; None:\n    \"\"\"\n    Sets the calibration parameters from an ImageMeasurement_Calibration object\n\n    Args:\n        calibration (ImageMeasurement_Calibration): Calibration parameters object\n\n    Raises:\n        AssertionError: Calibration parameters are not set\n        AssertionError: Calibration parameters are not an ImageMeasurement_Calibration object\n    \"\"\"\n    assert isinstance(calibration, ImgMea_Cal), 'Calibration must be an ImageMeasurement_Calibration object'\n    assert calibration.check_calibration_set(), 'Calibration parameters are not set'\n\n    self._calibration = calibration\n    self._flg_mat_calculated = False\n    self.refresh_metadata()\n    return\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.set_dict_measurement_fromfile","title":"<code>set_dict_measurement_fromfile(dict_measurements)</code>","text":"<p>Sets the measurements from a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>dict_measurements</code> <code>dict</code> <p>Measurements dictionary</p> required Source code in <code>iris/data/measurement_image.py</code> <pre><code>def set_dict_measurement_fromfile(self,dict_measurements:dict) -&gt; None:\n    \"\"\"\n    Sets the measurements from a dictionary\n\n    Args:\n        dict_measurements (dict): Measurements dictionary\n    \"\"\"\n    assert set(dict_measurements.keys()) == set(self._dict_measurements.keys()), 'Measurement keys must match the measurement types'\n    assert all([isinstance(dict_measurements[key], list) for key in dict_measurements.keys()]), 'Measurement values must be lists'\n    assert all([all([isinstance(val, self._dict_measurements_types[key]) for val in dict_measurements[key]]) for key in dict_measurements.keys()]), 'Measurement values must match the measurement types'\n\n    self._dict_measurements.clear()\n    for key in dict_measurements.keys():\n        self._dict_measurements[key] = dict_measurements[key]\n\n    self.reprocess_lowres_images()\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.set_metadata_fromfile","title":"<code>set_metadata_fromfile(dict_meta)</code>","text":"<p>Sets the unit attributes based on the given metadata dictionary</p> <p>Parameters:</p> Name Type Description Default <code>dict_meta</code> <code>dict</code> <p>Metadata dictionary</p> required Source code in <code>iris/data/measurement_image.py</code> <pre><code>def set_metadata_fromfile(self,dict_meta:dict) -&gt; None:\n    \"\"\"\n    Sets the unit attributes based on the given metadata dictionary\n\n    Args:\n        dict_meta (dict): Metadata dictionary\n    \"\"\"\n    assert all([key in dict_meta.keys() for key in set(self._metadata.keys())]), 'Metadata keys must match the metadata types'\n\n    self._unitID = dict_meta['id']\n    self._unitName = dict_meta['name']\n\n    cal = ImgMea_Cal()\n    cal.set_calibration_fromdict(dict_meta['calibration_id'],dict_meta['calibration_dict'])\n\n    self._calibration = cal\n    self._flg_mat_calculated = False\n\n    self.refresh_metadata()\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.set_name","title":"<code>set_name(unit_name)</code>","text":"<p>Sets the name of the ImageMeasurement_Unit</p> <p>Parameters:</p> Name Type Description Default <code>unit_name</code> <code>str</code> <p>Name of the ImageMeasurement_Unit</p> required Source code in <code>iris/data/measurement_image.py</code> <pre><code>def set_name(self,unit_name:str) -&gt; None:\n    \"\"\"\n    Sets the name of the ImageMeasurement_Unit\n\n    Args:\n        unit_name (str): Name of the ImageMeasurement_Unit\n    \"\"\"\n    assert isinstance(unit_name,str), 'Name must be a string'\n    self._unitName = unit_name\n    self._metadata['name'] = unit_name\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.MeaImg_Unit.test_generate_dummy","title":"<code>test_generate_dummy()</code>","text":"<p>Generates dummy measurements for testing purposes</p> Source code in <code>iris/data/measurement_image.py</code> <pre><code>def test_generate_dummy(self):\n    \"\"\"\n    Generates dummy measurements for testing purposes\n    \"\"\"\n    for i in range(5):\n        timestamp = get_timestamp_us_str()\n        x_coor = float(np.random.uniform(0,1))\n        y_coor = float(np.random.uniform(0,1))\n        z_coor = float(0)\n        colour = (np.random.randint(0,256),np.random.randint(0,256),np.random.randint(0,256))\n        image = Image.new('RGB',(100,100),color=colour)\n\n        self.add_measurement(timestamp, x_coor, y_coor, z_coor, image)\n    return\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/data/measurement_image/#iris.data.measurement_image.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/","title":"dataHub_MeaImg","text":"<p>A hub to manage all the ImageMeasurement_Units stored in an ImageMeasurement_Hub captured in the session. This is modeled after the sframe_dataHubMapping module.</p>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Image_SaverLoader_Worker","title":"<code>Image_SaverLoader_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Worker class to save ImageMeasurement_Hub data in a separate thread.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>class Image_SaverLoader_Worker(QObject):\n    \"\"\"\n    Worker class to save ImageMeasurement_Hub data in a separate thread.\n    \"\"\"\n    finished = Signal(str)\n    error = Signal(str)\n\n    msg_save_db = 'ImageMeasurementHub saved successfully (.db).'\n    msg_load_db = 'ImageMeasurementHub loaded successfully (.db).'\n    msg_save_png = 'ImageMeasurementUnit saved successfully as PNG.'\n\n    def __init__(self):\n        super().__init__()\n\n    @Slot(MeaImg_Hub,str,str)\n    def save_ImageMeasurementHub(self, hub:MeaImg_Hub, initdir:str, savename:str):\n        \"\"\"\n        Save the ImageMeasurement_Hub data to a database file.\n\n        Args:\n            hub (ImageMeasurement_Hub): ImageMeasurement_Hub object to save\n            initdir (str): Directory to save the database file\n            savename (str): Name of the database file\n        \"\"\"\n        try:\n            handler = MeaImg_Handler()\n            thread = handler.save_ImageMeasurementHub_database(hub=hub,initdir=initdir,savename=savename)\n            thread.join()\n            self.finished.emit(self.msg_save_db)\n        except Exception as e:\n            self.error.emit(str(e))\n\n    @Slot(MeaImg_Hub,str)\n    def load_ImageMeasurementHub(self, hub:MeaImg_Hub, file_path:str):\n        \"\"\"\n        Load the ImageMeasurement_Hub data from the database file.\n\n        Args:\n            hub (ImageMeasurement_Hub): ImageMeasurement_Hub object to load data into\n            file_path (str): Path to the database file\n        \"\"\"\n        try:\n            hub.reset_ImageMeasurementUnits()\n            handler = MeaImg_Handler()\n            handler.load_ImageMeasurementHub_database(file_path,hub)\n            self.finished.emit(self.msg_load_db)\n        except Exception as e:\n            self.error.emit(str(e))\n\n    @Slot(MeaImg_Unit,str,float)\n    def save_ImageMeasurementUnit_png(self, unit:MeaImg_Unit, dirpath:str, resolution:float):\n        \"\"\"\n        Save the ImageMeasurement_Unit data as PNG files in the specified directory.\n\n        Args:\n            unit (ImageMeasurement_Unit): ImageMeasurement_Unit object to save\n            dirpath (str): Directory to save the PNG files\n            resolution (float): Resolution percentage for the PNG files\n        \"\"\"\n        try:\n            stitched_img = unit.get_image_all_stitched(low_res=False)[0]\n            stitched_img.thumbnail((int(stitched_img.width*resolution/100), int(stitched_img.height*resolution/100)))\n            stitched_img.save(os.path.join(dirpath, f'{unit.get_IdName()[1]}.png'))\n            self.finished.emit(f'{self.msg_save_png} {unit.get_IdName()[1]}')\n        except Exception as e:\n            self.error.emit(str(e))\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Image_SaverLoader_Worker.load_ImageMeasurementHub","title":"<code>load_ImageMeasurementHub(hub, file_path)</code>","text":"<p>Load the ImageMeasurement_Hub data from the database file.</p> <p>Parameters:</p> Name Type Description Default <code>hub</code> <code>ImageMeasurement_Hub</code> <p>ImageMeasurement_Hub object to load data into</p> required <code>file_path</code> <code>str</code> <p>Path to the database file</p> required Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>@Slot(MeaImg_Hub,str)\ndef load_ImageMeasurementHub(self, hub:MeaImg_Hub, file_path:str):\n    \"\"\"\n    Load the ImageMeasurement_Hub data from the database file.\n\n    Args:\n        hub (ImageMeasurement_Hub): ImageMeasurement_Hub object to load data into\n        file_path (str): Path to the database file\n    \"\"\"\n    try:\n        hub.reset_ImageMeasurementUnits()\n        handler = MeaImg_Handler()\n        handler.load_ImageMeasurementHub_database(file_path,hub)\n        self.finished.emit(self.msg_load_db)\n    except Exception as e:\n        self.error.emit(str(e))\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Image_SaverLoader_Worker.save_ImageMeasurementHub","title":"<code>save_ImageMeasurementHub(hub, initdir, savename)</code>","text":"<p>Save the ImageMeasurement_Hub data to a database file.</p> <p>Parameters:</p> Name Type Description Default <code>hub</code> <code>ImageMeasurement_Hub</code> <p>ImageMeasurement_Hub object to save</p> required <code>initdir</code> <code>str</code> <p>Directory to save the database file</p> required <code>savename</code> <code>str</code> <p>Name of the database file</p> required Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>@Slot(MeaImg_Hub,str,str)\ndef save_ImageMeasurementHub(self, hub:MeaImg_Hub, initdir:str, savename:str):\n    \"\"\"\n    Save the ImageMeasurement_Hub data to a database file.\n\n    Args:\n        hub (ImageMeasurement_Hub): ImageMeasurement_Hub object to save\n        initdir (str): Directory to save the database file\n        savename (str): Name of the database file\n    \"\"\"\n    try:\n        handler = MeaImg_Handler()\n        thread = handler.save_ImageMeasurementHub_database(hub=hub,initdir=initdir,savename=savename)\n        thread.join()\n        self.finished.emit(self.msg_save_db)\n    except Exception as e:\n        self.error.emit(str(e))\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Image_SaverLoader_Worker.save_ImageMeasurementUnit_png","title":"<code>save_ImageMeasurementUnit_png(unit, dirpath, resolution)</code>","text":"<p>Save the ImageMeasurement_Unit data as PNG files in the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>ImageMeasurement_Unit</code> <p>ImageMeasurement_Unit object to save</p> required <code>dirpath</code> <code>str</code> <p>Directory to save the PNG files</p> required <code>resolution</code> <code>float</code> <p>Resolution percentage for the PNG files</p> required Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>@Slot(MeaImg_Unit,str,float)\ndef save_ImageMeasurementUnit_png(self, unit:MeaImg_Unit, dirpath:str, resolution:float):\n    \"\"\"\n    Save the ImageMeasurement_Unit data as PNG files in the specified directory.\n\n    Args:\n        unit (ImageMeasurement_Unit): ImageMeasurement_Unit object to save\n        dirpath (str): Directory to save the PNG files\n        resolution (float): Resolution percentage for the PNG files\n    \"\"\"\n    try:\n        stitched_img = unit.get_image_all_stitched(low_res=False)[0]\n        stitched_img.thumbnail((int(stitched_img.width*resolution/100), int(stitched_img.height*resolution/100)))\n        stitched_img.save(os.path.join(dirpath, f'{unit.get_IdName()[1]}.png'))\n        self.finished.emit(f'{self.msg_save_png} {unit.get_IdName()[1]}')\n    except Exception as e:\n        self.error.emit(str(e))\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image","title":"<code>Wdg_DataHub_Image</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>GUI to show all the data being stored in the ImageMeasurement_Hub and ImageMeasurement_Calibration_Hub. Modeled after the Frm_DataHub_Mapping class.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>class Wdg_DataHub_Image(qw.QWidget):\n    \"\"\"\n    GUI to show all the data being stored in the ImageMeasurement_Hub and ImageMeasurement_Calibration_Hub.\n    Modeled after the Frm_DataHub_Mapping class.\n    \"\"\"\n    sig_save = Signal(MeaImg_Hub, str, str)\n    sig_load = Signal(MeaImg_Hub, str)\n    sig_save_png = Signal(MeaImg_Unit, str, float)\n    sig_updateTree = Signal()\n\n    def __init__(self, main, getter_ImageHub: Callable[[], MeaImg_Hub]|None=None, **kwargs) -&gt; None:\n        \"\"\"\n        Initialize the Frame. The getters are used to get the ImageMeasurement_Hub and ImageMeasurement_Calibration_Hub\n        to update the data in the object when required. If none are provided, the default objects are created and these\n        updates will be unavailable.\n\n        Args:\n            main (tk.Tk|tk.Frame): Main window or frame\n            getter_ImageHub (Callable[[], ImageMeasurement_Hub]): Function to get the ImageMeasurement_Hub\n            width_rel (float): Relative width of the frame. Defaults to 1\n            height_rel (float): Relative height of the frame. Defaults to 1\n        \"\"\"\n        super().__init__(main, **kwargs)\n        self._getter_ImageHub = getter_ImageHub\n\n    # &gt;&gt;&gt; Top layout setup &lt;&lt;&lt;\n        self._widget = DataHub_Image_Design(self)\n        lyt = qw.QVBoxLayout(self)\n        lyt.addWidget(self._widget)\n        self.setLayout(lyt)\n        wdg = self._widget\n\n    # &gt;&gt;&gt; Hub setups &lt;&lt;&lt;\n        self.ImageHub = self._getter_ImageHub() \\\n            if self._getter_ImageHub is not None else MeaImg_Hub()\n\n        self.ImageHub.add_observer(self.sig_updateTree.emit)\n\n    # &gt;&gt;&gt; Save parameters setup &lt;&lt;&lt;\n        self._sessionid = get_timestamp_us_str()    # Session ID\n        self._flg_issaved = True    # Flag to indicate if the data is saved\n\n    # &gt;&gt;&gt; Treeview setup &lt;&lt;&lt;\n        self._tree = wdg.tree\n        self._tree.setColumnCount(4)\n        self._tree.setHeaderLabels(['Unit ID', 'Unit Name', '# Pictures', 'Metadata'])\n\n    # &gt;&gt;&gt; Other control widgets &lt;&lt;&lt;\n        # Widgets to manipulate the entries\n        self._btn_save = wdg.btn_save\n        self._btn_load = wdg.btn_load\n        self._btn_remove = wdg.btn_remove\n        self._btn_save_png = wdg.btn_save_png\n\n        self._btn_save.clicked.connect(lambda: self.save_ImageMeasurementHub())\n        self._btn_load.clicked.connect(lambda: self.load_ImageMeasurementHub())\n        self._btn_remove.clicked.connect(lambda: self.remove_selected_ImageMeasurementUnit())\n        self._btn_save_png.clicked.connect(lambda: self.export_selected_as_png())\n\n        self._txt_btn_save = self._btn_save.text()\n        self._txt_btn_load = self._btn_load.text()\n        self._txt_btn_remove = self._btn_remove.text()\n        self._txt_btn_save_png = self._btn_save_png.text()\n\n    # &gt;&gt;&gt; Worker setup &lt;&lt;&lt;\n        self._init_workers_and_signals()\n\n    def _init_workers_and_signals(self):\n        \"\"\"\n        Initialize the worker threads for saving and loading ImageMeasurement_Hub data.\n        \"\"\"\n        self._thread = QThread()\n        self._worker = Image_SaverLoader_Worker()\n        self._worker.moveToThread(self._thread)\n\n        self.sig_save.connect(self._worker.save_ImageMeasurementHub)\n        self.sig_load.connect(self._worker.load_ImageMeasurementHub)\n        self.sig_save_png.connect(self._worker.save_ImageMeasurementUnit_png)\n\n        self._worker.finished.connect(self.on_worker_finished)\n        self._worker.error.connect(lambda msg: qw.QMessageBox.critical(self, 'Error', msg))\n\n        self._thread.finished.connect(self._thread.deleteLater)\n        self._thread.finished.connect(self._worker.deleteLater)\n\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread.start)\n\n        # Signals\n        self.sig_updateTree.connect(self.update_tree)\n\n    def on_worker_finished(self, msg:str):\n        \"\"\"\n        Slot to handle the finished signal from the worker.\n\n        Args:\n            msg (str): Message from the worker\n        \"\"\"\n        if msg == self._worker.msg_save_db:\n            self._flg_issaved = True\n        elif msg == self._worker.msg_load_db:\n            self._flg_issaved = True\n            self.sig_updateTree.emit()\n\n        qw.QMessageBox.information(self, 'Success', msg)\n\n        self.reset_buttons()\n\n    def reset_buttons(self):\n        \"\"\"\n        Reset the button texts and states to their original values.\n        \"\"\"\n        self._btn_save.setEnabled(True)\n        self._btn_save.setText(self._txt_btn_save)\n\n        self._btn_load.setEnabled(True)\n        self._btn_load.setText(self._txt_btn_load)\n\n        self._btn_remove.setEnabled(True)\n        self._btn_remove.setText(self._txt_btn_remove)\n\n        self._btn_save_png.setEnabled(True)\n        self._btn_save_png.setText(self._txt_btn_save_png)\n\n    def disable_buttons(self):\n        \"\"\"\n        Disable all buttons in the frame.\n        \"\"\"\n        self._btn_save.setEnabled(False)\n        self._btn_load.setEnabled(False)\n        self._btn_remove.setEnabled(False)\n        self._btn_save_png.setEnabled(False)\n\n    def load_ImageMeasurementHub(self) -&gt; None:\n        \"\"\"\n        Load the ImageMeasurement_Hub data from the database file.\n        \"\"\"\n        self.disable_buttons()\n        self._btn_load.setText('Loading...')\n        file_path = qw.QFileDialog.getOpenFileName(self, 'Open Image Measurement Hub',\n                                                    filter='Database files (*.db)')[0]\n\n        if os.path.isfile(file_path) is False:\n            qw.QMessageBox.warning(self, 'Error', 'No file selected or file doesn\\'t exist.')\n            return\n\n        self._flg_issaved = True\n        self.sig_load.emit(self.ImageHub, file_path)\n\n    def save_ImageMeasurementHub(self) -&gt; None:\n        \"\"\"\n        Save the ImageMeasurement_Hub data to a database file.\n        \"\"\"\n        self.disable_buttons()\n        self._btn_save.setText('Saving to .db ...')\n        file_path = qw.QFileDialog.getSaveFileName(\n            self, 'Save Image Measurement Hub',\n            filter='Database files (*.db)'\n        )[0]\n\n        if not file_path: raise Exception('No file selected.')\n\n        initdir = os.path.dirname(file_path)\n        savename = os.path.basename(file_path)\n\n        self.sig_save.emit(self.ImageHub, initdir, savename)\n\n    def export_selected_as_png(self):\n        \"\"\"\n        Exports the selected ImageMeasurement_Units as PNG files.\n        \"\"\"\n        self.disable_buttons()\n        self._btn_save_png.setText('Saving to .png ...')\n\n        res = qw.QInputDialog.getDouble(\n            self, 'Export Resolution', 'Enter the resolution (percentage) for the PNG export:', 100, 0.1, 100, 1\n        )\n        if not res[1]: self.reset_buttons(); return\n\n        resolution = res[0]\n\n        # Prompt for the directory to save the PNG files\n        dirpath = qw.QFileDialog.getExistingDirectory(\n            self, 'Select the folder to save the PNG files'\n        )\n        if not os.path.isdir(dirpath):\n            qw.QMessageBox.critical(self, 'Error', 'Invalid folder selected.'); self.reset_buttons(); return\n\n        tree = self._tree\n        selections = tree.selectedItems()\n        if len(selections) == 0:\n            qw.QMessageBox.critical(self, 'Error', 'No entry selected.'); self.reset_buttons()\n            return\n\n        for item in selections:\n            unit_id = item.text(0)\n            unit = self.ImageHub.get_ImageMeasurementUnit(unit_id=unit_id)\n            self.sig_save_png.emit(unit, dirpath, resolution)\n\n    def append_ImageMeasurementUnit(self, unit:MeaImg_Unit, flg_nameprompt:bool=True):\n        \"\"\"\n        Appends the given ImageMeasurement_Unit to the ImageMeasurement_Hub and\n        update the treeview\n\n        Args:\n            unit (ImageMeasurement_Unit): ImageMeasurement_Unit object\n            flg_nameprompt (bool): Flag to prompt the user for the name of the unit. Defaults to True\n        \"\"\"\n        try:\n            if flg_nameprompt:\n                imgname = qw.QInputDialog.getText(\n                    self, 'Image Name', 'Enter the name of the image:'\n                )[0]\n\n                # Validation\n                if not imgname:\n                    raise ValueError('Image name cannot be empty.')\n                if imgname in self.ImageHub.get_list_ImageUnit_names():\n                    raise ValueError('Image name already exists in the hub.')\n\n                unit.set_name(imgname)\n            self.ImageHub.append_ImageMeasurementUnit(unit)\n            self._flg_issaved = False\n            self.sig_updateTree.emit()\n\n        except Exception as e:\n            qw.QMessageBox.warning(self, 'Error', str(e))\n            retry = qw.QMessageBox.question(\n                self, 'Retry', 'Do you want to retry adding the ImageMeasurement_Unit?',\n                qw.QMessageBox.Yes | qw.QMessageBox.No # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes/No exists\n            )\n            if retry == qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes exists\n                self.append_ImageMeasurementUnit(unit, True)\n\n    def remove_selected_ImageMeasurementUnit(self):\n        \"\"\"\n        Remove the selected ImageMeasurementUnit from the ImageMeasurement_Hub.\n        \"\"\"\n        tree = self._tree\n        selection = tree.selectedItems()\n        if len(selection) == 0:\n            qw.QMessageBox.warning(self, 'Error', 'No entry selected.')\n            return\n\n        for item in selection:\n            unit_id = item.text(0)\n            self.ImageHub.remove_ImageMeasurementUnit(unit_id)\n\n        self._flg_issaved = False\n        self.sig_updateTree.emit()\n\n    def get_ImageMeasurement_Hub(self) -&gt; MeaImg_Hub:\n        \"\"\"\n        Get the ImageMeasurement_Hub object.\n\n        Returns:\n            ImageMeasurement_Hub: ImageMeasurement_Hub object\n        \"\"\"\n        return self.ImageHub\n\n    def update_ImageMeasurementHub(self):\n        \"\"\"\n        Update the ImageMeasurement_Hub and ImageMeasurement_Calibration_Hub with the data from the getters.\n        \"\"\"\n        if self._getter_ImageHub is not None:\n            self.ImageHub = self._getter_ImageHub()\n\n        self._flg_issaved = False\n        self.sig_updateTree.emit()\n\n    @Slot()\n    def update_tree(self):\n        \"\"\"\n        Update the treeview widget with the data from the ImageMeasurement_Hub.\n        \"\"\"\n        tree = self._tree\n        tree.clear()\n\n        list_id, list_name, list_num_measurements, list_metadata = self.ImageHub.get_summary_units()\n\n        for id,name,num,meta in zip(list_id, list_name, list_num_measurements, list_metadata):\n            # Add to the treeview\n            item = qw.QTreeWidgetItem()\n            item.setText(0, str(id))\n            item.setText(1, str(name))\n            item.setText(2, str(num))\n            item.setText(3, str(meta))\n            tree.addTopLevelItem(item)\n\n    def check_safeToTerminate(self) -&gt; bool:\n        \"\"\"\n        Check if the data has been saved before terminating the app.\n\n        Returns:\n            bool: True if safe to terminate, False otherwise\n        \"\"\"\n        if self._flg_issaved: return True\n        elif len(self.ImageHub.get_list_ImageUnit_ids()) == 0: return True\n\n        flg_close = qw.QMessageBox.question(\n            self, 'Save Image Hub',\n            'There are unsaved changes to the Image Data Hub. Are you sure you want to exit without saving?',\n            qw.QMessageBox.Yes | qw.QMessageBox.Cancel, # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes/No/Cancel exists\n            qw.QMessageBox.Cancel # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Cancel exists\n        )\n\n        if flg_close == qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes exists\n            return True\n        else: # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.No exists\n            return False\n\n\n    def terminate(self):\n        \"\"\"\n        Termination protocol for the Image data hub.\n        \"\"\"\n        return\n\n    def test_generate_dummy(self):\n        \"\"\"\n        Generate dummy data for testing purposes.\n        \"\"\"\n        self.ImageHub.test_generate_dummy()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.__init__","title":"<code>__init__(main, getter_ImageHub=None, **kwargs)</code>","text":"<p>Initialize the Frame. The getters are used to get the ImageMeasurement_Hub and ImageMeasurement_Calibration_Hub to update the data in the object when required. If none are provided, the default objects are created and these updates will be unavailable.</p> <p>Parameters:</p> Name Type Description Default <code>main</code> <code>Tk | Frame</code> <p>Main window or frame</p> required <code>getter_ImageHub</code> <code>Callable[[], ImageMeasurement_Hub]</code> <p>Function to get the ImageMeasurement_Hub</p> <code>None</code> <code>width_rel</code> <code>float</code> <p>Relative width of the frame. Defaults to 1</p> required <code>height_rel</code> <code>float</code> <p>Relative height of the frame. Defaults to 1</p> required Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def __init__(self, main, getter_ImageHub: Callable[[], MeaImg_Hub]|None=None, **kwargs) -&gt; None:\n    \"\"\"\n    Initialize the Frame. The getters are used to get the ImageMeasurement_Hub and ImageMeasurement_Calibration_Hub\n    to update the data in the object when required. If none are provided, the default objects are created and these\n    updates will be unavailable.\n\n    Args:\n        main (tk.Tk|tk.Frame): Main window or frame\n        getter_ImageHub (Callable[[], ImageMeasurement_Hub]): Function to get the ImageMeasurement_Hub\n        width_rel (float): Relative width of the frame. Defaults to 1\n        height_rel (float): Relative height of the frame. Defaults to 1\n    \"\"\"\n    super().__init__(main, **kwargs)\n    self._getter_ImageHub = getter_ImageHub\n\n# &gt;&gt;&gt; Top layout setup &lt;&lt;&lt;\n    self._widget = DataHub_Image_Design(self)\n    lyt = qw.QVBoxLayout(self)\n    lyt.addWidget(self._widget)\n    self.setLayout(lyt)\n    wdg = self._widget\n\n# &gt;&gt;&gt; Hub setups &lt;&lt;&lt;\n    self.ImageHub = self._getter_ImageHub() \\\n        if self._getter_ImageHub is not None else MeaImg_Hub()\n\n    self.ImageHub.add_observer(self.sig_updateTree.emit)\n\n# &gt;&gt;&gt; Save parameters setup &lt;&lt;&lt;\n    self._sessionid = get_timestamp_us_str()    # Session ID\n    self._flg_issaved = True    # Flag to indicate if the data is saved\n\n# &gt;&gt;&gt; Treeview setup &lt;&lt;&lt;\n    self._tree = wdg.tree\n    self._tree.setColumnCount(4)\n    self._tree.setHeaderLabels(['Unit ID', 'Unit Name', '# Pictures', 'Metadata'])\n\n# &gt;&gt;&gt; Other control widgets &lt;&lt;&lt;\n    # Widgets to manipulate the entries\n    self._btn_save = wdg.btn_save\n    self._btn_load = wdg.btn_load\n    self._btn_remove = wdg.btn_remove\n    self._btn_save_png = wdg.btn_save_png\n\n    self._btn_save.clicked.connect(lambda: self.save_ImageMeasurementHub())\n    self._btn_load.clicked.connect(lambda: self.load_ImageMeasurementHub())\n    self._btn_remove.clicked.connect(lambda: self.remove_selected_ImageMeasurementUnit())\n    self._btn_save_png.clicked.connect(lambda: self.export_selected_as_png())\n\n    self._txt_btn_save = self._btn_save.text()\n    self._txt_btn_load = self._btn_load.text()\n    self._txt_btn_remove = self._btn_remove.text()\n    self._txt_btn_save_png = self._btn_save_png.text()\n\n# &gt;&gt;&gt; Worker setup &lt;&lt;&lt;\n    self._init_workers_and_signals()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.append_ImageMeasurementUnit","title":"<code>append_ImageMeasurementUnit(unit, flg_nameprompt=True)</code>","text":"<p>Appends the given ImageMeasurement_Unit to the ImageMeasurement_Hub and update the treeview</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>ImageMeasurement_Unit</code> <p>ImageMeasurement_Unit object</p> required <code>flg_nameprompt</code> <code>bool</code> <p>Flag to prompt the user for the name of the unit. Defaults to True</p> <code>True</code> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def append_ImageMeasurementUnit(self, unit:MeaImg_Unit, flg_nameprompt:bool=True):\n    \"\"\"\n    Appends the given ImageMeasurement_Unit to the ImageMeasurement_Hub and\n    update the treeview\n\n    Args:\n        unit (ImageMeasurement_Unit): ImageMeasurement_Unit object\n        flg_nameprompt (bool): Flag to prompt the user for the name of the unit. Defaults to True\n    \"\"\"\n    try:\n        if flg_nameprompt:\n            imgname = qw.QInputDialog.getText(\n                self, 'Image Name', 'Enter the name of the image:'\n            )[0]\n\n            # Validation\n            if not imgname:\n                raise ValueError('Image name cannot be empty.')\n            if imgname in self.ImageHub.get_list_ImageUnit_names():\n                raise ValueError('Image name already exists in the hub.')\n\n            unit.set_name(imgname)\n        self.ImageHub.append_ImageMeasurementUnit(unit)\n        self._flg_issaved = False\n        self.sig_updateTree.emit()\n\n    except Exception as e:\n        qw.QMessageBox.warning(self, 'Error', str(e))\n        retry = qw.QMessageBox.question(\n            self, 'Retry', 'Do you want to retry adding the ImageMeasurement_Unit?',\n            qw.QMessageBox.Yes | qw.QMessageBox.No # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes/No exists\n        )\n        if retry == qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes exists\n            self.append_ImageMeasurementUnit(unit, True)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.check_safeToTerminate","title":"<code>check_safeToTerminate()</code>","text":"<p>Check if the data has been saved before terminating the app.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if safe to terminate, False otherwise</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def check_safeToTerminate(self) -&gt; bool:\n    \"\"\"\n    Check if the data has been saved before terminating the app.\n\n    Returns:\n        bool: True if safe to terminate, False otherwise\n    \"\"\"\n    if self._flg_issaved: return True\n    elif len(self.ImageHub.get_list_ImageUnit_ids()) == 0: return True\n\n    flg_close = qw.QMessageBox.question(\n        self, 'Save Image Hub',\n        'There are unsaved changes to the Image Data Hub. Are you sure you want to exit without saving?',\n        qw.QMessageBox.Yes | qw.QMessageBox.Cancel, # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes/No/Cancel exists\n        qw.QMessageBox.Cancel # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Cancel exists\n    )\n\n    if flg_close == qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes exists\n        return True\n    else: # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.No exists\n        return False\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.disable_buttons","title":"<code>disable_buttons()</code>","text":"<p>Disable all buttons in the frame.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def disable_buttons(self):\n    \"\"\"\n    Disable all buttons in the frame.\n    \"\"\"\n    self._btn_save.setEnabled(False)\n    self._btn_load.setEnabled(False)\n    self._btn_remove.setEnabled(False)\n    self._btn_save_png.setEnabled(False)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.export_selected_as_png","title":"<code>export_selected_as_png()</code>","text":"<p>Exports the selected ImageMeasurement_Units as PNG files.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def export_selected_as_png(self):\n    \"\"\"\n    Exports the selected ImageMeasurement_Units as PNG files.\n    \"\"\"\n    self.disable_buttons()\n    self._btn_save_png.setText('Saving to .png ...')\n\n    res = qw.QInputDialog.getDouble(\n        self, 'Export Resolution', 'Enter the resolution (percentage) for the PNG export:', 100, 0.1, 100, 1\n    )\n    if not res[1]: self.reset_buttons(); return\n\n    resolution = res[0]\n\n    # Prompt for the directory to save the PNG files\n    dirpath = qw.QFileDialog.getExistingDirectory(\n        self, 'Select the folder to save the PNG files'\n    )\n    if not os.path.isdir(dirpath):\n        qw.QMessageBox.critical(self, 'Error', 'Invalid folder selected.'); self.reset_buttons(); return\n\n    tree = self._tree\n    selections = tree.selectedItems()\n    if len(selections) == 0:\n        qw.QMessageBox.critical(self, 'Error', 'No entry selected.'); self.reset_buttons()\n        return\n\n    for item in selections:\n        unit_id = item.text(0)\n        unit = self.ImageHub.get_ImageMeasurementUnit(unit_id=unit_id)\n        self.sig_save_png.emit(unit, dirpath, resolution)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.get_ImageMeasurement_Hub","title":"<code>get_ImageMeasurement_Hub()</code>","text":"<p>Get the ImageMeasurement_Hub object.</p> <p>Returns:</p> Name Type Description <code>ImageMeasurement_Hub</code> <code>MeaImg_Hub</code> <p>ImageMeasurement_Hub object</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def get_ImageMeasurement_Hub(self) -&gt; MeaImg_Hub:\n    \"\"\"\n    Get the ImageMeasurement_Hub object.\n\n    Returns:\n        ImageMeasurement_Hub: ImageMeasurement_Hub object\n    \"\"\"\n    return self.ImageHub\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.load_ImageMeasurementHub","title":"<code>load_ImageMeasurementHub()</code>","text":"<p>Load the ImageMeasurement_Hub data from the database file.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def load_ImageMeasurementHub(self) -&gt; None:\n    \"\"\"\n    Load the ImageMeasurement_Hub data from the database file.\n    \"\"\"\n    self.disable_buttons()\n    self._btn_load.setText('Loading...')\n    file_path = qw.QFileDialog.getOpenFileName(self, 'Open Image Measurement Hub',\n                                                filter='Database files (*.db)')[0]\n\n    if os.path.isfile(file_path) is False:\n        qw.QMessageBox.warning(self, 'Error', 'No file selected or file doesn\\'t exist.')\n        return\n\n    self._flg_issaved = True\n    self.sig_load.emit(self.ImageHub, file_path)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.on_worker_finished","title":"<code>on_worker_finished(msg)</code>","text":"<p>Slot to handle the finished signal from the worker.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>Message from the worker</p> required Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def on_worker_finished(self, msg:str):\n    \"\"\"\n    Slot to handle the finished signal from the worker.\n\n    Args:\n        msg (str): Message from the worker\n    \"\"\"\n    if msg == self._worker.msg_save_db:\n        self._flg_issaved = True\n    elif msg == self._worker.msg_load_db:\n        self._flg_issaved = True\n        self.sig_updateTree.emit()\n\n    qw.QMessageBox.information(self, 'Success', msg)\n\n    self.reset_buttons()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.remove_selected_ImageMeasurementUnit","title":"<code>remove_selected_ImageMeasurementUnit()</code>","text":"<p>Remove the selected ImageMeasurementUnit from the ImageMeasurement_Hub.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def remove_selected_ImageMeasurementUnit(self):\n    \"\"\"\n    Remove the selected ImageMeasurementUnit from the ImageMeasurement_Hub.\n    \"\"\"\n    tree = self._tree\n    selection = tree.selectedItems()\n    if len(selection) == 0:\n        qw.QMessageBox.warning(self, 'Error', 'No entry selected.')\n        return\n\n    for item in selection:\n        unit_id = item.text(0)\n        self.ImageHub.remove_ImageMeasurementUnit(unit_id)\n\n    self._flg_issaved = False\n    self.sig_updateTree.emit()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.reset_buttons","title":"<code>reset_buttons()</code>","text":"<p>Reset the button texts and states to their original values.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def reset_buttons(self):\n    \"\"\"\n    Reset the button texts and states to their original values.\n    \"\"\"\n    self._btn_save.setEnabled(True)\n    self._btn_save.setText(self._txt_btn_save)\n\n    self._btn_load.setEnabled(True)\n    self._btn_load.setText(self._txt_btn_load)\n\n    self._btn_remove.setEnabled(True)\n    self._btn_remove.setText(self._txt_btn_remove)\n\n    self._btn_save_png.setEnabled(True)\n    self._btn_save_png.setText(self._txt_btn_save_png)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.save_ImageMeasurementHub","title":"<code>save_ImageMeasurementHub()</code>","text":"<p>Save the ImageMeasurement_Hub data to a database file.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def save_ImageMeasurementHub(self) -&gt; None:\n    \"\"\"\n    Save the ImageMeasurement_Hub data to a database file.\n    \"\"\"\n    self.disable_buttons()\n    self._btn_save.setText('Saving to .db ...')\n    file_path = qw.QFileDialog.getSaveFileName(\n        self, 'Save Image Measurement Hub',\n        filter='Database files (*.db)'\n    )[0]\n\n    if not file_path: raise Exception('No file selected.')\n\n    initdir = os.path.dirname(file_path)\n    savename = os.path.basename(file_path)\n\n    self.sig_save.emit(self.ImageHub, initdir, savename)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.terminate","title":"<code>terminate()</code>","text":"<p>Termination protocol for the Image data hub.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Termination protocol for the Image data hub.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.test_generate_dummy","title":"<code>test_generate_dummy()</code>","text":"<p>Generate dummy data for testing purposes.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def test_generate_dummy(self):\n    \"\"\"\n    Generate dummy data for testing purposes.\n    \"\"\"\n    self.ImageHub.test_generate_dummy()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.update_ImageMeasurementHub","title":"<code>update_ImageMeasurementHub()</code>","text":"<p>Update the ImageMeasurement_Hub and ImageMeasurement_Calibration_Hub with the data from the getters.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def update_ImageMeasurementHub(self):\n    \"\"\"\n    Update the ImageMeasurement_Hub and ImageMeasurement_Calibration_Hub with the data from the getters.\n    \"\"\"\n    if self._getter_ImageHub is not None:\n        self.ImageHub = self._getter_ImageHub()\n\n    self._flg_issaved = False\n    self.sig_updateTree.emit()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_Image.update_tree","title":"<code>update_tree()</code>","text":"<p>Update the treeview widget with the data from the ImageMeasurement_Hub.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>@Slot()\ndef update_tree(self):\n    \"\"\"\n    Update the treeview widget with the data from the ImageMeasurement_Hub.\n    \"\"\"\n    tree = self._tree\n    tree.clear()\n\n    list_id, list_name, list_num_measurements, list_metadata = self.ImageHub.get_summary_units()\n\n    for id,name,num,meta in zip(list_id, list_name, list_num_measurements, list_metadata):\n        # Add to the treeview\n        item = qw.QTreeWidgetItem()\n        item.setText(0, str(id))\n        item.setText(1, str(name))\n        item.setText(2, str(num))\n        item.setText(3, str(meta))\n        tree.addTopLevelItem(item)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_ImgCal","title":"<code>Wdg_DataHub_ImgCal</code>","text":"<p>               Bases: <code>Ui_wdg_objectives</code>, <code>QWidget</code></p> <p>GUI to show all the ImageMeasurement_Calibration objs stored in the ImageMeasurement_Calibration_Hub. It has a combobox to show the available calibrations in a selected folder, and a button to load the calibration folder.</p> <p>Note: the term calibration and objective are used interchangeably in this object docstrings/attributes/methods.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>class Wdg_DataHub_ImgCal(Ui_wdg_objectives,qw.QWidget):\n    \"\"\"\n    GUI to show all the ImageMeasurement_Calibration objs stored in the ImageMeasurement_Calibration_Hub.\n    It has a combobox to show the available calibrations in a selected folder, and a button to load the\n    calibration folder.\n\n    Note: the term calibration and objective are used interchangeably in this object docstrings/attributes/methods.\n    \"\"\"\n\n    sig_update_combobox = Signal()\n\n    def __init__(self, main, getter_ImageCalHub:Callable[[], ImgMea_Cal_Hub]|None=None,\n                 *args, **kwargs) -&gt; None:\n        \"\"\"\n        Initialize the frame. The getter is used to get the ImageMeasurement_Calibration_Hub to update the data in the\n        object when required. Especially useful when creating an instance outside the controller (i.e., to connect with other\n        modules). If none is provided, the default object is created and these updates will be unavailable.\n\n        Args:\n            main (tk.Tk|tk.Frame): Main window or frame\n            getter_ImageCalHub (Callable[[], ImageMeasurement_Calibration_Hub]): Function to get the ImageMeasurement_Calibration_Hub\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        # Main attributes\n        self._getter_CalHub = getter_ImageCalHub\n        self._CalHub = self._getter_CalHub() if self._getter_CalHub is not None else ImgMea_Cal_Hub()\n\n        # List of the available calibrations\n        self._list_cals = []\n        self._empty_cal = ImgMea_Cal()\n        self._lastdirpath = None\n\n        # Setup the combobox and button\n        self._combo_cal = self.combo_objective\n\n        # Observers\n        self._list_observer_calibrationChange:list[Callable[[],None]] = []\n\n    def _init_signals(self):\n        \"\"\"\n        Initialize the signals for the frame.\n        \"\"\"\n        self._combo_cal.activated.connect(self._notify_observers_calibrationChange)\n        self._CalHub.add_observer(self.sig_update_combobox.emit)\n        self.sig_update_combobox.connect(self.update_combobox)\n\n    def add_observer_calibrationChange(self, func:Callable[[],None]) -&gt; None:\n        \"\"\"\n        Append an observer function to be called when the selected calibration changes.\n\n        Args:\n            func (Callable[[], None]): Function to be called when the selected calibration changes\n        \"\"\"\n        assert callable(func), 'Observer must be a callable function'\n\n        self._list_observer_calibrationChange.append(func)\n\n    def remove_observer_calibrationChange(self, func:Callable[[],None]) -&gt; None:\n        \"\"\"\n        Remove an observer function from the list.\n\n        Args:\n            func (Callable[[], None]): Function to be removed\n        \"\"\"\n        assert callable(func), 'Observer must be a callable function'\n        assert func in self._list_observer_calibrationChange, 'Function not found in observer list'\n\n        if func in self._list_observer_calibrationChange:\n            self._list_observer_calibrationChange.remove(func)\n\n    def _notify_observers_calibrationChange(self) -&gt; None:\n        \"\"\"\n        Notify all observer functions of a calibration change.\n        \"\"\"\n        for func in self._list_observer_calibrationChange:\n            try: func()\n            except Exception as e: print(f'Error notifying observer (ImgCal): {e}')\n\n    def get_ImageMeasurement_Calibration_Hub(self) -&gt; ImgMea_Cal_Hub:\n        \"\"\"\n        Get the ImageMeasurement_Calibration_Hub object.\n\n        Returns:\n            ImageMeasurement_Calibration_Hub: ImageMeasurement_Calibration_Hub object\n        \"\"\"\n        return self._CalHub\n\n    def get_selected_calibration(self) -&gt; ImgMea_Cal:\n        \"\"\"\n        Get the selected calibration from the combobox.\n\n        Returns:\n            ImageMeasurement_Calibration: Selected calibration object\n        \"\"\"\n        cal_id = self._combo_cal.currentText()\n        if cal_id: return self._CalHub.get_calibration(cal_id)\n        else: return self._empty_cal\n\n    def update_combobox(self) -&gt; None:\n        \"\"\"\n        Updates the combo box list of values based on the calibrations in the ImageMeasurement_Calibration_Hub.\n        \"\"\"\n        list_cals = self._CalHub.get_calibration_ids()\n\n        if list_cals == self._list_cals: return # No need to update\n\n        self._list_cals = list_cals.copy()\n\n        # Add the new itmes\n        self._combo_cal.setEditable(False)\n        self._combo_cal.clear()\n        self._combo_cal.addItems(self._list_cals)\n\n        if self._combo_cal.currentText() not in self._list_cals:\n            self._combo_cal.setCurrentIndex(0)\n            self._notify_observers_calibrationChange()\n\n    @Slot()\n    def _refresh_calibration_folder(self) -&gt; None:\n        \"\"\"\n        Refreshes the combobox list by re-scanning the calibration folder.\n\n        Args:\n            supp_msg (bool): Flag to suppress the success message. Defaults to False.\n        \"\"\"\n        if not self._lastdirpath:\n            qw.QMessageBox.warning(self, 'Error', 'No previously selected folder.'); return\n\n        try:\n            self._CalHub.load_calibrations(self._lastdirpath)\n            self.update_combobox()\n        except Exception as e:\n            qw.QMessageBox.critical(self, 'Error', str(e))\n        finally:\n            self._notify_observers_calibrationChange()\n\n    def _load_calibration_folder(self,dirpath:str|None=None,supp_msg:bool=False) -&gt; None:\n        \"\"\"\n        Prompts the user to select a folder containing the calibration files.\n\n        Args:\n            dirpath (str|None): Path to the folder, if none is provided, it will\n                prompt the user for one. Defaults to None.\n            supp_msg (bool): Flag to suppress the success message. Defaults to False.\n        \"\"\"\n        if dirpath is None:\n            initdir = LibraryConfigEnum.OBJECTIVE_CALIBRATION_DIR.value\n            initdir = initdir if os.path.isdir(initdir) else None\n            dirpath = qw.QFileDialog.getExistingDirectory(self, 'Select the objective folder', initdir or '')\n\n        if not os.path.isdir(dirpath) and not supp_msg: qw.QMessageBox.critical(self, 'Error', 'Invalid folder selected.'); return\n\n        self._lastdirpath = dirpath\n\n        try:\n            self._CalHub.load_calibrations(dirpath)\n            self.update_combobox()\n            if not supp_msg: qw.QMessageBox.information(self, 'Success', 'Calibration folder loaded successfully.')\n            print(f'Loaded calibration folder: {dirpath}')\n        except Exception as e:\n            if not supp_msg: qw.QMessageBox.critical(self, 'Error', str(e))\n            print(f'Error loading calibration folder: {e}')\n        finally:\n            self._notify_observers_calibrationChange()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_ImgCal.__init__","title":"<code>__init__(main, getter_ImageCalHub=None, *args, **kwargs)</code>","text":"<p>Initialize the frame. The getter is used to get the ImageMeasurement_Calibration_Hub to update the data in the object when required. Especially useful when creating an instance outside the controller (i.e., to connect with other modules). If none is provided, the default object is created and these updates will be unavailable.</p> <p>Parameters:</p> Name Type Description Default <code>main</code> <code>Tk | Frame</code> <p>Main window or frame</p> required <code>getter_ImageCalHub</code> <code>Callable[[], ImageMeasurement_Calibration_Hub]</code> <p>Function to get the ImageMeasurement_Calibration_Hub</p> <code>None</code> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def __init__(self, main, getter_ImageCalHub:Callable[[], ImgMea_Cal_Hub]|None=None,\n             *args, **kwargs) -&gt; None:\n    \"\"\"\n    Initialize the frame. The getter is used to get the ImageMeasurement_Calibration_Hub to update the data in the\n    object when required. Especially useful when creating an instance outside the controller (i.e., to connect with other\n    modules). If none is provided, the default object is created and these updates will be unavailable.\n\n    Args:\n        main (tk.Tk|tk.Frame): Main window or frame\n        getter_ImageCalHub (Callable[[], ImageMeasurement_Calibration_Hub]): Function to get the ImageMeasurement_Calibration_Hub\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.setupUi(self)\n    self.setLayout(self.main_layout)\n\n    # Main attributes\n    self._getter_CalHub = getter_ImageCalHub\n    self._CalHub = self._getter_CalHub() if self._getter_CalHub is not None else ImgMea_Cal_Hub()\n\n    # List of the available calibrations\n    self._list_cals = []\n    self._empty_cal = ImgMea_Cal()\n    self._lastdirpath = None\n\n    # Setup the combobox and button\n    self._combo_cal = self.combo_objective\n\n    # Observers\n    self._list_observer_calibrationChange:list[Callable[[],None]] = []\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_ImgCal.add_observer_calibrationChange","title":"<code>add_observer_calibrationChange(func)</code>","text":"<p>Append an observer function to be called when the selected calibration changes.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[], None]</code> <p>Function to be called when the selected calibration changes</p> required Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def add_observer_calibrationChange(self, func:Callable[[],None]) -&gt; None:\n    \"\"\"\n    Append an observer function to be called when the selected calibration changes.\n\n    Args:\n        func (Callable[[], None]): Function to be called when the selected calibration changes\n    \"\"\"\n    assert callable(func), 'Observer must be a callable function'\n\n    self._list_observer_calibrationChange.append(func)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_ImgCal.get_ImageMeasurement_Calibration_Hub","title":"<code>get_ImageMeasurement_Calibration_Hub()</code>","text":"<p>Get the ImageMeasurement_Calibration_Hub object.</p> <p>Returns:</p> Name Type Description <code>ImageMeasurement_Calibration_Hub</code> <code>ImgMea_Cal_Hub</code> <p>ImageMeasurement_Calibration_Hub object</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def get_ImageMeasurement_Calibration_Hub(self) -&gt; ImgMea_Cal_Hub:\n    \"\"\"\n    Get the ImageMeasurement_Calibration_Hub object.\n\n    Returns:\n        ImageMeasurement_Calibration_Hub: ImageMeasurement_Calibration_Hub object\n    \"\"\"\n    return self._CalHub\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_ImgCal.get_selected_calibration","title":"<code>get_selected_calibration()</code>","text":"<p>Get the selected calibration from the combobox.</p> <p>Returns:</p> Name Type Description <code>ImageMeasurement_Calibration</code> <code>ImgMea_Cal</code> <p>Selected calibration object</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def get_selected_calibration(self) -&gt; ImgMea_Cal:\n    \"\"\"\n    Get the selected calibration from the combobox.\n\n    Returns:\n        ImageMeasurement_Calibration: Selected calibration object\n    \"\"\"\n    cal_id = self._combo_cal.currentText()\n    if cal_id: return self._CalHub.get_calibration(cal_id)\n    else: return self._empty_cal\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_ImgCal.remove_observer_calibrationChange","title":"<code>remove_observer_calibrationChange(func)</code>","text":"<p>Remove an observer function from the list.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[], None]</code> <p>Function to be removed</p> required Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def remove_observer_calibrationChange(self, func:Callable[[],None]) -&gt; None:\n    \"\"\"\n    Remove an observer function from the list.\n\n    Args:\n        func (Callable[[], None]): Function to be removed\n    \"\"\"\n    assert callable(func), 'Observer must be a callable function'\n    assert func in self._list_observer_calibrationChange, 'Function not found in observer list'\n\n    if func in self._list_observer_calibrationChange:\n        self._list_observer_calibrationChange.remove(func)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.Wdg_DataHub_ImgCal.update_combobox","title":"<code>update_combobox()</code>","text":"<p>Updates the combo box list of values based on the calibrations in the ImageMeasurement_Calibration_Hub.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def update_combobox(self) -&gt; None:\n    \"\"\"\n    Updates the combo box list of values based on the calibrations in the ImageMeasurement_Calibration_Hub.\n    \"\"\"\n    list_cals = self._CalHub.get_calibration_ids()\n\n    if list_cals == self._list_cals: return # No need to update\n\n    self._list_cals = list_cals.copy()\n\n    # Add the new itmes\n    self._combo_cal.setEditable(False)\n    self._combo_cal.clear()\n    self._combo_cal.addItems(self._list_cals)\n\n    if self._combo_cal.currentText() not in self._list_cals:\n        self._combo_cal.setCurrentIndex(0)\n        self._notify_observers_calibrationChange()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.generate_dummy_frmImageHub","title":"<code>generate_dummy_frmImageHub(parent)</code>","text":"<p>Generate a dummy Frm_DataHub_Image for testing purposes.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent window or frame</p> required <p>Returns:</p> Name Type Description <code>Wdg_DataHub_Image</code> <code>Wdg_DataHub_Image</code> <p>Dummy Wdg_DataHub_Image object</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def generate_dummy_frmImageHub(parent:qw.QWidget) -&gt; Wdg_DataHub_Image:\n    \"\"\"\n    Generate a dummy Frm_DataHub_Image for testing purposes.\n\n    Args:\n        parent (qw.QWidget): Parent window or frame\n\n    Returns:\n        Wdg_DataHub_Image: Dummy Wdg_DataHub_Image object\n    \"\"\"\n    frm_imgHub = Wdg_DataHub_Image(parent)\n    frm_imgHub.test_generate_dummy()\n    return frm_imgHub\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.generate_dummy_frmImgCalHub","title":"<code>generate_dummy_frmImgCalHub(parent)</code>","text":"<p>Generate a dummy Frm_DataHub_ImgCal for testing purposes. Dummy calibrations are automatically generated.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent window or frame</p> required <p>Returns:</p> Name Type Description <code>Wdg_DataHub_ImgCal</code> <code>Wdg_DataHub_ImgCal</code> <p>Dummy Wdg_DataHub_ImgCal object</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def generate_dummy_frmImgCalHub(parent:qw.QWidget) -&gt; Wdg_DataHub_ImgCal:\n    \"\"\"\n    Generate a dummy Frm_DataHub_ImgCal for testing purposes.\n    Dummy calibrations are automatically generated.\n\n    Args:\n        parent (qw.QWidget): Parent window or frame\n\n    Returns:\n        Wdg_DataHub_ImgCal: Dummy Wdg_DataHub_ImgCal object\n    \"\"\"\n    frm_imgCal = Wdg_DataHub_ImgCal(parent)\n    frm_imgCal.get_ImageMeasurement_Calibration_Hub().generate_dummy_calibrations()\n    return frm_imgCal\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.test_DataHubImage","title":"<code>test_DataHubImage()</code>","text":"<p>Test the Wdg_DataHub_Image class.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def test_DataHubImage():\n    \"\"\"\n    Test the Wdg_DataHub_Image class.\n    \"\"\"\n    app = qw.QApplication([])\n    window = qw.QMainWindow()\n    window.setWindowTitle('Data Hub Image Test')\n    wdg = Wdg_DataHub_Image(window)\n    window.setCentralWidget(wdg)\n\n    wdg.test_generate_dummy()\n\n    window.show()\n    sys.exit(app.exec())\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.test_DataHub_ImgCal","title":"<code>test_DataHub_ImgCal()</code>","text":"<p>Test the Wdg_DataHub_ImgCal class.</p> Source code in <code>iris/gui/dataHub_MeaImg.py</code> <pre><code>def test_DataHub_ImgCal():\n    \"\"\"\n    Test the Wdg_DataHub_ImgCal class.\n    \"\"\"\n    app = qw.QApplication([])\n    window = qw.QMainWindow()\n    window.setWindowTitle('Data Hub Image Calibration Test')\n    wdg = Wdg_DataHub_ImgCal(window)\n    window.setCentralWidget(wdg)\n\n    window.show()\n    sys.exit(app.exec())\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaImg/#iris.gui.dataHub_MeaImg.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/","title":"dataHub_MeaRMap","text":"<p>A class that stores the all the measurement data in the current experiment. - Shows the stored data in a table format - Allows the user to add new data to the table - Allows the user to delete data from the table</p>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Save_worker","title":"<code>Save_worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>class Save_worker(QObject):\n\n    sig_save_done = Signal(str)\n    save_success = \"Saved the data successfully.\"\n    load_success = \"Loaded the data successfully.\"\n\n    def __init__(self, mapping_hub:MeaRMap_Hub):\n        super().__init__()\n        self._mappinghub = mapping_hub\n        self._handler = MeaRMap_Handler()\n\n        self._flg_issaved = True\n\n    @Slot(str,str)\n    def save_database(self,savedirpath:str,savename:str) -&gt; None:\n        \"\"\"\n        Save the MappingMeasurement_Hub stored internally to the local disk.\n\n        Args:\n            savedirpath (str): The directory path to save the database to\n            savename (str): The name of the database file\n        \"\"\"\n        try:\n            thread = MeaRMap_Handler().save_MappingHub_database(\n                mappingHub=self._mappinghub,\n                savedirpath=savedirpath,\n                savename=savename,\n            )\n            thread.join()\n            self._flg_issaved = True\n            self.sig_save_done.emit(self.save_success)\n        except Exception as e:\n            self.sig_save_done.emit(\"Error in saving Mapping Hub database:\\n\" + str(e))\n\n    @Slot(str, str, str)\n    def save_unit_ext(self, unit_id:str, savepath:str, extension:str) -&gt; None:\n        \"\"\"\n        Saves the selected MappingMeasurement_Unit in the treeview to a text file\n\n        Args:\n            unit_id (str): The ID of the MappingMeasurement_Unit to save\n            savepath (str): The path to save the file to\n            extension (str): The file extension to save as\n        \"\"\"\n        try:\n            flg_saveraw = True\n            filepath = os.path.abspath(savepath)\n            if not filepath.endswith(f\".{extension}\"):\n                filepath += f\".{extension}\"\n\n            unit = self._mappinghub.get_MappingUnit(unit_id)\n            thread = self._handler.save_MappingUnit_ext(\n                mappingUnit=unit,\n                filepath=filepath,\n                flg_saveraw=flg_saveraw,\n                extension=extension,\n            )\n            thread.join()\n            self.sig_save_done.emit(self.save_success)\n        except AssertionError as e:\n            self.sig_save_done.emit(\"Error in saving Mapping Unit to .txt:\\n\" + str(e))\n        except Exception as e:\n            self.sig_save_done.emit(\"Error in saving Mapping Unit to .txt:\\n\" + str(e))\n\n    @Slot(str)\n    def load_database(self, loadpath: str) -&gt; None:\n        \"\"\"\n        Load a MappingMeasurement_Hub from a database file\n        \"\"\"\n        try:\n            self._handler.load_MappingMeasurementHub_database(\n                self._mappinghub, loadpath=loadpath, flg_readraw=True)\n            self.sig_save_done.emit(self.load_success)\n        except Exception as e:\n            self.sig_save_done.emit(\"Error in loading Mapping Hub database:\\n\" + str(e))\n\n    def set_MappingHub(self, mappingHub:MeaRMap_Hub):\n        \"\"\"\n        Set the MappingMeasurement_Hub for the dataHub, which will be referred to for all the MappingMeasurement_Unit\n        retrieval and storage.\n\n        Args:\n            mappingHub (MappingMeasurement_Hub): The MappingMeasurement_Hub to set\n        \"\"\"\n        self._mappinghub = mappingHub\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Save_worker.load_database","title":"<code>load_database(loadpath)</code>","text":"<p>Load a MappingMeasurement_Hub from a database file</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>@Slot(str)\ndef load_database(self, loadpath: str) -&gt; None:\n    \"\"\"\n    Load a MappingMeasurement_Hub from a database file\n    \"\"\"\n    try:\n        self._handler.load_MappingMeasurementHub_database(\n            self._mappinghub, loadpath=loadpath, flg_readraw=True)\n        self.sig_save_done.emit(self.load_success)\n    except Exception as e:\n        self.sig_save_done.emit(\"Error in loading Mapping Hub database:\\n\" + str(e))\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Save_worker.save_database","title":"<code>save_database(savedirpath, savename)</code>","text":"<p>Save the MappingMeasurement_Hub stored internally to the local disk.</p> <p>Parameters:</p> Name Type Description Default <code>savedirpath</code> <code>str</code> <p>The directory path to save the database to</p> required <code>savename</code> <code>str</code> <p>The name of the database file</p> required Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>@Slot(str,str)\ndef save_database(self,savedirpath:str,savename:str) -&gt; None:\n    \"\"\"\n    Save the MappingMeasurement_Hub stored internally to the local disk.\n\n    Args:\n        savedirpath (str): The directory path to save the database to\n        savename (str): The name of the database file\n    \"\"\"\n    try:\n        thread = MeaRMap_Handler().save_MappingHub_database(\n            mappingHub=self._mappinghub,\n            savedirpath=savedirpath,\n            savename=savename,\n        )\n        thread.join()\n        self._flg_issaved = True\n        self.sig_save_done.emit(self.save_success)\n    except Exception as e:\n        self.sig_save_done.emit(\"Error in saving Mapping Hub database:\\n\" + str(e))\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Save_worker.save_unit_ext","title":"<code>save_unit_ext(unit_id, savepath, extension)</code>","text":"<p>Saves the selected MappingMeasurement_Unit in the treeview to a text file</p> <p>Parameters:</p> Name Type Description Default <code>unit_id</code> <code>str</code> <p>The ID of the MappingMeasurement_Unit to save</p> required <code>savepath</code> <code>str</code> <p>The path to save the file to</p> required <code>extension</code> <code>str</code> <p>The file extension to save as</p> required Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>@Slot(str, str, str)\ndef save_unit_ext(self, unit_id:str, savepath:str, extension:str) -&gt; None:\n    \"\"\"\n    Saves the selected MappingMeasurement_Unit in the treeview to a text file\n\n    Args:\n        unit_id (str): The ID of the MappingMeasurement_Unit to save\n        savepath (str): The path to save the file to\n        extension (str): The file extension to save as\n    \"\"\"\n    try:\n        flg_saveraw = True\n        filepath = os.path.abspath(savepath)\n        if not filepath.endswith(f\".{extension}\"):\n            filepath += f\".{extension}\"\n\n        unit = self._mappinghub.get_MappingUnit(unit_id)\n        thread = self._handler.save_MappingUnit_ext(\n            mappingUnit=unit,\n            filepath=filepath,\n            flg_saveraw=flg_saveraw,\n            extension=extension,\n        )\n        thread.join()\n        self.sig_save_done.emit(self.save_success)\n    except AssertionError as e:\n        self.sig_save_done.emit(\"Error in saving Mapping Unit to .txt:\\n\" + str(e))\n    except Exception as e:\n        self.sig_save_done.emit(\"Error in saving Mapping Unit to .txt:\\n\" + str(e))\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Save_worker.set_MappingHub","title":"<code>set_MappingHub(mappingHub)</code>","text":"<p>Set the MappingMeasurement_Hub for the dataHub, which will be referred to for all the MappingMeasurement_Unit retrieval and storage.</p> <p>Parameters:</p> Name Type Description Default <code>mappingHub</code> <code>MappingMeasurement_Hub</code> <p>The MappingMeasurement_Hub to set</p> required Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def set_MappingHub(self, mappingHub:MeaRMap_Hub):\n    \"\"\"\n    Set the MappingMeasurement_Hub for the dataHub, which will be referred to for all the MappingMeasurement_Unit\n    retrieval and storage.\n\n    Args:\n        mappingHub (MappingMeasurement_Hub): The MappingMeasurement_Hub to set\n    \"\"\"\n    self._mappinghub = mappingHub\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping","title":"<code>Wdg_DataHub_Mapping</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>class Wdg_DataHub_Mapping(qw.QWidget):\n\n    _sig_modify_tree = Signal()     # Emitted when the treeview needs to be modified (internal)\n    sig_tree_changed = Signal()     # Emitted when the treeview is changed\n    sig_tree_selection = Signal()   # Emitted when the treeview selection is changed\n    sig_tree_selection_str = Signal(str)   # Emitted when the treeview selection is changed, with the selected unit name as argument\n\n    sig_save_ext = Signal(str,str,str)  # Emitted to save the selected MappingMeasurement_Unit externally\n    sig_save_db = Signal(str,str)       # Emitted to save the MappingMeasurement_Hub to the database\n    sig_load_db = Signal(str)           # Emitted to load the MappingMeasurement_Hub from the database\n\n    def __init__(self, parent:Any, mappingHub:MeaRMap_Hub|None=None,autosave:bool=False):\n        \"\"\"\n        Initialises the data hub frame. This frame stores all the data from the measurement session.\n\n        Args:\n            parent (Any): The parent widget\n            mappingHub (MeaRMap_Hub|None): The MappingMeasurement_Hub instance. Defaults to None.\n            autosave (bool, optional): If True, will enable autosaving of the MappingMeasurement_Hub. Defaults to False.\n\n        Note: mappingHub will be used during the refresh callback to get the latest MappingMeasurement_Hub.\n        \"\"\"\n        super().__init__(parent)\n        # Main GUI setup\n        lyt = qw.QVBoxLayout()\n        self.setLayout(lyt)\n        self._widget = Wdg_DataHub_Mapping_Ui(self)\n        lyt.addWidget(self._widget)\n        wdg = self._widget\n\n        # Storage to store the data\n        if isinstance(mappingHub, MeaRMap_Hub): self._MappingHub = mappingHub\n        else: self._MappingHub = MeaRMap_Hub()\n        # Defer observer registration to prevent signals during initialization\n        QTimer.singleShot(0, lambda: self._MappingHub.add_observer(self._sig_modify_tree.emit))\n\n        # Save parameters\n        self._sessionid = get_timestamp_us_str()\n        self._flg_issaved = True   # Indicate if the stored data has been saved\n        self._list_pickled = []    # List of pickled files\n        self._temp_savedir = SaveParamsEnum.DEFAULT_SAVE_PATH.value + r'\\temp'\n        if not os.path.exists(self._temp_savedir): os.makedirs(self._temp_savedir)\n\n        # Widgets to show the stored data\n        self._tree = wdg.tree_data\n        self._tree.setColumnCount(3)\n        self._tree.setHeaderLabels([\"Region of interest name\", \"Metadata\", \"Number of samplings\"])\n\n        # Set up the searchbar\n        wdg.ent_searchbar.textChanged.connect(lambda: self.update_tree(keep_selection=False))\n\n        # Widgets to manipulate entries\n        wdg.btn_refresh.clicked.connect(self.update_tree)\n        wdg.btn_rename.clicked.connect(self.rename_unit)\n        wdg.btn_delete.clicked.connect(self.delete_unit)\n        self._btn_save_ext = wdg.btn_save_ext\n        self._btn_save_db = wdg.btn_save_db\n        self._btn_load_db = wdg.btn_load_db\n\n        self._btn_save_ext_ori = self._btn_save_ext.text()\n        self._btn_save_db_ori = self._btn_save_db.text()\n        self._btn_load_MappingHub_ori = self._btn_load_db.text()\n\n        # Other connection setups\n        self._tree.itemSelectionChanged.connect(self._emit_signal_selection)\n\n    # &gt; Save/load worker and thread setup &lt;\n        self._save_worker = Save_worker(self._MappingHub)\n        self._thread_save = QThread(self)\n        self._save_worker.moveToThread(self._thread_save)\n        self.destroyed.connect(self._thread_save.quit)\n        self.destroyed.connect(self._save_worker.deleteLater)\n        self.destroyed.connect(self._thread_save.deleteLater)\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread_save.start)\n\n        # Button connection setup\n        self._btn_save_ext.clicked.connect(self._save_unit_ext)\n        self._btn_save_db.clicked.connect(self._save_hub_database)\n        self._btn_load_db.clicked.connect(self._load_hub_database)\n\n        self._save_worker.sig_save_done.connect(self._reset_reenable_saveload_buttons)\n        self.sig_save_ext.connect(self._save_worker.save_unit_ext)\n        self.sig_save_db.connect(self._save_worker.save_database)\n        self.sig_load_db.connect(self._save_worker.load_database)\n\n        # Other connection setup\n        self._save_worker.sig_save_done.connect(self._handle_saveload_result)\n        self._sig_modify_tree.connect(self.update_tree)\n\n    # &gt; Autosave info &lt;\n        # Autosave parameters\n        self._autosave_path = os.path.abspath(SaveParamsEnum.AUTOSAVE_PATH.value)\n        if not os.path.exists(self._autosave_path): os.makedirs(self._autosave_path)\n\n        # Autosave widgets\n        self._flg_autosave = SaveParamsEnum.AUTOSAVE_ENABLED.value and autosave\n        self._autosave_interval = SaveParamsEnum.AUTOSAVE_INTERVAL_HOURS.value\n        if self._autosave_interval &lt;= 0.0: self._flg_autosave = False\n        if self._flg_autosave:\n            wdg.lbl_autosave.setText(f'Autosave: every {self._autosave_interval} hours to\\n{self._autosave_path}')\n\n    @Slot()\n    def _emit_signal_selection(self):\n        \"\"\"\n        Emit the selection changed signal with the selected unit name\n        \"\"\"\n        selections = self._tree.selectedItems()\n        if len(selections) == 0:\n            self.sig_tree_selection_str.emit(\"\")\n        else:\n            unit_name = selections[0].text(0)\n            self.sig_tree_selection_str.emit(unit_name)\n\n        self.sig_tree_selection.emit()\n\n    def get_tree(self) -&gt; qw.QTreeWidget:\n        return self._tree\n\n    def get_selected_MappingUnit(self) -&gt; list[MeaRMap_Unit]:\n        \"\"\"\n        Returns the selected MappingMeasurement_Unit in the treeview\n\n        Returns:\n            list[MappingMeasurement_Unit]: The selected MappingMeasurement_Unit\n        \"\"\"\n        selections = self._tree.selectedItems()\n\n        list_units = []\n        for item in selections:\n            unit_name = item.text(0)\n            try: unit = self._MappingHub.get_MappingUnit(unit_name=unit_name)\n            except ValueError: continue\n            list_units.append(unit)\n\n        return list_units\n\n    def get_MappingHub(self) -&gt; MeaRMap_Hub:\n        return self._MappingHub\n\n    def _filter_by_search(self) -&gt; list[str]:\n        \"\"\"\n        Filters the treeview items based on the search query.\n\n        Returns:\n            list[str]: The filtered list of unit IDs\n        \"\"\"\n        search_query = self._widget.ent_searchbar.text().lower()\n        dict_unit_IdNames = {unit.get_unit_id(): unit.get_unit_name().lower()\\\n            for unit in self._MappingHub.get_list_MappingUnit()}\n        list_unit_ids = self._MappingHub.get_list_MappingUnit_ids()\n\n        # Return all if the search query is empty\n        if not search_query or search_query == \"\":\n            return list_unit_ids\n\n        # Perform fuzzy matching on the unit names\n        list_matches = process.extract(\n            search_query, dict_unit_IdNames.values(), scorer=fuzz.partial_token_set_ratio, limit=None)\n        list_matches = sorted(list_matches, key=lambda x: x[1], reverse=True)\n\n        list_matches_id = [\n            unit_id\n            for name, _ in list_matches\n            for unit_id, unit_name in dict_unit_IdNames.items()\n            if unit_name == name\n        ]\n\n        return list_matches_id\n\n    @Slot()\n    def update_tree(self, keep_selection:bool=True):\n        # Store the current selections\n        list_unitID = [unit.get_unit_id() for unit in self.get_selected_MappingUnit()]\n        list_matched_ids = self._filter_by_search()\n\n        self._tree.clear()\n        list_unit_ids, list_unit_names, list_metadata, list_num_measurements = self._MappingHub.get_summary_units()\n\n        for unit_id in list_matched_ids:\n            idx = list_unit_ids.index(unit_id)\n            qw.QTreeWidgetItem(self._tree,\n                [list_unit_names[idx], str(list_metadata[idx]), str(list_num_measurements[idx])])\n\n        # Set the selection back to the previous selection\n        if keep_selection: self.set_selection_unitID(list_unitID)\n\n        self.sig_tree_changed.emit()\n\n    def set_selection_unitID(self, list_unitID:list[str]|str, clear_previous:bool=True):\n        \"\"\"\n        Sets the selection in the treeview to the given unit IDs.\n\n        Args:\n            list_unitID (list[str]|str): The list of unit IDs to select or a single unit ID.\n            clear_previous (bool): Whether to clear the previous selection.\n        \"\"\"\n        if not isinstance(list_unitID, list): list_unitID = [list_unitID]\n        list_name = [self._MappingHub.get_MappingUnit(unit_id).get_unit_name() for unit_id in list_unitID]\n\n        self._tree.blockSignals(True)\n\n        if clear_previous: self._tree.clearSelection()\n\n        # Get the invisible root item (parent of all top-level items)\n        root = self._tree.invisibleRootItem()\n\n        # Iterate through all top-level items\n        for i in range(root.childCount()):\n            item = root.child(i)\n            unit_name_in_tree = item.text(0) \n\n            # Check if the item's ID is in our target list\n            if unit_name_in_tree in list_name: item.setSelected(True) \n\n        self._tree.blockSignals(False)\n\n        self.sig_tree_selection.emit()\n\n    @Slot(str)\n    def set_selection_unitName(self, unit_name:str):\n        \"\"\"\n        Sets the selection in the treeview to the given unit name.\n\n        Args:\n            unit_name (str): The unit name to select.\n        \"\"\"\n        list_names = self._MappingHub.get_list_MappingUnit_names()\n        if not unit_name in list_names: return\n        unit = self._MappingHub.get_MappingUnit(unit_name=unit_name)\n        self.set_selection_unitID(unit.get_unit_id())\n\n    def append_MappingUnit(self, unit: MeaRMap_Unit, persist:bool=True):\n        \"\"\"\n        Append a MappingMeasurement_Unit to the MappingMeasurement_Hub\n\n        Args:\n            unit (MappingMeasurement_Unit): The unit to append\n            persist (bool, optional): If True, will ask for a new unit ID. Defaults to True.\n        \"\"\"\n        while True:\n            try:\n                self._MappingHub.append_mapping_unit(unit)\n                self._flg_issaved = False\n                self.update_tree()\n                break\n            except FileExistsError as e:\n                if not persist: qw.QErrorMessage().showMessage(\"Unit ID already exists:\\n\" + str(e)); break\n                new_unitName, ok = qw.QInputDialog.getText(\n                    None, \"Unit name already exists\", \"Unit name already exists!\\nEnter a new 'unit name':\",\n                    text=unit.get_unit_name())\n                if ok: unit.set_unitName_and_unitID(new_unitName)\n                else: break\n\n        self._sig_modify_tree.emit()\n\n    def extend_MappingUnit(self, list_unit:list[MeaRMap_Unit], persist:bool=True):\n        \"\"\"\n        Extend a MappingMeasurement_Unit in the MappingMeasurement_Hub\n\n        Args:\n            list_unit (list[MappingMeasurement_Unit]): The unit to extend\n            persist (bool, optional): If True, will ask for a new unit ID if the unit ID does not exist. Defaults to True.\n        \"\"\"\n        for unit in list_unit: self.append_MappingUnit(unit, persist=persist)\n\n    def rename_unit(self):\n        \"\"\"\n        Rename the selected MappingMeasurement_Unit in the MappingMeasurement_Hub\n        \"\"\"\n        try:\n            selections = self._tree.selectedItems()\n\n            if len(selections) == 0:\n                qw.QErrorMessage().showMessage(\"No unit selected\")\n                return\n            elif len(selections) &gt; 1:\n                qw.QErrorMessage().showMessage(\"Multiple units selected. Please select only one unit to rename\")\n                return\n\n            unit_name = selections[0].text(0)\n            unit = self._MappingHub.get_MappingUnit(unit_name=unit_name)\n            new_name, ok = qw.QInputDialog.getText(None, \"Rename Mapping Unit\", \"Enter the new name for the selected Mapping Unit:\",\n                                                    text=unit.get_unit_name())\n            if ok: self._MappingHub.rename_mapping_unit(unit_name, new_name)\n            self._flg_issaved = False\n        except Exception as e: qw.QErrorMessage().showMessage(\"Error in renaming the Mapping Unit\\n\" + str(e))\n        finally: self._sig_modify_tree.emit()\n\n    def delete_unit(self):\n        \"\"\"\n        Delete the selected MappingMeasurement_Unit from the MappingMeasurement_Hub\n        \"\"\"\n        # Get the currently selected units\n        selections = self._tree.selectedItems()\n\n        if len(selections) == 0:\n            qw.QErrorMessage().showMessage(\"No unit selected\")\n            return\n\n        flg_remove = qw.QMessageBox.question(\n            None,\n            \"Mapping Unit deletion\",\n            \"Are you sure you want to delete the selected units?\"\n            \"\\n!!! This action cannot be undone !!!\",\n            qw.QMessageBox.Yes | qw.QMessageBox.No, qw.QMessageBox.No) # type: ignore\n        if flg_remove != qw.QMessageBox.Yes: return  # type: ignore\n\n        list_names = [item.text(0) for item in selections]\n        for unit_name in list_names:\n            self._MappingHub.remove_mapping_unit_name(unit_name)\n\n        if len(selections) &gt; 0: self._flg_issaved = False\n        self._sig_modify_tree.emit()\n\n    @Slot()\n    def _save_unit_ext(self) -&gt; None:\n        \"\"\"\n        Save the selected MappingMeasurement_Unit in the treeview to a text file\n        \"\"\"\n        self._btn_save_ext.setEnabled(False)\n        self._btn_save_ext.setText(\"Saving...\")\n\n        list_units = self.get_selected_MappingUnit()\n        list_ids = [unit.get_unit_id() for unit in list_units]\n\n        if len(list_ids) != 1:\n            qw.QErrorMessage().showMessage(\"Please select only one unit to save\")\n            self._reset_reenable_saveload_buttons()\n            return\n\n        dict_ext_options = MeaRMap_Handler().get_dict_extensions()\n        save_path, save_ext = qw.QFileDialog.getSaveFileName(\n            None,\n            \"Save Mapping Unit as...\",\n            \"\",\n            \";;\".join([f\"{value.upper()} files (*.{key})\" for key,value in dict_ext_options.items()]),\n        )\n        save_ext = save_ext.split('(')[1].split('*.')[1].split(')')[0]\n\n        self.sig_save_ext.emit(list_ids[0], save_path, save_ext)\n\n    @Slot()\n    def _save_hub_database(self) -&gt; None:\n        \"\"\"\n        Save the MappingMeasurement_Hub stored internally to the local disk as a database\n        \"\"\"\n        self._btn_save_db.setEnabled(False)\n        self._btn_save_db.setText(\"Saving...\")\n\n        savepath = qw.QFileDialog.getSaveFileName(\n            None,\n            \"Save Mapping Hub database...\",\n            \"\",\n            \"Database files (*.db)\"\n        )[0]\n\n        savedirpath, savename = os.path.split(savepath)\n        self.sig_save_db.emit(savedirpath, savename)\n\n    @Slot()\n    def _load_hub_database(self) -&gt; None:\n        \"\"\"\n        Load a MappingMeasurement_Hub from a database file\n        \"\"\"\n        self._btn_load_db.setEnabled(False)\n        self._btn_load_db.setText(\"Loading...\")\n\n        loadpath = qw.QFileDialog.getOpenFileName(\n            None,\n            \"Load Mapping Hub database...\",\n            \"\",\n            \"Database files (*.db)\"\n        )[0]\n\n        self.sig_load_db.emit(loadpath)\n\n    @Slot()\n    def _disable_saveload_buttons(self):\n        list_widgets = get_all_widgets_from_layout(self._widget.lyt_saveload)\n        list_buttons = [wdg for wdg in list_widgets if isinstance(wdg, qw.QPushButton)]\n\n        for wdg in list_buttons: wdg.setEnabled(False)\n\n    @Slot()\n    def _reset_reenable_saveload_buttons(self):\n        list_widgets = get_all_widgets_from_layout(self._widget.lyt_saveload)\n        list_buttons = [wdg for wdg in list_widgets if isinstance(wdg, qw.QPushButton)]\n\n        for wdg in list_buttons:\n            wdg.setEnabled(True)\n            if wdg == self._btn_save_ext: wdg.setText(self._btn_save_ext_ori)\n            elif wdg == self._btn_save_db: wdg.setText(self._btn_save_db_ori)\n            elif wdg == self._btn_load_db: wdg.setText(self._btn_load_MappingHub_ori)\n            wdg.setStyleSheet(\"\")\n\n    @Slot(str)\n    def _handle_saveload_result(self, message:str):\n        \"\"\"\n        Handle the result of the save/load operation\n\n        Args:\n            message (str): The message to display\n        \"\"\"\n        if message != Save_worker.save_success and message != Save_worker.load_success:\n            qw.QErrorMessage().showMessage(message)\n        else: qw.QMessageBox.information(None, \"Save/Load operation\", message)\n        self._reset_reenable_saveload_buttons()\n        self._sig_modify_tree.emit()\n\n    def _handle_hub_change(self):\n        \"\"\"\n        Handle changes in the MappingMeasurement_Hub\n        \"\"\"\n        self._flg_issaved = False\n        self._sig_modify_tree.emit()\n\n    def append_RamanMeasurement_multi(self, measurement:MeaRaman, coor:tuple=(0,0,0)):\n        \"\"\"\n        Append a RamanMeasurement to the MappingMeasurement_Hub by assigning it to a unit.\n\n        Args:\n            measurement (RamanMeasurement): The RamanMeasurement to append\n            coor (tuple, optional): The coordinates of the measurement. Defaults to (0,0,0).\n        \"\"\"\n        # Mapping ID request and check\n        unit_name = None\n        while unit_name == None:\n            unit_name = messagebox_request_input(\n                parent=self,\n                title= \"Unit ID\",\n                message=\"Enter the ID for the added Raman measurement:\",\n                default=f\"Single point measurement at {coor}: \",\n                )\n            if isinstance(unit_name,str) and not unit_name == '': break\n\n        unit = MeaRMap_Unit(unit_name=unit_name)\n\n        timestamp = measurement.get_latest_timestamp()\n        unit.append_ramanmeasurement_data(timestamp=timestamp, coor=coor, measurement=measurement)\n\n        self.append_MappingUnit(unit)\n\n    def check_safeToTerminate(self) -&gt; bool:\n        \"\"\"\n        Check if the data has been saved before terminating the app.\n\n        Returns:\n            bool: True if the app can be terminated, False otherwise\n        \"\"\"\n        if self._flg_issaved: return True\n        elif len(self._MappingHub.get_list_MappingUnit()) == 0: return True\n\n        flg_close = qw.QMessageBox.question(\n            None,\n            \"Unsaved data\",\n            \"There is unsaved data in the Mapping Hub.\\nAre you sure you want to exit without saving?\",\n            qw.QMessageBox.Yes | qw.QMessageBox.Cancel, # pyright: ignore[reportAttributeAccessIssue]\n            qw.QMessageBox.Cancel) # type: ignore\n\n        if flg_close == qw.QMessageBox.Yes:   # type: ignore\n            return True\n        else:\n            return False\n\n    def terminate(self):\n        \"\"\"\n        App termination sequence:\n        Force the user to save the data before closing the app\n        \"\"\"\n        return\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.__init__","title":"<code>__init__(parent, mappingHub=None, autosave=False)</code>","text":"<p>Initialises the data hub frame. This frame stores all the data from the measurement session.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Any</code> <p>The parent widget</p> required <code>mappingHub</code> <code>MeaRMap_Hub | None</code> <p>The MappingMeasurement_Hub instance. Defaults to None.</p> <code>None</code> <code>autosave</code> <code>bool</code> <p>If True, will enable autosaving of the MappingMeasurement_Hub. Defaults to False.</p> <code>False</code> <p>Note: mappingHub will be used during the refresh callback to get the latest MappingMeasurement_Hub.</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def __init__(self, parent:Any, mappingHub:MeaRMap_Hub|None=None,autosave:bool=False):\n    \"\"\"\n    Initialises the data hub frame. This frame stores all the data from the measurement session.\n\n    Args:\n        parent (Any): The parent widget\n        mappingHub (MeaRMap_Hub|None): The MappingMeasurement_Hub instance. Defaults to None.\n        autosave (bool, optional): If True, will enable autosaving of the MappingMeasurement_Hub. Defaults to False.\n\n    Note: mappingHub will be used during the refresh callback to get the latest MappingMeasurement_Hub.\n    \"\"\"\n    super().__init__(parent)\n    # Main GUI setup\n    lyt = qw.QVBoxLayout()\n    self.setLayout(lyt)\n    self._widget = Wdg_DataHub_Mapping_Ui(self)\n    lyt.addWidget(self._widget)\n    wdg = self._widget\n\n    # Storage to store the data\n    if isinstance(mappingHub, MeaRMap_Hub): self._MappingHub = mappingHub\n    else: self._MappingHub = MeaRMap_Hub()\n    # Defer observer registration to prevent signals during initialization\n    QTimer.singleShot(0, lambda: self._MappingHub.add_observer(self._sig_modify_tree.emit))\n\n    # Save parameters\n    self._sessionid = get_timestamp_us_str()\n    self._flg_issaved = True   # Indicate if the stored data has been saved\n    self._list_pickled = []    # List of pickled files\n    self._temp_savedir = SaveParamsEnum.DEFAULT_SAVE_PATH.value + r'\\temp'\n    if not os.path.exists(self._temp_savedir): os.makedirs(self._temp_savedir)\n\n    # Widgets to show the stored data\n    self._tree = wdg.tree_data\n    self._tree.setColumnCount(3)\n    self._tree.setHeaderLabels([\"Region of interest name\", \"Metadata\", \"Number of samplings\"])\n\n    # Set up the searchbar\n    wdg.ent_searchbar.textChanged.connect(lambda: self.update_tree(keep_selection=False))\n\n    # Widgets to manipulate entries\n    wdg.btn_refresh.clicked.connect(self.update_tree)\n    wdg.btn_rename.clicked.connect(self.rename_unit)\n    wdg.btn_delete.clicked.connect(self.delete_unit)\n    self._btn_save_ext = wdg.btn_save_ext\n    self._btn_save_db = wdg.btn_save_db\n    self._btn_load_db = wdg.btn_load_db\n\n    self._btn_save_ext_ori = self._btn_save_ext.text()\n    self._btn_save_db_ori = self._btn_save_db.text()\n    self._btn_load_MappingHub_ori = self._btn_load_db.text()\n\n    # Other connection setups\n    self._tree.itemSelectionChanged.connect(self._emit_signal_selection)\n\n# &gt; Save/load worker and thread setup &lt;\n    self._save_worker = Save_worker(self._MappingHub)\n    self._thread_save = QThread(self)\n    self._save_worker.moveToThread(self._thread_save)\n    self.destroyed.connect(self._thread_save.quit)\n    self.destroyed.connect(self._save_worker.deleteLater)\n    self.destroyed.connect(self._thread_save.deleteLater)\n    # Defer thread start until after initialization is complete\n    QTimer.singleShot(0, self._thread_save.start)\n\n    # Button connection setup\n    self._btn_save_ext.clicked.connect(self._save_unit_ext)\n    self._btn_save_db.clicked.connect(self._save_hub_database)\n    self._btn_load_db.clicked.connect(self._load_hub_database)\n\n    self._save_worker.sig_save_done.connect(self._reset_reenable_saveload_buttons)\n    self.sig_save_ext.connect(self._save_worker.save_unit_ext)\n    self.sig_save_db.connect(self._save_worker.save_database)\n    self.sig_load_db.connect(self._save_worker.load_database)\n\n    # Other connection setup\n    self._save_worker.sig_save_done.connect(self._handle_saveload_result)\n    self._sig_modify_tree.connect(self.update_tree)\n\n# &gt; Autosave info &lt;\n    # Autosave parameters\n    self._autosave_path = os.path.abspath(SaveParamsEnum.AUTOSAVE_PATH.value)\n    if not os.path.exists(self._autosave_path): os.makedirs(self._autosave_path)\n\n    # Autosave widgets\n    self._flg_autosave = SaveParamsEnum.AUTOSAVE_ENABLED.value and autosave\n    self._autosave_interval = SaveParamsEnum.AUTOSAVE_INTERVAL_HOURS.value\n    if self._autosave_interval &lt;= 0.0: self._flg_autosave = False\n    if self._flg_autosave:\n        wdg.lbl_autosave.setText(f'Autosave: every {self._autosave_interval} hours to\\n{self._autosave_path}')\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.append_MappingUnit","title":"<code>append_MappingUnit(unit, persist=True)</code>","text":"<p>Append a MappingMeasurement_Unit to the MappingMeasurement_Hub</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>MappingMeasurement_Unit</code> <p>The unit to append</p> required <code>persist</code> <code>bool</code> <p>If True, will ask for a new unit ID. Defaults to True.</p> <code>True</code> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def append_MappingUnit(self, unit: MeaRMap_Unit, persist:bool=True):\n    \"\"\"\n    Append a MappingMeasurement_Unit to the MappingMeasurement_Hub\n\n    Args:\n        unit (MappingMeasurement_Unit): The unit to append\n        persist (bool, optional): If True, will ask for a new unit ID. Defaults to True.\n    \"\"\"\n    while True:\n        try:\n            self._MappingHub.append_mapping_unit(unit)\n            self._flg_issaved = False\n            self.update_tree()\n            break\n        except FileExistsError as e:\n            if not persist: qw.QErrorMessage().showMessage(\"Unit ID already exists:\\n\" + str(e)); break\n            new_unitName, ok = qw.QInputDialog.getText(\n                None, \"Unit name already exists\", \"Unit name already exists!\\nEnter a new 'unit name':\",\n                text=unit.get_unit_name())\n            if ok: unit.set_unitName_and_unitID(new_unitName)\n            else: break\n\n    self._sig_modify_tree.emit()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.append_RamanMeasurement_multi","title":"<code>append_RamanMeasurement_multi(measurement, coor=(0, 0, 0))</code>","text":"<p>Append a RamanMeasurement to the MappingMeasurement_Hub by assigning it to a unit.</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>RamanMeasurement</code> <p>The RamanMeasurement to append</p> required <code>coor</code> <code>tuple</code> <p>The coordinates of the measurement. Defaults to (0,0,0).</p> <code>(0, 0, 0)</code> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def append_RamanMeasurement_multi(self, measurement:MeaRaman, coor:tuple=(0,0,0)):\n    \"\"\"\n    Append a RamanMeasurement to the MappingMeasurement_Hub by assigning it to a unit.\n\n    Args:\n        measurement (RamanMeasurement): The RamanMeasurement to append\n        coor (tuple, optional): The coordinates of the measurement. Defaults to (0,0,0).\n    \"\"\"\n    # Mapping ID request and check\n    unit_name = None\n    while unit_name == None:\n        unit_name = messagebox_request_input(\n            parent=self,\n            title= \"Unit ID\",\n            message=\"Enter the ID for the added Raman measurement:\",\n            default=f\"Single point measurement at {coor}: \",\n            )\n        if isinstance(unit_name,str) and not unit_name == '': break\n\n    unit = MeaRMap_Unit(unit_name=unit_name)\n\n    timestamp = measurement.get_latest_timestamp()\n    unit.append_ramanmeasurement_data(timestamp=timestamp, coor=coor, measurement=measurement)\n\n    self.append_MappingUnit(unit)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.check_safeToTerminate","title":"<code>check_safeToTerminate()</code>","text":"<p>Check if the data has been saved before terminating the app.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the app can be terminated, False otherwise</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def check_safeToTerminate(self) -&gt; bool:\n    \"\"\"\n    Check if the data has been saved before terminating the app.\n\n    Returns:\n        bool: True if the app can be terminated, False otherwise\n    \"\"\"\n    if self._flg_issaved: return True\n    elif len(self._MappingHub.get_list_MappingUnit()) == 0: return True\n\n    flg_close = qw.QMessageBox.question(\n        None,\n        \"Unsaved data\",\n        \"There is unsaved data in the Mapping Hub.\\nAre you sure you want to exit without saving?\",\n        qw.QMessageBox.Yes | qw.QMessageBox.Cancel, # pyright: ignore[reportAttributeAccessIssue]\n        qw.QMessageBox.Cancel) # type: ignore\n\n    if flg_close == qw.QMessageBox.Yes:   # type: ignore\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.delete_unit","title":"<code>delete_unit()</code>","text":"<p>Delete the selected MappingMeasurement_Unit from the MappingMeasurement_Hub</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def delete_unit(self):\n    \"\"\"\n    Delete the selected MappingMeasurement_Unit from the MappingMeasurement_Hub\n    \"\"\"\n    # Get the currently selected units\n    selections = self._tree.selectedItems()\n\n    if len(selections) == 0:\n        qw.QErrorMessage().showMessage(\"No unit selected\")\n        return\n\n    flg_remove = qw.QMessageBox.question(\n        None,\n        \"Mapping Unit deletion\",\n        \"Are you sure you want to delete the selected units?\"\n        \"\\n!!! This action cannot be undone !!!\",\n        qw.QMessageBox.Yes | qw.QMessageBox.No, qw.QMessageBox.No) # type: ignore\n    if flg_remove != qw.QMessageBox.Yes: return  # type: ignore\n\n    list_names = [item.text(0) for item in selections]\n    for unit_name in list_names:\n        self._MappingHub.remove_mapping_unit_name(unit_name)\n\n    if len(selections) &gt; 0: self._flg_issaved = False\n    self._sig_modify_tree.emit()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.extend_MappingUnit","title":"<code>extend_MappingUnit(list_unit, persist=True)</code>","text":"<p>Extend a MappingMeasurement_Unit in the MappingMeasurement_Hub</p> <p>Parameters:</p> Name Type Description Default <code>list_unit</code> <code>list[MappingMeasurement_Unit]</code> <p>The unit to extend</p> required <code>persist</code> <code>bool</code> <p>If True, will ask for a new unit ID if the unit ID does not exist. Defaults to True.</p> <code>True</code> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def extend_MappingUnit(self, list_unit:list[MeaRMap_Unit], persist:bool=True):\n    \"\"\"\n    Extend a MappingMeasurement_Unit in the MappingMeasurement_Hub\n\n    Args:\n        list_unit (list[MappingMeasurement_Unit]): The unit to extend\n        persist (bool, optional): If True, will ask for a new unit ID if the unit ID does not exist. Defaults to True.\n    \"\"\"\n    for unit in list_unit: self.append_MappingUnit(unit, persist=persist)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.get_selected_MappingUnit","title":"<code>get_selected_MappingUnit()</code>","text":"<p>Returns the selected MappingMeasurement_Unit in the treeview</p> <p>Returns:</p> Type Description <code>list[MeaRMap_Unit]</code> <p>list[MappingMeasurement_Unit]: The selected MappingMeasurement_Unit</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def get_selected_MappingUnit(self) -&gt; list[MeaRMap_Unit]:\n    \"\"\"\n    Returns the selected MappingMeasurement_Unit in the treeview\n\n    Returns:\n        list[MappingMeasurement_Unit]: The selected MappingMeasurement_Unit\n    \"\"\"\n    selections = self._tree.selectedItems()\n\n    list_units = []\n    for item in selections:\n        unit_name = item.text(0)\n        try: unit = self._MappingHub.get_MappingUnit(unit_name=unit_name)\n        except ValueError: continue\n        list_units.append(unit)\n\n    return list_units\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.rename_unit","title":"<code>rename_unit()</code>","text":"<p>Rename the selected MappingMeasurement_Unit in the MappingMeasurement_Hub</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def rename_unit(self):\n    \"\"\"\n    Rename the selected MappingMeasurement_Unit in the MappingMeasurement_Hub\n    \"\"\"\n    try:\n        selections = self._tree.selectedItems()\n\n        if len(selections) == 0:\n            qw.QErrorMessage().showMessage(\"No unit selected\")\n            return\n        elif len(selections) &gt; 1:\n            qw.QErrorMessage().showMessage(\"Multiple units selected. Please select only one unit to rename\")\n            return\n\n        unit_name = selections[0].text(0)\n        unit = self._MappingHub.get_MappingUnit(unit_name=unit_name)\n        new_name, ok = qw.QInputDialog.getText(None, \"Rename Mapping Unit\", \"Enter the new name for the selected Mapping Unit:\",\n                                                text=unit.get_unit_name())\n        if ok: self._MappingHub.rename_mapping_unit(unit_name, new_name)\n        self._flg_issaved = False\n    except Exception as e: qw.QErrorMessage().showMessage(\"Error in renaming the Mapping Unit\\n\" + str(e))\n    finally: self._sig_modify_tree.emit()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.set_selection_unitID","title":"<code>set_selection_unitID(list_unitID, clear_previous=True)</code>","text":"<p>Sets the selection in the treeview to the given unit IDs.</p> <p>Parameters:</p> Name Type Description Default <code>list_unitID</code> <code>list[str] | str</code> <p>The list of unit IDs to select or a single unit ID.</p> required <code>clear_previous</code> <code>bool</code> <p>Whether to clear the previous selection.</p> <code>True</code> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def set_selection_unitID(self, list_unitID:list[str]|str, clear_previous:bool=True):\n    \"\"\"\n    Sets the selection in the treeview to the given unit IDs.\n\n    Args:\n        list_unitID (list[str]|str): The list of unit IDs to select or a single unit ID.\n        clear_previous (bool): Whether to clear the previous selection.\n    \"\"\"\n    if not isinstance(list_unitID, list): list_unitID = [list_unitID]\n    list_name = [self._MappingHub.get_MappingUnit(unit_id).get_unit_name() for unit_id in list_unitID]\n\n    self._tree.blockSignals(True)\n\n    if clear_previous: self._tree.clearSelection()\n\n    # Get the invisible root item (parent of all top-level items)\n    root = self._tree.invisibleRootItem()\n\n    # Iterate through all top-level items\n    for i in range(root.childCount()):\n        item = root.child(i)\n        unit_name_in_tree = item.text(0) \n\n        # Check if the item's ID is in our target list\n        if unit_name_in_tree in list_name: item.setSelected(True) \n\n    self._tree.blockSignals(False)\n\n    self.sig_tree_selection.emit()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.set_selection_unitName","title":"<code>set_selection_unitName(unit_name)</code>","text":"<p>Sets the selection in the treeview to the given unit name.</p> <p>Parameters:</p> Name Type Description Default <code>unit_name</code> <code>str</code> <p>The unit name to select.</p> required Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>@Slot(str)\ndef set_selection_unitName(self, unit_name:str):\n    \"\"\"\n    Sets the selection in the treeview to the given unit name.\n\n    Args:\n        unit_name (str): The unit name to select.\n    \"\"\"\n    list_names = self._MappingHub.get_list_MappingUnit_names()\n    if not unit_name in list_names: return\n    unit = self._MappingHub.get_MappingUnit(unit_name=unit_name)\n    self.set_selection_unitID(unit.get_unit_id())\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping.terminate","title":"<code>terminate()</code>","text":"<p>App termination sequence: Force the user to save the data before closing the app</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    App termination sequence:\n    Force the user to save the data before closing the app\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping_Plus","title":"<code>Wdg_DataHub_Mapping_Plus</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Like the Frm_DataHub, but also shows the data of a single MappingMeasurement_Unit.</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>class Wdg_DataHub_Mapping_Plus(qw.QWidget):\n    \"\"\"\n    Like the Frm_DataHub, but also shows the data of a single MappingMeasurement_Unit.\n    \"\"\"\n    sig_selection_changed = Signal()   # Emitted when the RamanMeasurement selection is changed\n    sig_selection_changed_mea = Signal(MeaRaman)   # Emitted when the RamanMeasurement selection is changed, with the measurement as argument\n\n    _sig_modify_tree = Signal()         # Emitted when the treeview needs to be modified (internal)\n    _sig_tree_rebuild_done = Signal()   # Emitted when the treeview has been rebuilt (internal)\n    _sig_emit_selection_changed = Signal()  # Emitted to indicate that the selection has changed (internal)\n\n    def __init__(self, master,dataHub:Wdg_DataHub_Mapping):\n        \"\"\"\n        Initialises the data hub frame. This frame stores all the data from the measurement session.\n\n        Args:\n            master (tk.Tk): The master window\n            dataHub (Frm_DataHub): The data hub to get the data from\n            width_rel (float, optional): The relative width of the frame. Defaults to 1.\n            height_rel (float, optional): The relative height of the frame. Defaults to 1.\n        \"\"\"\n        super().__init__(master)\n        assert isinstance(dataHub, Wdg_DataHub_Mapping), \"dataHub must be a Frm_DataHub object\"\n\n        # DataHub setup\n        self._dataHub = dataHub\n        self._tree_MappingHub = self._dataHub.get_tree()\n\n        # Main widget\n        self._widget = Wdg_DataHubPlus_Mapping_Ui(self)\n        lyt = qw.QVBoxLayout()\n        self.setLayout(lyt)\n        lyt.addWidget(self._widget)\n        wdg = self._widget\n\n        # Storage parameters setup\n        self._mappingUnit:MeaRMap_Unit|None = None\n\n        # Unit tree setup\n        columns = (\"Timestamp\", \"Coor-x\", \"Coor-y\", \"Coor-z\", \"Metadata\")\n        self._unit_id:str|None = None\n        self._tree_unit = wdg.tree_data\n        self._tree_unit.setColumnCount(len(columns))\n        self._tree_unit.setHeaderLabels(columns)\n\n        # Status bar setup\n        self._lbl_statusbar = wdg.lbl_info\n\n        # Interactive widget setup\n        self._sig_modify_tree.connect(self.update_tree_unit)\n        self._dataHub.sig_tree_selection.connect(self._set_mappingUnit)\n        self._tree_unit.itemSelectionChanged.connect(self._emit_signal_selection)\n\n        self._sig_emit_selection_changed.connect(self._emit_signal_selection)\n\n    @Slot()\n    def _emit_signal_selection(self):\n        \"\"\"\n        Emits the selection changed signals with the selected RamanMeasurement\n        \"\"\"\n        # Only process events if the widget is fully initialized and visible\n        # This prevents crashes during initialization\n        if self.isVisible():\n            QCoreApplication.processEvents()\n\n        self.sig_selection_changed.emit()\n        mea = self.get_selected_RamanMeasurement()\n        if mea is not None:\n            self.sig_selection_changed_mea.emit(mea)\n\n    @Slot(str)\n    def set_selected_RamanMeasurement(self, measurement_id:str):\n        \"\"\"\n        Sets the selected RamanMeasurement in the unit treeview\n\n        Args:\n            measurement_id (str): The id of the RamanMeasurement to select\n        \"\"\"\n        assert isinstance(measurement_id, str), \"measurement_id must be a string\"\n\n        if not isinstance(self._mappingUnit, MeaRMap_Unit):\n            print(\"No MappingMeasurement_Unit is currently selected.\")\n            return\n\n        list_measurementIds = self._mappingUnit.get_list_RamanMeasurement_ids()\n        list_measurementIds_str = [str(mid) for mid in list_measurementIds]\n        if measurement_id not in list_measurementIds_str:\n            print(f\"RamanMeasurement with ID {measurement_id} not found in the current MappingMeasurement_Unit.\")\n            return\n\n        # Set the selection in the treeview\n        self._tree_unit.clearSelection()\n        idx_selection = bisect.bisect_left(list_measurementIds, int(measurement_id))\n        item = self._tree_unit.topLevelItem(idx_selection)\n        if item is None:\n            qw.QMessageBox.warning(None, \"Selection error\", f\"Could not find the RamanMeasurement with ID {measurement_id} in the treeview.\")\n            return\n        item.setSelected(True)\n\n        self._sig_emit_selection_changed.emit()\n\n    def get_selected_RamanMeasurement_summary(self) -&gt; dict:\n        \"\"\"\n        Returns the summary of the selected RamanMeasurement in the unit treeview\n        from the MappingMeasurement_Unit.\n\n        Returns:\n            dict: The summary of the selected RamanMeasurement\n        \"\"\"\n        selections = self._tree_unit.selectedItems()\n\n        if not isinstance(self._mappingUnit, MeaRMap_Unit): return {}\n        mea_id = selections[0].text(0)\n        return self._mappingUnit.get_dict_RamanMeasurement_summary(mea_id,exclude_id=True)\n\n    def get_selected_RamanMeasurement(self) -&gt; MeaRaman|None:\n        \"\"\"\n        Returns the selected RamanMeasurement in the unit treeview\n\n        Returns:\n            RamanMeasurement: The selected RamanMeasurement\n        \"\"\"\n        try:\n            selections = self._tree_unit.selectedItems()\n            if not isinstance(self._mappingUnit, MeaRMap_Unit): return None\n            if len(selections) == 0: return None\n            mea_id = selections[0].text(0)\n            return self._mappingUnit.get_RamanMeasurement(mea_id)\n        except Exception as e:\n            print(f\"Error getting selected RamanMeasurement: {e}\")\n            return None\n\n    @Slot()\n    def _set_mappingUnit(self):\n        \"\"\"\n        Sets the unit based on the dataHub selection.\n        If there is no selection, nothing happens and if there are multiple selections, the first one is selected\n        \"\"\"\n        list_unit = self._dataHub.get_selected_MappingUnit()\n\n        if len(list_unit) == 0: return\n        self._mappingUnit = list_unit[0]\n\n        self._sig_modify_tree.emit()\n\n    @Slot()\n    def update_tree_unit(self):\n        \"\"\"\n        Refreshes the unit treeview with the data in the MappingMeasurement_Unit\n        \"\"\"\n        # If the widget is not visible, do not update\n        if not self.isVisible(): return\n\n        self._lbl_statusbar.setText(\"Updating the Data Hub Plus. Interactive features not ready.\")\n        self._lbl_statusbar.setStyleSheet(\"background-color: yellow\")\n\n        # Block signals to prevent crashes during tree update\n        self._tree_unit.blockSignals(True)\n\n        self._tree_unit.clear()\n        if self._mappingUnit is None:\n            self._tree_unit.blockSignals(False)\n            return\n\n        dict_metadata = self._mappingUnit.get_dict_measurement_metadata()\n        dict_measurement = self._mappingUnit.get_dict_measurements(copy=False)\n        mea_id_key, coorx_key, coory_key, coorz_key, _, _ = self._mappingUnit.get_keys_dict_measurement()\n\n        list_timestamp = dict_measurement[mea_id_key]\n        list_coorx = dict_measurement[coorx_key]\n        list_coory = dict_measurement[coory_key]\n        list_coorz = dict_measurement[coorz_key]\n        list_metadata = [str(dict_metadata)] * len(list_timestamp)\n\n        for ts, x, y, z, meta in zip(list_timestamp, list_coorx, list_coory, list_coorz, list_metadata):\n            qw.QTreeWidgetItem(self._tree_unit,\n                [str(ts), str(x), str(y), str(z), meta])\n\n        # Unblock signals after tree update is complete\n        self._tree_unit.blockSignals(False)\n\n        self._lbl_statusbar.setText(\"Data Hub Plus updated. Ready.\")\n        self._lbl_statusbar.setStyleSheet(\"\")\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping_Plus.__init__","title":"<code>__init__(master, dataHub)</code>","text":"<p>Initialises the data hub frame. This frame stores all the data from the measurement session.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Tk</code> <p>The master window</p> required <code>dataHub</code> <code>Frm_DataHub</code> <p>The data hub to get the data from</p> required <code>width_rel</code> <code>float</code> <p>The relative width of the frame. Defaults to 1.</p> required <code>height_rel</code> <code>float</code> <p>The relative height of the frame. Defaults to 1.</p> required Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def __init__(self, master,dataHub:Wdg_DataHub_Mapping):\n    \"\"\"\n    Initialises the data hub frame. This frame stores all the data from the measurement session.\n\n    Args:\n        master (tk.Tk): The master window\n        dataHub (Frm_DataHub): The data hub to get the data from\n        width_rel (float, optional): The relative width of the frame. Defaults to 1.\n        height_rel (float, optional): The relative height of the frame. Defaults to 1.\n    \"\"\"\n    super().__init__(master)\n    assert isinstance(dataHub, Wdg_DataHub_Mapping), \"dataHub must be a Frm_DataHub object\"\n\n    # DataHub setup\n    self._dataHub = dataHub\n    self._tree_MappingHub = self._dataHub.get_tree()\n\n    # Main widget\n    self._widget = Wdg_DataHubPlus_Mapping_Ui(self)\n    lyt = qw.QVBoxLayout()\n    self.setLayout(lyt)\n    lyt.addWidget(self._widget)\n    wdg = self._widget\n\n    # Storage parameters setup\n    self._mappingUnit:MeaRMap_Unit|None = None\n\n    # Unit tree setup\n    columns = (\"Timestamp\", \"Coor-x\", \"Coor-y\", \"Coor-z\", \"Metadata\")\n    self._unit_id:str|None = None\n    self._tree_unit = wdg.tree_data\n    self._tree_unit.setColumnCount(len(columns))\n    self._tree_unit.setHeaderLabels(columns)\n\n    # Status bar setup\n    self._lbl_statusbar = wdg.lbl_info\n\n    # Interactive widget setup\n    self._sig_modify_tree.connect(self.update_tree_unit)\n    self._dataHub.sig_tree_selection.connect(self._set_mappingUnit)\n    self._tree_unit.itemSelectionChanged.connect(self._emit_signal_selection)\n\n    self._sig_emit_selection_changed.connect(self._emit_signal_selection)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping_Plus.get_selected_RamanMeasurement","title":"<code>get_selected_RamanMeasurement()</code>","text":"<p>Returns the selected RamanMeasurement in the unit treeview</p> <p>Returns:</p> Name Type Description <code>RamanMeasurement</code> <code>MeaRaman | None</code> <p>The selected RamanMeasurement</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def get_selected_RamanMeasurement(self) -&gt; MeaRaman|None:\n    \"\"\"\n    Returns the selected RamanMeasurement in the unit treeview\n\n    Returns:\n        RamanMeasurement: The selected RamanMeasurement\n    \"\"\"\n    try:\n        selections = self._tree_unit.selectedItems()\n        if not isinstance(self._mappingUnit, MeaRMap_Unit): return None\n        if len(selections) == 0: return None\n        mea_id = selections[0].text(0)\n        return self._mappingUnit.get_RamanMeasurement(mea_id)\n    except Exception as e:\n        print(f\"Error getting selected RamanMeasurement: {e}\")\n        return None\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping_Plus.get_selected_RamanMeasurement_summary","title":"<code>get_selected_RamanMeasurement_summary()</code>","text":"<p>Returns the summary of the selected RamanMeasurement in the unit treeview from the MappingMeasurement_Unit.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The summary of the selected RamanMeasurement</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def get_selected_RamanMeasurement_summary(self) -&gt; dict:\n    \"\"\"\n    Returns the summary of the selected RamanMeasurement in the unit treeview\n    from the MappingMeasurement_Unit.\n\n    Returns:\n        dict: The summary of the selected RamanMeasurement\n    \"\"\"\n    selections = self._tree_unit.selectedItems()\n\n    if not isinstance(self._mappingUnit, MeaRMap_Unit): return {}\n    mea_id = selections[0].text(0)\n    return self._mappingUnit.get_dict_RamanMeasurement_summary(mea_id,exclude_id=True)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping_Plus.set_selected_RamanMeasurement","title":"<code>set_selected_RamanMeasurement(measurement_id)</code>","text":"<p>Sets the selected RamanMeasurement in the unit treeview</p> <p>Parameters:</p> Name Type Description Default <code>measurement_id</code> <code>str</code> <p>The id of the RamanMeasurement to select</p> required Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>@Slot(str)\ndef set_selected_RamanMeasurement(self, measurement_id:str):\n    \"\"\"\n    Sets the selected RamanMeasurement in the unit treeview\n\n    Args:\n        measurement_id (str): The id of the RamanMeasurement to select\n    \"\"\"\n    assert isinstance(measurement_id, str), \"measurement_id must be a string\"\n\n    if not isinstance(self._mappingUnit, MeaRMap_Unit):\n        print(\"No MappingMeasurement_Unit is currently selected.\")\n        return\n\n    list_measurementIds = self._mappingUnit.get_list_RamanMeasurement_ids()\n    list_measurementIds_str = [str(mid) for mid in list_measurementIds]\n    if measurement_id not in list_measurementIds_str:\n        print(f\"RamanMeasurement with ID {measurement_id} not found in the current MappingMeasurement_Unit.\")\n        return\n\n    # Set the selection in the treeview\n    self._tree_unit.clearSelection()\n    idx_selection = bisect.bisect_left(list_measurementIds, int(measurement_id))\n    item = self._tree_unit.topLevelItem(idx_selection)\n    if item is None:\n        qw.QMessageBox.warning(None, \"Selection error\", f\"Could not find the RamanMeasurement with ID {measurement_id} in the treeview.\")\n        return\n    item.setSelected(True)\n\n    self._sig_emit_selection_changed.emit()\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.Wdg_DataHub_Mapping_Plus.update_tree_unit","title":"<code>update_tree_unit()</code>","text":"<p>Refreshes the unit treeview with the data in the MappingMeasurement_Unit</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>@Slot()\ndef update_tree_unit(self):\n    \"\"\"\n    Refreshes the unit treeview with the data in the MappingMeasurement_Unit\n    \"\"\"\n    # If the widget is not visible, do not update\n    if not self.isVisible(): return\n\n    self._lbl_statusbar.setText(\"Updating the Data Hub Plus. Interactive features not ready.\")\n    self._lbl_statusbar.setStyleSheet(\"background-color: yellow\")\n\n    # Block signals to prevent crashes during tree update\n    self._tree_unit.blockSignals(True)\n\n    self._tree_unit.clear()\n    if self._mappingUnit is None:\n        self._tree_unit.blockSignals(False)\n        return\n\n    dict_metadata = self._mappingUnit.get_dict_measurement_metadata()\n    dict_measurement = self._mappingUnit.get_dict_measurements(copy=False)\n    mea_id_key, coorx_key, coory_key, coorz_key, _, _ = self._mappingUnit.get_keys_dict_measurement()\n\n    list_timestamp = dict_measurement[mea_id_key]\n    list_coorx = dict_measurement[coorx_key]\n    list_coory = dict_measurement[coory_key]\n    list_coorz = dict_measurement[coorz_key]\n    list_metadata = [str(dict_metadata)] * len(list_timestamp)\n\n    for ts, x, y, z, meta in zip(list_timestamp, list_coorx, list_coory, list_coorz, list_metadata):\n        qw.QTreeWidgetItem(self._tree_unit,\n            [str(ts), str(x), str(y), str(z), meta])\n\n    # Unblock signals after tree update is complete\n    self._tree_unit.blockSignals(False)\n\n    self._lbl_statusbar.setText(\"Data Hub Plus updated. Ready.\")\n    self._lbl_statusbar.setStyleSheet(\"\")\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.generate_dummy_frmMappingHub","title":"<code>generate_dummy_frmMappingHub(parent)</code>","text":"<p>Generates a dummy Frm_DataHub_Mapping for testing purposes.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Tk</code> <p>The parent window to attach the frame to.</p> required <p>Returns:</p> Name Type Description <code>Frm_DataHub_Mapping</code> <code>Wdg_DataHub_Mapping</code> <p>The generated data hub mapping frame.</p> Source code in <code>iris/gui/dataHub_MeaRMap.py</code> <pre><code>def generate_dummy_frmMappingHub(parent) -&gt; Wdg_DataHub_Mapping:\n    \"\"\"\n    Generates a dummy Frm_DataHub_Mapping for testing purposes.\n\n    Args:\n        parent (tk.Tk): The parent window to attach the frame to.\n\n    Returns:\n        Frm_DataHub_Mapping: The generated data hub mapping frame.\n    \"\"\"\n    frm = Wdg_DataHub_Mapping(parent)\n    frm.get_MappingHub().test_generate_dummy()\n    return frm\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/dataHub_MeaRMap/#iris.gui.dataHub_MeaRMap.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/","title":"hilvl_Brightfield","text":"<p>An extension to define the region of interest (ROI) for the mapping measurements. It calibrates the ROI based on the stage's movement and the camera's image.</p> <p>Extension ID: ROIDEF    # To be used as a prefix in global variables</p> Extension for <ul> <li>main_controller.py</li> <li>main_analyser.py</li> </ul> <p>Note: To set the calibration parameters, take all of them as they are:         - stage coor shift/image coor shift (be it negative of positive)         - the image flip/coor flip in reference to the mapping frame of reference will be are handled separately             in the image_measurement object and the Frm_HeatmapOverlay object, when the flip is required</p>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.Wdg_HighLvlController_Brightfield","title":"<code>Wdg_HighLvlController_Brightfield</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>The controller extension part. Handles image collection and calibration</p> Source code in <code>iris/gui/hilvl_Brightfield.py</code> <pre><code>class Wdg_HighLvlController_Brightfield(qw.QWidget):\n    \"\"\"\n    The controller extension part. Handles image collection and calibration\n    \"\"\"\n    def __init__(\n        self,\n        parent:qw.QWidget,\n        processor:mpp.Pool,\n        dataHub_map:Wdg_DataHub_Mapping,\n        dataHub_img:Wdg_DataHub_Image,\n        dataHub_imgcal:Wdg_DataHub_ImgCal,\n        motion_controller:Wdg_MotionController,\n        stageHub:DataStreamer_StageCam,\n        coorHub:List_MeaCoor_Hub,\n        main:bool=False):\n        \"\"\"\n        Args:\n            parent (tk parent): Parent widget\n            processor (multiprocessing.pool.Pool): Processor pool\n            dataHub_map (Wdg_DataHub_Mapping): Data hub to get the data\n            dataHub_image (Wdg_DataHub_Image): Data hub for the image data\n            dataHub_imgcal (Wdg_DataHub_ImgCal): Data hub for the image calibration data\n            getter_coor (Callable[[],tuple[float,float,float]]): Function to get the stage coordinates\n            getter_cameraImage (Callable[[],Image]): Function to get the camera image\n            main (bool): Flag to indicate if this is the main script\n        \"\"\"\n        assert isinstance(processor, mpp.Pool), 'Processor must be a multiprocessing.pool.Pool object'\n        assert isinstance(dataHub_map, Wdg_DataHub_Mapping), 'DataHub must be a Wdg_DataHub object'\n        assert isinstance(dataHub_img, Wdg_DataHub_Image), 'DataHub must be a Wdg_DataHub object'\n        assert isinstance(dataHub_imgcal, Wdg_DataHub_ImgCal), 'DataHub must be a Wdg_DataHub object'\n        assert isinstance(motion_controller, Wdg_MotionController), 'Motion controller must be a Wdg_MotionController object'\n        assert isinstance(stageHub, DataStreamer_StageCam), 'StageHub must be a stage_measurement_hub object'\n\n        super().__init__(parent)\n        # self.title('ROI Definition')\n        self._processor = processor\n        self._dataHub_map = dataHub_map\n        self._dataHub_img = dataHub_img\n        self._dataHub_imgcal = dataHub_imgcal\n        self._motion_ctrl = motion_controller\n        self._getter_coor = self._motion_ctrl.get_coordinates_closest_mm\n        self._getter_cameraImage = self._motion_ctrl.get_current_image\n        self._stageHub = stageHub\n        self._coorHub = coorHub\n\n    # &gt;&gt;&gt; Initialise the main widget &lt;&lt;&lt;\n        self._widget = Hilvl_Brightfield_Design(self)\n        lyt = qw.QVBoxLayout()\n        lyt.addWidget(self._widget)\n        self.setLayout(lyt)\n        wdg = self._widget\n\n    # &gt;&gt;&gt; Parameters &lt;&lt;&lt;\n        # GUI parameters\n        self._showHints = AppPlotEnum.IMGCAL_SHOWHINTS.value\n\n    # &gt;&gt;&gt; Capture and calibration widgets &lt;&lt;&lt;\n        # Setup the calibration widget in a separate main window\n        self._main_window_calibration = qw.QMainWindow(self)\n        self._main_window_calibration.setWindowTitle('Image Calibration Setup')\n        self._main_window_calibration.setMinimumSize(800,600)\n\n        self._wdg_Calibration = Wdg_Calibration(\n            parent=self,\n            processor=self._processor,\n            dataHub_img=self._dataHub_img,\n            dataHub_imgcal=self._dataHub_imgcal,\n            getter_coor=self._getter_coor,\n            getter_cameraImage=self._getter_cameraImage,\n        )\n        self._main_window_calibration.setCentralWidget(self._wdg_Calibration)\n        self._dataHub_imgcal.btn_objectiveSetup.clicked.connect(\n            self._main_window_calibration.show)\n        self._wdg_Calibration.sig_saved_calibration.connect(\n            self._dataHub_imgcal._refresh_calibration_folder)\n\n        # Override the main window close event to hide the window instead of closing it\n        def closeEvent_override(event):\n            event.ignore()\n            self._main_window_calibration.hide()\n        self._main_window_calibration.closeEvent = closeEvent_override\n\n    # &gt;&gt; Overlay frame &lt;&lt;\n        # Heatmap plotter widgets setup\n        self._wdg_heatmapOverlay = Wdg_HeatmapOverlay(\n            parent=self,\n            processor=self._processor,\n            mappingHub=self._dataHub_map.get_MappingHub(),\n            imghub_getter=self._dataHub_img.get_ImageMeasurement_Hub,\n            dataHub_imgcal=self._dataHub_imgcal,\n            figsize_pxl=AppPlotEnum.IMGCAL_IMG_SIZE.value\n        )\n        wdg.lyt_heatmapOverlay.addWidget(self._wdg_heatmapOverlay)\n\n    # &gt;&gt; Tiling frame &lt;&lt;\n        tiling = Wdg_HiLvlTiling(\n            parent=self,\n            motion_controller=self._motion_ctrl,\n            stageHub=self._stageHub,\n            dataHub_img=self._dataHub_img,\n            dataHub_imgcal=self._dataHub_imgcal,\n            coorHub=self._coorHub,\n            processor=self._processor\n        )\n        wdg.lyt_tiling.addWidget(tiling)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.Wdg_HighLvlController_Brightfield.__init__","title":"<code>__init__(parent, processor, dataHub_map, dataHub_img, dataHub_imgcal, motion_controller, stageHub, coorHub, main=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parent</code> <code>tk parent</code> <p>Parent widget</p> required <code>processor</code> <code>Pool</code> <p>Processor pool</p> required <code>dataHub_map</code> <code>Wdg_DataHub_Mapping</code> <p>Data hub to get the data</p> required <code>dataHub_image</code> <code>Wdg_DataHub_Image</code> <p>Data hub for the image data</p> required <code>dataHub_imgcal</code> <code>Wdg_DataHub_ImgCal</code> <p>Data hub for the image calibration data</p> required <code>getter_coor</code> <code>Callable[[], tuple[float, float, float]]</code> <p>Function to get the stage coordinates</p> required <code>getter_cameraImage</code> <code>Callable[[], Image]</code> <p>Function to get the camera image</p> required <code>main</code> <code>bool</code> <p>Flag to indicate if this is the main script</p> <code>False</code> Source code in <code>iris/gui/hilvl_Brightfield.py</code> <pre><code>def __init__(\n    self,\n    parent:qw.QWidget,\n    processor:mpp.Pool,\n    dataHub_map:Wdg_DataHub_Mapping,\n    dataHub_img:Wdg_DataHub_Image,\n    dataHub_imgcal:Wdg_DataHub_ImgCal,\n    motion_controller:Wdg_MotionController,\n    stageHub:DataStreamer_StageCam,\n    coorHub:List_MeaCoor_Hub,\n    main:bool=False):\n    \"\"\"\n    Args:\n        parent (tk parent): Parent widget\n        processor (multiprocessing.pool.Pool): Processor pool\n        dataHub_map (Wdg_DataHub_Mapping): Data hub to get the data\n        dataHub_image (Wdg_DataHub_Image): Data hub for the image data\n        dataHub_imgcal (Wdg_DataHub_ImgCal): Data hub for the image calibration data\n        getter_coor (Callable[[],tuple[float,float,float]]): Function to get the stage coordinates\n        getter_cameraImage (Callable[[],Image]): Function to get the camera image\n        main (bool): Flag to indicate if this is the main script\n    \"\"\"\n    assert isinstance(processor, mpp.Pool), 'Processor must be a multiprocessing.pool.Pool object'\n    assert isinstance(dataHub_map, Wdg_DataHub_Mapping), 'DataHub must be a Wdg_DataHub object'\n    assert isinstance(dataHub_img, Wdg_DataHub_Image), 'DataHub must be a Wdg_DataHub object'\n    assert isinstance(dataHub_imgcal, Wdg_DataHub_ImgCal), 'DataHub must be a Wdg_DataHub object'\n    assert isinstance(motion_controller, Wdg_MotionController), 'Motion controller must be a Wdg_MotionController object'\n    assert isinstance(stageHub, DataStreamer_StageCam), 'StageHub must be a stage_measurement_hub object'\n\n    super().__init__(parent)\n    # self.title('ROI Definition')\n    self._processor = processor\n    self._dataHub_map = dataHub_map\n    self._dataHub_img = dataHub_img\n    self._dataHub_imgcal = dataHub_imgcal\n    self._motion_ctrl = motion_controller\n    self._getter_coor = self._motion_ctrl.get_coordinates_closest_mm\n    self._getter_cameraImage = self._motion_ctrl.get_current_image\n    self._stageHub = stageHub\n    self._coorHub = coorHub\n\n# &gt;&gt;&gt; Initialise the main widget &lt;&lt;&lt;\n    self._widget = Hilvl_Brightfield_Design(self)\n    lyt = qw.QVBoxLayout()\n    lyt.addWidget(self._widget)\n    self.setLayout(lyt)\n    wdg = self._widget\n\n# &gt;&gt;&gt; Parameters &lt;&lt;&lt;\n    # GUI parameters\n    self._showHints = AppPlotEnum.IMGCAL_SHOWHINTS.value\n\n# &gt;&gt;&gt; Capture and calibration widgets &lt;&lt;&lt;\n    # Setup the calibration widget in a separate main window\n    self._main_window_calibration = qw.QMainWindow(self)\n    self._main_window_calibration.setWindowTitle('Image Calibration Setup')\n    self._main_window_calibration.setMinimumSize(800,600)\n\n    self._wdg_Calibration = Wdg_Calibration(\n        parent=self,\n        processor=self._processor,\n        dataHub_img=self._dataHub_img,\n        dataHub_imgcal=self._dataHub_imgcal,\n        getter_coor=self._getter_coor,\n        getter_cameraImage=self._getter_cameraImage,\n    )\n    self._main_window_calibration.setCentralWidget(self._wdg_Calibration)\n    self._dataHub_imgcal.btn_objectiveSetup.clicked.connect(\n        self._main_window_calibration.show)\n    self._wdg_Calibration.sig_saved_calibration.connect(\n        self._dataHub_imgcal._refresh_calibration_folder)\n\n    # Override the main window close event to hide the window instead of closing it\n    def closeEvent_override(event):\n        event.ignore()\n        self._main_window_calibration.hide()\n    self._main_window_calibration.closeEvent = closeEvent_override\n\n# &gt;&gt; Overlay frame &lt;&lt;\n    # Heatmap plotter widgets setup\n    self._wdg_heatmapOverlay = Wdg_HeatmapOverlay(\n        parent=self,\n        processor=self._processor,\n        mappingHub=self._dataHub_map.get_MappingHub(),\n        imghub_getter=self._dataHub_img.get_ImageMeasurement_Hub,\n        dataHub_imgcal=self._dataHub_imgcal,\n        figsize_pxl=AppPlotEnum.IMGCAL_IMG_SIZE.value\n    )\n    wdg.lyt_heatmapOverlay.addWidget(self._wdg_heatmapOverlay)\n\n# &gt;&gt; Tiling frame &lt;&lt;\n    tiling = Wdg_HiLvlTiling(\n        parent=self,\n        motion_controller=self._motion_ctrl,\n        stageHub=self._stageHub,\n        dataHub_img=self._dataHub_img,\n        dataHub_imgcal=self._dataHub_imgcal,\n        coorHub=self._coorHub,\n        processor=self._processor\n    )\n    wdg.lyt_tiling.addWidget(tiling)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.test_hilvl_Brightfield_app","title":"<code>test_hilvl_Brightfield_app(processor=None)</code>","text":"<p>Generates a dummy high-level Raman application for testing purposes.</p> Source code in <code>iris/gui/hilvl_Brightfield.py</code> <pre><code>def test_hilvl_Brightfield_app(processor:mpp.Pool|None=None):\n    \"\"\"\n    Generates a dummy high-level Raman application for testing purposes.\n    \"\"\"\n    import sys\n\n    from iris.gui.motion_video import generate_dummy_motion_controller\n    from iris.gui.raman import generate_dummy_spectrometer_controller\n\n    from iris.gui.hilvl_coorGen import generate_dummy_wdg_hilvlCoorGenerator\n\n    if processor is None:\n        processor = mpp.Pool()\n\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    wdg_main = qw.QWidget()\n    main_window.setCentralWidget(wdg_main)\n    layout = qw.QHBoxLayout()\n    wdg_main.setLayout(layout)\n\n    from iris.data.measurement_RamanMap import MeaRMap_Hub\n\n    mappingHub = MeaRMap_Hub()\n    dataHub = Wdg_DataHub_Mapping(wdg_main,mappingHub)\n\n    wdg_motion_video = generate_dummy_motion_controller(wdg_main)\n    datastreamer_motion = wdg_motion_video._stageHub\n    wdg_raman = generate_dummy_spectrometer_controller(wdg_main,processor,dataHub)\n    wdg_hilvlcoorgen = generate_dummy_wdg_hilvlCoorGenerator(wdg_main,datahub_map=dataHub)\n    wdg_imgcal = Wdg_DataHub_ImgCal(wdg_main)\n\n    hilvl_brightfield_app = Wdg_HighLvlController_Brightfield(\n        parent=main_window,\n        processor=processor,\n        motion_controller=wdg_motion_video,\n        stageHub=datastreamer_motion,\n        dataHub_map=dataHub,\n        dataHub_img=Wdg_DataHub_Image(wdg_main),\n        dataHub_imgcal=wdg_imgcal,\n        coorHub=wdg_hilvlcoorgen._coorHub,\n        )\n\n    layout.addWidget(wdg_motion_video)\n    layout.addWidget(hilvl_brightfield_app)\n    layout.addWidget(wdg_imgcal)\n    layout.addWidget(wdg_raman)\n    layout.addWidget(wdg_hilvlcoorgen)\n    layout.addWidget(dataHub)\n\n    wdg_hilvlcoorgen._coorHub.generate_dummy_data()\n\n    main_window.show()\n\n    sys.exit(app.exec())\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Brightfield/#iris.gui.hilvl_Brightfield.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/","title":"hilvl_Raman","text":""},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Enum_ScanDir","title":"<code>Enum_ScanDir</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for the scan direction options for the mapping measurement.</p> <p>Attributes:</p> Name Type Description <code>XDIR</code> <code>str</code> <p>X-direction scan option</p> <code>YDIR</code> <code>str</code> <p>Y-direction scan option</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>class Enum_ScanDir(Enum):\n    \"\"\"\n    Enum for the scan direction options for the mapping measurement.\n\n    Attributes:\n        XDIR (str): X-direction scan option\n        YDIR (str): Y-direction scan option\n    \"\"\"\n    XDIR = 'x-direction'\n    YDIR = 'y-direction'\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Enum_ScanMthd","title":"<code>Enum_ScanMthd</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for the scan options for the mapping measurement.</p> <p>Attributes:</p> Name Type Description <code>SNAKE</code> <code>str</code> <p>Snake scan option</p> <code>RASTER</code> <code>str</code> <p>Raster scan option</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>class Enum_ScanMthd(Enum):\n    \"\"\"\n    Enum for the scan options for the mapping measurement.\n\n    Attributes:\n        SNAKE (str): Snake scan option\n        RASTER (str): Raster scan option\n    \"\"\"\n    SNAKE = 'snake'\n    RASTER = 'raster'\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Hilvl_MeasurementAcq_Worker","title":"<code>Hilvl_MeasurementAcq_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Worker class for performing measurements in a separate thread.</p> Signals <p>sig_progress_update (int): Signal to update progress percentage sig_mea_error (str): Signal emitted when an error occurs during measurement sig_mea_cancelled: Signal emitted when measurement is cancelled sig_mea_done: Signal emitted when measurement is done</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>class Hilvl_MeasurementAcq_Worker(QObject):\n    \"\"\"\n    Worker class for performing measurements in a separate thread.\n\n    Signals:\n        sig_progress_update (int): Signal to update progress percentage\n        sig_mea_error (str): Signal emitted when an error occurs during measurement\n        sig_mea_cancelled: Signal emitted when measurement is cancelled\n        sig_mea_done: Signal emitted when measurement is done\n    \"\"\"\n    sig_progress_update_str = Signal(str)  # Signal to update progress (string message)\n\n    sig_error_during_mea = Signal(str)  # Signal emitted when an error occurs during measurement\n    sig_mea_done = Signal() # Signal emitted when measurement is done (no differentiation between success, cancelled, or error)\n    sig_mea_done_msg = Signal(str)  # Signal emitted when measurement is done with a message\n\n    msg_mea_error = \"An error occurred during the mapping measurement: \"\n    msg_mea_cancelled = \"Mapping measurement was cancelled by the user\"\n    msg_mea_finished = \"Mapping measurement finished successfully\"\n\n    err_msg_ismeasuring = \"Cannot start a new mapping measurement while another is running.\"\n\n    _sig_stop_autosaver = Signal()\n    _sig_gotocor = Signal(tuple, threading.Event)\n    _sig_setvelrel = Signal(float, float, threading.Event)\n    _sig_append_queue_mea = Signal(queue.Queue, threading.Event)\n    _sig_remove_queue_mea = Signal(queue.Queue)\n    _sig_acquire_discrete_mea = Signal(AcquisitionParams)\n    _sig_acquire_continuous_mea = Signal(AcquisitionParams, queue.Queue, queue.Queue)\n    _sig_acquire_list_coors = Signal(list, threading.Event)\n\n    def __init__(self, mapping_hub:MeaRMap_Hub, syncer_raman:Syncer_Raman, event_isacquiring:threading.Event):\n        \"\"\"\n        Worker to perform the measurement acquisition for Raman imaging. For the slots details, refer to the\n        methods in RamanMeasurement_Worker class in raman.py.\n\n        Args:\n            mapping_hub (MeaRMap_Hub): The mapping measurement hub to store the measurement data\n            syncer_raman (Syncer_Raman): The synchronization object for Raman measurements\n            event_isacquiring (threading.Event): The event flag to indicate if a measurement is ongoing\n        \"\"\"\n        super().__init__()\n        self.mapping_hub = mapping_hub\n        self._syncer = syncer_raman\n        self._event_isacquiring = event_isacquiring\n\n        self._q_mea_acq:queue.Queue = queue.Queue() # Queue for the acquisition to store the measurement data\n\n    def _calculate_time_remaining(self, points_done:int, total_points:int, time_elapsed:float) -&gt; str:\n        \"\"\"\n        Calculates the estimated time remaining for the measurement.\n\n        Args:\n            points_done (int): The number of points already measured\n            total_points (int): The total number of points to be measured\n            time_elapsed (float): The time elapsed since the start of the measurement in seconds\n\n        Returns:\n            str: The estimated time remaining (auto converted to hours, minutes, seconds)\n        \"\"\"\n        if points_done == 0:\n            return \"Waiting for first point...\"\n        time_per_point = time_elapsed / points_done\n        points_remaining = total_points - points_done\n        time_remaining = time_per_point * points_remaining\n        return self._convert_time_to_hms(time_remaining)\n\n    def _convert_time_to_hms(self, time_remaining:float) -&gt; str:\n        \"\"\"\n        Converts time in seconds to a string in hours, minutes, and seconds.\n\n        Args:\n            time_remaining (float): The time remaining in seconds\n\n        Returns:\n            str: The time remaining in \"Xh Ym Zs\" format\n        \"\"\"\n        hours = int(time_remaining // 3600)\n        minutes = int((time_remaining % 3600) // 60)\n        seconds = int(time_remaining % 60)\n\n        if hours &gt; 0:\n            return f\"{hours}h {minutes}m {seconds}s\"\n        elif minutes &gt; 0:\n            return f\"{minutes}m {seconds}s\"\n        else:\n            return f\"{seconds}s\"\n\n    @Slot(AcquisitionParams, list, queue.Queue)\n    def run_scan_discrete(\n        self,\n        params:AcquisitionParams,\n        mapping_coordinates:list,\n        q_mea_out:queue.Queue[tuple[MeaRaman,tuple]]):\n        print(\"Starting discrete mapping measurement...\")\n\n        # Go through all the coordinates\n        while not self._q_mea_acq.empty(): self._q_mea_acq.get()   # Clear the acquisition queue\n\n        print(params)\n        int_time = params['int_time_ms']\n\n        # Append the measurement queue to the acquisition controller\n        event_append_done = threading.Event()\n        self._sig_append_queue_mea.emit(self._q_mea_acq, event_append_done)\n        event_append_done.wait()\n\n        time_start = time.time()\n        total_points = len(mapping_coordinates)\n        self._event_isacquiring.set()\n        for i, coor in enumerate(mapping_coordinates):\n            try:\n                if not self._event_isacquiring.is_set():\n                    self.emit_finish_signals(self.msg_mea_cancelled)\n                    break\n\n                # Go to the requested coordinates\n                event_finish = threading.Event()\n                # print('Moving to coordinates:',coor)\n                # print('Emitting _sig_gotocor signal...')\n                self._sig_gotocor.emit(\n                    (float(coor[0]),float(coor[1]),float(coor[2])),\n                    event_finish\n                )\n                # print('Waiting for movement to complete...')\n                event_finish.wait(10)\n                if not event_finish.is_set(): raise TimeoutError('Failed to reach the target coordinate. Movement to coordinates timed out.')\n                # print('Movement wait finished. Event set:', event_finish.is_set())\n\n                # Trigger the acquisition and wait for the return queue to be filled\n                self._sig_acquire_discrete_mea.emit(params)\n\n                mea:MeaRaman = self._q_mea_acq.get(timeout=int_time/1000 * 10) # Waits up to 10x the integration time for the measurement\n\n                # Send the measurement data to the autosaver\n                if i == 0: continue  # Skip the zeroth measurement to avoid initialisation artifacts\n                q_mea_out.put(mea)\n\n            except Exception as e:\n                self.sig_error_during_mea.emit(self.msg_mea_error + str(e))\n                print('Error in run_scan_discrete:',e)\n\n            finally:\n                # Update progress\n                points_done = i + 1\n                time_elapsed = time.time() - time_start\n                time_remaining_str = self._calculate_time_remaining(points_done, total_points, time_elapsed)\n                progress_msg = f'Measured {points_done}/{total_points} points. Estimated time remaining: {time_remaining_str}. Elapsed time: {self._convert_time_to_hms(time_elapsed)}.'\n                self.sig_progress_update_str.emit(progress_msg)\n\n        self._event_isacquiring.clear()\n        self._sig_remove_queue_mea.emit(self._q_mea_acq)\n        self.emit_finish_signals(self.msg_mea_finished)\n        return\n\n    @Slot(AcquisitionParams, list, float, queue.Queue)\n    def run_scan_continuous(\n        self,\n        params:AcquisitionParams,\n        mapping_coordinates_ends:list,\n        mapping_speed_rel:float,\n        q_mea_out:queue.Queue):\n        \"\"\"\n        Scans the mapping coordinates continuously based on the given scan coordinates.\n\n        Args:\n            params (AcquisitionParams): The acquisition parameters for the measurement\n            mapping_coordinates_ends (list): List of scan coordinates (end coordinates of each scan lines)\n            mapping_speed_rel (int): The relative speed to move between the coordinates\n            q_mea_out (queue.Queue): The queue to store the measurement data\n        \"\"\"\n        print(\"Starting continuous mapping measurement...\")\n        # Prepare the events to synchronise the movement and measurement\n        event_finish_setvel = threading.Event()\n        event_finish_goto = threading.Event()\n\n        # Prepare the measurement queue to save the measurement data into\n        # the mapping unit (set up in the main thread)\n        while not self._q_mea_acq.empty(): self._q_mea_acq.get()   # Clear the acquisition queue\n        event_ready = threading.Event()\n        self._sig_append_queue_mea.emit(self._q_mea_acq, event_ready)\n        q_trig = queue.Queue()  # Queue to send the measurement trigger commands\n        self._sig_acquire_continuous_mea.emit(params, q_trig, q_mea_out)\n\n        print('Acquisition started, moving to start position...')\n        # &gt;&gt;&gt; Perform the mapping measurement &lt;&lt;&lt;\n        time_start = time.time()\n        total_points = len(mapping_coordinates_ends)\n        self._event_isacquiring.set()\n        for i, coor in enumerate(mapping_coordinates_ends):\n            try:\n                flg_continue = self._execute_scan_continuous_step(mapping_speed_rel, q_mea_out, event_finish_setvel, event_finish_goto, q_trig, i, coor)\n                if not flg_continue: break\n            except Exception as e:\n                self.sig_error_during_mea.emit(self.msg_mea_error + str(e))\n                print('Error in run_scan_continuous:',e)\n            finally:\n                # Update progress\n                points_done = i + 1\n                time_elapsed = time.time() - time_start\n                time_remaining_str = self._calculate_time_remaining(points_done, total_points, time_elapsed)\n                progress_msg = f'Measured {points_done}/{total_points} lines. Estimated time remaining: {time_remaining_str}. Elapsed time: {self._convert_time_to_hms(time_elapsed)}.'\n                self.sig_progress_update_str.emit(progress_msg)\n\n        # Stop raman frame's continuous measurement and store the final measurements\n        q_trig.put(EnumTrig.STORE)\n        q_trig.put(EnumTrig.FINISH)\n\n        self._event_isacquiring.clear()\n        self._sig_remove_queue_mea.emit(self._q_mea_acq)\n        self.emit_finish_signals(self.msg_mea_finished)\n\n    def _execute_scan_continuous_step(\n        self,\n        mapping_speed_rel:float,\n        q_mea_out:queue.Queue,\n        event_finish_setvel:threading.Event,\n        event_finish_goto:threading.Event,\n        q_trig:queue.Queue,\n        coor_idx:int,\n        coor:tuple,\n        ) -&gt; bool:\n        \"\"\"\n        Executes a single step in the continuous mapping measurement.\n\n        Args:\n            mapping_speed_rel (float): The relative speed to move between the coordinates\n            q_mea_out (queue.Queue): The queue to store the measurement data\n            event_finish_setvel (threading.Event): Event to signal the completion of setting velocity\n            event_finish_goto (threading.Event): Event to signal the completion of going to coordinates\n            q_trig (queue.Queue): Queue to send the measurement trigger commands\n            i (int): The index of the current coordinate\n            coor (tuple): The target coordinate\n\n        Returns:\n            bool: True if the step was executed successfully, False if the measurement was cancelled\n        \"\"\"\n\n        if not self._event_isacquiring.is_set():\n            self.emit_finish_signals(self.msg_mea_cancelled)\n            return False\n\n        event_finish_setvel.clear()\n        if coor_idx == 0:\n            print('Moving to start position...')\n            self._syncer.set_notready()\n            q_trig.put(EnumTrig.START)\n            event_finish_setvel.set()\n            print('Reached start position.')\n        elif coor_idx%2 == 0:\n            print('Moving to next line end position (odd line)...')\n            self._syncer.set_notready()\n            q_trig.put(EnumTrig.IGNORE)\n            self._sig_setvelrel.emit(mapping_speed_rel, -1.0, event_finish_setvel)   # Set actual speed to move between x-coordinates\n            print('Reached line end position.')\n        else:\n            print('Moving to next line end position (even line)...')\n            q_trig.put(EnumTrig.STORE)\n            self._sig_setvelrel.emit(100.0, -1.0, event_finish_setvel) # Set actual speed to move between x-coordinates\n            print('Reached line end position.')\n        self._syncer.wait_ready()\n        event_finish_setvel.wait()\n\n                # Check the autosave queue size and wait if necessary to prevent overflow\n        q_size = q_mea_out.qsize()\n        if q_size &gt; AppRamanEnum.CONTINUOUS_MEASUREMENT_BUFFER_SIZE.value:\n            while not q_mea_out.empty():\n                print(f'Measurement buffer full:\\nAdjust [APP - RAMAN MEASUREMENT CONTROLLER] \"continuous_measurement_buffer_size\"\\nin the config.ini file to adjust the buffer size')\n                time.sleep(0.1)\n                print(f'Waiting for the measurement buffer to clear... Current size: {q_mea_out.qsize()}')\n            q_trig.put(EnumTrig.IGNORE)\n\n        while not self._q_mea_acq.empty():\n            try:\n                if coor_idx == 0: # Skip the first measurement to avoid initialisation artifacts\n                    self._q_mea_acq.get()\n                    continue\n                mea:MeaRaman = self._q_mea_acq.get()\n                q_mea_out.put(mea)\n            except queue.Empty:\n                break\n            except Exception as e:\n                self.sig_error_during_mea.emit(self.msg_mea_error + str(e))\n                print('Error in run_scan_continuous (autosave):',e)\n                continue\n\n                # Go to the requested coordinates\n        event_finish_goto.clear()\n        self._sig_gotocor.emit(\n                    (float(coor[0]),float(coor[1]),float(coor[2])),\n                    event_finish_goto\n                )\n        event_finish_goto.wait()\n        return True\n\n    @Slot(str)\n    def emit_finish_signals(self,msg:str):\n        \"\"\"\n        Emits the measurement done signal with a message.\n\n        Args:\n            msg (str): The message to emit with the signal\n        \"\"\"\n        self.sig_mea_done.emit()\n        self.sig_mea_done_msg.emit(msg)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Hilvl_MeasurementAcq_Worker.__init__","title":"<code>__init__(mapping_hub, syncer_raman, event_isacquiring)</code>","text":"<p>Worker to perform the measurement acquisition for Raman imaging. For the slots details, refer to the methods in RamanMeasurement_Worker class in raman.py.</p> <p>Parameters:</p> Name Type Description Default <code>mapping_hub</code> <code>MeaRMap_Hub</code> <p>The mapping measurement hub to store the measurement data</p> required <code>syncer_raman</code> <code>Syncer_Raman</code> <p>The synchronization object for Raman measurements</p> required <code>event_isacquiring</code> <code>Event</code> <p>The event flag to indicate if a measurement is ongoing</p> required Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def __init__(self, mapping_hub:MeaRMap_Hub, syncer_raman:Syncer_Raman, event_isacquiring:threading.Event):\n    \"\"\"\n    Worker to perform the measurement acquisition for Raman imaging. For the slots details, refer to the\n    methods in RamanMeasurement_Worker class in raman.py.\n\n    Args:\n        mapping_hub (MeaRMap_Hub): The mapping measurement hub to store the measurement data\n        syncer_raman (Syncer_Raman): The synchronization object for Raman measurements\n        event_isacquiring (threading.Event): The event flag to indicate if a measurement is ongoing\n    \"\"\"\n    super().__init__()\n    self.mapping_hub = mapping_hub\n    self._syncer = syncer_raman\n    self._event_isacquiring = event_isacquiring\n\n    self._q_mea_acq:queue.Queue = queue.Queue() # Queue for the acquisition to store the measurement data\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Hilvl_MeasurementAcq_Worker.emit_finish_signals","title":"<code>emit_finish_signals(msg)</code>","text":"<p>Emits the measurement done signal with a message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to emit with the signal</p> required Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>@Slot(str)\ndef emit_finish_signals(self,msg:str):\n    \"\"\"\n    Emits the measurement done signal with a message.\n\n    Args:\n        msg (str): The message to emit with the signal\n    \"\"\"\n    self.sig_mea_done.emit()\n    self.sig_mea_done_msg.emit(msg)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Hilvl_MeasurementAcq_Worker.run_scan_continuous","title":"<code>run_scan_continuous(params, mapping_coordinates_ends, mapping_speed_rel, q_mea_out)</code>","text":"<p>Scans the mapping coordinates continuously based on the given scan coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>AcquisitionParams</code> <p>The acquisition parameters for the measurement</p> required <code>mapping_coordinates_ends</code> <code>list</code> <p>List of scan coordinates (end coordinates of each scan lines)</p> required <code>mapping_speed_rel</code> <code>int</code> <p>The relative speed to move between the coordinates</p> required <code>q_mea_out</code> <code>Queue</code> <p>The queue to store the measurement data</p> required Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>@Slot(AcquisitionParams, list, float, queue.Queue)\ndef run_scan_continuous(\n    self,\n    params:AcquisitionParams,\n    mapping_coordinates_ends:list,\n    mapping_speed_rel:float,\n    q_mea_out:queue.Queue):\n    \"\"\"\n    Scans the mapping coordinates continuously based on the given scan coordinates.\n\n    Args:\n        params (AcquisitionParams): The acquisition parameters for the measurement\n        mapping_coordinates_ends (list): List of scan coordinates (end coordinates of each scan lines)\n        mapping_speed_rel (int): The relative speed to move between the coordinates\n        q_mea_out (queue.Queue): The queue to store the measurement data\n    \"\"\"\n    print(\"Starting continuous mapping measurement...\")\n    # Prepare the events to synchronise the movement and measurement\n    event_finish_setvel = threading.Event()\n    event_finish_goto = threading.Event()\n\n    # Prepare the measurement queue to save the measurement data into\n    # the mapping unit (set up in the main thread)\n    while not self._q_mea_acq.empty(): self._q_mea_acq.get()   # Clear the acquisition queue\n    event_ready = threading.Event()\n    self._sig_append_queue_mea.emit(self._q_mea_acq, event_ready)\n    q_trig = queue.Queue()  # Queue to send the measurement trigger commands\n    self._sig_acquire_continuous_mea.emit(params, q_trig, q_mea_out)\n\n    print('Acquisition started, moving to start position...')\n    # &gt;&gt;&gt; Perform the mapping measurement &lt;&lt;&lt;\n    time_start = time.time()\n    total_points = len(mapping_coordinates_ends)\n    self._event_isacquiring.set()\n    for i, coor in enumerate(mapping_coordinates_ends):\n        try:\n            flg_continue = self._execute_scan_continuous_step(mapping_speed_rel, q_mea_out, event_finish_setvel, event_finish_goto, q_trig, i, coor)\n            if not flg_continue: break\n        except Exception as e:\n            self.sig_error_during_mea.emit(self.msg_mea_error + str(e))\n            print('Error in run_scan_continuous:',e)\n        finally:\n            # Update progress\n            points_done = i + 1\n            time_elapsed = time.time() - time_start\n            time_remaining_str = self._calculate_time_remaining(points_done, total_points, time_elapsed)\n            progress_msg = f'Measured {points_done}/{total_points} lines. Estimated time remaining: {time_remaining_str}. Elapsed time: {self._convert_time_to_hms(time_elapsed)}.'\n            self.sig_progress_update_str.emit(progress_msg)\n\n    # Stop raman frame's continuous measurement and store the final measurements\n    q_trig.put(EnumTrig.STORE)\n    q_trig.put(EnumTrig.FINISH)\n\n    self._event_isacquiring.clear()\n    self._sig_remove_queue_mea.emit(self._q_mea_acq)\n    self.emit_finish_signals(self.msg_mea_finished)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Hilvl_MeasurementStorer_Worker","title":"<code>Hilvl_MeasurementStorer_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>class Hilvl_MeasurementStorer_Worker(QObject):\n\n    sig_gotmea = Signal() # Emitted when a measurement is received from the queue\n    sig_error = Signal(str)\n    sig_finished = Signal()\n    sig_finished_relay_msg = Signal(str)    # To relay finished messages once the imaging and the saving are both done. The message is obtained from the acquisition worker.\n\n    def __init__(self, datastreamer_stage:DataStreamer_StageCam):\n        super().__init__()\n        self._ds_stage = datastreamer_stage\n        self._isrunning = True\n\n    @Slot(MeaRMap_Unit, queue.Queue)\n    def set_save_params(\n        self,\n        mapping_unit:MeaRMap_Unit,\n        queue_measurement:queue.Queue[MeaRaman]):\n        \"\"\"\n        Sets the parameters for the autosaver\n\n        Args:\n            mapping_unit (MeaRMap_Unit): The mapping unit to store the measurement data\n            queue_measurement (queue.Queue): The queue to store the measurement data\n        \"\"\"\n        self._mapping_unit = mapping_unit\n        self._queue_measurement = queue_measurement\n\n    @Slot()\n    def start_autosaver(self):\n        \"\"\"\n        Starts the measurement autosaver\n        \"\"\"\n        self._isrunning = True\n        self._schedule_next_autosave()\n\n    @Slot()\n    def stop_autosaver(self):\n        \"\"\"\n        Stops the measurement autosaver\n        \"\"\"\n        self._isrunning = False\n\n    @Slot()\n    def _schedule_next_autosave(self):\n        \"\"\"\n        Schedules the next autosave measurement\n        \"\"\"\n        try:\n            self._autosave_measurement()\n        except Exception as e:\n            self.sig_error.emit(f'Error in scheduling autosave: {e}')\n            print(f'Error in scheduling autosave: {e}')\n        finally:\n            if self._isrunning or not self._queue_measurement.empty():\n                QTimer.singleShot(1, self._schedule_next_autosave)\n            else:\n                print('Autosaver finished all measurements.')\n                self.sig_finished.emit()\n\n    @Slot()\n    def _autosave_measurement(self):\n        \"\"\"\n        A function to automatically grabs the measurement data form the\n        measurement queue and stores it in the storage class.\n\n        Args:\n            mapping_unit (MappingMeasurement_Unit): The mapping unit to store the measurement data\n            flg_isrunning (threading.Event): The flag to stop the measurement\n            queue_measurement (queue.Queue): The queue to store the measurement data\n        \"\"\"\n        # print(f'Autosaver checking queue, size: {self._queue_measurement.qsize()}')\n        for _ in range(self._queue_measurement.qsize()):\n            try:\n                result:MeaRaman|tuple[MeaRaman,tuple]=self._queue_measurement.get(timeout=0.05)\n                self.sig_gotmea.emit()\n            except queue.Empty:\n                return\n            except Exception as e:\n                self.sig_error.emit(f'Error in autosaver: {e}')\n                return\n\n            try:\n                if isinstance(result,MeaRaman):\n                    mea = result\n                    # mea = mea.copy()\n                    ts = mea.get_latest_timestamp()\n                    coor = self._ds_stage.get_coordinates_interpolate(ts)\n                else:\n                    mea, coor = result\n                    # mea = mea.copy()\n                    ts = mea.get_latest_timestamp()\n                assert coor is not None, 'No stage coordinates found for the measurement timestamp'\n\n                mea.check_uptodate(autoupdate=True)\n                self._mapping_unit.append_ramanmeasurement_data(\n                    timestamp=ts,\n                    coor=coor,\n                    measurement=mea\n                )\n            except Exception as e:\n                self.sig_error.emit(f'Error in autosaver: {e}')\n\n    @Slot(str)\n    def relay_finished_message(self, msg:str):\n        \"\"\"\n        Relays the finished message when the autosaver is done\n\n        Args:\n            msg (str): The message to relay\n        \"\"\"\n        if not self._isrunning and self._queue_measurement.empty():\n            self.sig_finished_relay_msg.emit(msg)\n        else:\n            QTimer.singleShot(100, lambda: self.relay_finished_message(msg))\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Hilvl_MeasurementStorer_Worker.relay_finished_message","title":"<code>relay_finished_message(msg)</code>","text":"<p>Relays the finished message when the autosaver is done</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to relay</p> required Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>@Slot(str)\ndef relay_finished_message(self, msg:str):\n    \"\"\"\n    Relays the finished message when the autosaver is done\n\n    Args:\n        msg (str): The message to relay\n    \"\"\"\n    if not self._isrunning and self._queue_measurement.empty():\n        self.sig_finished_relay_msg.emit(msg)\n    else:\n        QTimer.singleShot(100, lambda: self.relay_finished_message(msg))\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Hilvl_MeasurementStorer_Worker.set_save_params","title":"<code>set_save_params(mapping_unit, queue_measurement)</code>","text":"<p>Sets the parameters for the autosaver</p> <p>Parameters:</p> Name Type Description Default <code>mapping_unit</code> <code>MeaRMap_Unit</code> <p>The mapping unit to store the measurement data</p> required <code>queue_measurement</code> <code>Queue</code> <p>The queue to store the measurement data</p> required Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>@Slot(MeaRMap_Unit, queue.Queue)\ndef set_save_params(\n    self,\n    mapping_unit:MeaRMap_Unit,\n    queue_measurement:queue.Queue[MeaRaman]):\n    \"\"\"\n    Sets the parameters for the autosaver\n\n    Args:\n        mapping_unit (MeaRMap_Unit): The mapping unit to store the measurement data\n        queue_measurement (queue.Queue): The queue to store the measurement data\n    \"\"\"\n    self._mapping_unit = mapping_unit\n    self._queue_measurement = queue_measurement\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Hilvl_MeasurementStorer_Worker.start_autosaver","title":"<code>start_autosaver()</code>","text":"<p>Starts the measurement autosaver</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>@Slot()\ndef start_autosaver(self):\n    \"\"\"\n    Starts the measurement autosaver\n    \"\"\"\n    self._isrunning = True\n    self._schedule_next_autosave()\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Hilvl_MeasurementStorer_Worker.stop_autosaver","title":"<code>stop_autosaver()</code>","text":"<p>Stops the measurement autosaver</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>@Slot()\ndef stop_autosaver(self):\n    \"\"\"\n    Stops the measurement autosaver\n    \"\"\"\n    self._isrunning = False\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman","title":"<code>Wdg_HighLvlController_Raman</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A higher level controller ruling over the motion controller and raman spectroscopy controller.</p> Houses the <ol> <li>Plot (auto-update)</li> <li>Mapping functionalities</li> <li>Raman spectroscopy save functions</li> </ol> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>class Wdg_HighLvlController_Raman(qw.QWidget):\n    \"\"\"\n    A higher level controller ruling over the motion controller and raman spectroscopy controller.\n\n    Houses the:\n        1. Plot (auto-update)\n        2. Mapping functionalities\n        3. Raman spectroscopy save functions\n    \"\"\"\n\n    sig_set_autosaver = Signal(MeaRMap_Unit, queue.Queue)   # Signal to set the autosaver parameters\n    sig_start_autosaver = Signal()\n\n    sig_stop_measurement = Signal() # Signal to trigger measurement collection\n    sig_run_scan_discrete = Signal(AcquisitionParams, list, queue.Queue)\n    sig_run_scan_continuous = Signal(AcquisitionParams, list, float, queue.Queue)\n\n    def __init__(self,\n                 parent,\n                 motion_controller:Wdg_MotionController,\n                 stageHub:DataStreamer_StageCam,\n                 raman_controller:Wdg_SpectrometerController,\n                 ramanHub:DataStreamer_Raman,\n                 dataHub_map:Wdg_DataHub_Mapping,\n                 dataHub_img:Wdg_DataHub_Image,\n                 dataHub_imgcal:Wdg_DataHub_ImgCal,\n                 coorHub:List_MeaCoor_Hub,\n                 wdg_coorGen:Wdg_Hilvl_CoorGenerator,\n                 processor:mpp.Pool):\n        \"\"\"\n        Initialises the higher level controller, which needs access to most (if not all)\n        other modules used in the app\n\n        Args:\n            parent (qw.QWidget): The parent widget\n            motion_controller (Frm_MotionController): The stage and video controller for motion controls\n            stageHub (stage_measurement_hub): The stage measurement hub for coordinate retrievals\n            raman_controller (Frm_RamanSpectrometerController): The spectrometer controllers\n            ramanHub (RamanMeasurementHub): The Raman measurement hub (NOT the DataHub!) for spectra retrievals\n            dataHub_map (Frm_DataHub_Mapping): The mapping data hub\n            dataHub_img (Frm_DataHub_Image): The image data hub\n            dataHub_imgcal (Frm_DataHub_ImgCal): The image calibration data hub\n            coorHub (MappingCoordinatesHub): The mapping coordinates hub\n            wdg_coorGen (Wdg_Hilvl_CoorGenerator): The coordinate generator GUI\n            processor (mpp.Pool): The multiprocessing pool\n        \"\"\"\n        super().__init__(parent)\n        self.processor = processor\n\n    # &gt;&gt;&gt; Measurement hubs setup &lt;&lt;&lt;\n        self._stageHub = stageHub\n        self._ramanHub = ramanHub\n        self._dataHub_map = dataHub_map\n        self._dataHub_img = dataHub_img\n        self._dataHub_imgcal = dataHub_imgcal\n        self._coorHub = coorHub\n        self._wdg_coorGen = wdg_coorGen\n\n    # &gt;&gt;&gt; Controller initialisation &lt;&lt;&lt;\n        # To gain access to the other 2 controllers and data save manager\n        self.motion_controller = motion_controller\n        self.raman_controller = raman_controller\n        self.save_manager_dot = MeaRaman_Handler()\n        self._mappingHub_Handler = MeaRMap_Handler()\n\n    # &gt;&gt;&gt; Main widget/layout setup &lt;&lt;&lt;\n        self._widget = Hilvl_Raman_Design(self)\n        self._main_layout = qw.QVBoxLayout(self)\n        self._main_layout.addWidget(self._widget)\n        wdg = self._widget\n\n    # &gt;&gt;&gt; Frame setup: top layout &lt;&lt;&lt;\n        # Status bar\n        self.statbar = qw.QStatusBar(self)\n        self.statbar.showMessage('Initialising controls')\n        self._main_layout.addWidget(self.statbar)\n\n    # &gt;&gt;&gt; Frame setup: Notebook (heatmap and mapping controls) &lt;&lt;&lt;\n        # Setup: Heatmap plotter\n        self.mdl_plot = Wdg_MappingMeasurement_Plotter(\n            self,self._dataHub_map.get_MappingHub())\n        wdg.lyt_heatmap_holder.addWidget(self.mdl_plot)\n\n        # Setup: Mapping controls\n        self._frm_coorHub_treeview = Wdg_Treeview_MappingCoordinates(\n            parent=self,mappingCoorHub=self._coorHub)\n        wdg.lyt_coorHub_holder.addWidget(self._frm_coorHub_treeview)\n\n    # &gt;&gt;&gt; Mapping widgets and parameters setups &lt;&lt;&lt;\n        # Parameters\n        self._list_sel_mapCoor = []\n        self._flg_meaCancelled = False # Flag to indicate if the measurement was cancelled\n\n        # &gt;&gt; Mapping options widgets setup &lt;&lt;\n        self._btn_discrete = wdg.btn_discrete\n        self._btn_discrete.clicked.connect(lambda: self.initiate_mapping(MappingMethods.DISCRETE))\n        self._btn_continuous = wdg.btn_continuous\n        self._btn_continuous.clicked.connect(lambda: self.initiate_mapping(MappingMethods.CONTINUOUS))\n        self._btn_stop = wdg.btn_stop\n        self._btn_stop.clicked.connect(lambda: self.sig_stop_measurement.emit())\n\n    # &gt;&gt;&gt; Mapping scrambler options setup &lt;&lt;&lt;\n        self._rb_snake = wdg.rb_snake\n        self._rb_raster = wdg.rb_raster\n        self._rb_xdir = wdg.rb_xdir\n        self._rb_ydir = wdg.rb_ydir\n\n        self._chk_randomise = wdg.chk_randomise\n        self._chk_skipover = wdg.chk_skipover\n        self._spin_skipover = wdg.spin_skipover\n\n    # &gt;&gt;&gt; Overlay heatmap plotter setup &lt;&lt;&lt;\n        # Heatmap plotter widgets setup\n        # self._frm_heatmapOverlay = Frm_HeatmapOverlay(\n        #     master=frm_mappingoverlay,\n        #     processor=self.processor,\n        #     mappingHub=self._dataHub_map.get_MappingHub(),\n        #     imghub_getter=self._dataHub_img.get_ImageMeasurement_Hub,\n        #     dataHub_imgcal=self._dataHub_imgcal,\n        #     figsize_pxl=AppPlotEnum.IMGCAL_IMG_SIZE.value\n        # )\n\n        # # Pack the widgets\n        # self._frm_heatmapOverlay.grid(row=0, column=0)\n\n    # &gt;&gt;&gt; Workers and connections setup &lt;&lt;&lt;\n        self._init_workers_connections()\n\n    # &gt;&gt;&gt; Controller widgets setup &lt;&lt;&lt;\n        self.statbar.showMessage('Ready')\n\n    def initialise(self):\n        \"\"\"\n        Initialises the controller, loading the last mapping coordinates from the temporary folder.\n        \"\"\"\n        # Ensure motion controller workers are initialized before connecting\n        if hasattr(self.motion_controller, '_init_workers'):\n            self.motion_controller._init_workers()\n\n        # Re-initialize worker connections now that all workers are ready\n        self._reinit_worker_connections()\n\n    def _reinit_worker_connections(self):\n        \"\"\"\n        Re-initializes the worker connections after all workers are ready.\n        This is needed when running from the main app where worker initialization \n        happens after the high-level controller is created.\n        \"\"\"\n        # Create worker manager if it doesn't exist yet\n        if not hasattr(self, '_worker_manager') or self._worker_manager is None:\n            try:\n                motion_goto_worker = self.motion_controller.get_goto_worker()\n                self._worker_manager = WorkerPipelineManager(\n                    hilvlacq_worker=self._worker_hilvlacq,\n                    raman_worker=self.raman_controller.get_mea_worker(),\n                    motion_controller=self.motion_controller,\n                    motion_goto_worker=motion_goto_worker\n                )\n                self._worker_manager.setParent(self)\n            except AttributeError as e:\n                print(f\"Warning: Could not initialize worker connections: {e}\")\n                return\n        else:\n            # Disconnect old connections first\n            try:\n                self._worker_hilvlacq._sig_gotocor.disconnect()\n                self._worker_hilvlacq._sig_setvelrel.disconnect()\n            except Exception:\n                pass  # Connections might not exist yet\n\n            # Re-establish connections with proper thread handling\n            self._worker_hilvlacq._sig_gotocor.connect(\n                self.motion_controller.get_goto_worker().work,\n                qc.Qt.ConnectionType.QueuedConnection\n            )\n            self._worker_hilvlacq._sig_setvelrel.connect(\n                self.motion_controller.set_vel_relative,\n                qc.Qt.ConnectionType.QueuedConnection\n            )\n    def terminate(self):\n        \"\"\"\n        Terminates the controller, saving the mapping coordinates to the temporary folder.\n        \"\"\"\n        pass\n\n    def _init_workers_connections(self):\n        \"\"\"\n        Initialises the workers and their connections\n        \"\"\"\n    # &gt;&gt;&gt; Worker setups &lt;&lt;&lt;\n        self._event_isacquiring = threading.Event()\n        self._worker_hilvlacq = Hilvl_MeasurementAcq_Worker(\n            self._dataHub_map.get_MappingHub(),\n            self.raman_controller.get_syncer_acquisition(),\n            self._event_isacquiring)\n\n        # Try to get the goto worker, but be defensive about timing\n        try:\n            motion_goto_worker = self.motion_controller.get_goto_worker()\n        except AttributeError:\n            # Workers not initialized yet, will be connected later in initialise()\n            motion_goto_worker = None\n\n        if motion_goto_worker is not None:\n            self._worker_manager = WorkerPipelineManager(\n                hilvlacq_worker=self._worker_hilvlacq,\n                raman_worker=self.raman_controller.get_mea_worker(),\n                motion_controller=self.motion_controller,\n                motion_goto_worker=motion_goto_worker\n            )\n            # Set the parent to prevent garbage collection\n            self._worker_manager.setParent(self)\n        self._worker_autoMeaStorer = Hilvl_MeasurementStorer_Worker(\n            datastreamer_stage=self._stageHub,\n        )\n\n    # &gt;&gt;&gt; Mapping acquisition worker setup &lt;&lt;&lt;\n        # Connection: Mapping acquisition signals\n        self.sig_stop_measurement.connect(self._event_isacquiring.clear)\n        self.sig_run_scan_discrete.connect(self._worker_hilvlacq.run_scan_discrete)\n        self.sig_run_scan_continuous.connect(self._worker_hilvlacq.run_scan_continuous)\n        self._worker_hilvlacq.sig_error_during_mea.connect(self.handle_error_during_mapping)\n        self._worker_hilvlacq.sig_mea_done_msg.connect(self._worker_autoMeaStorer.relay_finished_message)\n\n        # Connection: Thread and worker management\n        self._thread_hilvlacq = QThread(self)\n        self._worker_hilvlacq.moveToThread(self._thread_hilvlacq)\n        self.destroyed.connect(self._thread_hilvlacq.quit)\n        self.destroyed.connect(self._thread_hilvlacq.deleteLater)\n        self.destroyed.connect(self._worker_hilvlacq.deleteLater)\n        self._thread_hilvlacq.start(QThread.Priority.HighestPriority)\n\n        # Message update handling\n        self._worker_hilvlacq.sig_progress_update_str.connect(self.handle_message_update)\n\n    # &gt;&gt;&gt; Autosaver worker setup &lt;&lt;&lt;\n        # Signal to stop the autosaver\n        self._worker_hilvlacq.sig_mea_done.connect(self._worker_autoMeaStorer.stop_autosaver)\n\n        # Signal to start and set the autosaver\n        self.sig_start_autosaver.connect(self._worker_autoMeaStorer.start_autosaver)\n        self.sig_set_autosaver.connect(self._worker_autoMeaStorer.set_save_params)\n\n        # Finish signal\n        self._worker_autoMeaStorer.sig_error.connect(self.handle_error_during_mapping)\n        self._worker_autoMeaStorer.sig_finished_relay_msg.connect(self.handle_mapping_completion)\n\n        # Signal to delete the thread and worker when finished\n        self._thread_autoMeaStorer = QThread(self)\n        self._worker_autoMeaStorer.moveToThread(self._thread_autoMeaStorer)\n        self.destroyed.connect(self._thread_autoMeaStorer.quit)\n        self.destroyed.connect(self._worker_autoMeaStorer.deleteLater)\n        self.destroyed.connect(self._thread_autoMeaStorer.deleteLater)\n\n        self._thread_autoMeaStorer.start(QThread.Priority.HighestPriority)\n\n    def _init_autoMeaStorer_worker(self, mapping_unit:MeaRMap_Unit) -&gt; queue.Queue:\n        q_storage = queue.Queue()\n        self.sig_set_autosaver.emit(mapping_unit, q_storage)\n        self.sig_start_autosaver.emit()\n        return q_storage\n\n    @Slot(str)\n    def handle_message_update(self, msg:str):\n        \"\"\"\n        Handles message updates from workers\n\n        Args:\n            msg (str): The message to display\n        \"\"\"\n        self.statbar.showMessage(msg)\n\n    def _get_scan_options(self) -&gt; tuple[str,str]:\n        \"\"\"\n        Retrieves the scan options from the GUI widgets\n\n        Returns:\n            tuple: (scan_method, scan_direction)\n        \"\"\"\n        if self._rb_raster.isChecked():\n            scan_method = Enum_ScanMthd.RASTER.value\n        elif self._rb_snake.isChecked():\n            scan_method = Enum_ScanMthd.SNAKE.value\n        else:\n            raise ValueError(\"Invalid scan method selected\")\n\n        if self._rb_xdir.isChecked():\n            scan_direction = Enum_ScanDir.XDIR.value\n        elif self._rb_ydir.isChecked():\n            scan_direction = Enum_ScanDir.YDIR.value\n        else:\n            raise ValueError(\"Invalid scan direction selected\")\n\n        return (scan_method, scan_direction)\n\n    def _generate_metadata_dict(self, map_method:MappingMethods) -&gt; dict:\n        \"\"\"\n        Generates extra metadata for the mapping measurement\n\n        Returns:\n            dict: The extra metadata\n        \"\"\"\n        assert map_method in MappingMethods, \"Invalid mapping method\"\n        controller_ids = self.motion_controller.get_controller_identifiers()\n\n        method,dir = self._get_scan_options()\n\n        extra_metadata = {\n            'camera_id': controller_ids[0],\n            'xystage_id': controller_ids[1],\n            'zstage_id': controller_ids[2],\n            'mapping_method': map_method.value,\n            'scan_method': method,\n            'scan_direction': dir,\n            'scramble_random': self._widget.chk_randomise.isChecked(),\n            'scramble_skipover': self._widget.chk_skipover.isChecked(),\n            'scramble_skipover_value': self._widget.spin_skipover.value(),\n        }\n        return extra_metadata\n\n    def _map_check_coor_min_max(self,mapping_coor:list):\n        \"\"\"\n        Checks if the coordinates are within the minimum and maximum limits\n\n        Args:\n            mapping_coor (list): The list of coordinates to be checked, should be in the format of [(x1,y1,z1),(x2,y2,z2),...]\n\n        Returns:\n            bool: True if the coordinates are within the limits\n        \"\"\"\n        pass #TODO: Implement coordinate checking (that every coordinate is within the stage limits)\n        return True\n\n    def _convertCoor_byScanOptions(self,mapping_coor:list|None=None,precision:int=4,ends_only:bool=False) -&gt; list|None:\n        \"\"\"\n        Converts coordinates to raster scan format.\n\n        Args:\n            mapping_coor (list): The list of coordinates to be checked, in the format [(x1, y1, z1), (x2, y2, z2), ...].\n            precision (int): The number of decimal places to round the coordinates to. Defaults to 4.\n            ends_only (bool): If True, only the ends of the coordinates for every line will be returned. Defaults to False.\n\n        Returns:\n            list: The coordinates reordered for the raster scan, or None if the input is None.\n        \"\"\"\n\n        mthd,dir = self._get_scan_options()\n\n        flg_snake = mthd == Enum_ScanMthd.SNAKE.value\n        dir_scan = dir\n\n        if not isinstance(mapping_coor, list) or len(mapping_coor) == 0:\n            print('No coordinates to convert')\n            return None\n\n        mapping_coor = mapping_coor.copy()  # Create a copy to avoid modifying the original list\n\n        # Sort the coordinates based on the scan direction\n        group_coor = {}\n        if dir_scan == Enum_ScanDir.YDIR.value:\n            for coor in mapping_coor:\n                x = round(coor[0], precision)\n                if x not in group_coor:\n                    group_coor[x] = []\n                group_coor[x].append(coor)\n            sorted_x = sorted(group_coor.keys())\n            if flg_snake:\n                for x in sorted_x[1::2]: group_coor[x].reverse()\n            if ends_only: \n                final_coor =    [(x, coor[1], coor[2]) for x in sorted_x for coor in group_coor[x][:1]] + \\\n                                [(x, coor[1], coor[2]) for x in sorted_x for coor in group_coor[x][-1:]]\n                final_coor = sorted(final_coor, key=lambda c: c[0])  # Sort by x-coordinate\n            else: final_coor = [(x, coor[1], coor[2]) for x in sorted_x for coor in group_coor[x]]\n        elif dir_scan == Enum_ScanDir.XDIR.value:\n            for coor in mapping_coor:\n                y = round(coor[1], precision)\n                if y not in group_coor:\n                    group_coor[y] = []\n                group_coor[y].append(coor)\n            sorted_y = sorted(group_coor.keys())\n            if flg_snake:\n                for y in sorted_y[1::2]: group_coor[y].reverse()\n            if ends_only:\n                final_coor =    [(coor[0], y, coor[2]) for y in sorted_y for coor in group_coor[y][:1]] + \\\n                                [(coor[0], y, coor[2]) for y in sorted_y for coor in group_coor[y][-1:]]\n                final_coor = sorted(final_coor, key=lambda c: c[1])  # Sort by y-coordinate\n            else: final_coor = [(coor[0], y, coor[2]) for y in sorted_y for coor in group_coor[y]]\n        else:\n            raise ValueError(\"Invalid scan direction. Use 'x-direction' or 'y-direction'.\")\n        return final_coor\n\n    def _calculate_total_XYdistance(self,mapping_coor:list) -&gt; float:\n        \"\"\"\n        Calculates the total distance to be travelled for the mapping measurement \n        (only for the XY plane).\n\n        Args:\n            mapping_coor (list): The list of coordinates to be checked, in the format [(x1, y1, z1), (x2, y2, z2), ...].\n\n        Returns:\n            float: The total distance to be travelled\n        \"\"\"\n        total_distance = 0\n        for i in range(len(mapping_coor)-1):\n            total_distance += math.sqrt((mapping_coor[i][0]-mapping_coor[i+1][0])**2+\n                                        (mapping_coor[i][1]-mapping_coor[i+1][1])**2)\n        return total_distance\n\n    def _initialise_mapping_parameters(self, mappingHub:MeaRMap_Hub, mapping_coordinates_mm:MeaCoor_mm,\n                                       mappingUnit_name:str|None=None) -&gt; tuple[list,float,str]:\n        \"\"\"\n        Performs the initial checks prior to the mapping measurement:\n            1. Running status check\n            2. Coordinates check\n            3.1. Mapping speed calculation\n            3.2. Mapping speed modifier check\n            4. Mapping ID request and check\n\n        Args:\n            mappingHub (MappingMeasurement_Hub): The mapping hub to store the mapping data\n            mapping_coordinates_mm (MappingCoordinates): The mapping coordinate list.\n            mappingUnit_name (str|None): The mapping ID. If None, the user will be prompted to enter it. Defaults to None.\n\n        Returns:\n            tuple: mapping coordinates, mapping speed (mm/sec), mapping ID\n\n        NOTE:\n            Assumes that the mapping coordinate will be followed as a pathway\n        \"\"\"\n        # Running status check\n        assert not self.raman_controller.get_running_status(), \"Please stop/finish the current measurement before starting\"\n        assert isinstance(mapping_coordinates_mm, MeaCoor_mm), \"Please generate the mapping coordinates first\"\n\n        list_coor_mm = mapping_coordinates_mm.mapping_coordinates\n\n        # Check that the controller can reach the coordinates\n        assert self._map_check_coor_min_max(list_coor_mm), \"The coordinates are out of range\"\n\n        # Calculates the required speed\n        integration_time_ms = self.raman_controller.get_integration_time_ms()\n        assert isinstance(integration_time_ms,(int,float)), \"Please enter a valid integration time\"\n\n        total_scan_time_sec = integration_time_ms * len(list_coor_mm) / 1e3\n        total_distance_mm = self._calculate_total_XYdistance(list_coor_mm)\n        mapping_speed_mmPerSec = abs(total_distance_mm/total_scan_time_sec)\n\n        # Mapping speed modifier check\n        assert isinstance(AppRamanEnum.CONTINUOUS_SPEED_MODIFIER.value, (int,float)) and AppRamanEnum.CONTINUOUS_SPEED_MODIFIER.value &gt; 0, \\\n            f\"The speed modifier in the config file must be a positive number. Got {AppRamanEnum.CONTINUOUS_SPEED_MODIFIER.value}\"\n\n        # Mapping ID request and check\n        list_mappingUnit_names = list(mappingHub.get_dict_nameToID().keys())\n        if mappingUnit_name is None and mapping_coordinates_mm.mappingUnit_name != '':\n            mappingUnit_name = mapping_coordinates_mm.mappingUnit_name\n\n        while mappingUnit_name is None:\n            mappingUnit_name = messagebox_request_input(\n                parent=self,\n                title='Mapping ID',\n                message='Enter the ID for the mapping measurement:',\n                default='',\n                validator=self._dataHub_map.get_MappingHub().validate_new_unit_name,\n                invalid_msg=\"Invalid 'mappingUnit name'. The name cannot be empty or already exist. Please try again.\",\n                loop_until_valid=True\n            )\n\n        return (list_coor_mm, mapping_speed_mmPerSec, mappingUnit_name)\n\n\n    def disable_widgets(self):\n        \"\"\"\n        Disables the mapping widgets\n        \"\"\"\n        widgets = get_all_widgets(self._widget.tab_mappingoptions)\n        for widget in widgets:\n            if isinstance(widget, (qw.QPushButton, qw.QComboBox, qw.QLineEdit, qw.QSpinBox, qw.QRadioButton, qw.QCheckBox)):\n                widget.setEnabled(False)\n\n    def enable_widgets(self):\n        \"\"\"\n        Enables the mapping widgets\n        \"\"\"\n        widgets = get_all_widgets(self._widget.tab_mappingoptions)\n        for widget in widgets:\n            if isinstance(widget, (qw.QPushButton, qw.QComboBox, qw.QLineEdit, qw.QSpinBox, qw.QRadioButton, qw.QCheckBox)):\n                widget.setEnabled(True)\n\n    def abort_mapping_run(self):\n        \"\"\"\n        Aborts the mapping run and resets the controller status\n\n        Args:\n            btn (tk.Button): The button to be reset\n            text (str): The text to be reset\n            command (Callable): The command to be reset\n        \"\"\"\n        self.flg_isrunning_mapping = False\n\n    def reset_mapping_widgets(self):\n        \"\"\"\n        Resets the mapping widgets after a mapping run\n\n        Args:\n            btn (tk.Button): The button to be reset\n            text (str): The text to be reset\n            command (Callable): The command to be reset\n        \"\"\"\n        self.enable_widgets()\n        self._btn_stop.setEnabled(False)\n        self.statbar.showMessage('Ready')\n\n    def _scramble_mapping_coordinates(self, list_mappingCoor:list, mode:MappingMethods) -&gt; list:\n        \"\"\"\n        Scrambles the mapping coordinates based on the selected mode.\n\n        Args:\n            list_mappingCoor (list): The list of coordinates to be scrambled\n            mode (str): The mode to scramble the coordinates. Can be 'discrete' or 'continuous'.\n\n        Returns:\n            list: The scrambled coordinates\n\n        Raises:\n            ValueError: If the jump value is not a positive integer\n\n        NOTE:\n            The 'discrete' mode will scramble the coordinates randomly, while the 'continuous' mode will always group the\n            start and end coordinates of the lines together.\n        \"\"\"\n        assert mode in MappingMethods, \"Invalid mapping method. Check the MappingMethods enum.\"\n        list_init = list_mappingCoor.copy()\n        if mode == MappingMethods.CONTINUOUS:\n            # Convert the coordinates to a list of two coordinates (assuming that the coordinates are in pairs)\n            list_temp = list_init.copy()\n            list_init.clear()\n            while len(list_temp)&gt;0:\n                list_init.append([list_temp.pop(0),list_temp.pop(0)])\n                if len(list_temp)==1:\n                    list_init.append([list_temp.pop(0),])\n\n        if self._widget.chk_randomise.isChecked(): random.shuffle(list_init)\n\n        def list_remap_jump(data_list, skip_interval):\n            \"\"\"Remaps the list by skipping elements based on the skip_interval\"\"\"\n            # Determine the actual 'step' size for slicing\n            # A skip_interval of 0 means a step of 1 (every element)\n            # A skip_interval of 1 means a step of 2 (every other element)\n            # A skip_interval of N means a step of N+1 (every N+1th element)\n            step = skip_interval + 1\n            num_passes = step\n            mapped_list = []\n            n = len(data_list)\n            for offset in range(num_passes):\n                current_index = offset\n                while current_index &lt; n:\n                    mapped_list.append(data_list[current_index])\n                    current_index += step\n            return mapped_list\n\n        if self._widget.chk_skipover.isChecked():\n            skip_val = self._spin_skipover.value()\n            try:\n                skip_val = int(skip_val)\n                if skip_val &lt; 0: raise ValueError\n            except ValueError:\n                raise ValueError(\"Jump value must be a positive integer\")\n\n            list_final = list_remap_jump(list_init, skip_val)\n        else:\n            list_final = list_init\n\n        # Convert the coordinates back to the original format\n        if mode == MappingMethods.CONTINUOUS:\n            list_temp = list_final.copy()\n            list_final.clear()\n            while len(list_temp)&gt;0:\n                list_final.extend(list_temp.pop(0))\n\n        return list_final\n\n    def initiate_mapping(self, method:MappingMethods,\n                         mapping_coordinates:MeaCoor_mm|None=None,):\n        \"\"\"\n        Performs multiple mapping based on the information stored in the dictionary\n\n        Args:\n            method (str): The mapping method to be performed. Can be 'discrete' or 'continuous'.\n            mapping_coordinates (MappingCoordinates|None): The mapping coordinates to be performed. If None,\n                the selected mapping coordinates from the treeview will be used. Defaults to None.\n        \"\"\"\n        # Prepare the list of measurements to be performed\n        if mapping_coordinates is None and len(self._list_sel_mapCoor) == 0:\n            self._list_sel_mapCoor = self._frm_coorHub_treeview.get_selected_mappingCoor(flg_message=True)\n        elif len(self._list_sel_mapCoor) &gt; 0: pass\n        else: self._list_sel_mapCoor = [mapping_coordinates,]\n        if len(self._list_sel_mapCoor) == 0: return\n\n        self.raman_controller.disable_widgets()\n        self.motion_controller.disable_widgets()\n        self.disable_widgets()\n\n        # Store the last mapping method used\n        assert method in MappingMethods, \"Invalid mapping method. Check the MappingMethods enum.\"\n        self._last_mappingmethod = method\n\n        self._perform_mapping(method=method)\n\n    @Slot(str)\n    def handle_error_during_mapping(self, msg:str):\n        \"\"\"\n        Handles errors during the mapping measurement\n        \"\"\"\n        self.statbar.showMessage(msg,5000)\n        self.statbar.setStyleSheet(\"QStatusBar { background-color : red; color : white; }\")\n\n    @Slot(str)\n    def handle_mapping_completion(self, msg:str):\n        \"\"\"\n        Handles the completion of a mapping measurement\n        \"\"\"\n        self.raman_controller.reset_enable_widgets()\n        self.motion_controller.enable_widgets()\n        self.enable_widgets()\n        self.statbar.showMessage('Mapping measurement complete')\n        self.statbar.setStyleSheet(\"\") # Reset to default\n\n        if msg == self._worker_hilvlacq.msg_mea_cancelled:\n            self._list_sel_mapCoor.clear()\n            qw.QMessageBox.warning(self,'Mapping measurement cancelled','The mapping measurement was cancelled by the user')\n            return\n        elif msg.startswith(self._worker_hilvlacq.msg_mea_error):\n            self._list_sel_mapCoor.clear()\n            qw.QMessageBox.critical(self,'Mapping measurement error',msg)\n            return\n\n        if msg == self._worker_hilvlacq.msg_mea_finished and len(self._list_sel_mapCoor) == 0:\n            qw.QMessageBox.information(self,'Mapping measurement complete','The mapping measurement is complete and added to the data hub')\n        elif msg == self._worker_hilvlacq.msg_mea_finished:\n            self.initiate_mapping(method=self._last_mappingmethod)\n        else: raise ValueError(\"Invalid mapping completion message\")\n\n    def _perform_mapping(self, method:MappingMethods):\n        \"\"\"\n        Performs discrete mapping based on the mapping coordinates stored in the list\n        \"\"\"\n        def reset(): self.enable_widgets()\n        assert method in MappingMethods, \"Invalid mapping method. Check the MappingMethods enum.\"\n\n        mapping_hub = self._dataHub_map.get_MappingHub()\n\n        mapCoor = self._list_sel_mapCoor.pop(0)\n        if not isinstance(mapCoor, MeaCoor_mm): \n            qw.QMessageBox.critical(self,'Error','Invalid mapping coordinates selected')\n            reset()\n            return\n\n        mappingUnit_name = mapCoor.mappingUnit_name\n        mapping_coordinates = mapCoor\n\n        try: result = self._initialise_mapping_parameters(mapping_hub,mapping_coordinates,mappingUnit_name)\n        except AssertionError as e: \n            qw.QMessageBox.critical(self,'Error',f\"Failed to initialise mapping parameters for '{mappingUnit_name}': {e}\")\n            reset()\n            return\n\n        list_coor, mapping_speed_mmPerSec, unit_name = result\n        if method == MappingMethods.CONTINUOUS: ends_only = True\n        else: ends_only = False\n        list_coor = self._convertCoor_byScanOptions(list_coor, ends_only=ends_only)\n\n        try:\n            self._btn_stop.setEnabled(True)\n            assert list_coor is not None and len(list_coor)&gt;0, \"No coordinates to perform mapping\"\n            self._request_Mapping(mapping_coordinates=list_coor, unit_name=unit_name, method=method, mapping_speed_mmPerSec=mapping_speed_mmPerSec)\n        except Exception as e:\n            qw.QMessageBox.critical(self,'Error',f\"Failed to perform mapping for '{mappingUnit_name}': {e}\")\n            reset()\n            if not self._flg_meaCancelled: self._coorHub.remove_mappingCoor(mappingUnit_name)\n\n    def _request_Mapping(\n        self,\n        mapping_coordinates:list,\n        unit_name:str,\n        method:MappingMethods,\n        mapping_speed_mmPerSec:float,\n        ) -&gt; None:\n        assert method in MappingMethods, \"Invalid mapping method. Check the MappingMethods enum.\"\n    # &gt;&gt;&gt; Initialisations &lt;&lt;&lt;\n        # Generate the extra metadata for the mapping measurement\n        extra_metadata = self._generate_metadata_dict(method)\n\n        # Initialise the mapping measurement data class\n        mea_unit = MeaRMap_Unit(unit_name, extra_metadata=extra_metadata)\n        self._dataHub_map.append_MappingUnit(mea_unit)\n\n        # Scramble the mapping coordinates if requested\n        mapping_coordinates = self._scramble_mapping_coordinates(mapping_coordinates, method)\n\n        # Perform the mapping measurement itself\n        q_autosave = self._init_autoMeaStorer_worker(mea_unit)\n        if method == MappingMethods.DISCRETE:\n            print('Requesting discrete mapping...')\n            self.sig_run_scan_discrete.emit(\n                self.raman_controller.generate_acquisition_params(),\n                mapping_coordinates,\n                q_autosave\n                )\n        else:\n            mapping_speed_rel = self.motion_controller.calculate_vel_relative(vel_xy_mmPerSec=mapping_speed_mmPerSec)\n            mapping_speed_rel *= AppRamanEnum.CONTINUOUS_SPEED_MODIFIER.value\n            self.sig_run_scan_continuous.emit(\n                self.raman_controller.generate_acquisition_params(),\n                mapping_coordinates,\n                mapping_speed_rel,\n                q_autosave,\n                )\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.__init__","title":"<code>__init__(parent, motion_controller, stageHub, raman_controller, ramanHub, dataHub_map, dataHub_img, dataHub_imgcal, coorHub, wdg_coorGen, processor)</code>","text":"<p>Initialises the higher level controller, which needs access to most (if not all) other modules used in the app</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>motion_controller</code> <code>Frm_MotionController</code> <p>The stage and video controller for motion controls</p> required <code>stageHub</code> <code>stage_measurement_hub</code> <p>The stage measurement hub for coordinate retrievals</p> required <code>raman_controller</code> <code>Frm_RamanSpectrometerController</code> <p>The spectrometer controllers</p> required <code>ramanHub</code> <code>RamanMeasurementHub</code> <p>The Raman measurement hub (NOT the DataHub!) for spectra retrievals</p> required <code>dataHub_map</code> <code>Frm_DataHub_Mapping</code> <p>The mapping data hub</p> required <code>dataHub_img</code> <code>Frm_DataHub_Image</code> <p>The image data hub</p> required <code>dataHub_imgcal</code> <code>Frm_DataHub_ImgCal</code> <p>The image calibration data hub</p> required <code>coorHub</code> <code>MappingCoordinatesHub</code> <p>The mapping coordinates hub</p> required <code>wdg_coorGen</code> <code>Wdg_Hilvl_CoorGenerator</code> <p>The coordinate generator GUI</p> required <code>processor</code> <code>Pool</code> <p>The multiprocessing pool</p> required Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def __init__(self,\n             parent,\n             motion_controller:Wdg_MotionController,\n             stageHub:DataStreamer_StageCam,\n             raman_controller:Wdg_SpectrometerController,\n             ramanHub:DataStreamer_Raman,\n             dataHub_map:Wdg_DataHub_Mapping,\n             dataHub_img:Wdg_DataHub_Image,\n             dataHub_imgcal:Wdg_DataHub_ImgCal,\n             coorHub:List_MeaCoor_Hub,\n             wdg_coorGen:Wdg_Hilvl_CoorGenerator,\n             processor:mpp.Pool):\n    \"\"\"\n    Initialises the higher level controller, which needs access to most (if not all)\n    other modules used in the app\n\n    Args:\n        parent (qw.QWidget): The parent widget\n        motion_controller (Frm_MotionController): The stage and video controller for motion controls\n        stageHub (stage_measurement_hub): The stage measurement hub for coordinate retrievals\n        raman_controller (Frm_RamanSpectrometerController): The spectrometer controllers\n        ramanHub (RamanMeasurementHub): The Raman measurement hub (NOT the DataHub!) for spectra retrievals\n        dataHub_map (Frm_DataHub_Mapping): The mapping data hub\n        dataHub_img (Frm_DataHub_Image): The image data hub\n        dataHub_imgcal (Frm_DataHub_ImgCal): The image calibration data hub\n        coorHub (MappingCoordinatesHub): The mapping coordinates hub\n        wdg_coorGen (Wdg_Hilvl_CoorGenerator): The coordinate generator GUI\n        processor (mpp.Pool): The multiprocessing pool\n    \"\"\"\n    super().__init__(parent)\n    self.processor = processor\n\n# &gt;&gt;&gt; Measurement hubs setup &lt;&lt;&lt;\n    self._stageHub = stageHub\n    self._ramanHub = ramanHub\n    self._dataHub_map = dataHub_map\n    self._dataHub_img = dataHub_img\n    self._dataHub_imgcal = dataHub_imgcal\n    self._coorHub = coorHub\n    self._wdg_coorGen = wdg_coorGen\n\n# &gt;&gt;&gt; Controller initialisation &lt;&lt;&lt;\n    # To gain access to the other 2 controllers and data save manager\n    self.motion_controller = motion_controller\n    self.raman_controller = raman_controller\n    self.save_manager_dot = MeaRaman_Handler()\n    self._mappingHub_Handler = MeaRMap_Handler()\n\n# &gt;&gt;&gt; Main widget/layout setup &lt;&lt;&lt;\n    self._widget = Hilvl_Raman_Design(self)\n    self._main_layout = qw.QVBoxLayout(self)\n    self._main_layout.addWidget(self._widget)\n    wdg = self._widget\n\n# &gt;&gt;&gt; Frame setup: top layout &lt;&lt;&lt;\n    # Status bar\n    self.statbar = qw.QStatusBar(self)\n    self.statbar.showMessage('Initialising controls')\n    self._main_layout.addWidget(self.statbar)\n\n# &gt;&gt;&gt; Frame setup: Notebook (heatmap and mapping controls) &lt;&lt;&lt;\n    # Setup: Heatmap plotter\n    self.mdl_plot = Wdg_MappingMeasurement_Plotter(\n        self,self._dataHub_map.get_MappingHub())\n    wdg.lyt_heatmap_holder.addWidget(self.mdl_plot)\n\n    # Setup: Mapping controls\n    self._frm_coorHub_treeview = Wdg_Treeview_MappingCoordinates(\n        parent=self,mappingCoorHub=self._coorHub)\n    wdg.lyt_coorHub_holder.addWidget(self._frm_coorHub_treeview)\n\n# &gt;&gt;&gt; Mapping widgets and parameters setups &lt;&lt;&lt;\n    # Parameters\n    self._list_sel_mapCoor = []\n    self._flg_meaCancelled = False # Flag to indicate if the measurement was cancelled\n\n    # &gt;&gt; Mapping options widgets setup &lt;&lt;\n    self._btn_discrete = wdg.btn_discrete\n    self._btn_discrete.clicked.connect(lambda: self.initiate_mapping(MappingMethods.DISCRETE))\n    self._btn_continuous = wdg.btn_continuous\n    self._btn_continuous.clicked.connect(lambda: self.initiate_mapping(MappingMethods.CONTINUOUS))\n    self._btn_stop = wdg.btn_stop\n    self._btn_stop.clicked.connect(lambda: self.sig_stop_measurement.emit())\n\n# &gt;&gt;&gt; Mapping scrambler options setup &lt;&lt;&lt;\n    self._rb_snake = wdg.rb_snake\n    self._rb_raster = wdg.rb_raster\n    self._rb_xdir = wdg.rb_xdir\n    self._rb_ydir = wdg.rb_ydir\n\n    self._chk_randomise = wdg.chk_randomise\n    self._chk_skipover = wdg.chk_skipover\n    self._spin_skipover = wdg.spin_skipover\n\n# &gt;&gt;&gt; Overlay heatmap plotter setup &lt;&lt;&lt;\n    # Heatmap plotter widgets setup\n    # self._frm_heatmapOverlay = Frm_HeatmapOverlay(\n    #     master=frm_mappingoverlay,\n    #     processor=self.processor,\n    #     mappingHub=self._dataHub_map.get_MappingHub(),\n    #     imghub_getter=self._dataHub_img.get_ImageMeasurement_Hub,\n    #     dataHub_imgcal=self._dataHub_imgcal,\n    #     figsize_pxl=AppPlotEnum.IMGCAL_IMG_SIZE.value\n    # )\n\n    # # Pack the widgets\n    # self._frm_heatmapOverlay.grid(row=0, column=0)\n\n# &gt;&gt;&gt; Workers and connections setup &lt;&lt;&lt;\n    self._init_workers_connections()\n\n# &gt;&gt;&gt; Controller widgets setup &lt;&lt;&lt;\n    self.statbar.showMessage('Ready')\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.abort_mapping_run","title":"<code>abort_mapping_run()</code>","text":"<p>Aborts the mapping run and resets the controller status</p> <p>Parameters:</p> Name Type Description Default <code>btn</code> <code>Button</code> <p>The button to be reset</p> required <code>text</code> <code>str</code> <p>The text to be reset</p> required <code>command</code> <code>Callable</code> <p>The command to be reset</p> required Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def abort_mapping_run(self):\n    \"\"\"\n    Aborts the mapping run and resets the controller status\n\n    Args:\n        btn (tk.Button): The button to be reset\n        text (str): The text to be reset\n        command (Callable): The command to be reset\n    \"\"\"\n    self.flg_isrunning_mapping = False\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.disable_widgets","title":"<code>disable_widgets()</code>","text":"<p>Disables the mapping widgets</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def disable_widgets(self):\n    \"\"\"\n    Disables the mapping widgets\n    \"\"\"\n    widgets = get_all_widgets(self._widget.tab_mappingoptions)\n    for widget in widgets:\n        if isinstance(widget, (qw.QPushButton, qw.QComboBox, qw.QLineEdit, qw.QSpinBox, qw.QRadioButton, qw.QCheckBox)):\n            widget.setEnabled(False)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.enable_widgets","title":"<code>enable_widgets()</code>","text":"<p>Enables the mapping widgets</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def enable_widgets(self):\n    \"\"\"\n    Enables the mapping widgets\n    \"\"\"\n    widgets = get_all_widgets(self._widget.tab_mappingoptions)\n    for widget in widgets:\n        if isinstance(widget, (qw.QPushButton, qw.QComboBox, qw.QLineEdit, qw.QSpinBox, qw.QRadioButton, qw.QCheckBox)):\n            widget.setEnabled(True)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.handle_error_during_mapping","title":"<code>handle_error_during_mapping(msg)</code>","text":"<p>Handles errors during the mapping measurement</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>@Slot(str)\ndef handle_error_during_mapping(self, msg:str):\n    \"\"\"\n    Handles errors during the mapping measurement\n    \"\"\"\n    self.statbar.showMessage(msg,5000)\n    self.statbar.setStyleSheet(\"QStatusBar { background-color : red; color : white; }\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.handle_mapping_completion","title":"<code>handle_mapping_completion(msg)</code>","text":"<p>Handles the completion of a mapping measurement</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>@Slot(str)\ndef handle_mapping_completion(self, msg:str):\n    \"\"\"\n    Handles the completion of a mapping measurement\n    \"\"\"\n    self.raman_controller.reset_enable_widgets()\n    self.motion_controller.enable_widgets()\n    self.enable_widgets()\n    self.statbar.showMessage('Mapping measurement complete')\n    self.statbar.setStyleSheet(\"\") # Reset to default\n\n    if msg == self._worker_hilvlacq.msg_mea_cancelled:\n        self._list_sel_mapCoor.clear()\n        qw.QMessageBox.warning(self,'Mapping measurement cancelled','The mapping measurement was cancelled by the user')\n        return\n    elif msg.startswith(self._worker_hilvlacq.msg_mea_error):\n        self._list_sel_mapCoor.clear()\n        qw.QMessageBox.critical(self,'Mapping measurement error',msg)\n        return\n\n    if msg == self._worker_hilvlacq.msg_mea_finished and len(self._list_sel_mapCoor) == 0:\n        qw.QMessageBox.information(self,'Mapping measurement complete','The mapping measurement is complete and added to the data hub')\n    elif msg == self._worker_hilvlacq.msg_mea_finished:\n        self.initiate_mapping(method=self._last_mappingmethod)\n    else: raise ValueError(\"Invalid mapping completion message\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.handle_message_update","title":"<code>handle_message_update(msg)</code>","text":"<p>Handles message updates from workers</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to display</p> required Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>@Slot(str)\ndef handle_message_update(self, msg:str):\n    \"\"\"\n    Handles message updates from workers\n\n    Args:\n        msg (str): The message to display\n    \"\"\"\n    self.statbar.showMessage(msg)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.initialise","title":"<code>initialise()</code>","text":"<p>Initialises the controller, loading the last mapping coordinates from the temporary folder.</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def initialise(self):\n    \"\"\"\n    Initialises the controller, loading the last mapping coordinates from the temporary folder.\n    \"\"\"\n    # Ensure motion controller workers are initialized before connecting\n    if hasattr(self.motion_controller, '_init_workers'):\n        self.motion_controller._init_workers()\n\n    # Re-initialize worker connections now that all workers are ready\n    self._reinit_worker_connections()\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.initiate_mapping","title":"<code>initiate_mapping(method, mapping_coordinates=None)</code>","text":"<p>Performs multiple mapping based on the information stored in the dictionary</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The mapping method to be performed. Can be 'discrete' or 'continuous'.</p> required <code>mapping_coordinates</code> <code>MappingCoordinates | None</code> <p>The mapping coordinates to be performed. If None, the selected mapping coordinates from the treeview will be used. Defaults to None.</p> <code>None</code> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def initiate_mapping(self, method:MappingMethods,\n                     mapping_coordinates:MeaCoor_mm|None=None,):\n    \"\"\"\n    Performs multiple mapping based on the information stored in the dictionary\n\n    Args:\n        method (str): The mapping method to be performed. Can be 'discrete' or 'continuous'.\n        mapping_coordinates (MappingCoordinates|None): The mapping coordinates to be performed. If None,\n            the selected mapping coordinates from the treeview will be used. Defaults to None.\n    \"\"\"\n    # Prepare the list of measurements to be performed\n    if mapping_coordinates is None and len(self._list_sel_mapCoor) == 0:\n        self._list_sel_mapCoor = self._frm_coorHub_treeview.get_selected_mappingCoor(flg_message=True)\n    elif len(self._list_sel_mapCoor) &gt; 0: pass\n    else: self._list_sel_mapCoor = [mapping_coordinates,]\n    if len(self._list_sel_mapCoor) == 0: return\n\n    self.raman_controller.disable_widgets()\n    self.motion_controller.disable_widgets()\n    self.disable_widgets()\n\n    # Store the last mapping method used\n    assert method in MappingMethods, \"Invalid mapping method. Check the MappingMethods enum.\"\n    self._last_mappingmethod = method\n\n    self._perform_mapping(method=method)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.reset_mapping_widgets","title":"<code>reset_mapping_widgets()</code>","text":"<p>Resets the mapping widgets after a mapping run</p> <p>Parameters:</p> Name Type Description Default <code>btn</code> <code>Button</code> <p>The button to be reset</p> required <code>text</code> <code>str</code> <p>The text to be reset</p> required <code>command</code> <code>Callable</code> <p>The command to be reset</p> required Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def reset_mapping_widgets(self):\n    \"\"\"\n    Resets the mapping widgets after a mapping run\n\n    Args:\n        btn (tk.Button): The button to be reset\n        text (str): The text to be reset\n        command (Callable): The command to be reset\n    \"\"\"\n    self.enable_widgets()\n    self._btn_stop.setEnabled(False)\n    self.statbar.showMessage('Ready')\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.Wdg_HighLvlController_Raman.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the controller, saving the mapping coordinates to the temporary folder.</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminates the controller, saving the mapping coordinates to the temporary folder.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.WorkerPipelineManager","title":"<code>WorkerPipelineManager</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Manages the signal and slot connections between workers</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>class WorkerPipelineManager(QObject):\n    \"\"\"\n    Manages the signal and slot connections between workers\n    \"\"\"\n    def __init__(\n        self,\n        hilvlacq_worker:Hilvl_MeasurementAcq_Worker,\n        raman_worker: RamanMeasurement_Worker,\n        motion_controller: Wdg_MotionController,\n        motion_goto_worker:Motion_GoToCoor_Worker,\n        parent=None\n        ):\n        \"\"\"\n        Initialises the signal-slot connections for the controller.\n        \"\"\"\n        super().__init__(parent)\n\n        # Store references to prevent garbage collection\n        self._hilvlacq_worker = hilvlacq_worker\n        self._raman_worker = raman_worker\n        self._motion_controller = motion_controller\n        self._motion_goto_worker = motion_goto_worker\n\n        # Use Qt.QueuedConnection to ensure proper cross-thread signal delivery\n        hilvlacq_worker._sig_gotocor.connect(\n            motion_goto_worker.work, \n            qc.Qt.ConnectionType.QueuedConnection\n        )\n        hilvlacq_worker._sig_setvelrel.connect(\n            motion_controller.set_vel_relative,\n            qc.Qt.ConnectionType.QueuedConnection\n        )\n        hilvlacq_worker._sig_append_queue_mea.connect(raman_worker.append_queue_observer_measurement)\n        hilvlacq_worker._sig_remove_queue_mea.connect(raman_worker.remove_queue_observer_measurement)\n        hilvlacq_worker._sig_acquire_discrete_mea.connect(raman_worker.acquire_single_measurement)\n        hilvlacq_worker._sig_acquire_continuous_mea.connect(raman_worker.acquire_continuous_burst_measurement_trigger)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.WorkerPipelineManager.__init__","title":"<code>__init__(hilvlacq_worker, raman_worker, motion_controller, motion_goto_worker, parent=None)</code>","text":"<p>Initialises the signal-slot connections for the controller.</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def __init__(\n    self,\n    hilvlacq_worker:Hilvl_MeasurementAcq_Worker,\n    raman_worker: RamanMeasurement_Worker,\n    motion_controller: Wdg_MotionController,\n    motion_goto_worker:Motion_GoToCoor_Worker,\n    parent=None\n    ):\n    \"\"\"\n    Initialises the signal-slot connections for the controller.\n    \"\"\"\n    super().__init__(parent)\n\n    # Store references to prevent garbage collection\n    self._hilvlacq_worker = hilvlacq_worker\n    self._raman_worker = raman_worker\n    self._motion_controller = motion_controller\n    self._motion_goto_worker = motion_goto_worker\n\n    # Use Qt.QueuedConnection to ensure proper cross-thread signal delivery\n    hilvlacq_worker._sig_gotocor.connect(\n        motion_goto_worker.work, \n        qc.Qt.ConnectionType.QueuedConnection\n    )\n    hilvlacq_worker._sig_setvelrel.connect(\n        motion_controller.set_vel_relative,\n        qc.Qt.ConnectionType.QueuedConnection\n    )\n    hilvlacq_worker._sig_append_queue_mea.connect(raman_worker.append_queue_observer_measurement)\n    hilvlacq_worker._sig_remove_queue_mea.connect(raman_worker.remove_queue_observer_measurement)\n    hilvlacq_worker._sig_acquire_discrete_mea.connect(raman_worker.acquire_single_measurement)\n    hilvlacq_worker._sig_acquire_continuous_mea.connect(raman_worker.acquire_continuous_burst_measurement_trigger)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.test_hilvl_Raman_app","title":"<code>test_hilvl_Raman_app(processor=None)</code>","text":"<p>Generates a dummy high-level Raman application for testing purposes.</p> Source code in <code>iris/gui/hilvl_Raman.py</code> <pre><code>def test_hilvl_Raman_app(processor:mpp.Pool|None=None):\n    \"\"\"\n    Generates a dummy high-level Raman application for testing purposes.\n    \"\"\"\n    import sys\n\n    from iris.gui.motion_video import generate_dummy_motion_controller\n    from iris.gui.raman import generate_dummy_spectrometer_controller\n\n    from iris.gui.hilvl_coorGen import generate_dummy_wdg_hilvlCoorGenerator\n\n    if processor is None:\n        processor = mpp.Pool()\n\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    wdg_main = qw.QWidget()\n    main_window.setCentralWidget(wdg_main)\n    layout = qw.QHBoxLayout()\n    wdg_main.setLayout(layout)\n\n    mappingHub = MeaRMap_Hub()\n    dataHub = Wdg_DataHub_Mapping(wdg_main,mappingHub)\n\n    wdg_motion_video = generate_dummy_motion_controller(wdg_main)\n    datastreamer_motion = wdg_motion_video._stageHub\n    wdg_raman = generate_dummy_spectrometer_controller(wdg_main,processor,dataHub)\n    wdg_hilvlcoorgen = generate_dummy_wdg_hilvlCoorGenerator(wdg_main,datahub_map=dataHub)\n\n    hilvl_raman_app = Wdg_HighLvlController_Raman(\n        parent=main_window,\n        motion_controller=wdg_motion_video,\n        stageHub=datastreamer_motion,\n        raman_controller=wdg_raman,\n        ramanHub=wdg_raman._ramanHub,\n        dataHub_map=dataHub,\n        dataHub_img=Wdg_DataHub_Image(wdg_main),\n        dataHub_imgcal=Wdg_DataHub_ImgCal(wdg_main),\n        coorHub=wdg_hilvlcoorgen._coorHub,\n        wdg_coorGen=wdg_hilvlcoorgen,\n        processor=mpp.Pool())\n\n    layout.addWidget(wdg_motion_video)\n    layout.addWidget(wdg_raman)\n    layout.addWidget(hilvl_raman_app)\n    layout.addWidget(wdg_hilvlcoorgen)\n    layout.addWidget(dataHub)\n\n\n    main_window.show()\n\n    sys.exit(app.exec())\n</code></pre>"},{"location":"reference/iris/gui/hilvl_Raman/#iris.gui.hilvl_Raman.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/","title":"hilvl_coorGen","text":""},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Coor_saveload_worker","title":"<code>Coor_saveload_worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>class Coor_saveload_worker(QObject):\n\n    sig_save_done = Signal() # Emitted when the mapping coordinates are saved.\n    sig_load_done = Signal() # Emitted when the mapping coordinates are loaded.\n    sig_loaded_lastsession = Signal(str) # Emitted when the last session's mapping coordinates are loaded.\n\n    sig_save_error = Signal(str) # Emitted when there is an error in saving the mapping coordinates.\n    sig_load_error = Signal(str) # Emitted when there is an error in loading the mapping coordinates.\n\n    message_loaded_lastsession = \"Previous unfinished mapping coordinates found and has been loaded\"\n\n    def __init__(self,mappingCoorHub:List_MeaCoor_Hub):\n        \"\"\"\n        Initialises the treeview for the mapping coordinates.\n\n        Args:\n            mappingCoorHub (MappingCoordinatesHub): The hub for the mapping coordinates.\n        \"\"\"\n        super().__init__()\n        self._mappingCoorHub = mappingCoorHub\n\n    @Slot(str, list, int)\n    def offload_mappingCoor(self,mapping_unitName:str,list_coor:list,idx:int):\n        \"\"\"\n        Saves the unfinished mapping coordinates to the local disk in the temporary folder. It will\n        save it with the mapping_unitName as the filename and overwrite it if it already exists.\n\n        Args:\n            mapping_unitName (str): The name of the mapping unit\n            list_coor (list): The list of coordinates to be saved, in the format [(x1, y1, z1), (x2, y2, z2), ...].\n            idx (int): The index of the mapping coordinates in the list indicating the measurements done.\n                (Convention: Up to idx-1 are done).\n        \"\"\"\n        # &gt; Save the mapping coordinates to the local disk\n        if not isinstance(list_coor, list) or len(list_coor) == 0:\n            print('No coordinates to save')\n            return\n\n        idx = idx-1 if idx!=0 else 0\n        list_coor_temp = list_coor.copy()[idx:]  # Create a copy to avoid modifying the original list\n\n        mappingCoor = MeaCoor_mm(mapping_unitName,list_coor_temp)\n\n        # Check if the file already exists and renames it if it does\n        file_path = os.path.join(AppRamanEnum.TEMPORARY_FOLDER.value, mapping_unitName + '.pkl')\n        flg_exist = False\n        if os.path.exists(file_path):\n            flg_exist = True\n            old_file_path = os.path.join(AppRamanEnum.TEMPORARY_FOLDER.value, uuid1().hex + '.pkl')\n            os.rename(file_path, old_file_path)\n\n        try:\n            mappingCoor.save_pickle(file_path)\n            # Delete the old file if it exists\n            if flg_exist: os.remove(old_file_path)\n        except Exception as e:\n            print('Error in saving the mapping coordinates:',e)\n            os.rename(old_file_path, file_path)  # Rename back to the original name\n\n    @Slot(str)\n    def delete_offload_mappingCoor(self,mapping_unitName:str):\n        \"\"\"\n        Deletes the offloaded mapping coordinates from the local disk in the temporary folder.\n        It will delete the file with the mapping_unitName as the filename.\n\n        Args:\n            mapping_unitName (str): The name of the mapping unit\n        \"\"\"\n        # &gt; Delete the mapping coordinates from the local disk\n        file_path = os.path.join(AppRamanEnum.TEMPORARY_FOLDER.value, mapping_unitName + '.pkl')\n        if os.path.exists(file_path): os.remove(file_path)\n\n    @Slot(list)\n    def load_MappingCoordinates(self,list_loadpath:list[str]):\n        \"\"\"\n        Loads the mapping coordinates from a pickle file and adds them to the list of mapping coordinates.\n\n        Args:\n            list_loadpath (list[str]|None): The path to load the coordinates from. Defaults to None.\n\n        Returns:\n            MappingCoordinates: The loaded mapping coordinates.\n        \"\"\"\n        for path in list_loadpath:\n            try:\n                mappingCoor = MeaCoor_mm(loadpath=path)\n                self._mappingCoorHub.append(mappingCoor)\n            except Exception as e: self.sig_load_error.emit(f\"Failed to load mapping coordinates: {e}\")\n        return\n\n    @Slot()\n    def load_lastsession_MappingCoordinates(self):\n        \"\"\"\n        Loads the mapping coordinates from the previous sessions saved in the temporary folder.\n        \"\"\"\n        search_path = os.path.abspath(AppRamanEnum.TEMPORARY_FOLDER.value)+r'\\*.pkl'\n        # print(f'_load_last_MappingCoordinates: search path: {search_path}')\n        list_paths = glob(search_path)\n        if len(list_paths) == 0: return\n\n        for path in list_paths:\n            try:\n                mappingCoor = MeaCoor_mm(loadpath=path)\n                self._mappingCoorHub.append(mappingCoor)\n            except Exception as e: self.sig_load_error.emit(f\"Failed to load mapping coordinates: {e}\")\n\n        for path in list_paths: os.remove(path)\n        self.sig_loaded_lastsession.emit(self.message_loaded_lastsession)\n        return\n\n    @Slot(list, str, str)\n    def save_MappingCoordinates(self,list_coorNames:list[str],dirpath:str,type:Literal['pickle','csv']='pickle'):\n        \"\"\"\n        Saves the selected mapping coordinates to a pickle file.\n\n        Args:\n            list_coorNames (list[str]): The list of mapping coordinate names to save.\n            dirpath (str): The directory path to save the coordinates to.\n            type (Literal['pickle','csv']): The type of file to save the coordinates to. Defaults to 'pickle'.\n        \"\"\"\n        if type=='pickle': extension = '.pkl'\n        elif type=='csv': extension = '.csv'\n\n        # Save all selected mapping coordinates\n        for unitname in list_coorNames:\n            mappingCoor = self._mappingCoorHub.get_mappingCoor(unitname)\n            if mappingCoor is None: continue\n            filename = os.path.join(dirpath,mappingCoor.mappingUnit_name+extension)\n\n            while True:\n                if os.path.exists(filename):\n                    # Remove the extension and add a UUID to the filename\n                    filename = os.path.splitext(filename)[0]\n                    filename += '_'+str(uuid1())\n                else: break\n\n            if type == 'csv':\n                mappingCoor.save_csv(filename)\n            elif type == 'pickle':\n                mappingCoor.save_pickle(filename)\n        return\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Coor_saveload_worker.__init__","title":"<code>__init__(mappingCoorHub)</code>","text":"<p>Initialises the treeview for the mapping coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>mappingCoorHub</code> <code>MappingCoordinatesHub</code> <p>The hub for the mapping coordinates.</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def __init__(self,mappingCoorHub:List_MeaCoor_Hub):\n    \"\"\"\n    Initialises the treeview for the mapping coordinates.\n\n    Args:\n        mappingCoorHub (MappingCoordinatesHub): The hub for the mapping coordinates.\n    \"\"\"\n    super().__init__()\n    self._mappingCoorHub = mappingCoorHub\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Coor_saveload_worker.delete_offload_mappingCoor","title":"<code>delete_offload_mappingCoor(mapping_unitName)</code>","text":"<p>Deletes the offloaded mapping coordinates from the local disk in the temporary folder. It will delete the file with the mapping_unitName as the filename.</p> <p>Parameters:</p> Name Type Description Default <code>mapping_unitName</code> <code>str</code> <p>The name of the mapping unit</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>@Slot(str)\ndef delete_offload_mappingCoor(self,mapping_unitName:str):\n    \"\"\"\n    Deletes the offloaded mapping coordinates from the local disk in the temporary folder.\n    It will delete the file with the mapping_unitName as the filename.\n\n    Args:\n        mapping_unitName (str): The name of the mapping unit\n    \"\"\"\n    # &gt; Delete the mapping coordinates from the local disk\n    file_path = os.path.join(AppRamanEnum.TEMPORARY_FOLDER.value, mapping_unitName + '.pkl')\n    if os.path.exists(file_path): os.remove(file_path)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Coor_saveload_worker.load_MappingCoordinates","title":"<code>load_MappingCoordinates(list_loadpath)</code>","text":"<p>Loads the mapping coordinates from a pickle file and adds them to the list of mapping coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>list_loadpath</code> <code>list[str] | None</code> <p>The path to load the coordinates from. Defaults to None.</p> required <p>Returns:</p> Name Type Description <code>MappingCoordinates</code> <p>The loaded mapping coordinates.</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>@Slot(list)\ndef load_MappingCoordinates(self,list_loadpath:list[str]):\n    \"\"\"\n    Loads the mapping coordinates from a pickle file and adds them to the list of mapping coordinates.\n\n    Args:\n        list_loadpath (list[str]|None): The path to load the coordinates from. Defaults to None.\n\n    Returns:\n        MappingCoordinates: The loaded mapping coordinates.\n    \"\"\"\n    for path in list_loadpath:\n        try:\n            mappingCoor = MeaCoor_mm(loadpath=path)\n            self._mappingCoorHub.append(mappingCoor)\n        except Exception as e: self.sig_load_error.emit(f\"Failed to load mapping coordinates: {e}\")\n    return\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Coor_saveload_worker.load_lastsession_MappingCoordinates","title":"<code>load_lastsession_MappingCoordinates()</code>","text":"<p>Loads the mapping coordinates from the previous sessions saved in the temporary folder.</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>@Slot()\ndef load_lastsession_MappingCoordinates(self):\n    \"\"\"\n    Loads the mapping coordinates from the previous sessions saved in the temporary folder.\n    \"\"\"\n    search_path = os.path.abspath(AppRamanEnum.TEMPORARY_FOLDER.value)+r'\\*.pkl'\n    # print(f'_load_last_MappingCoordinates: search path: {search_path}')\n    list_paths = glob(search_path)\n    if len(list_paths) == 0: return\n\n    for path in list_paths:\n        try:\n            mappingCoor = MeaCoor_mm(loadpath=path)\n            self._mappingCoorHub.append(mappingCoor)\n        except Exception as e: self.sig_load_error.emit(f\"Failed to load mapping coordinates: {e}\")\n\n    for path in list_paths: os.remove(path)\n    self.sig_loaded_lastsession.emit(self.message_loaded_lastsession)\n    return\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Coor_saveload_worker.offload_mappingCoor","title":"<code>offload_mappingCoor(mapping_unitName, list_coor, idx)</code>","text":"<p>Saves the unfinished mapping coordinates to the local disk in the temporary folder. It will save it with the mapping_unitName as the filename and overwrite it if it already exists.</p> <p>Parameters:</p> Name Type Description Default <code>mapping_unitName</code> <code>str</code> <p>The name of the mapping unit</p> required <code>list_coor</code> <code>list</code> <p>The list of coordinates to be saved, in the format [(x1, y1, z1), (x2, y2, z2), ...].</p> required <code>idx</code> <code>int</code> <p>The index of the mapping coordinates in the list indicating the measurements done. (Convention: Up to idx-1 are done).</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>@Slot(str, list, int)\ndef offload_mappingCoor(self,mapping_unitName:str,list_coor:list,idx:int):\n    \"\"\"\n    Saves the unfinished mapping coordinates to the local disk in the temporary folder. It will\n    save it with the mapping_unitName as the filename and overwrite it if it already exists.\n\n    Args:\n        mapping_unitName (str): The name of the mapping unit\n        list_coor (list): The list of coordinates to be saved, in the format [(x1, y1, z1), (x2, y2, z2), ...].\n        idx (int): The index of the mapping coordinates in the list indicating the measurements done.\n            (Convention: Up to idx-1 are done).\n    \"\"\"\n    # &gt; Save the mapping coordinates to the local disk\n    if not isinstance(list_coor, list) or len(list_coor) == 0:\n        print('No coordinates to save')\n        return\n\n    idx = idx-1 if idx!=0 else 0\n    list_coor_temp = list_coor.copy()[idx:]  # Create a copy to avoid modifying the original list\n\n    mappingCoor = MeaCoor_mm(mapping_unitName,list_coor_temp)\n\n    # Check if the file already exists and renames it if it does\n    file_path = os.path.join(AppRamanEnum.TEMPORARY_FOLDER.value, mapping_unitName + '.pkl')\n    flg_exist = False\n    if os.path.exists(file_path):\n        flg_exist = True\n        old_file_path = os.path.join(AppRamanEnum.TEMPORARY_FOLDER.value, uuid1().hex + '.pkl')\n        os.rename(file_path, old_file_path)\n\n    try:\n        mappingCoor.save_pickle(file_path)\n        # Delete the old file if it exists\n        if flg_exist: os.remove(old_file_path)\n    except Exception as e:\n        print('Error in saving the mapping coordinates:',e)\n        os.rename(old_file_path, file_path)  # Rename back to the original name\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Coor_saveload_worker.save_MappingCoordinates","title":"<code>save_MappingCoordinates(list_coorNames, dirpath, type='pickle')</code>","text":"<p>Saves the selected mapping coordinates to a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>list_coorNames</code> <code>list[str]</code> <p>The list of mapping coordinate names to save.</p> required <code>dirpath</code> <code>str</code> <p>The directory path to save the coordinates to.</p> required <code>type</code> <code>Literal['pickle', 'csv']</code> <p>The type of file to save the coordinates to. Defaults to 'pickle'.</p> <code>'pickle'</code> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>@Slot(list, str, str)\ndef save_MappingCoordinates(self,list_coorNames:list[str],dirpath:str,type:Literal['pickle','csv']='pickle'):\n    \"\"\"\n    Saves the selected mapping coordinates to a pickle file.\n\n    Args:\n        list_coorNames (list[str]): The list of mapping coordinate names to save.\n        dirpath (str): The directory path to save the coordinates to.\n        type (Literal['pickle','csv']): The type of file to save the coordinates to. Defaults to 'pickle'.\n    \"\"\"\n    if type=='pickle': extension = '.pkl'\n    elif type=='csv': extension = '.csv'\n\n    # Save all selected mapping coordinates\n    for unitname in list_coorNames:\n        mappingCoor = self._mappingCoorHub.get_mappingCoor(unitname)\n        if mappingCoor is None: continue\n        filename = os.path.join(dirpath,mappingCoor.mappingUnit_name+extension)\n\n        while True:\n            if os.path.exists(filename):\n                # Remove the extension and add a UUID to the filename\n                filename = os.path.splitext(filename)[0]\n                filename += '_'+str(uuid1())\n            else: break\n\n        if type == 'csv':\n            mappingCoor.save_csv(filename)\n        elif type == 'pickle':\n            mappingCoor.save_pickle(filename)\n    return\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_CoorModifier","title":"<code>Wdg_CoorModifier</code>","text":"<p>               Bases: <code>Ui_coorMod</code>, <code>QWidget</code></p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>class Wdg_CoorModifier(Ui_coorMod, qw.QWidget):\n    def __init__(\n        self,\n        parent:qw.QWidget,\n        motion_controller:Wdg_MotionController,\n        coor_Hub:List_MeaCoor_Hub):\n        \"\"\"\n        Displays the GUI for the coordinate modifier methods.\n\n        Args:\n            master (tk.Tk | tk.Frame): The parent frame or window.\n            motion_controller (Frm_MotionController): The motion controller to use.\n            coor_Hub (MappingCoordinatesHub): The hub for the mapping coordinates.\n        \"\"\"\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        self._motion_controller = motion_controller\n        self._coorHub = coor_Hub\n\n        # &gt; Options setup &lt;\n        self._dict_mapModMethods_kwargs = {\n            'parent': self,\n            'motion_controller': self._motion_controller,\n            'mappingCoorHub': self._coorHub,\n            'motion_controller': self._motion_controller,\n        }\n        self._dict_mapModMethods = {\n            '1. Every Z': MapMod1,\n            '2. Z Interpolate': MapMod2,\n            '3. Topology visualiser': MapMod3,\n            '4. Translate XYZ': MapMod4,\n            '5. Gridify': MapMod5\n        }   # Mapping methods, to be programmed manually\n\n        self.combo_methods.addItems(list(self._dict_mapModMethods.keys()))\n        self.combo_methods.currentTextChanged.connect(\n            lambda text: self.show_chosen_mapModMethod(text))\n\n        # &gt; Initial map modifier method setup &lt;\n        self._current_mapModMethod = MapMod1(**self._dict_mapModMethods_kwargs)\n        self.lyt_holder_modifiers.addWidget(self._current_mapModMethod)\n\n    @Slot(str)\n    def show_chosen_mapModMethod(self, method_name:str):\n        \"\"\"\n        Shows the options for the selected mapping method\n\n        Args:\n            method_name (str): The name of the mapping method to show.\n        \"\"\"\n        widgets = get_all_widgets_from_layout(self.lyt_holder_modifiers)\n\n        for widget in widgets:\n            widget.deleteLater()\n        qw.QApplication.processEvents()\n\n        self._current_map_method = self._dict_mapModMethods[method_name](**self._dict_mapModMethods_kwargs)\n        self.lyt_holder_modifiers.addWidget(self._current_map_method)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_CoorModifier.__init__","title":"<code>__init__(parent, motion_controller, coor_Hub)</code>","text":"<p>Displays the GUI for the coordinate modifier methods.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Tk | Frame</code> <p>The parent frame or window.</p> required <code>motion_controller</code> <code>Frm_MotionController</code> <p>The motion controller to use.</p> required <code>coor_Hub</code> <code>MappingCoordinatesHub</code> <p>The hub for the mapping coordinates.</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def __init__(\n    self,\n    parent:qw.QWidget,\n    motion_controller:Wdg_MotionController,\n    coor_Hub:List_MeaCoor_Hub):\n    \"\"\"\n    Displays the GUI for the coordinate modifier methods.\n\n    Args:\n        master (tk.Tk | tk.Frame): The parent frame or window.\n        motion_controller (Frm_MotionController): The motion controller to use.\n        coor_Hub (MappingCoordinatesHub): The hub for the mapping coordinates.\n    \"\"\"\n    super().__init__(parent)\n    self.setupUi(self)\n    self.setLayout(self.main_layout)\n\n    self._motion_controller = motion_controller\n    self._coorHub = coor_Hub\n\n    # &gt; Options setup &lt;\n    self._dict_mapModMethods_kwargs = {\n        'parent': self,\n        'motion_controller': self._motion_controller,\n        'mappingCoorHub': self._coorHub,\n        'motion_controller': self._motion_controller,\n    }\n    self._dict_mapModMethods = {\n        '1. Every Z': MapMod1,\n        '2. Z Interpolate': MapMod2,\n        '3. Topology visualiser': MapMod3,\n        '4. Translate XYZ': MapMod4,\n        '5. Gridify': MapMod5\n    }   # Mapping methods, to be programmed manually\n\n    self.combo_methods.addItems(list(self._dict_mapModMethods.keys()))\n    self.combo_methods.currentTextChanged.connect(\n        lambda text: self.show_chosen_mapModMethod(text))\n\n    # &gt; Initial map modifier method setup &lt;\n    self._current_mapModMethod = MapMod1(**self._dict_mapModMethods_kwargs)\n    self.lyt_holder_modifiers.addWidget(self._current_mapModMethod)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_CoorModifier.show_chosen_mapModMethod","title":"<code>show_chosen_mapModMethod(method_name)</code>","text":"<p>Shows the options for the selected mapping method</p> <p>Parameters:</p> Name Type Description Default <code>method_name</code> <code>str</code> <p>The name of the mapping method to show.</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>@Slot(str)\ndef show_chosen_mapModMethod(self, method_name:str):\n    \"\"\"\n    Shows the options for the selected mapping method\n\n    Args:\n        method_name (str): The name of the mapping method to show.\n    \"\"\"\n    widgets = get_all_widgets_from_layout(self.lyt_holder_modifiers)\n\n    for widget in widgets:\n        widget.deleteLater()\n    qw.QApplication.processEvents()\n\n    self._current_map_method = self._dict_mapModMethods[method_name](**self._dict_mapModMethods_kwargs)\n    self.lyt_holder_modifiers.addWidget(self._current_map_method)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Hilvl_CoorGenerator","title":"<code>Wdg_Hilvl_CoorGenerator</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A class to generate coordinates for the mapping measurement and image tiling.</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>class Wdg_Hilvl_CoorGenerator(qw.QWidget):\n    \"\"\"\n    A class to generate coordinates for the mapping measurement and image tiling.\n    \"\"\"\n    def __init__(self,\n                 parent:qw.QWidget,\n                 coorHub:List_MeaCoor_Hub,\n                 motion_controller:Wdg_MotionController,\n                 dataHub_map:Wdg_DataHub_Mapping,\n                 dataHub_img:Wdg_DataHub_Image,\n                 dataHub_imgcal:Wdg_DataHub_ImgCal,\n                 ):\n        \"\"\"\n        Initialises the coordinate generator frame.\n\n        Args:\n            parent (qw.QWidget): The parent widget.\n            coorHub (List_MeaCoor_Hub): The hub for the mapping coordinates.\n            motion_controller (Wdg_MotionController): The motion controller to use.\n            dataHub_map (Wdg_DataHub_Mapping): The mapping data hub to use.\n            dataHub_img (Wdg_DataHub_Image): The image measurement data hub to use.\n            dataHub_imgcal (Wdg_DataHub_ImgCal): The image calibration data hub to use.\n        \"\"\"\n    # &gt;&gt;&gt; Initial setup &lt;&lt;&lt;\n        super().__init__(parent)\n        self.master = parent\n        self._coorHub = coorHub\n        self._motion_controller = motion_controller\n        self._dataHub_map = dataHub_map\n        self._dataHub_img = dataHub_img\n        self._dataHub_imgcal = dataHub_imgcal\n\n    # &gt;&gt;&gt; Main widget/layout setup &lt;&lt;&lt;\n        self._widget = Hilvl_CoorGen_UiDesign(self)\n        self._layout_main = qw.QHBoxLayout(self)\n        self._layout_main.addWidget(self._widget)\n        wdg = self._widget\n\n    # &gt;&gt;&gt; Top level frame setup &lt;&lt;&lt;\n        self._wdg_tv_mapcoor = Wdg_Treeview_MappingCoordinates(\n            wdg.wdg_coorHub_holder,self._coorHub)\n        wdg.lyt_coorHub_holder.addWidget(self._wdg_tv_mapcoor)\n\n        self._wdg_coorMod = Wdg_CoorModifier(\n            parent=self,\n            motion_controller=self._motion_controller,\n            coor_Hub=self._coorHub,\n        )\n        wdg.lyt_coorMod_holder.addWidget(self._wdg_coorMod)\n\n    # &gt;&gt;&gt; Mapping coordinate method widgets&lt;&lt;&lt;\n        # &gt; Dictionaries and parameters to set up the mapping methods &lt;\n        wdg.wdg_coorGen_holder.setLayout(qw.QVBoxLayout())\n        self._dict_mappingmethods_kwargs = {\n            'parent':wdg.wdg_coorGen_holder,\n            'motion_controller':self._motion_controller,\n            'dataHub_img':self._dataHub_img,\n            'dataHub_imgCal':self._dataHub_imgcal,\n            'getter_imgcal':self._dataHub_imgcal.get_selected_calibration,\n        }\n        self._dict_mappingmethods = {\n            '1. Start/End': Map1,\n            '2. Around center': Map2,\n            '3. Video': Map3,\n            '4. Image': Map4,\n            '5. Image points': Map5,\n            '6. Single point Z-scan': Map6,\n            }   # Mapping methods, to be programmed manually\n        self._current_map_method = Map1(**self._dict_mappingmethods_kwargs)\n        wdg.lyt_coorGen_holder.addWidget(self._current_map_method)\n\n        # &gt; Widget setup &lt;\n        # Mapping method selection\n        self._combo_mappingmethods = wdg.combo_coorGen\n        self._combo_mappingmethods.addItems(list(self._dict_mappingmethods.keys()))\n        self._combo_mappingmethods.currentTextChanged.connect(\n            lambda text: self.show_chosen_coorGen(text))\n\n        # Z-scan method selection\n        self._zscan_method = ZScan1(\n            parent = wdg.wdg_3Dmod_holder,\n            getter_stagecoor = self._motion_controller.get_coordinates_closest_mm)\n        wdg.lyt_3Dmod_holder.addWidget(self._zscan_method)\n\n        # &gt; Control widgets &lt;\n        self._btn_genCoor_2D = wdg.btn_gen_2Dcoor\n        self._btn_genCoor_3D = wdg.btn_gen_3Dcoor\n\n        self._btn_genCoor_2D.clicked.connect(self._generate_mapping_coordinate_2D)\n        self._btn_genCoor_3D.clicked.connect(self._generate_mapping_coordinate_3D)\n\n    def initialise(self):\n        \"\"\"\n        Initialises the treeview and loads the mapping coordinates from the hub.\n        \"\"\"\n        self._wdg_tv_mapcoor.sig_load_lastsession_MappingCoordinates.emit()\n\n    def terminate(self):\n        \"\"\"\n        Terminates the treeview and removes the observer from the hub.\n        \"\"\"\n        self._wdg_tv_mapcoor.save_MappingCoordinates(autosave=True)\n\n    def generate_current_mapping_coordinates(self) -&gt; MeaCoor_mm:\n        \"\"\"\n        Generates the current mapping coordinates based on the selected mapping method.\n\n        Returns:\n            MappingCoordinates_mm: The generated mapping coordinates.\n        \"\"\"\n        mapping_coordinates = self._current_map_method.get_mapping_coordinates_mm()\n\n        if mapping_coordinates is None: raise ValueError(\"No mapping coordinates generated\")\n\n        validator = self._dataHub_map.get_MappingHub().validate_new_unit_name\n        unit_name = None\n        while unit_name is None:\n            unit_name = messagebox_request_input(\n                parent=self,\n                title='Unit name',\n                message='Enter the \"unit name\" for the measurement:',\n                validator=validator,\n                invalid_msg='Invalid unit name. Please try again.',\n            )\n\n        return MeaCoor_mm(mappingUnit_name=unit_name, mapping_coordinates=mapping_coordinates) # pyright: ignore[reportArgumentType] ; At this point, mapping_coordinates is guaranteed to be a list of tuples of floats.\n\n    @Slot(str)\n    def show_chosen_coorGen(self, method_name:str):\n        \"\"\"\n        Shows the options for the selected mapping method\n\n        Args:\n            method_name (str): The name of the mapping method to show.\n        \"\"\"\n        widgets = get_all_widgets_from_layout(self._widget.lyt_coorGen_holder)\n\n        for widget in widgets:\n            widget.deleteLater()\n        qw.QApplication.processEvents()\n\n        self._current_map_method:Map1 = self._dict_mappingmethods[method_name](**self._dict_mappingmethods_kwargs)\n        self._widget.lyt_coorGen_holder.addWidget(self._current_map_method)\n\n    @Slot()\n    def _generate_mapping_coordinate_2D(self):\n        \"\"\"\n        Adds the mapping coordinate to the list\n        \"\"\"\n        mapping_coordinates = self._current_map_method.get_mapping_coordinates_mm()\n        # Convert to list of tuples of floats\n        if mapping_coordinates is None: return\n\n        mapping_hub = self._dataHub_map.get_MappingHub()\n        list_mappingUnit_names = list(mapping_hub.get_dict_nameToID().keys())\n        while True:\n            mappingUnit_name = qw.QInputDialog.getText(self, 'Mapping ID','Enter the ID for the mapping measurement:')[0]\n            if mappingUnit_name == '' or not isinstance(mappingUnit_name,str)\\\n                or mappingUnit_name in list_mappingUnit_names or self._coorHub.search_mappingCoor(mappingUnit_name) is not None:\n                retry = qw.QMessageBox.question(self, 'Error',\"Invalid 'mappingUnit name'. The name cannot be empty or already exist. Please try again.\",\n                    qw.QMessageBox.Retry | qw.QMessageBox.Cancel) # pyright: ignore[reportAttributeAccessIssue] ; Retry and Cancel attributes exists\n                if retry == qw.QMessageBox.Cancel: return # pyright: ignore[reportAttributeAccessIssue] ; Retry and Cancel attributes exists\n            else: break\n\n        mappingCoor = MeaCoor_mm(mappingUnit_name,mapping_coordinates)\n        self._coorHub.append(mappingCoor)\n\n    @Slot()\n    def _generate_mapping_coordinate_3D(self):\n        \"\"\"\n        Adds the z-scan mapping coordinate to the list\n        \"\"\"\n        def check_mappingUnit_name(name:str) -&gt; bool:\n            nonlocal self, list_mappingUnit_names, list_mapping_coordinates\n            res = True\n            if name == ''\\\n                or not isinstance(name,str)\\\n                or name in list_mappingUnit_names\\\n                or self._coorHub.search_mappingCoor(name) is not None:\n                res = False\n            return res\n\n        mapping_coordinates = self._current_map_method.get_mapping_coordinates_mm()\n        list_mapping_coordinates = self._zscan_method.get_coordinates_mm(mapping_coordinates)\n        if list_mapping_coordinates is None: return\n\n        list_zcoor = [f'z{list_coor[0][2]*1e3:.1f}um' for list_coor in list_mapping_coordinates]\n\n        mapping_hub = self._dataHub_map.get_MappingHub()\n        list_mappingUnit_names = list(mapping_hub.get_dict_nameToID().keys())\n        while True:\n            mappingUnit_name = qw.QInputDialog.getText(self, 'Mapping ID','Enter the ID for the mapping measurement:')[0]\n            list_new_mappingUnit_names = [mappingUnit_name+f'_{zcoor}' for zcoor in list_zcoor]\n            if any([not check_mappingUnit_name(name) for name in list_new_mappingUnit_names]) or mappingUnit_name == '':\n                retry = qw.QMessageBox.question(self, 'Error',\"Invalid 'mappingUnit name'. The name cannot be empty or already exist. Please try again.\",\n                    qw.QMessageBox.Retry | qw.QMessageBox.Cancel) # pyright: ignore[reportAttributeAccessIssue] ; Retry and Cancel attributes exists\n                if retry == qw.QMessageBox.Cancel: return # pyright: ignore[reportAttributeAccessIssue] ; Retry and Cancel attributes exists\n            else: break\n\n        list_mappingCoor = [\n            MeaCoor_mm(mappingUnit_name=name,mapping_coordinates=coor)\n            for name, coor in zip(list_new_mappingUnit_names, list_mapping_coordinates)\n        ]\n\n        self._coorHub.extend(list_mappingCoor)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Hilvl_CoorGenerator.__init__","title":"<code>__init__(parent, coorHub, motion_controller, dataHub_map, dataHub_img, dataHub_imgcal)</code>","text":"<p>Initialises the coordinate generator frame.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget.</p> required <code>coorHub</code> <code>List_MeaCoor_Hub</code> <p>The hub for the mapping coordinates.</p> required <code>motion_controller</code> <code>Wdg_MotionController</code> <p>The motion controller to use.</p> required <code>dataHub_map</code> <code>Wdg_DataHub_Mapping</code> <p>The mapping data hub to use.</p> required <code>dataHub_img</code> <code>Wdg_DataHub_Image</code> <p>The image measurement data hub to use.</p> required <code>dataHub_imgcal</code> <code>Wdg_DataHub_ImgCal</code> <p>The image calibration data hub to use.</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def __init__(self,\n             parent:qw.QWidget,\n             coorHub:List_MeaCoor_Hub,\n             motion_controller:Wdg_MotionController,\n             dataHub_map:Wdg_DataHub_Mapping,\n             dataHub_img:Wdg_DataHub_Image,\n             dataHub_imgcal:Wdg_DataHub_ImgCal,\n             ):\n    \"\"\"\n    Initialises the coordinate generator frame.\n\n    Args:\n        parent (qw.QWidget): The parent widget.\n        coorHub (List_MeaCoor_Hub): The hub for the mapping coordinates.\n        motion_controller (Wdg_MotionController): The motion controller to use.\n        dataHub_map (Wdg_DataHub_Mapping): The mapping data hub to use.\n        dataHub_img (Wdg_DataHub_Image): The image measurement data hub to use.\n        dataHub_imgcal (Wdg_DataHub_ImgCal): The image calibration data hub to use.\n    \"\"\"\n# &gt;&gt;&gt; Initial setup &lt;&lt;&lt;\n    super().__init__(parent)\n    self.master = parent\n    self._coorHub = coorHub\n    self._motion_controller = motion_controller\n    self._dataHub_map = dataHub_map\n    self._dataHub_img = dataHub_img\n    self._dataHub_imgcal = dataHub_imgcal\n\n# &gt;&gt;&gt; Main widget/layout setup &lt;&lt;&lt;\n    self._widget = Hilvl_CoorGen_UiDesign(self)\n    self._layout_main = qw.QHBoxLayout(self)\n    self._layout_main.addWidget(self._widget)\n    wdg = self._widget\n\n# &gt;&gt;&gt; Top level frame setup &lt;&lt;&lt;\n    self._wdg_tv_mapcoor = Wdg_Treeview_MappingCoordinates(\n        wdg.wdg_coorHub_holder,self._coorHub)\n    wdg.lyt_coorHub_holder.addWidget(self._wdg_tv_mapcoor)\n\n    self._wdg_coorMod = Wdg_CoorModifier(\n        parent=self,\n        motion_controller=self._motion_controller,\n        coor_Hub=self._coorHub,\n    )\n    wdg.lyt_coorMod_holder.addWidget(self._wdg_coorMod)\n\n# &gt;&gt;&gt; Mapping coordinate method widgets&lt;&lt;&lt;\n    # &gt; Dictionaries and parameters to set up the mapping methods &lt;\n    wdg.wdg_coorGen_holder.setLayout(qw.QVBoxLayout())\n    self._dict_mappingmethods_kwargs = {\n        'parent':wdg.wdg_coorGen_holder,\n        'motion_controller':self._motion_controller,\n        'dataHub_img':self._dataHub_img,\n        'dataHub_imgCal':self._dataHub_imgcal,\n        'getter_imgcal':self._dataHub_imgcal.get_selected_calibration,\n    }\n    self._dict_mappingmethods = {\n        '1. Start/End': Map1,\n        '2. Around center': Map2,\n        '3. Video': Map3,\n        '4. Image': Map4,\n        '5. Image points': Map5,\n        '6. Single point Z-scan': Map6,\n        }   # Mapping methods, to be programmed manually\n    self._current_map_method = Map1(**self._dict_mappingmethods_kwargs)\n    wdg.lyt_coorGen_holder.addWidget(self._current_map_method)\n\n    # &gt; Widget setup &lt;\n    # Mapping method selection\n    self._combo_mappingmethods = wdg.combo_coorGen\n    self._combo_mappingmethods.addItems(list(self._dict_mappingmethods.keys()))\n    self._combo_mappingmethods.currentTextChanged.connect(\n        lambda text: self.show_chosen_coorGen(text))\n\n    # Z-scan method selection\n    self._zscan_method = ZScan1(\n        parent = wdg.wdg_3Dmod_holder,\n        getter_stagecoor = self._motion_controller.get_coordinates_closest_mm)\n    wdg.lyt_3Dmod_holder.addWidget(self._zscan_method)\n\n    # &gt; Control widgets &lt;\n    self._btn_genCoor_2D = wdg.btn_gen_2Dcoor\n    self._btn_genCoor_3D = wdg.btn_gen_3Dcoor\n\n    self._btn_genCoor_2D.clicked.connect(self._generate_mapping_coordinate_2D)\n    self._btn_genCoor_3D.clicked.connect(self._generate_mapping_coordinate_3D)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Hilvl_CoorGenerator.generate_current_mapping_coordinates","title":"<code>generate_current_mapping_coordinates()</code>","text":"<p>Generates the current mapping coordinates based on the selected mapping method.</p> <p>Returns:</p> Name Type Description <code>MappingCoordinates_mm</code> <code>MeaCoor_mm</code> <p>The generated mapping coordinates.</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def generate_current_mapping_coordinates(self) -&gt; MeaCoor_mm:\n    \"\"\"\n    Generates the current mapping coordinates based on the selected mapping method.\n\n    Returns:\n        MappingCoordinates_mm: The generated mapping coordinates.\n    \"\"\"\n    mapping_coordinates = self._current_map_method.get_mapping_coordinates_mm()\n\n    if mapping_coordinates is None: raise ValueError(\"No mapping coordinates generated\")\n\n    validator = self._dataHub_map.get_MappingHub().validate_new_unit_name\n    unit_name = None\n    while unit_name is None:\n        unit_name = messagebox_request_input(\n            parent=self,\n            title='Unit name',\n            message='Enter the \"unit name\" for the measurement:',\n            validator=validator,\n            invalid_msg='Invalid unit name. Please try again.',\n        )\n\n    return MeaCoor_mm(mappingUnit_name=unit_name, mapping_coordinates=mapping_coordinates) # pyright: ignore[reportArgumentType] ; At this point, mapping_coordinates is guaranteed to be a list of tuples of floats.\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Hilvl_CoorGenerator.initialise","title":"<code>initialise()</code>","text":"<p>Initialises the treeview and loads the mapping coordinates from the hub.</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def initialise(self):\n    \"\"\"\n    Initialises the treeview and loads the mapping coordinates from the hub.\n    \"\"\"\n    self._wdg_tv_mapcoor.sig_load_lastsession_MappingCoordinates.emit()\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Hilvl_CoorGenerator.show_chosen_coorGen","title":"<code>show_chosen_coorGen(method_name)</code>","text":"<p>Shows the options for the selected mapping method</p> <p>Parameters:</p> Name Type Description Default <code>method_name</code> <code>str</code> <p>The name of the mapping method to show.</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>@Slot(str)\ndef show_chosen_coorGen(self, method_name:str):\n    \"\"\"\n    Shows the options for the selected mapping method\n\n    Args:\n        method_name (str): The name of the mapping method to show.\n    \"\"\"\n    widgets = get_all_widgets_from_layout(self._widget.lyt_coorGen_holder)\n\n    for widget in widgets:\n        widget.deleteLater()\n    qw.QApplication.processEvents()\n\n    self._current_map_method:Map1 = self._dict_mappingmethods[method_name](**self._dict_mappingmethods_kwargs)\n    self._widget.lyt_coorGen_holder.addWidget(self._current_map_method)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Hilvl_CoorGenerator.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the treeview and removes the observer from the hub.</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminates the treeview and removes the observer from the hub.\n    \"\"\"\n    self._wdg_tv_mapcoor.save_MappingCoordinates(autosave=True)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Treeview_MappingCoordinates","title":"<code>Wdg_Treeview_MappingCoordinates</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A class to create a treeview for the mapping coordinates.</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>class Wdg_Treeview_MappingCoordinates(qw.QWidget):\n    \"\"\"\n    A class to create a treeview for the mapping coordinates.\n    \"\"\"\n    sig_offload_mappingCoor = Signal(str, list, int) # Emitted to offload the mapping coordinates to the local disk.\n    sig_delete_offload_mappingCoor = Signal(str) # Emitted to delete the offloaded mapping coordinates from the local disk.\n    sig_load_mappingCoor = Signal(list) # Emitted to load the mapping coordinates from the local disk.\n    sig_load_lastsession_MappingCoordinates = Signal() # Emitted to load the mapping coordinates from the previous session.\n    sig_save_mappingCoor = Signal(list, str, str) # Emitted to save the mapping coordinates to the local disk.\n\n    _sig_update_tree = Signal() # Emitted when the treeview needs to be updated.\n\n    def __init__(self,parent:qw.QWidget,mappingCoorHub:List_MeaCoor_Hub):\n        \"\"\"\n        Initialises the treeview for the mapping coordinates.\n\n        Args:\n            parent (tk.Tk | tk.Frame): The parent frame or window.\n            mappingCoorHub (MappingCoordinatesHub): The hub for the mapping coordinates.\n        \"\"\"\n        super().__init__(parent)\n        self._mappingCoorHub = mappingCoorHub\n\n        # &gt; Top level frame setup &lt;\n        self._widget = DataHub_Coor_UiDesign(self)\n        self._layout_main = qw.QHBoxLayout(self)\n        self._layout_main.addWidget(self._widget)\n        wdg = self._widget\n\n        self._init_multiCoor_tree()\n\n        # &gt; Control widgets &lt;\n        self._btn_remove = wdg.btn_remove\n        self._btn_rename = wdg.btn_rename\n        self._btn_load = wdg.btn_load\n        self._btn_save = wdg.btn_save\n\n        self._btn_remove.clicked.connect(lambda: self._remove_selected_mapping_coordinate())\n        self._btn_rename.clicked.connect(lambda: self.rename_MappingCoordinate())\n        self._btn_load.clicked.connect(lambda: self._load_MappingCoordinates())\n        self._btn_save.clicked.connect(lambda: self.save_MappingCoordinates(type='csv'))\n\n        # &gt; Run parameters setup &lt;\n        self._sig_update_tree.connect(self._update_multi_mapping_tree)\n        self._mappingCoorHub.add_observer(self._sig_update_tree.emit)\n\n        # &gt; Worker and thread setup &lt;\n        self._worker = Coor_saveload_worker(self._mappingCoorHub)\n        self._thread = QThread(self)\n        self._worker.moveToThread(self._thread)\n\n        self.destroyed.connect(self._thread.quit)\n        self.destroyed.connect(self._worker.deleteLater)\n        self._thread.finished.connect(self._worker.deleteLater)\n        self._thread.finished.connect(self._thread.deleteLater)\n\n        self._thread.start()\n\n        self.sig_offload_mappingCoor.connect(self._worker.offload_mappingCoor)\n        self.sig_delete_offload_mappingCoor.connect(self._worker.delete_offload_mappingCoor)\n        self.sig_load_mappingCoor.connect(self._worker.load_MappingCoordinates)\n        self.sig_load_lastsession_MappingCoordinates.connect(self._worker.load_lastsession_MappingCoordinates)\n        self.sig_save_mappingCoor.connect(self._worker.save_MappingCoordinates)\n\n        self._worker.sig_save_error.connect(lambda msg: qw.QMessageBox.warning(self, 'Error', msg))\n        self._worker.sig_load_error.connect(lambda msg: qw.QMessageBox.warning(self, 'Error', msg))\n        self._worker.sig_loaded_lastsession.connect(\n            lambda msg: qw.QMessageBox.information(self, 'Info', msg))\n\n        self._worker.sig_save_done.connect(lambda: self._btn_save.setEnabled(True))\n        self._worker.sig_load_done.connect(lambda: self._btn_load.setEnabled(True))\n        self._worker.sig_loaded_lastsession.connect(lambda: self._btn_load.setEnabled(True))\n\n    def _init_multiCoor_tree(self):\n        \"\"\"\n        Initialises the tree view for the multi-coordinate mapping\n        \"\"\"\n        self._tree = self._widget.tree_coor\n\n        self._tree.setColumnCount(3)\n        self._tree.setHeaderLabels(['Index','ROI name','Number of samplings'])\n\n    def get_selected_mappingCoor(self, flg_message:bool=False) -&gt; list[MeaCoor_mm]:\n        \"\"\"\n        Gets the selected mapping coordinates from the tree view\n\n        Args:\n            message (bool): If True, a message box will be shown to notify the user of the selected units. Defaults to False.\n\n        Returns:\n            list[MappingCoordinates]: The list of selected mapping coordinates\n        \"\"\"\n        list_sels = self._tree.selectedItems()\n        list_names = [item.text(1) for item in list_sels]\n\n        list_sel_mapCoor = self._mappingCoorHub.get_list_MappingCoordinates(list_names)\n\n        if flg_message:\n            if len(list_sel_mapCoor) == 0:\n                qw.QMessageBox.information(self, 'No selection', 'No mapping coordinates have been selected.')\n            list_show_names = [mc.mappingUnit_name for mc in list_sel_mapCoor]\n            if len(list_sel_mapCoor) &gt; 3:\n                list_show_names = [mc.mappingUnit_name for mc in list_sel_mapCoor[:3]] + ['...']\n            qw.QMessageBox.information(self, 'Selected mapping coordinates',\n                                f'The following mapping coordinates have been selected:\\n\\n{list_show_names}')\n        return list_sel_mapCoor\n\n    def offload_mappingCoor(self,mapping_unitName:str,list_coor:list,idx:int):\n        \"\"\"\n        Saves the unfinished mapping coordinates to the local disk in the temporary folder. It will\n        save it with the mapping_unitName as the filename and overwrite it if it already exists.\n\n        Args:\n            mapping_unitName (str): The name of the mapping unit\n            list_coor (list): The list of coordinates to be saved, in the format [(x1, y1, z1), (x2, y2, z2), ...].\n            idx (int): The index of the mapping coordinates in the list indicating the measurements done.\n                (Convention: Up to idx-1 are done).\n        \"\"\"\n        # &gt; Save the mapping coordinates to the local disk\n        if not isinstance(list_coor, list) or len(list_coor) == 0:\n            print('No coordinates to save')\n            return\n\n        idx = idx-1 if idx!=0 else 0\n        list_coor_temp = list_coor.copy()[idx:]  # Create a copy to avoid modifying the original list\n        self.sig_offload_mappingCoor.emit(mapping_unitName,list_coor_temp,idx)\n\n    def delete_offload_mappingCoor(self,mapping_unitName:str):\n        \"\"\"\n        Deletes the offloaded mapping coordinates from the local disk in the temporary folder.\n        It will delete the file with the mapping_unitName as the filename.\n\n        Args:\n            mapping_unitName (str): The name of the mapping unit\n        \"\"\"\n        # &gt; Delete the mapping coordinates from the local disk\n        self.sig_delete_offload_mappingCoor.emit(mapping_unitName)\n\n    def _load_MappingCoordinates(self):\n        \"\"\"\n        Loads the mapping coordinates from a pickle file and adds them to the list of mapping coordinates.\n\n        Args:\n            list_loadpath (list[str]|None): The path to load the coordinates from. Defaults to None.\n\n        Returns:\n            MappingCoordinates: The loaded mapping coordinates.\n        \"\"\"\n        def reset():\n            self._btn_load.setEnabled(True)\n\n        self._btn_load.setEnabled(False)\n\n        list_loadpath, _ = qw.QFileDialog.getOpenFileNames(\n            self,'Select the mapping coordinates files to load',\n            filter='Pickle files (*.pkl);;CSV files (*.csv)'\n        )\n\n        if len(list_loadpath) == 0: return None\n\n        if not isinstance(list_loadpath, (list,tuple)):\n            qw.QMessageBox.warning(self, 'Error',f\"Expected list, got {type(list_loadpath)}\")\n            return\n        if not all(isinstance(path, str) for path in list_loadpath):\n            qw.QMessageBox.warning(self, 'Error',f\"Expected list of str, got {type(list_loadpath)}\")\n            return\n        if not all(os.path.exists(path) for path in list_loadpath):\n            qw.QMessageBox.warning(self, 'Error',f\"Some files do not exist\")\n            return\n\n        self.sig_load_mappingCoor.emit(list_loadpath)\n        return\n\n    def save_MappingCoordinates(self,autosave:bool=False,type:Literal['pickle','csv']='pickle'):\n        \"\"\"\n        Saves the selected mapping coordinates to a pickle file.\n\n        Args:\n            autosave (bool): If True, suppresses the message box and uses the temporary folder. Defaults to False.\n            type (Literal['pickle','csv']): The type of file to save the coordinates to. Defaults to 'pickle'.\n        \"\"\"\n        def reset():\n            nonlocal self\n\n        if autosave: list_selection = self._tree.findItems('*', Qt.MatchWildcard | Qt.MatchRecursive) # pyright: ignore[reportAttributeAccessIssue] ; MatchWildcard and MatchRecursive attributes exists\n        else: list_selection = self._tree.selectedItems()\n\n        if len(list_selection) == 0:\n            if not autosave:\n                qw.QMessageBox.warning(self, 'Error','No mapping coordinates selected')\n            return\n\n        if autosave:\n            dirpath = os.path.abspath(AppRamanEnum.TEMPORARY_FOLDER.value)\n            if not os.path.exists(dirpath): os.makedirs(dirpath)\n        else:\n            dirpath = qw.QFileDialog.getExistingDirectory(\n                self,'Select the directory to save the mapping coordinates')\n        if not os.path.exists(dirpath):\n            if not autosave: qw.QMessageBox.warning(self, 'Error',f\"Directory {dirpath} does not exist\")\n            reset()\n            return\n\n        # Save all selected mapping coordinates\n        list_names = [item.text(1) for item in list_selection]\n        self.sig_save_mappingCoor.emit(list_names,dirpath,type)\n        if not autosave: qw.QMessageBox.information(self, 'Info','Mapping coordinates saved')\n        return\n\n    def rename_MappingCoordinate(self):\n        \"\"\"\n        Renames the selected mapping coordinate in the list.\n        \"\"\"\n        list_names = [item.text(1) for item in self._tree.selectedItems()]\n\n        if len(list_names) == 0:\n            qw.QMessageBox.information(self, 'No selection', 'No mapping coordinates have been selected.')\n        elif len(list_names) &gt; 1:\n            qw.QMessageBox.information(self, 'Multiple selection', 'Please select only one mapping coordinate to rename at a time.')\n            return\n\n        init_name = list_names[0]\n        while True:\n            try:\n                new_name,ok = qw.QInputDialog.getText(self, 'Rename mapping coordinate',\n                    f'Enter the new name for the mapping coordinate for\\n\"{init_name}\":',\n                    text=init_name)\n                if not ok: return\n                self._mappingCoorHub.rename_mappingCoor(init_name, new_name)\n                break\n            except ValueError as e:\n                qw.QMessageBox.warning(self, 'Error',f\"Invalid unit name: {e}\")\n\n    def _remove_selected_mapping_coordinate(self):\n        \"\"\"\n        Removes the selected mapping coordinate from the list\n        \"\"\"\n        list_selection = self._tree.selectedItems()\n        list_unitname = [item.text(1) for item in list_selection]\n\n        for unitname in list_unitname:\n            self._mappingCoorHub.remove_mappingCoor(unitname)\n\n    @Slot()\n    def _update_multi_mapping_tree(self):\n        \"\"\"\n        Refreshes the tree view for the multi-coordinate mapping with the data stored in the dictionary\n        \"\"\"\n        self._tree.clear()\n\n        for i, mappingCoor in enumerate(self._mappingCoorHub):\n            qw.QTreeWidgetItem(self._tree, [str(i+1), mappingCoor.mappingUnit_name, str(len(mappingCoor.mapping_coordinates))])\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Treeview_MappingCoordinates.__init__","title":"<code>__init__(parent, mappingCoorHub)</code>","text":"<p>Initialises the treeview for the mapping coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Tk | Frame</code> <p>The parent frame or window.</p> required <code>mappingCoorHub</code> <code>MappingCoordinatesHub</code> <p>The hub for the mapping coordinates.</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def __init__(self,parent:qw.QWidget,mappingCoorHub:List_MeaCoor_Hub):\n    \"\"\"\n    Initialises the treeview for the mapping coordinates.\n\n    Args:\n        parent (tk.Tk | tk.Frame): The parent frame or window.\n        mappingCoorHub (MappingCoordinatesHub): The hub for the mapping coordinates.\n    \"\"\"\n    super().__init__(parent)\n    self._mappingCoorHub = mappingCoorHub\n\n    # &gt; Top level frame setup &lt;\n    self._widget = DataHub_Coor_UiDesign(self)\n    self._layout_main = qw.QHBoxLayout(self)\n    self._layout_main.addWidget(self._widget)\n    wdg = self._widget\n\n    self._init_multiCoor_tree()\n\n    # &gt; Control widgets &lt;\n    self._btn_remove = wdg.btn_remove\n    self._btn_rename = wdg.btn_rename\n    self._btn_load = wdg.btn_load\n    self._btn_save = wdg.btn_save\n\n    self._btn_remove.clicked.connect(lambda: self._remove_selected_mapping_coordinate())\n    self._btn_rename.clicked.connect(lambda: self.rename_MappingCoordinate())\n    self._btn_load.clicked.connect(lambda: self._load_MappingCoordinates())\n    self._btn_save.clicked.connect(lambda: self.save_MappingCoordinates(type='csv'))\n\n    # &gt; Run parameters setup &lt;\n    self._sig_update_tree.connect(self._update_multi_mapping_tree)\n    self._mappingCoorHub.add_observer(self._sig_update_tree.emit)\n\n    # &gt; Worker and thread setup &lt;\n    self._worker = Coor_saveload_worker(self._mappingCoorHub)\n    self._thread = QThread(self)\n    self._worker.moveToThread(self._thread)\n\n    self.destroyed.connect(self._thread.quit)\n    self.destroyed.connect(self._worker.deleteLater)\n    self._thread.finished.connect(self._worker.deleteLater)\n    self._thread.finished.connect(self._thread.deleteLater)\n\n    self._thread.start()\n\n    self.sig_offload_mappingCoor.connect(self._worker.offload_mappingCoor)\n    self.sig_delete_offload_mappingCoor.connect(self._worker.delete_offload_mappingCoor)\n    self.sig_load_mappingCoor.connect(self._worker.load_MappingCoordinates)\n    self.sig_load_lastsession_MappingCoordinates.connect(self._worker.load_lastsession_MappingCoordinates)\n    self.sig_save_mappingCoor.connect(self._worker.save_MappingCoordinates)\n\n    self._worker.sig_save_error.connect(lambda msg: qw.QMessageBox.warning(self, 'Error', msg))\n    self._worker.sig_load_error.connect(lambda msg: qw.QMessageBox.warning(self, 'Error', msg))\n    self._worker.sig_loaded_lastsession.connect(\n        lambda msg: qw.QMessageBox.information(self, 'Info', msg))\n\n    self._worker.sig_save_done.connect(lambda: self._btn_save.setEnabled(True))\n    self._worker.sig_load_done.connect(lambda: self._btn_load.setEnabled(True))\n    self._worker.sig_loaded_lastsession.connect(lambda: self._btn_load.setEnabled(True))\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Treeview_MappingCoordinates.delete_offload_mappingCoor","title":"<code>delete_offload_mappingCoor(mapping_unitName)</code>","text":"<p>Deletes the offloaded mapping coordinates from the local disk in the temporary folder. It will delete the file with the mapping_unitName as the filename.</p> <p>Parameters:</p> Name Type Description Default <code>mapping_unitName</code> <code>str</code> <p>The name of the mapping unit</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def delete_offload_mappingCoor(self,mapping_unitName:str):\n    \"\"\"\n    Deletes the offloaded mapping coordinates from the local disk in the temporary folder.\n    It will delete the file with the mapping_unitName as the filename.\n\n    Args:\n        mapping_unitName (str): The name of the mapping unit\n    \"\"\"\n    # &gt; Delete the mapping coordinates from the local disk\n    self.sig_delete_offload_mappingCoor.emit(mapping_unitName)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Treeview_MappingCoordinates.get_selected_mappingCoor","title":"<code>get_selected_mappingCoor(flg_message=False)</code>","text":"<p>Gets the selected mapping coordinates from the tree view</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bool</code> <p>If True, a message box will be shown to notify the user of the selected units. Defaults to False.</p> required <p>Returns:</p> Type Description <code>list[MeaCoor_mm]</code> <p>list[MappingCoordinates]: The list of selected mapping coordinates</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def get_selected_mappingCoor(self, flg_message:bool=False) -&gt; list[MeaCoor_mm]:\n    \"\"\"\n    Gets the selected mapping coordinates from the tree view\n\n    Args:\n        message (bool): If True, a message box will be shown to notify the user of the selected units. Defaults to False.\n\n    Returns:\n        list[MappingCoordinates]: The list of selected mapping coordinates\n    \"\"\"\n    list_sels = self._tree.selectedItems()\n    list_names = [item.text(1) for item in list_sels]\n\n    list_sel_mapCoor = self._mappingCoorHub.get_list_MappingCoordinates(list_names)\n\n    if flg_message:\n        if len(list_sel_mapCoor) == 0:\n            qw.QMessageBox.information(self, 'No selection', 'No mapping coordinates have been selected.')\n        list_show_names = [mc.mappingUnit_name for mc in list_sel_mapCoor]\n        if len(list_sel_mapCoor) &gt; 3:\n            list_show_names = [mc.mappingUnit_name for mc in list_sel_mapCoor[:3]] + ['...']\n        qw.QMessageBox.information(self, 'Selected mapping coordinates',\n                            f'The following mapping coordinates have been selected:\\n\\n{list_show_names}')\n    return list_sel_mapCoor\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Treeview_MappingCoordinates.offload_mappingCoor","title":"<code>offload_mappingCoor(mapping_unitName, list_coor, idx)</code>","text":"<p>Saves the unfinished mapping coordinates to the local disk in the temporary folder. It will save it with the mapping_unitName as the filename and overwrite it if it already exists.</p> <p>Parameters:</p> Name Type Description Default <code>mapping_unitName</code> <code>str</code> <p>The name of the mapping unit</p> required <code>list_coor</code> <code>list</code> <p>The list of coordinates to be saved, in the format [(x1, y1, z1), (x2, y2, z2), ...].</p> required <code>idx</code> <code>int</code> <p>The index of the mapping coordinates in the list indicating the measurements done. (Convention: Up to idx-1 are done).</p> required Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def offload_mappingCoor(self,mapping_unitName:str,list_coor:list,idx:int):\n    \"\"\"\n    Saves the unfinished mapping coordinates to the local disk in the temporary folder. It will\n    save it with the mapping_unitName as the filename and overwrite it if it already exists.\n\n    Args:\n        mapping_unitName (str): The name of the mapping unit\n        list_coor (list): The list of coordinates to be saved, in the format [(x1, y1, z1), (x2, y2, z2), ...].\n        idx (int): The index of the mapping coordinates in the list indicating the measurements done.\n            (Convention: Up to idx-1 are done).\n    \"\"\"\n    # &gt; Save the mapping coordinates to the local disk\n    if not isinstance(list_coor, list) or len(list_coor) == 0:\n        print('No coordinates to save')\n        return\n\n    idx = idx-1 if idx!=0 else 0\n    list_coor_temp = list_coor.copy()[idx:]  # Create a copy to avoid modifying the original list\n    self.sig_offload_mappingCoor.emit(mapping_unitName,list_coor_temp,idx)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Treeview_MappingCoordinates.rename_MappingCoordinate","title":"<code>rename_MappingCoordinate()</code>","text":"<p>Renames the selected mapping coordinate in the list.</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def rename_MappingCoordinate(self):\n    \"\"\"\n    Renames the selected mapping coordinate in the list.\n    \"\"\"\n    list_names = [item.text(1) for item in self._tree.selectedItems()]\n\n    if len(list_names) == 0:\n        qw.QMessageBox.information(self, 'No selection', 'No mapping coordinates have been selected.')\n    elif len(list_names) &gt; 1:\n        qw.QMessageBox.information(self, 'Multiple selection', 'Please select only one mapping coordinate to rename at a time.')\n        return\n\n    init_name = list_names[0]\n    while True:\n        try:\n            new_name,ok = qw.QInputDialog.getText(self, 'Rename mapping coordinate',\n                f'Enter the new name for the mapping coordinate for\\n\"{init_name}\":',\n                text=init_name)\n            if not ok: return\n            self._mappingCoorHub.rename_mappingCoor(init_name, new_name)\n            break\n        except ValueError as e:\n            qw.QMessageBox.warning(self, 'Error',f\"Invalid unit name: {e}\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.Wdg_Treeview_MappingCoordinates.save_MappingCoordinates","title":"<code>save_MappingCoordinates(autosave=False, type='pickle')</code>","text":"<p>Saves the selected mapping coordinates to a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>autosave</code> <code>bool</code> <p>If True, suppresses the message box and uses the temporary folder. Defaults to False.</p> <code>False</code> <code>type</code> <code>Literal['pickle', 'csv']</code> <p>The type of file to save the coordinates to. Defaults to 'pickle'.</p> <code>'pickle'</code> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def save_MappingCoordinates(self,autosave:bool=False,type:Literal['pickle','csv']='pickle'):\n    \"\"\"\n    Saves the selected mapping coordinates to a pickle file.\n\n    Args:\n        autosave (bool): If True, suppresses the message box and uses the temporary folder. Defaults to False.\n        type (Literal['pickle','csv']): The type of file to save the coordinates to. Defaults to 'pickle'.\n    \"\"\"\n    def reset():\n        nonlocal self\n\n    if autosave: list_selection = self._tree.findItems('*', Qt.MatchWildcard | Qt.MatchRecursive) # pyright: ignore[reportAttributeAccessIssue] ; MatchWildcard and MatchRecursive attributes exists\n    else: list_selection = self._tree.selectedItems()\n\n    if len(list_selection) == 0:\n        if not autosave:\n            qw.QMessageBox.warning(self, 'Error','No mapping coordinates selected')\n        return\n\n    if autosave:\n        dirpath = os.path.abspath(AppRamanEnum.TEMPORARY_FOLDER.value)\n        if not os.path.exists(dirpath): os.makedirs(dirpath)\n    else:\n        dirpath = qw.QFileDialog.getExistingDirectory(\n            self,'Select the directory to save the mapping coordinates')\n    if not os.path.exists(dirpath):\n        if not autosave: qw.QMessageBox.warning(self, 'Error',f\"Directory {dirpath} does not exist\")\n        reset()\n        return\n\n    # Save all selected mapping coordinates\n    list_names = [item.text(1) for item in list_selection]\n    self.sig_save_mappingCoor.emit(list_names,dirpath,type)\n    if not autosave: qw.QMessageBox.information(self, 'Info','Mapping coordinates saved')\n    return\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.generate_dummy_wdg_hilvlCoorGenerator","title":"<code>generate_dummy_wdg_hilvlCoorGenerator(parent, motion_controller=None, datahub_map=None, datahub_img=None, datahub_imgcal=None)</code>","text":"<p>Generates a dummy coordinate generator frame for testing purposes.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Tk | Frame</code> <p>The parent frame or window.</p> required <code>motion_controller</code> <code>Frm_MotionController | None</code> <p>The motion controller to use. If None, a dummy motion controller will be generated.</p> <code>None</code> <code>datahub_map</code> <code>Frm_DataHub_Mapping | None</code> <p>The mapping data hub to use. If None, a dummy mapping data hub will be generated.</p> <code>None</code> <code>datahub_img</code> <code>ImageMeasurement_Hub | None</code> <p>The image measurement hub to use. If None, a dummy image measurement hub will be generated.</p> <code>None</code> <code>datahub_imgcal</code> <code>ImageMeasurement_Calibration_Hub | None</code> <p>The image calibration hub to use. If None, a dummy image calibration hub will be generated.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sframe_CoorGenerator</code> <code>Wdg_Hilvl_CoorGenerator</code> <p>The dummy coordinate generator frame.</p> Source code in <code>iris/gui/hilvl_coorGen.py</code> <pre><code>def generate_dummy_wdg_hilvlCoorGenerator(\n    parent:qw.QWidget,\n    motion_controller:Wdg_MotionController|None=None,\n    datahub_map:Wdg_DataHub_Mapping|None=None,\n    datahub_img:Wdg_DataHub_Image|None=None,\n    datahub_imgcal:Wdg_DataHub_ImgCal|None=None\n    ) -&gt; Wdg_Hilvl_CoorGenerator:\n    \"\"\"\n    Generates a dummy coordinate generator frame for testing purposes.\n\n    Args:\n        parent (tk.Tk | tk.Frame): The parent frame or window.\n        motion_controller (Frm_MotionController | None): The motion controller to use. If None, a dummy motion controller will be generated.\n        datahub_map (Frm_DataHub_Mapping | None): The mapping data hub to use. If None, a dummy mapping data hub will be generated.\n        datahub_img (ImageMeasurement_Hub | None): The image measurement hub to use. If None, a dummy image measurement hub will be generated.\n        datahub_imgcal (ImageMeasurement_Calibration_Hub | None): The image calibration hub to use. If None, a dummy image calibration hub will be generated.\n\n    Returns:\n        sframe_CoorGenerator: The dummy coordinate generator frame.\n    \"\"\"\n    from iris.gui.motion_video import generate_dummy_motion_controller\n    from iris.data.calibration_objective import generate_dummy_calibrationHub\n    from iris.gui.dataHub_MeaImg import generate_dummy_frmImageHub, generate_dummy_frmImgCalHub\n    from iris.gui.dataHub_MeaRMap import generate_dummy_frmMappingHub\n\n    coorHub = List_MeaCoor_Hub()\n    motion_controller = generate_dummy_motion_controller(parent) if motion_controller is None else motion_controller\n    dataHub_map = generate_dummy_frmMappingHub(parent) if datahub_map is None else datahub_map\n    dataHub_img = generate_dummy_frmImageHub(parent) if datahub_img is None else datahub_img\n    dataHub_imgcal = generate_dummy_frmImgCalHub(parent) if datahub_imgcal is None else datahub_imgcal\n\n    return Wdg_Hilvl_CoorGenerator(\n        parent=parent,\n        coorHub=coorHub,\n        motion_controller=motion_controller,\n        dataHub_map=dataHub_map,\n        dataHub_img=dataHub_img,\n        dataHub_imgcal=dataHub_imgcal,\n    )\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/hilvl_coorGen/#iris.gui.hilvl_coorGen.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/motion_video/","title":"motion_video","text":"<p>A class that manages the motion controller aspect for the Thorlabs stages</p> <p>Made on: 04 March 2024 By: Kevin Uning For: The Thomas Group, Biochemical Engineering Dept., UCL</p>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.CustomButton","title":"<code>CustomButton</code>","text":"<p>               Bases: <code>QPushButton</code></p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>class CustomButton(qw.QPushButton):\n    # Define custom signals for left and right clicks\n    rightClicked = Signal()\n    leftClicked = Signal()\n    leftReleased = Signal()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Connect the custom signals to the provided functions\n\n    def set_left_click_function(self, func: Callable[[], Any]):\n        \"\"\"\n        Sets the function to be called on left click\n\n        Args:\n            func (Callable[[], Any]): The function to be called on left click\n        \"\"\"\n        self.leftClicked.connect(func)\n\n    def set_left_release_function(self, func: Callable[[], Any]):\n        \"\"\"\n        Sets the function to be called on left button release\n\n        Args:\n            func (Callable[[], Any]): The function to be called on left button release\n        \"\"\"\n        self.leftReleased.connect(func)\n\n    def set_right_click_function(self, func: Callable[[], Any]):\n        \"\"\"\n        Sets the function to be called on right click\n\n        Args:\n            func (Callable[[], Any]): The function to be called on right click\n        \"\"\"\n        self.rightClicked.connect(func)\n\n    def mousePressEvent(self, event):\n        if event.button() == qt.MouseButton.LeftButton:\n            self.leftClicked.emit()\n        elif event.button() == qt.MouseButton.RightButton:\n            self.rightClicked.emit()\n        super().mousePressEvent(event)\n\n    def mouseReleaseEvent(self, event):\n        if event.button() == qt.MouseButton.LeftButton:\n            self.leftReleased.emit()\n        super().mouseReleaseEvent(event)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.CustomButton.set_left_click_function","title":"<code>set_left_click_function(func)</code>","text":"<p>Sets the function to be called on left click</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[], Any]</code> <p>The function to be called on left click</p> required Source code in <code>iris/gui/motion_video.py</code> <pre><code>def set_left_click_function(self, func: Callable[[], Any]):\n    \"\"\"\n    Sets the function to be called on left click\n\n    Args:\n        func (Callable[[], Any]): The function to be called on left click\n    \"\"\"\n    self.leftClicked.connect(func)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.CustomButton.set_left_release_function","title":"<code>set_left_release_function(func)</code>","text":"<p>Sets the function to be called on left button release</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[], Any]</code> <p>The function to be called on left button release</p> required Source code in <code>iris/gui/motion_video.py</code> <pre><code>def set_left_release_function(self, func: Callable[[], Any]):\n    \"\"\"\n    Sets the function to be called on left button release\n\n    Args:\n        func (Callable[[], Any]): The function to be called on left button release\n    \"\"\"\n    self.leftReleased.connect(func)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.CustomButton.set_right_click_function","title":"<code>set_right_click_function(func)</code>","text":"<p>Sets the function to be called on right click</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[], Any]</code> <p>The function to be called on right click</p> required Source code in <code>iris/gui/motion_video.py</code> <pre><code>def set_right_click_function(self, func: Callable[[], Any]):\n    \"\"\"\n    Sets the function to be called on right click\n\n    Args:\n        func (Callable[[], Any]): The function to be called on right click\n    \"\"\"\n    self.rightClicked.connect(func)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Motion_GetCoordinatesClosest_mm_Worker","title":"<code>Motion_GetCoordinatesClosest_mm_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A worker to get the closest coordinates in mm from the stage controller</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>class Motion_GetCoordinatesClosest_mm_Worker(QObject):\n    \"\"\"\n    A worker to get the closest coordinates in mm from the stage controller\n    \"\"\"\n    sig_coor = Signal(np.ndarray)\n\n    def __init__(self, stageHub:DataStreamer_StageCam, parent=None):\n        super().__init__(parent)\n        self._stageHub = stageHub\n\n    def _get_coor(self):\n        timestamp_req = get_timestamp_us_int()\n        result = self._stageHub.get_coordinates_closest(timestamp_req)\n\n        if result is None:\n            return (None,None,None)\n\n        coor_x,coor_y,coor_z = result\n        coor = np.array([coor_x,coor_y,coor_z])\n        return coor\n\n    @Slot()\n    def work_async(self):\n        coor = self._get_coor()\n        self.sig_coor.emit(coor)\n\n    @Slot(queue.Queue)\n    def work_sync(self, q_ret:queue.Queue):\n        coor = self._get_coor()\n        q_ret.put(coor)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Motion_GoToCoor_Worker","title":"<code>Motion_GoToCoor_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A worker to move the stage to the target coordinates</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>class Motion_GoToCoor_Worker(QObject):\n    \"\"\"\n    A worker to move the stage to the target coordinates\n    \"\"\"\n    sig_mvmt_started = Signal(str)\n    sig_mvmt_finished = Signal(str)\n\n    msg_target_reached = 'Target reached'\n    msg_target_timeout = 'Timeout waiting for target'\n    msg_target_failed = 'Failed to set or reach target'\n\n    def __init__(self, stageHub:DataStreamer_StageCam, ctrl_xy: 'Controller_XY',\n                 ctrl_z: 'Controller_Z', parent=None):\n        super().__init__(parent)\n        self._stageHub = stageHub\n        self.ctrl_xy = ctrl_xy\n        self.ctrl_z = ctrl_z\n\n    def _get_coor(self) -&gt; np.ndarray|None:\n        \"\"\"\n        Gets the current coordinates from the stage hub\n\n        Returns:\n            np.ndarray: The current coordinates in mm (x,y,z)\n        \"\"\"\n        timestamp_req = get_timestamp_us_int()\n        result = self._stageHub.get_coordinates_closest(timestamp_req)\n\n        if result is None: return None\n        else: return np.array(result)\n\n    def _notify_finish(self, thread_xy:threading.Thread, thread_z:threading.Thread,\n                       event_finished:threading.Event):\n        \"\"\"\n        Waits for the target to be reached, the coordinate doesn't update within the timeout, raises a TimeoutError\n\n        Args:\n            thread_xy (threading.Thread): The thread moving the XY stage\n            thread_z (threading.Thread): The thread moving the Z stage\n            timeout (float): Timeout in seconds\n\n        Raises:\n            TimeoutError: If the target is not reached within the timeout\n        \"\"\"\n        timeout = WAIT_MOVEMENT_TIMEOUT\n\n        start_time = time.time()\n        coor = self._get_coor()\n        while True:\n            if thread_xy.is_alive() or thread_z.is_alive():\n                thread_xy.join(timeout=0.1)\n                thread_z.join(timeout=0.1)\n            else:\n                event_finished.set()\n                self.sig_mvmt_finished.emit(self.msg_target_reached)\n                break\n\n            if time.time() - start_time &gt; timeout:\n                event_finished.set()\n                self.sig_mvmt_finished.emit(self.msg_target_timeout)\n\n            coor_new = self._get_coor()\n            # Resets the timer if the coordinates are not the same (i.e., the stage is still moving)\n            if coor_new is None: continue\n            if coor is None: coor = coor_new\n            if np.allclose(coor,coor_new,atol=0.001): start_time = time.time()\n            coor = coor_new\n\n    @Slot(tuple, threading.Event)\n    def work(\n        self,\n        coors_mm:tuple[float,float,float],\n        event_finished:threading.Event):\n        \"\"\"\n        Moves the stage to specific coordinates, except if None is provided\n\n        Args:\n            coors_mm (tuple[float,float,float]): Target coordinates in mm (x,y,z). Use None to skip moving that axis.\n            event_finished (threading.Event): An event to signal when the movement is finished.\n        \"\"\"\n        # print('Motion_GoToCoor_Worker.work() called with coordinates (mm):',coors_mm)\n        # print('Thread ID:', threading.current_thread().ident)\n        # If None is provided, assign the current coordinates (i.e., do not move)\n        coor_x_mm, coor_y_mm, coor_z_mm = coors_mm\n        if any([coor_x_mm is None,coor_y_mm is None,coor_z_mm is None]):\n            res = self._get_coor()\n            if res is None:\n                self.sig_mvmt_finished.emit(self.msg_target_failed)\n                return\n            coor_x_current,coor_y_current,coor_z_current = res\n            if coor_x_mm is None: coor_x_mm = coor_x_current\n            if coor_y_mm is None: coor_y_mm = coor_y_current\n            if coor_z_mm is None: coor_z_mm = coor_z_current\n\n        self.sig_mvmt_started.emit('Moving to X: {:.3f} Y: {:.3f} Z: {:.3f} mm'.format(coor_x_mm,coor_y_mm,coor_z_mm))\n\n        # Operate both stages at once\n        thread_xy_move = threading.Thread(target=self.ctrl_xy.move_direct,args=((coor_x_mm,coor_y_mm),))\n        thread_z_move = threading.Thread(target=self.ctrl_z.move_direct,args=(coor_z_mm,))\n\n        thread_xy_move.start()\n        thread_z_move.start()\n\n        self._notify_finish(thread_xy_move,thread_z_move,event_finished)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Motion_GoToCoor_Worker.work","title":"<code>work(coors_mm, event_finished)</code>","text":"<p>Moves the stage to specific coordinates, except if None is provided</p> <p>Parameters:</p> Name Type Description Default <code>coors_mm</code> <code>tuple[float, float, float]</code> <p>Target coordinates in mm (x,y,z). Use None to skip moving that axis.</p> required <code>event_finished</code> <code>Event</code> <p>An event to signal when the movement is finished.</p> required Source code in <code>iris/gui/motion_video.py</code> <pre><code>@Slot(tuple, threading.Event)\ndef work(\n    self,\n    coors_mm:tuple[float,float,float],\n    event_finished:threading.Event):\n    \"\"\"\n    Moves the stage to specific coordinates, except if None is provided\n\n    Args:\n        coors_mm (tuple[float,float,float]): Target coordinates in mm (x,y,z). Use None to skip moving that axis.\n        event_finished (threading.Event): An event to signal when the movement is finished.\n    \"\"\"\n    # print('Motion_GoToCoor_Worker.work() called with coordinates (mm):',coors_mm)\n    # print('Thread ID:', threading.current_thread().ident)\n    # If None is provided, assign the current coordinates (i.e., do not move)\n    coor_x_mm, coor_y_mm, coor_z_mm = coors_mm\n    if any([coor_x_mm is None,coor_y_mm is None,coor_z_mm is None]):\n        res = self._get_coor()\n        if res is None:\n            self.sig_mvmt_finished.emit(self.msg_target_failed)\n            return\n        coor_x_current,coor_y_current,coor_z_current = res\n        if coor_x_mm is None: coor_x_mm = coor_x_current\n        if coor_y_mm is None: coor_y_mm = coor_y_current\n        if coor_z_mm is None: coor_z_mm = coor_z_current\n\n    self.sig_mvmt_started.emit('Moving to X: {:.3f} Y: {:.3f} Z: {:.3f} mm'.format(coor_x_mm,coor_y_mm,coor_z_mm))\n\n    # Operate both stages at once\n    thread_xy_move = threading.Thread(target=self.ctrl_xy.move_direct,args=((coor_x_mm,coor_y_mm),))\n    thread_z_move = threading.Thread(target=self.ctrl_z.move_direct,args=(coor_z_mm,))\n\n    thread_xy_move.start()\n    thread_z_move.start()\n\n    self._notify_finish(thread_xy_move,thread_z_move,event_finished)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Motion_MoveBreathingZ_Worker","title":"<code>Motion_MoveBreathingZ_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Moves the z-stage up and down for a few cycles</p> <p>Parameters:</p> Name Type Description Default <code>flg_done</code> <code>Event</code> <p>A flag to stop the breathing motion</p> required Source code in <code>iris/gui/motion_video.py</code> <pre><code>class Motion_MoveBreathingZ_Worker(QObject):\n    \"\"\"\n    Moves the z-stage up and down for a few cycles\n\n    Args:\n        flg_done (threading.Event): A flag to stop the breathing motion\n    \"\"\"\n    signal_breathing_finished = Signal()\n\n    def __init__(self, ctrl_z: 'Controller_Z', parent=None):\n        super().__init__(parent)\n        self.ctrl_z = ctrl_z\n        self._breathing_timer: QTimer|None = None\n\n    @Slot()\n    def start(self):\n        self._breathing_timer = QTimer(self)\n        self._breathing_timer.timeout.connect(self._do_breathing_step)\n        self._breathing_state = 0 # Use a state machine to track the motion\n        self._breathing_timer.start(10) # 50ms interval\n\n    @Slot()\n    def _do_breathing_step(self):\n        # A simple state machine to perform the sequence\n        if self._breathing_state == 0:\n            self.ctrl_z.move_jog('zfwd')\n        elif self._breathing_state == 1:\n            self.ctrl_z.move_jog('zrev')\n        elif self._breathing_state == 2:\n            self.ctrl_z.move_jog('zrev')\n        elif self._breathing_state == 3:\n            self.ctrl_z.move_jog('zfwd')\n\n        self._breathing_state = (self._breathing_state + 1) % 4\n\n    @Slot()\n    def stop(self):\n        if self._breathing_timer is not None:\n            self._breathing_timer.stop()\n        self.signal_breathing_finished.emit()\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController","title":"<code>Wdg_MotionController</code>","text":"<p>               Bases: <code>QGroupBox</code></p> <p>A class to control the app subwindow for the motion: - video output - stage control and calibration</p> <p>Future update: - Image recognition of the stage &gt;&gt; auto-detect coordinates</p> <p>move stage automatically by clicking on the video feed also show the move distance limitation with a red square inlayed on top of the video output</p> <p>Parameters:</p> Name Type Description Default <code>tk</code> <code>None</code> <p>Nothing needed here</p> required Source code in <code>iris/gui/motion_video.py</code> <pre><code>class Wdg_MotionController(qw.QGroupBox):\n    \"\"\"\n    A class to control the app subwindow for the motion:\n    - video output\n    - stage control and calibration\n\n    Future update:\n    - Image recognition of the stage &gt;&gt; auto-detect coordinates\n    &gt;&gt; move stage automatically by clicking on the video feed\n    &gt;&gt; also show the move distance limitation with a red square\n    inlayed on top of the video output\n\n    Args:\n        tk (None): Nothing needed here\n    \"\"\"\n    sig_statbar_message = Signal(str,str)  # A signal to update the status bar message\n    sig_breathing_stopped = Signal()\n\n    _sig_go_to_coordinates = Signal(tuple,threading.Event)\n\n    def __init__(\n        self,\n        parent,\n        xy_controller:Controller_XY,\n        z_controller:Controller_Z,\n        stageHub:DataStreamer_StageCam,\n        getter_imgcal:Callable[[],ImgMea_Cal],\n        flg_issimulation=True,\n        main:bool=False\n        ):\n        # Initialise the class\n        super().__init__(parent)\n        self._stageHub:DataStreamer_StageCam = stageHub\n        self._getter_imgcal = getter_imgcal   # A getter method to get the image calibration\n\n        self._flg_isrunning = threading.Event()\n        self._flg_isrunning.set()  # A flag to check if the thread is running\n\n    # &gt;&gt;&gt; Simulation setup &lt;&lt;&lt;\n        self.flg_issimulation = flg_issimulation    # If True, request the motion controller to do a simulation instead\n\n    # &gt;&gt;&gt; Top layout &lt;&lt;&lt;\n        main_layout = qw.QVBoxLayout(self)  # The main layout for the entire frame\n        wdg_video = BrightfieldController(self)  # Top layout compartment for the video\n        self._wdg_stage = StageControl(self)\n        self._statbar = qw.QStatusBar(self)  # Status bar at the bottom\n        self._statbar.showMessage(\"Video and stage initialisation\")\n\n        main_layout.addWidget(wdg_video)\n        main_layout.addWidget(self._wdg_stage)\n        main_layout.addWidget(self._statbar)\n\n    # &gt;&gt;&gt; Video widgets and parameter setup &lt;&lt;&lt;\n        self._camera_ctrl:CameraController = self._stageHub.get_camera_controller()\n        self._video_height = ControllerConfigEnum.VIDEOFEED_HEIGHT.value    # Video feed height in pixel\n        self._flg_isvideorunning = False         # A flag to turn on/off the video\n        self._currentImage:Image.Image|None = None   # The current image to be displayed\n        self._currentFrame = None               # The current frame to be displayed\n        self._flg_isNewFrmReady = threading.Event()  # A flag to wait for the frame to be captured\n\n        # &gt;&gt; Sub-frame setup &lt;&lt;\n        self._init_video_widgets(stageHub, wdg_video)\n\n    # &gt;&gt;&gt; Motion widgets and parameter setup &lt;&lt;&lt;\n        # Set up the variable for the controller later\n        self.ctrl_xy = xy_controller    # The xy-stage controller (proxy)\n        self.ctrl_z = z_controller      # The z-stage controller (proxy)\n\n        try: self._controller_id_camera = self._stageHub.get_camera_controller().get_identifier()\n        except: self._controller_id_camera = 'failed to get camera ID'; qw.QErrorMessage(self).showMessage('Failed to get camera ID')\n        try: self._controller_id_xy = self.ctrl_xy.get_identifier()\n        except: self._controller_id_xy = 'failed to get xy ID'; qw.QErrorMessage(self).showMessage('Failed to get xy stage ID')\n        try: self._controller_id_z = self.ctrl_z.get_identifier()\n        except: self._controller_id_z = 'failed to get z ID'; qw.QErrorMessage(self).showMessage('Failed to get z stage ID')\n\n        self._current_coor:np.ndarray = np.zeros(3)  # The current coordinates of the stage, only to be used internally!\n        self._flg_ontarget_gotocoor = threading.Event() # A flag to check if the stage is on target for the go to coordinates\n\n        # Connection flag\n        self._flg_connectionReady_xyz = threading.Event()  # A flag to check if the reconnection is in progress\n        self._flg_connectionReady_xyz.set()\n\n    # &gt;&gt;&gt; Continuous motion controller widgets &lt;&lt;&lt;\n        self._init_xyz_control_widgets(self._wdg_stage)\n\n    # &gt;&gt;&gt; Jogging configuration widgets &lt;&lt;&lt;\n        self._init_xyz_jog_widgets(self._wdg_stage)\n\n    # &gt;&gt;&gt; Go to coordinate widgets &lt;&lt;&lt;\n        # Add the entry boxes\n        self._init_gotocoor_widgets(self._wdg_stage)\n\n    # &gt;&gt;&gt; Motor parameter setup widgets &lt;&lt;&lt;\n        self._init_stageparam_widgets(self._wdg_stage)\n\n    # &gt;&gt;&gt; Status update &lt;&lt;&lt;\n        self.sig_statbar_message.connect(self.status_update)\n        self.sig_statbar_message.emit('Initialising the motion controllers','yellow')\n        self._motion_controller_initialisation()\n        self._init_workers()\n        self.video_initialise()\n\n    def _init_stageparam_widgets(self, widget:StageControl):\n        \"\"\"\n        Initialises the widgets for the motor parameter setup\n\n        Args:\n            widget (StageControl): The widget to add the motor parameter setups to\n        \"\"\"\n        # Coordinate reporting\n        # &gt; Coordinate reporting\n        self._lbl_coor = widget.lbl_coor_um\n\n        # Add the entry boxes, label, and button for the speed parameter setups\n        self.lbl_speed_xy = widget.lbl_speedxy\n        self.lbl_speed_z = widget.lbl_speedz\n        self.ent_speed_xy = widget.ent_speedxy\n        self.ent_speed_z = widget.ent_speedz\n\n        # Bind the functions\n        self.ent_speed_xy.returnPressed.connect(lambda: self._set_vel_acc_params())\n        self.ent_speed_z.returnPressed.connect(lambda: self._set_vel_acc_params())\n\n        # Disable the widgets until the controller is initialised\n        self.ent_speed_xy.setEnabled(False)\n        self.ent_speed_z.setEnabled(False)\n\n        # Add the entry boxes, label, and button for the jogging parameter setup\n        self.lbl_jog_xy = widget.lbl_stepsizexy\n        self.lbl_jog_z = widget.lbl_stepsizez\n        self.ent_jog_xy = widget.ent_stepxy_um\n        self.ent_jog_z = widget.ent_stepz_um\n\n        # Bind the functions\n        self.ent_jog_xy.returnPressed.connect(lambda: self._set_jog_params())\n        self.ent_jog_z.returnPressed.connect(lambda: self._set_jog_params())\n\n        # Disable the widgets until the controller is initialised\n        self.ent_jog_xy.setEnabled(False)\n        self.ent_jog_z.setEnabled(False)\n\n    def _init_xyz_jog_widgets(self, widget: StageControl):\n        \"\"\"\n        Initialises the widgets for the jogging configuration\n\n        Args:\n            widget (StageControl): The widget to add the jogging configuration to\n        \"\"\"\n        self._chkbox_jog_enabled = widget.chk_stepmode\n        self._chkbox_jog_enabled.setChecked(False)  # A flag to check if the jogging is enabled\n\n    def _init_gotocoor_widgets(self, widget:StageControl):\n        \"\"\"\n        Initialises the widgets for the go to coordinate setup\n\n        Args:\n            widget (StageControl): The widget to add the go to coordinate controls to\n        \"\"\"\n        self.ent_coor_x = widget.ent_goto_x_um\n        self.ent_coor_y = widget.ent_goto_y_um\n        self.ent_coor_z = widget.ent_goto_z_um\n\n        # Bind: Enter to go to the coordinates\n        self.ent_coor_x.returnPressed.connect(lambda: self._move_go_to())\n        self.ent_coor_y.returnPressed.connect(lambda: self._move_go_to())\n        self.ent_coor_z.returnPressed.connect(lambda: self._move_go_to())\n\n        # Add the go to button\n        btn_goto = widget.btn_goto\n        btn_goto.released.connect(lambda: self._move_go_to())\n        btn_goto.setEnabled(False)\n\n    def _init_xyz_control_widgets(self, widget:StageControl):\n        \"\"\"\n        Initialises the widgets for the xyz stage control.\n\n        Args:\n            widget (StageControl): The widget to add the stage control buttons to\n        \"\"\"\n        # Add the buttons (disabled until controller initialisation)\n        ## Add the buttons for the xy stage\n        self.btn_xy_up = CustomButton('up')\n        self.btn_xy_down = CustomButton('down')\n        self.btn_xy_right= CustomButton('right')\n        self.btn_xy_left = CustomButton('left')\n\n        # Disable the buttons until the controller is initialised\n        self.btn_xy_up.setEnabled(False)\n        self.btn_xy_down.setEnabled(False)\n        self.btn_xy_right.setEnabled(False)\n        self.btn_xy_left.setEnabled(False)\n\n        # Bind the functions\n        self.btn_xy_up.set_left_click_function(lambda: self.motion_button_manager('yfwd'))\n        self.btn_xy_down.set_left_click_function(lambda: self.motion_button_manager('yrev'))\n        self.btn_xy_right.set_left_click_function(lambda: self.motion_button_manager('xfwd'))\n        self.btn_xy_left.set_left_click_function(lambda: self.motion_button_manager('xrev'))\n\n        self.btn_xy_up.set_left_release_function(lambda: self.motion_button_manager('ystop'))\n        self.btn_xy_down.set_left_release_function(lambda: self.motion_button_manager('ystop'))\n        self.btn_xy_right.set_left_release_function(lambda: self.motion_button_manager('xstop'))\n        self.btn_xy_left.set_left_release_function(lambda: self.motion_button_manager('xstop'))\n\n        self.btn_xy_up.set_right_click_function(lambda: self.move_jog('yfwd'))\n        self.btn_xy_down.set_right_click_function(lambda: self.move_jog('yrev'))\n        self.btn_xy_right.set_right_click_function(lambda: self.move_jog('xfwd'))\n        self.btn_xy_left.set_right_click_function(lambda: self.move_jog('xrev'))\n\n        # Layout configuration\n        sslyt_xy_move = widget.lyt_xy\n        sslyt_xy_move.addWidget(self.btn_xy_up,0,1)\n        sslyt_xy_move.addWidget(self.btn_xy_left,1,0)\n        sslyt_xy_move.addWidget(self.btn_xy_right,1,2)\n        sslyt_xy_move.addWidget(self.btn_xy_down,2,1)\n\n        ## Add the buttons for the z stage\n        self.btn_z_up = CustomButton('up')\n        self.btn_z_down = CustomButton('down')\n        self._btn_z_breathing = qw.QPushButton('Breathing')\n\n        # Disable the buttons until the controller is initialised\n        self.btn_z_up.setEnabled(False)\n        self.btn_z_down.setEnabled(False)\n        self._btn_z_breathing.setEnabled(False)\n\n        # Bind the functions\n        self.btn_z_up.set_left_click_function(lambda: self.motion_button_manager('zfwd'))\n        self.btn_z_down.set_left_click_function(lambda: self.motion_button_manager('zrev'))\n        self._btn_z_breathing.released.connect(lambda: self._start_breathing_z())\n\n        self.btn_z_up.set_left_release_function(lambda: self.motion_button_manager('zstop'))\n        self.btn_z_down.set_left_release_function(lambda: self.motion_button_manager('zstop'))\n\n        self.btn_z_up.set_right_click_function(lambda: self.move_jog('zfwd'))\n        self.btn_z_down.set_right_click_function(lambda: self.move_jog('zrev'))\n\n        # Layout configuration\n        sslyt_z_move = widget.lyt_z\n        sslyt_z_move.addWidget(self.btn_z_up)\n        sslyt_z_move.addWidget(self.btn_z_down)\n        sslyt_z_move.addStretch(1)\n        sslyt_z_move.addWidget(self._btn_z_breathing)\n\n        ## Home/Calibration buttons\n        self.btn_xy_home = widget.btn_home_xy\n        self.btn_z_home = widget.btn_home_z\n\n        self.btn_xy_home.setEnabled(False)\n        self.btn_z_home.setEnabled(False)\n\n        self.btn_xy_home.released.connect(lambda: self.motion_button_manager('xyhome'))\n        self.btn_z_home.released.connect(lambda: self.motion_button_manager('zhome'))\n\n    def _init_video_widgets(self, stageHub: DataStreamer_StageCam, wdg_video: BrightfieldController):\n        \"\"\"\n        Initialises the video widgets and layouts\n\n        Args:\n            stageHub (DataStreamer_StageCam): The stage hub for video streaming\n            wdg_video (BrightfieldController): The widget for the video feed\n        \"\"\"\n        # &gt; Video\n        lyt = qw.QVBoxLayout()\n        self._lbl_video = ResizableQLabel(min_height=1,parent=wdg_video)    # A label to show the video feed\n\n        wdg_video.wdg_video.setLayout(lyt)\n        lyt.addWidget(self._lbl_video)\n\n        # &gt; Video controllers\n        self._btn_videotoggle = wdg_video.btn_camera_onoff\n        self._btn_reinit_conn = wdg_video.pushButton_2\n        self._btn_videotoggle.released.connect(lambda: self.video_initialise())\n        # self._btn_reinit_conn.released.connect(lambda: self.reinitialise_connection('camera'))\n        self._btn_reinit_conn.setEnabled(False)\n        self._btn_videotoggle.setStyleSheet('background-color: yellow')\n        self._btn_reinit_conn.setStyleSheet('background-color: yellow')\n\n        self._chkbox_crosshair = wdg_video.chk_crosshair\n        self._chkbox_scalebar = wdg_video.chk_scalebar\n        self._chkbox_crosshair.setChecked(False)\n        self._chkbox_scalebar.setChecked(True)\n\n        btn_set_imgproc_gain = wdg_video.btn_setffgain\n        btn_set_flatfield = wdg_video.btn_setff\n        btn_save_flatfield = wdg_video.btn_saveff\n        btn_load_flatfield = wdg_video.btn_loadff\n        btn_set_imgproc_gain.released.connect(lambda: self._set_imageProc_gain())\n        btn_set_flatfield.released.connect(lambda: self._set_flatfield_correction_camera())\n        btn_save_flatfield.released.connect(lambda: self._save_flatfield_correction())\n        btn_load_flatfield.released.connect(lambda: self._load_flatfield_correction())\n\n        # Video corrections\n        self._dict_vidcorrection = {}\n        self._combo_vidcorrection = wdg_video.combo_image_correction\n        self._combo_vidcorrection.addItems(list(stageHub.Enum_CamCorrectionType.__members__))\n        self._combo_vidcorrection.setCurrentIndex(0)\n\n\n    def _init_workers(self):\n        \"\"\"\n        Initialises the auto-updaters to be used post widget initialisations\n        (ALL THREADS) to prevent the main thread from being blocked\n        \"\"\"\n        # For the coordinate status bar\n        self._worker_coor_report = Motion_AutoCoorReport_Worker(stageHub=self._stageHub)\n        self._worker_coor_report.sig_coor.connect(self._lbl_coor.setText)\n\n        self._thread_coor_report = QThread(self)\n        self._worker_coor_report.moveToThread(self._thread_coor_report)\n\n        self._thread_coor_report.started.connect(self._worker_coor_report.start)\n        self._thread_coor_report.finished.connect(self._worker_coor_report.deleteLater)\n        self._thread_coor_report.finished.connect(self._thread_coor_report.deleteLater)\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread_coor_report.start)\n        self.destroyed.connect(self._thread_coor_report.quit)\n\n        # For _worker_get_coordinates_closest_mm\n        self._worker_getcoorclosest = Motion_GetCoordinatesClosest_mm_Worker(stageHub=self._stageHub)\n        self._thread_getcoorclosest = QThread(self)\n        self._worker_getcoorclosest.moveToThread(self._thread_getcoorclosest)\n        self._thread_getcoorclosest.finished.connect(self._worker_getcoorclosest.deleteLater)\n        self._thread_getcoorclosest.finished.connect(self._thread_getcoorclosest.deleteLater)\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread_getcoorclosest.start)\n        self.destroyed.connect(self._thread_getcoorclosest.quit)\n\n        # For _worker_go_to_coordinates\n        self._worker_gotocoor = Motion_GoToCoor_Worker(\n            stageHub=self._stageHub,\n            ctrl_xy=self.ctrl_xy,\n            ctrl_z=self.ctrl_z)\n        self._worker_gotocoor.sig_mvmt_started.connect(self._statbar.showMessage)\n        self._sig_go_to_coordinates.connect(self._worker_gotocoor.work)\n\n        self._thread_gotocoor = QThread(self)\n        self._worker_gotocoor.moveToThread(self._thread_gotocoor)\n        self._thread_gotocoor.finished.connect(self._worker_gotocoor.deleteLater)\n        self._thread_gotocoor.finished.connect(self._thread_gotocoor.deleteLater)\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread_gotocoor.start)\n        self.destroyed.connect(self._thread_gotocoor.quit)\n\n        # self.destroyed.connect(self.terminate)\n\n    def get_goto_worker(self) -&gt; Motion_GoToCoor_Worker:\n        \"\"\"\n        Returns the worker to command the stage to go to specific coordinates\n\n        Returns:\n            Motion_GoToCoor_Worker: The worker to perform the goto coordinate command.\n        \"\"\"\n        return self._worker_gotocoor\n\n    def _set_imageProc_gain(self):\n        \"\"\"\n        Sets the gain for the image processing (not setting the gain of the camera directly but\n        through the stage hub). Especially useful for the flatfield correction without overexposing\n        the camera.\n        \"\"\"\n        try:\n            init_gain = self._stageHub.get_flatfield_gain()\n            new_gain = messagebox_request_input(\n                parent=self,\n                title='Set gain',\n                message='Set gain for the image processing (not camera gain)',\n                default=str(init_gain),\n                validator=validator_float_greaterThanZero,\n                invalid_msg='Gain must be a positive number',\n                loop_until_valid=True,\n            )\n            if new_gain is None:\n                qw.QMessageBox.information(self, 'Gain not set', 'Gain not changed')\n                return\n\n            self._stageHub.set_flatfield_gain(float(new_gain))\n            qw.QMessageBox.information(self, 'Gain set', 'Gain set to {}'.format(self._stageHub.get_flatfield_gain()))\n        except Exception as e:\n            qw.QMessageBox.critical(self, 'Error', 'Failed to set gain:\\n' + str(e))\n\n    def _set_flatfield_correction_camera(self):\n        \"\"\"\n        Sets the flatfield correction using the camera's current image\n        \"\"\"\n        try:\n            img = self._camera_ctrl.img_capture()\n            img_arr = np.array(img)\n\n            self._stageHub.set_flatfield_reference(img_arr)\n            qw.QMessageBox.information(self, 'Flatfield correction', 'Flatfield correction set to the current camera image')\n        except Exception as e:\n            qw.QMessageBox.critical(self, 'Error', 'Failed to set flatfield correction:\\n' + str(e))\n\n    def _save_flatfield_correction(self):\n        \"\"\"\n        Saves the flatfield correction to a file\n        \"\"\"\n        try:\n            filename = qw.QFileDialog.getSaveFileName(\n                parent=None,\n                caption='Save flatfield correction file',\n                filter='Numpy files (*.npy);;All files (*)',\n            )[0]\n            if filename == '': raise ValueError('No file selected')\n            self._stageHub.save_flatfield_reference(filename)\n        except Exception as e:\n            qw.QMessageBox.critical(self, 'Error', 'Failed to save flatfield correction:\\n' + str(e))\n\n    def _load_flatfield_correction(self):\n        \"\"\"\n        Loads the flatfield correction from a file\n        \"\"\"\n        try:\n            filename = qw.QFileDialog.getOpenFileName(\n                parent=None,\n                caption='Select flatfield correction file',\n                filter='Numpy files (*.npy);;All files (*)',\n            )[0]\n            if filename == '': raise ValueError('No file selected')\n\n            self._stageHub.load_flatfield_reference(filename)\n            qw.QMessageBox.information(self, 'Flatfield correction', 'Flatfield correction loaded from {}'.format(filename))\n        except Exception as e:\n            qw.QMessageBox.critical(self, 'Error', 'Failed to load flatfield correction:\\n' + str(e))\n\n    def set_camera_exposure(self):\n        \"\"\"\n        Sets the camera exposure time in microseconds\n        \"\"\"\n        main_window = self.window()\n        if not hasattr(self._camera_ctrl,'set_exposure_time') or not hasattr(self._camera_ctrl,'get_exposure_time'):\n            qw.QMessageBox.critical(main_window, 'Error', 'Camera does not support exposure time setting')\n            return\n        try:\n            init_exposure_time = self._camera_ctrl.get_exposure_time()\n            new_exposure_time = messagebox_request_input(\n                parent=main_window,\n                title='Set exposure time',\n                message='Set exposure time in device unit',\n                default=str(init_exposure_time),\n                validator=validator_float_greaterThanZero,\n                invalid_msg='Exposure time must be a positive number',\n                loop_until_valid=True,\n            )\n            if new_exposure_time is None: \n                qw.QMessageBox.information(main_window, 'Exposure time not set', 'Exposure time not changed')\n                return\n            self._camera_ctrl.set_exposure_time(float(new_exposure_time))\n            qw.QMessageBox.information(main_window, 'Exposure time set', 'Exposure time set to {} ms'.format(self._camera_ctrl.get_exposure_time()))\n        except Exception as e:\n            qw.QMessageBox.critical(main_window, 'Error', 'Failed to set exposure time:\\n' + str(e))\n\n    # @thread_assign\n    # def reinitialise_connection(self,unit:Literal['xy','z','camera']) -&gt; threading.Thread:\n    #     \"\"\"\n    #     Reinitialises the connection to the stage or camera\n\n    #     Args:\n    #         unit (Literal['xy','z','camera']): The unit to reinitialise\n\n    #     Returns:\n    #         threading.Thread: The thread started\n    #     \"\"\"\n    #     if unit == 'xy':\n    #         self.ctrl_xy.reinitialise_connection()\n    #         self.signal_statbar_message.emit('XY stage re-initialised', None)\n    #     elif unit == 'z':\n    #         self.ctrl_z.reinitialise_connection()\n    #         self.signal_statbar_message.emit('Z stage re-initialised', None)\n    #     elif unit == 'camera':\n    #         self._camera_ctrl.reinitialise_connection()\n    #         self.signal_statbar_message.emit('Camera re-initialised', None)\n    #     else:\n    #         raise ValueError('Invalid unit for reinitialisation')\n\n    def disable_overlays(self):\n        \"\"\"\n        Disables the overlays on the video feed\n        \"\"\"\n        self._chkbox_crosshair.setChecked(False)\n        self._chkbox_scalebar.setChecked(False)\n        return\n\n    def video_terminate(self):\n        self._flg_isvideorunning = False\n        # By turning this flag off, the video autoupdater should automatically terminate, \n        # disconnect from the camera, and resets all the parameters for next use.\n\n        # Turn the button back into a camera on button\n        self._btn_videotoggle.released.disconnect()\n        self._btn_videotoggle.setText('Turn camera ON')\n        self._btn_videotoggle.released.connect(lambda: self.video_initialise())\n        self._btn_videotoggle.setStyleSheet('background-color: yellow')\n\n    def video_initialise(self):\n        \"\"\"\n        Initialises the video:\n        1. Define the controller\n        2. Sets the first frame\n        3. Starts the multi-threading to start the autoupdater\n        \"\"\"\n        try:\n            if self._flg_isvideorunning: return\n            # Initialise the video capture\n            ## camera initialisation moved to self.video_update for responsiveness\n            # Start multithreading for the video to constantly update the captured frame\n            threading.Thread(target=self.video_update, daemon=True).start()\n\n            # Turn the button into a video stop button\n            self._btn_videotoggle.released.disconnect()\n            self._btn_videotoggle.setText('Turn camera OFF')\n            self._btn_videotoggle.released.connect(lambda: self.video_terminate())\n            self._btn_videotoggle.setStyleSheet('background-color: red')\n        except Exception as e:\n            print(f'Video feed cannot start:\\n{e}')\n\n    def _start_breathing_z(self) -&gt; None:\n        \"\"\"\n        Moves the z-stage up and down for a few cycles\n\n        Returns:\n            threading.Thread: The thread started\n        \"\"\"\n        # Store references to prevent premature destruction\n        self._breathing_z_worker = Motion_MoveBreathingZ_Worker(self.ctrl_z)\n        self._breathing_z_worker.signal_breathing_finished.connect(self.sig_breathing_stopped)\n        self._breathing_z_thread = QThread(self)\n        self._breathing_z_worker.moveToThread(self._breathing_z_thread)\n        self._breathing_z_thread.started.connect(self._breathing_z_worker.start)\n        self._breathing_z_thread.finished.connect(self._breathing_z_worker.deleteLater)\n\n        # Change the button to a stop button\n        self._btn_z_breathing.released.disconnect()\n        self._btn_z_breathing.setText('STOP Breathing')\n        self._btn_z_breathing.setStyleSheet('background-color: red')\n        self._btn_z_breathing.released.connect(self._breathing_z_worker.stop)\n\n        # Connect the breathing stopped signal to the stop function\n        self._breathing_z_worker.signal_breathing_finished.connect(self._stop_breathing_and_thread)\n\n        self._breathing_z_thread.start()\n\n    def _stop_breathing_and_thread(self) -&gt; None:\n        \"\"\"\n        Stops the breathing thread and resets the button\n        \"\"\"\n        self._breathing_z_thread.quit()\n        self._btn_z_breathing.released.disconnect()\n        self._btn_z_breathing.setText('Breathing')\n        self._btn_z_breathing.released.connect(self._start_breathing_z)\n        self._btn_z_breathing.setStyleSheet('')\n\n    def move_jog(self,dir:str):\n        \"\"\"\n        Moves the stage per request from the button presses\n\n        Args:\n            dir (str): 'yfwd', 'xfwd', 'zfwd', 'yrev', 'xrev', 'zrev'\n            as described in self.motion_button_manager\n        \"\"\"\n        def _move_jog():\n            self.sig_statbar_message.emit(f'Jogging to: {dir}', 'yellow')\n\n            if dir not in ['yfwd','xfwd','zfwd','yrev','xrev','zrev']:\n                raise SyntaxError('move_jog: Invalid direction input')\n            elif dir in ['xfwd','xrev','yfwd','yrev']:\n                self.ctrl_xy.move_jog(dir)\n            elif dir in ['zfwd','zrev']:\n                self.ctrl_z.move_jog(dir)\n\n            self.sig_statbar_message.emit(None, None)\n\n        if hasattr(self,'_thread_jog') and self._thread_jog.is_alive(): return\n        self._thread_jog = threading.Thread(target=_move_jog)\n        self._thread_jog.start()\n\n    def _update_set_jog_labels(self):\n        \"\"\"\n        Updates the labels for the jogging parameters obtained from the device controllers\n        \"\"\"\n        jog_x_mm,jog_y_mm = self.ctrl_xy.get_jog()[:2]\n        jog_z_mm,_,_ = self.ctrl_z.get_jog()\n\n        jog_x_um = float(jog_x_mm * 10**3)\n        jog_y_um = float(jog_y_mm * 10**3)\n        if jog_x_um!=jog_y_um:\n            self.sig_statbar_message.emit('Jogging parameters XY are not the same','yellow')\n            print('Jogging parameters XY are not the same. Jog x: {:.1f}\u00b5m Jog y: {:.1f}\u00b5m'.format(jog_x_mm,jog_y_mm))\n        jog_xy_um = jog_x_um\n        jog_z_um = float(jog_z_mm * 10**3)\n\n        self.lbl_jog_xy.setText(f'{jog_xy_um:.1f}')\n        self.lbl_jog_z.setText(f'{jog_z_um:.1f}')\n\n    def _set_jog_params(self):\n        \"\"\"\n        Sets the motors jogging parameters according to the widget entries in [\u00b5m]\n        \"\"\"\n        # Convert it to mm for the controller\n        jog_xy_ent = self.ent_jog_xy.text()\n        if jog_xy_ent != '': \n            jog_xy_mm = float(jog_xy_ent)*10**-3\n            self.ctrl_xy.set_jog(dist_mm=jog_xy_mm)\n\n        jog_z_ent = self.ent_jog_z.text()\n        if jog_z_ent != '':\n            jog_z_mm = float(jog_z_ent)*10**-3\n            self.ctrl_z.set_jog(dist_mm=jog_z_mm)\n\n        self._update_set_jog_labels()\n\n    def _update_set_vel_labels(self):\n        \"\"\"\n        Updates the labels for the motor parameters obtained from the device controllers\n        \"\"\"\n        _,xy_speed,_ = self.ctrl_xy.get_vel_acc_relative()\n        _,z_speed,_ = self.ctrl_z.get_vel_acc_relative()\n\n        xy_speed = float(xy_speed)\n        z_speed = float(z_speed)\n\n        if isinstance(xy_speed,float) and isinstance(z_speed,float):\n            self.lbl_speed_xy.setText(f'{xy_speed:.2f}')\n            self.lbl_speed_z.setText(f'{z_speed:.2f}')\n\n    def get_controller_identifiers(self) -&gt; tuple:\n        \"\"\"\n        Returns the controller identifiers for the camera, xy-stage, and z-stage\n        Returns:\n            tuple: (camera-id, xy-stage-id, z-stage-id)\n        \"\"\"\n        return (self._controller_id_camera,\n                self._controller_id_xy,\n                self._controller_id_z)\n\n    def get_VelocityParameters(self):\n        \"\"\"\n        Returns the velocity parameters for the motors\n\n        Returns:\n            tuple: (xy-velocity, z-velocity) Velocity parameters for the xy-stage and z-stage in percentage\n        \"\"\"\n        vel_xy = self.ctrl_xy.get_vel_acc_relative()[1]\n        vel_z = self.ctrl_z.get_vel_acc_relative()[1]\n\n        return (vel_xy,vel_z)\n\n    def incrase_decrease_speed(self,stage:str,increase:bool):\n        \"\"\"\n        Increase or decrease the velocity of the motors by 5% or 1% for the xy-stage and z-stage\n        (5% if speed is &gt;= 10%, 1% if speed is &lt; 10%)\n\n        Args:\n            stage (str): 'xy' or 'z' for the stage to be controlled\n            increase (bool): True to increase, False to decrease\n        \"\"\"\n        assert stage in ['xy','z'], 'Invalid stage input'\n\n        mult = 1 if increase else -1\n        velxy = self.ctrl_xy.get_vel_acc_relative()[1]\n        velz = self.ctrl_z.get_vel_acc_relative()[1]\n        if stage == 'xy':\n            velxy += 5*mult if velxy &gt;= 10 else 1*mult\n            if velxy &lt;= 0: velxy = 1\n            elif velxy &gt;= 100: velxy = 100\n        elif stage == 'z':\n            velz = self.ctrl_z.get_vel_acc_relative()[1]\n            velz += 5*mult if velz &gt;= 10 else 1*mult\n            if velz &lt;= 0: velz = 1\n            elif velz &gt;= 100: velz = 100\n\n        self.set_vel_relative(vel_xy=velxy,vel_z=velz)\n\n    def calculate_vel_relative(self, vel_xy_mmPerSec:float) -&gt; float:\n        \"\"\"\n        Calculates the velocity in percentage based on the given velocity in mm/s\n        based on the each device controller's internal method.\n\n        Args:\n            vel_xy_mmPerSec (float): The velocity in mm/s\n\n        Returns:\n            float: The velocity in percentage, relative to the device's maximum velocity\n        \"\"\"\n        return self.ctrl_xy.calculate_vel_relative(vel_xy_mmPerSec)\n\n    @Slot(float,float,threading.Event)\n    def set_vel_relative(self,vel_xy:float=-1.0,vel_z:float=-1.0,event_finish:threading.Event|None=None):\n        \"\"\"\n        Sets the velocity parameters for the motors\n\n        Args:\n            vel_xy (float, optional): Velocity (percentage) for the xy-stage. Must be between 0[%] and 100[%]. If -1, uses the current velocity. Defaults to None.\n            vel_z (float, optional): Velocity (percentage) for the z-stage. Must be between 0[%] and 100[%]. If -1, uses the current velocity. Defaults to None.\n        \"\"\"\n        if vel_xy &lt;= 0.0 or vel_xy &gt; 100.0: vel_xy = self.ctrl_xy.get_vel_acc_relative()[1]\n        if vel_z &lt;= 0.0 or vel_z &gt; 100.0: vel_z = self.ctrl_z.get_vel_acc_relative()[1]\n\n        assert isinstance(vel_xy,(float,int)) and isinstance(vel_z,(float,int)), 'Invalid input type for the velocity parameters'\n\n        self.ctrl_xy.set_vel_acc_relative(vel_homing=vel_xy,vel_move=vel_xy)\n        self.ctrl_z.set_vel_acc_relative(vel_homing=vel_z,vel_move=vel_z)\n\n        speed_xy = self.ctrl_xy.get_vel_acc_relative()[1]\n        speed_z = self.ctrl_z.get_vel_acc_relative()[1]\n\n        if isinstance(event_finish,threading.Event): event_finish.set()\n\n        self._update_set_vel_labels()\n\n    def _set_vel_acc_params(self):\n        \"\"\"\n        Sets the motors velocity and acceleration parameters according to the widget entries\n        \"\"\"\n        def clear_status():\n            time.sleep(2)\n            self.sig_statbar_message.emit('Motor parameters have been set', 'green')\n\n        try:\n            speed_xy = self.ent_speed_xy.text()\n            speed_z = self.ent_speed_z.text()\n\n            if speed_xy == '':\n                speed_xy = self.ctrl_xy.get_vel_acc_relative()[1]\n            if speed_z == '':\n                speed_z = self.ctrl_z.get_vel_acc_relative()[1]\n\n            speed_xy = float(speed_xy)\n            speed_z = float(speed_z)\n\n            self.ctrl_xy.set_vel_acc_relative(vel_homing=speed_xy,vel_move=speed_xy)\n            self.ctrl_z.set_vel_acc_relative(vel_homing=speed_z,vel_move=speed_z)\n\n            self.sig_statbar_message.emit('Motor parameters have been set', 'green')\n        except:\n            self.sig_statbar_message.emit('Invalid input for the motor parameters', 'yellow')\n        finally:\n            self._update_set_vel_labels()\n\n    def _move_go_to(self):\n        \"\"\"\n        Moves the stage to specific coordinates using the coordinates given in the entry boxes\n        \"\"\"\n        coor_x_um_str = self.ent_coor_x.text()\n        coor_y_um_str = self.ent_coor_y.text()\n        coor_z_um_str = self.ent_coor_z.text()\n\n        coor_x_current_mm,coor_y_current_mm = self.ctrl_xy.get_coordinates()\n        coor_z_current_mm = self.ctrl_z.get_coordinates()\n\n        try: coor_x_mm = float(coor_x_um_str)/1e3\n        except: coor_x_mm = coor_x_current_mm\n        try: coor_y_mm = float(coor_y_um_str)/1e3\n        except: coor_y_mm = coor_y_current_mm\n        try: coor_z_mm = float(coor_z_um_str)/1e3\n        except: coor_z_mm = coor_z_current_mm\n\n        self.go_to_coordinates(coor_x_mm,coor_y_mm,coor_z_mm)\n\n        # Empty the entry boxes\n        self.ent_coor_x.setText('')\n        self.ent_coor_y.setText('')\n        self.ent_coor_z.setText('')\n\n    def check_coordinates(self,coor_mm:tuple[float,float,float]) -&gt; bool:\n        \"\"\"\n        Checks if the given coordinates are within the travel range of the stages\n\n        Args:\n            coor_mm (tuple[float,float,float]): The coordinates to check\n\n        Returns:\n            bool: True if the coordinates are within the travel range, False otherwise\n        \"\"\"\n        # NOTE: Implement this!\n        pass\n        return True\n\n    @Slot(tuple,bool,threading.Event)\n    def go_to_coordinates(\n        self,\n        coors_mm:tuple[float|None,float|None,float|None]=(None,None,None),\n        override_controls:bool=False,\n        event_finish:threading.Event|None=None):\n        \"\"\"\n        Moves the stage to specific coordinates, except if None is provided. (Asynchronous)\n\n        Args:\n            coors_mm (tuple[float|None,float|None,float|None], optional): A tuple of x, y, and z coordinates in mm to move to. If None\n            override_controls (bool, optional): If True, does not disable/enable the controls. Defaults to False.\n            event_finish (threading.Event, optional): An event to set when the movement is finished. Defaults to None.\n\n        Raises:\n            TimeoutError: If the stage does not move within the timeout\n        \"\"\"\n        coor_x_mm,coor_y_mm,coor_z_mm = coors_mm\n        if not override_controls: self.disable_widgets()\n        self._sig_go_to_coordinates.emit((coor_x_mm,coor_y_mm,coor_z_mm), event_finish)\n\n        if not override_controls: self.enable_widgets()\n\n        # Resets the statusbar, let the user know that it's done moving\n        self.sig_statbar_message.emit('Stage movement complete', None)\n\n    def get_coordinates_closest_mm(self) -&gt; tuple[float|None,float|None,float|None]:\n        \"\"\"\n        Returns the current coordinate of both channels x, y, and z of the stages.\n\n        Returns:\n            float: x, y, and z coordinates of the stage (converted from Thorlabs Decimals)\n        \"\"\"\n        timestamp_req = get_timestamp_us_int()\n        result = self._stageHub.get_coordinates_closest(timestamp_req)\n\n        if result is None: return (None,None,None)\n        coor_x,coor_y,coor_z = result\n\n        self._current_coor = np.array([coor_x,coor_y,coor_z])\n\n        return coor_x,coor_y,coor_z\n\n    def motion_button_manager(self,dir):\n        \"\"\"\n        Moves the stage per request from the button presses and releases.\n        Should be assigned to a worker thread.\n\n        Args:\n            dir (str): 'yfwd', 'xfwd', 'zfwd', 'yrev', 'xrev', 'zrev', 'ystop', 'xstop', 'zstop', 'xyhome', 'zhome'\n            for x, y and z motors with fwd, rev, and stop for forward, backward, and stop.\n            'xyhome' and 'zhome' are for calibrating and homing the xy and z stage respectively.\n            Note that 'xstop' and 'ystop' will stop both x and y motors.\n        \"\"\"\n        if self._chkbox_jog_enabled.isChecked(): self.move_jog(dir); return\n\n        def _move():\n            if dir not in ['yfwd','xfwd','zfwd','yrev','xrev','zrev','xyhome','zhome']:\n                self.sig_statbar_message.emit(f'Moving: {dir}', 'yellow')\n            elif dir in ['xstop','ystop','zstop']:\n                self.sig_statbar_message.emit(f'Stopping: {dir}', None)\n\n            if dir in ['yfwd','xfwd','yrev','xrev']:\n                self.ctrl_xy.move_continuous(dir)\n            elif dir in ['zfwd','zrev']:\n                self.ctrl_z.move_continuous(dir)\n            elif dir in ['xstop','ystop']:\n                self.ctrl_xy.stop_move()\n            elif dir == 'zstop':\n                self.ctrl_z.stop_move()\n            elif dir == 'xyhome':\n                self.ctrl_xy.homing_n_coor_calibration()\n            elif dir == 'zhome':\n                self.ctrl_z.homing_n_coor_calibration()\n            else: raise SyntaxError('motion_button_manager: Invalid direction input')\n\n            self.sig_statbar_message.emit(None, None)\n\n        if hasattr(self,'_thread_move') and self._thread_move.is_alive(): return\n\n        self._thread_move = threading.Thread(target=_move)\n        self._thread_move.start()\n\n    def _motion_controller_initialisation(self):\n        \"\"\"\n        Initialises the controller and enables the buttons\n        \"\"\"\n        # Re-enables the controls\n        self._update_set_vel_labels()\n        self._update_set_jog_labels()\n        self.enable_widgets()\n\n    def disable_widgets(self):\n        \"\"\"\n        Disables all stage control widgets\n        \"\"\"\n        all_widgets = get_all_widgets(self._wdg_stage)\n        [widget.setEnabled(False) for widget in all_widgets if isinstance(widget,(qw.QPushButton,qw.QLineEdit))]\n\n    def enable_widgets(self):\n        \"\"\"\n        Enables all stage control widgets\n        \"\"\"\n        all_widgets = get_all_widgets(self._wdg_stage)\n        [widget.setEnabled(True) for widget in all_widgets if isinstance(widget,(qw.QPushButton,qw.QLineEdit))]\n\n        # Updates the statusbar\n        self.sig_statbar_message.emit('Stage controller ready', None)\n\n    def get_current_image(self, wait_newimage:bool=False) -&gt; Image.Image|None:\n        \"\"\"\n        Returns the current frame of the video feed\n\n        Returns:\n            ImageTk.PhotoImage: The current frame of the video feed\n            wait_newimage (bool, optional): Waits for a new image to be taken. Defaults to False.\n        \"\"\"\n        if wait_newimage:\n            self._flg_isNewFrmReady.clear()\n            self._flg_isNewFrmReady.wait()\n        return self._currentImage\n\n    def get_image_shape(self) -&gt; tuple[int,int]|None:\n        \"\"\"\n        Returns the shape of the current image in (width, height)\n\n        Returns:\n            tuple[int,int]|None: The shape of the current image in (width, height) or None if no image is available\n        \"\"\"\n        if isinstance(self._currentImage,Image.Image):\n            return self._currentImage.size\n        return None\n\n    def _overlay_scalebar(self,img:Image.Image) -&gt; Image.Image:\n        \"\"\"\n        Overlays a scalebar on the image based on the image calibration file\n\n        Args:\n            img (Image.Image): The image to be overlayed with the scalebar\n\n        Returns:\n            Image.Image: The image with the scalebar overlayed\n        \"\"\"\n        cal = self._getter_imgcal()\n\n        if not isinstance(cal,ImgMea_Cal) or not cal.check_calibration_set():\n            return img\n\n        if not isinstance(img,Image.Image): return img\n\n        scalex = 1/cal.scale_x_pixelPerMm\n        scalebar_length = int(ControllerConfigEnum.SCALEBAR_LENGTH_RATIO.value * img.size[0]) # in pixel\n        scalebar_height = int(ControllerConfigEnum.SCALEBAR_HEIGHT_RATIO.value * img.size[1]) # in pixel\n\n        length_mm = scalebar_length * scalex\n        font = ControllerConfigEnum.SCALEBAR_FONT.value\n        font_size = int(scalebar_length/10 * ControllerConfigEnum.SCALEBAR_FONT_RATIO.value)\n        line_width = int(scalebar_length/50 * ControllerConfigEnum.SCALEBAR_FONT_RATIO.value)\n\n        line_offset = scalebar_length/10\n\n        box_length = scalebar_length + 2*line_offset\n        box_height = scalebar_height + 2*line_offset\n\n        draw = ImageDraw.Draw(img)\n        # Draw a box around the scalebar, taking consideration of the font size height\n        draw.rectangle([(img.size[0]-box_length, img.size[1]-box_height),\n                        (img.size[0], img.size[1])], fill=(0,0,0))\n        draw.line([(img.size[0]-scalebar_length-line_offset, img.size[1]-line_offset),\n                   (img.size[0]-line_offset, img.size[1]-line_offset)],\n                  fill=(255,255,255), width=line_width)\n\n        try: text_params = {'text':'{:.0f} \u00b5m'.format(abs(length_mm*1e3)), 'font':ImageFont.truetype(font,font_size)}\n        except Exception: raise ValueError('Scalebar font file not found. Please check the font path in the configuration.')\n\n        text_length = draw.textlength(**text_params)\n\n        draw.text((img.size[0]-box_length/2-text_length/2, img.size[1]-line_offset*2-line_width-font_size/2),\n                  align='left', fill=(255,255,255), **text_params)\n        return img\n\n    def video_update(self):\n        \"\"\"\n        Updates the video feed, taking in mind Tkinter's single thread.\n        Use in a worker thread, DO NOT use in the mainthread!!!\n        \"\"\"\n        def draw_crosshair(img:Image.Image) -&gt; Image.Image:\n            width, height = img.size\n            draw = ImageDraw.Draw(img)\n            line_color = (255, 0, 0)\n            # Draw vertical line\n            draw.line([(width/2, 0), (width/2, height)], fill=line_color, width=3)\n            # Draw horizontal line\n            draw.line([(0, height/2), (width, height/2)], fill=line_color, width=3)\n            return img\n\n        # Initialise the camera controller and grabs the first image\n        if not self._camera_ctrl.get_initialisation_status(): self._camera_ctrl.__init__()\n        self._currentFrame = None            # Empties the current frame\n\n        # Loops the image updater to create outputs the video capture frame by frame\n        self._flg_isvideorunning = True  # Enables the autoupdater\n        while self._flg_isvideorunning:\n            try:\n                time1 = time.time()\n                # Triggers the frame capture from the camera\n                request = self._combo_vidcorrection.currentText()\n\n                if self._stageHub.Enum_CamCorrectionType[request] == self._stageHub.Enum_CamCorrectionType.RAW:\n                    img = self._camera_ctrl.img_capture()\n                else:\n                    img:Image.Image = self._stageHub.get_image(request=self._stageHub.Enum_CamCorrectionType[request])\n                # video_width = int(img.size[1]/img.size[0]*self._video_height)\n\n                # Add a scalebar to it\n                img = self._overlay_scalebar(img) if self._chkbox_scalebar.isChecked() else img\n\n                # Overlay a crosshair if requested\n                if self._chkbox_crosshair.isChecked(): img = draw_crosshair(img)\n                new_frame:QPixmap = ImageQt.toqpixmap(img)\n\n                # Update the image in the app window\n                # Only update if the frame is different. Sometimes the program isn't done taking the new image.\n                # In this case, it skips the frame update\n                if self._currentFrame != new_frame:\n                    self._lbl_video.setPixmap(new_frame)\n                    self._currentFrame = new_frame\n                    self._currentImage = img\n\n                # Let the coordinate updater know that the frame is ready if any is waiting\n                self._flg_isNewFrmReady.set()\n                time_elapsed = time.time() - time1\n                if time_elapsed &lt; 1/AppVideoEnum.VIDEOFEED_REFRESH_RATE.value:\n                    time.sleep(1/AppVideoEnum.VIDEOFEED_REFRESH_RATE.value - time_elapsed)\n            except Exception as e: print(f'Video feed failed: {e}'); time.sleep(0.02)\n\n    @Slot(str,str)\n    def status_update(self,message=None,bg_colour=None):\n        \"\"\"\n        To update the status bar at the bottom\n\n        Args:\n            message (str, optional): The update message. Defualts to None\n            bg_colour (str, optional): Background colour. Defaults to 'default'.\n        \"\"\"\n        if not message: message = 'Motion controller ready'\n\n        try:\n            self._statbar.showMessage(message)\n            self._statbar.setStyleSheet(f\"background-color: {bg_colour}\") if bg_colour is not None else self._statbar.setStyleSheet(\"\")\n        except Exception as e:\n            print(f'Status bar update failed: {e}')\n\n    def terminate(self):\n        \"\"\"\n        Terminates the motion controller\n        \"\"\"\n        self._flg_isrunning.clear()\n        self.video_terminate()  # Terminates the camera controller as well\n        self.ctrl_xy.terminate()\n        self.ctrl_z.terminate()\n        self._camera_ctrl.camera_termination()\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.calculate_vel_relative","title":"<code>calculate_vel_relative(vel_xy_mmPerSec)</code>","text":"<p>Calculates the velocity in percentage based on the given velocity in mm/s based on the each device controller's internal method.</p> <p>Parameters:</p> Name Type Description Default <code>vel_xy_mmPerSec</code> <code>float</code> <p>The velocity in mm/s</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The velocity in percentage, relative to the device's maximum velocity</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def calculate_vel_relative(self, vel_xy_mmPerSec:float) -&gt; float:\n    \"\"\"\n    Calculates the velocity in percentage based on the given velocity in mm/s\n    based on the each device controller's internal method.\n\n    Args:\n        vel_xy_mmPerSec (float): The velocity in mm/s\n\n    Returns:\n        float: The velocity in percentage, relative to the device's maximum velocity\n    \"\"\"\n    return self.ctrl_xy.calculate_vel_relative(vel_xy_mmPerSec)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.check_coordinates","title":"<code>check_coordinates(coor_mm)</code>","text":"<p>Checks if the given coordinates are within the travel range of the stages</p> <p>Parameters:</p> Name Type Description Default <code>coor_mm</code> <code>tuple[float, float, float]</code> <p>The coordinates to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the coordinates are within the travel range, False otherwise</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def check_coordinates(self,coor_mm:tuple[float,float,float]) -&gt; bool:\n    \"\"\"\n    Checks if the given coordinates are within the travel range of the stages\n\n    Args:\n        coor_mm (tuple[float,float,float]): The coordinates to check\n\n    Returns:\n        bool: True if the coordinates are within the travel range, False otherwise\n    \"\"\"\n    # NOTE: Implement this!\n    pass\n    return True\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.disable_overlays","title":"<code>disable_overlays()</code>","text":"<p>Disables the overlays on the video feed</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def disable_overlays(self):\n    \"\"\"\n    Disables the overlays on the video feed\n    \"\"\"\n    self._chkbox_crosshair.setChecked(False)\n    self._chkbox_scalebar.setChecked(False)\n    return\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.disable_widgets","title":"<code>disable_widgets()</code>","text":"<p>Disables all stage control widgets</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def disable_widgets(self):\n    \"\"\"\n    Disables all stage control widgets\n    \"\"\"\n    all_widgets = get_all_widgets(self._wdg_stage)\n    [widget.setEnabled(False) for widget in all_widgets if isinstance(widget,(qw.QPushButton,qw.QLineEdit))]\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.enable_widgets","title":"<code>enable_widgets()</code>","text":"<p>Enables all stage control widgets</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def enable_widgets(self):\n    \"\"\"\n    Enables all stage control widgets\n    \"\"\"\n    all_widgets = get_all_widgets(self._wdg_stage)\n    [widget.setEnabled(True) for widget in all_widgets if isinstance(widget,(qw.QPushButton,qw.QLineEdit))]\n\n    # Updates the statusbar\n    self.sig_statbar_message.emit('Stage controller ready', None)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.get_VelocityParameters","title":"<code>get_VelocityParameters()</code>","text":"<p>Returns the velocity parameters for the motors</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(xy-velocity, z-velocity) Velocity parameters for the xy-stage and z-stage in percentage</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def get_VelocityParameters(self):\n    \"\"\"\n    Returns the velocity parameters for the motors\n\n    Returns:\n        tuple: (xy-velocity, z-velocity) Velocity parameters for the xy-stage and z-stage in percentage\n    \"\"\"\n    vel_xy = self.ctrl_xy.get_vel_acc_relative()[1]\n    vel_z = self.ctrl_z.get_vel_acc_relative()[1]\n\n    return (vel_xy,vel_z)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.get_controller_identifiers","title":"<code>get_controller_identifiers()</code>","text":"<p>Returns the controller identifiers for the camera, xy-stage, and z-stage Returns:     tuple: (camera-id, xy-stage-id, z-stage-id)</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def get_controller_identifiers(self) -&gt; tuple:\n    \"\"\"\n    Returns the controller identifiers for the camera, xy-stage, and z-stage\n    Returns:\n        tuple: (camera-id, xy-stage-id, z-stage-id)\n    \"\"\"\n    return (self._controller_id_camera,\n            self._controller_id_xy,\n            self._controller_id_z)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.get_coordinates_closest_mm","title":"<code>get_coordinates_closest_mm()</code>","text":"<p>Returns the current coordinate of both channels x, y, and z of the stages.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>tuple[float | None, float | None, float | None]</code> <p>x, y, and z coordinates of the stage (converted from Thorlabs Decimals)</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def get_coordinates_closest_mm(self) -&gt; tuple[float|None,float|None,float|None]:\n    \"\"\"\n    Returns the current coordinate of both channels x, y, and z of the stages.\n\n    Returns:\n        float: x, y, and z coordinates of the stage (converted from Thorlabs Decimals)\n    \"\"\"\n    timestamp_req = get_timestamp_us_int()\n    result = self._stageHub.get_coordinates_closest(timestamp_req)\n\n    if result is None: return (None,None,None)\n    coor_x,coor_y,coor_z = result\n\n    self._current_coor = np.array([coor_x,coor_y,coor_z])\n\n    return coor_x,coor_y,coor_z\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.get_current_image","title":"<code>get_current_image(wait_newimage=False)</code>","text":"<p>Returns the current frame of the video feed</p> <p>Returns:</p> Name Type Description <code>Image | None</code> <p>ImageTk.PhotoImage: The current frame of the video feed</p> <code>wait_newimage</code> <code>(bool, optional)</code> <p>Waits for a new image to be taken. Defaults to False.</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def get_current_image(self, wait_newimage:bool=False) -&gt; Image.Image|None:\n    \"\"\"\n    Returns the current frame of the video feed\n\n    Returns:\n        ImageTk.PhotoImage: The current frame of the video feed\n        wait_newimage (bool, optional): Waits for a new image to be taken. Defaults to False.\n    \"\"\"\n    if wait_newimage:\n        self._flg_isNewFrmReady.clear()\n        self._flg_isNewFrmReady.wait()\n    return self._currentImage\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.get_goto_worker","title":"<code>get_goto_worker()</code>","text":"<p>Returns the worker to command the stage to go to specific coordinates</p> <p>Returns:</p> Name Type Description <code>Motion_GoToCoor_Worker</code> <code>Motion_GoToCoor_Worker</code> <p>The worker to perform the goto coordinate command.</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def get_goto_worker(self) -&gt; Motion_GoToCoor_Worker:\n    \"\"\"\n    Returns the worker to command the stage to go to specific coordinates\n\n    Returns:\n        Motion_GoToCoor_Worker: The worker to perform the goto coordinate command.\n    \"\"\"\n    return self._worker_gotocoor\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.get_image_shape","title":"<code>get_image_shape()</code>","text":"<p>Returns the shape of the current image in (width, height)</p> <p>Returns:</p> Type Description <code>tuple[int, int] | None</code> <p>tuple[int,int]|None: The shape of the current image in (width, height) or None if no image is available</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def get_image_shape(self) -&gt; tuple[int,int]|None:\n    \"\"\"\n    Returns the shape of the current image in (width, height)\n\n    Returns:\n        tuple[int,int]|None: The shape of the current image in (width, height) or None if no image is available\n    \"\"\"\n    if isinstance(self._currentImage,Image.Image):\n        return self._currentImage.size\n    return None\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.go_to_coordinates","title":"<code>go_to_coordinates(coors_mm=(None, None, None), override_controls=False, event_finish=None)</code>","text":"<p>Moves the stage to specific coordinates, except if None is provided. (Asynchronous)</p> <p>Parameters:</p> Name Type Description Default <code>coors_mm</code> <code>tuple[float | None, float | None, float | None]</code> <p>A tuple of x, y, and z coordinates in mm to move to. If None</p> <code>(None, None, None)</code> <code>override_controls</code> <code>bool</code> <p>If True, does not disable/enable the controls. Defaults to False.</p> <code>False</code> <code>event_finish</code> <code>Event</code> <p>An event to set when the movement is finished. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the stage does not move within the timeout</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>@Slot(tuple,bool,threading.Event)\ndef go_to_coordinates(\n    self,\n    coors_mm:tuple[float|None,float|None,float|None]=(None,None,None),\n    override_controls:bool=False,\n    event_finish:threading.Event|None=None):\n    \"\"\"\n    Moves the stage to specific coordinates, except if None is provided. (Asynchronous)\n\n    Args:\n        coors_mm (tuple[float|None,float|None,float|None], optional): A tuple of x, y, and z coordinates in mm to move to. If None\n        override_controls (bool, optional): If True, does not disable/enable the controls. Defaults to False.\n        event_finish (threading.Event, optional): An event to set when the movement is finished. Defaults to None.\n\n    Raises:\n        TimeoutError: If the stage does not move within the timeout\n    \"\"\"\n    coor_x_mm,coor_y_mm,coor_z_mm = coors_mm\n    if not override_controls: self.disable_widgets()\n    self._sig_go_to_coordinates.emit((coor_x_mm,coor_y_mm,coor_z_mm), event_finish)\n\n    if not override_controls: self.enable_widgets()\n\n    # Resets the statusbar, let the user know that it's done moving\n    self.sig_statbar_message.emit('Stage movement complete', None)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.incrase_decrease_speed","title":"<code>incrase_decrease_speed(stage, increase)</code>","text":"<p>Increase or decrease the velocity of the motors by 5% or 1% for the xy-stage and z-stage (5% if speed is &gt;= 10%, 1% if speed is &lt; 10%)</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>str</code> <p>'xy' or 'z' for the stage to be controlled</p> required <code>increase</code> <code>bool</code> <p>True to increase, False to decrease</p> required Source code in <code>iris/gui/motion_video.py</code> <pre><code>def incrase_decrease_speed(self,stage:str,increase:bool):\n    \"\"\"\n    Increase or decrease the velocity of the motors by 5% or 1% for the xy-stage and z-stage\n    (5% if speed is &gt;= 10%, 1% if speed is &lt; 10%)\n\n    Args:\n        stage (str): 'xy' or 'z' for the stage to be controlled\n        increase (bool): True to increase, False to decrease\n    \"\"\"\n    assert stage in ['xy','z'], 'Invalid stage input'\n\n    mult = 1 if increase else -1\n    velxy = self.ctrl_xy.get_vel_acc_relative()[1]\n    velz = self.ctrl_z.get_vel_acc_relative()[1]\n    if stage == 'xy':\n        velxy += 5*mult if velxy &gt;= 10 else 1*mult\n        if velxy &lt;= 0: velxy = 1\n        elif velxy &gt;= 100: velxy = 100\n    elif stage == 'z':\n        velz = self.ctrl_z.get_vel_acc_relative()[1]\n        velz += 5*mult if velz &gt;= 10 else 1*mult\n        if velz &lt;= 0: velz = 1\n        elif velz &gt;= 100: velz = 100\n\n    self.set_vel_relative(vel_xy=velxy,vel_z=velz)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.motion_button_manager","title":"<code>motion_button_manager(dir)</code>","text":"<p>Moves the stage per request from the button presses and releases. Should be assigned to a worker thread.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'yfwd', 'xfwd', 'zfwd', 'yrev', 'xrev', 'zrev', 'ystop', 'xstop', 'zstop', 'xyhome', 'zhome'</p> required Source code in <code>iris/gui/motion_video.py</code> <pre><code>def motion_button_manager(self,dir):\n    \"\"\"\n    Moves the stage per request from the button presses and releases.\n    Should be assigned to a worker thread.\n\n    Args:\n        dir (str): 'yfwd', 'xfwd', 'zfwd', 'yrev', 'xrev', 'zrev', 'ystop', 'xstop', 'zstop', 'xyhome', 'zhome'\n        for x, y and z motors with fwd, rev, and stop for forward, backward, and stop.\n        'xyhome' and 'zhome' are for calibrating and homing the xy and z stage respectively.\n        Note that 'xstop' and 'ystop' will stop both x and y motors.\n    \"\"\"\n    if self._chkbox_jog_enabled.isChecked(): self.move_jog(dir); return\n\n    def _move():\n        if dir not in ['yfwd','xfwd','zfwd','yrev','xrev','zrev','xyhome','zhome']:\n            self.sig_statbar_message.emit(f'Moving: {dir}', 'yellow')\n        elif dir in ['xstop','ystop','zstop']:\n            self.sig_statbar_message.emit(f'Stopping: {dir}', None)\n\n        if dir in ['yfwd','xfwd','yrev','xrev']:\n            self.ctrl_xy.move_continuous(dir)\n        elif dir in ['zfwd','zrev']:\n            self.ctrl_z.move_continuous(dir)\n        elif dir in ['xstop','ystop']:\n            self.ctrl_xy.stop_move()\n        elif dir == 'zstop':\n            self.ctrl_z.stop_move()\n        elif dir == 'xyhome':\n            self.ctrl_xy.homing_n_coor_calibration()\n        elif dir == 'zhome':\n            self.ctrl_z.homing_n_coor_calibration()\n        else: raise SyntaxError('motion_button_manager: Invalid direction input')\n\n        self.sig_statbar_message.emit(None, None)\n\n    if hasattr(self,'_thread_move') and self._thread_move.is_alive(): return\n\n    self._thread_move = threading.Thread(target=_move)\n    self._thread_move.start()\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.move_jog","title":"<code>move_jog(dir)</code>","text":"<p>Moves the stage per request from the button presses</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>'yfwd', 'xfwd', 'zfwd', 'yrev', 'xrev', 'zrev'</p> required Source code in <code>iris/gui/motion_video.py</code> <pre><code>def move_jog(self,dir:str):\n    \"\"\"\n    Moves the stage per request from the button presses\n\n    Args:\n        dir (str): 'yfwd', 'xfwd', 'zfwd', 'yrev', 'xrev', 'zrev'\n        as described in self.motion_button_manager\n    \"\"\"\n    def _move_jog():\n        self.sig_statbar_message.emit(f'Jogging to: {dir}', 'yellow')\n\n        if dir not in ['yfwd','xfwd','zfwd','yrev','xrev','zrev']:\n            raise SyntaxError('move_jog: Invalid direction input')\n        elif dir in ['xfwd','xrev','yfwd','yrev']:\n            self.ctrl_xy.move_jog(dir)\n        elif dir in ['zfwd','zrev']:\n            self.ctrl_z.move_jog(dir)\n\n        self.sig_statbar_message.emit(None, None)\n\n    if hasattr(self,'_thread_jog') and self._thread_jog.is_alive(): return\n    self._thread_jog = threading.Thread(target=_move_jog)\n    self._thread_jog.start()\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.set_camera_exposure","title":"<code>set_camera_exposure()</code>","text":"<p>Sets the camera exposure time in microseconds</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def set_camera_exposure(self):\n    \"\"\"\n    Sets the camera exposure time in microseconds\n    \"\"\"\n    main_window = self.window()\n    if not hasattr(self._camera_ctrl,'set_exposure_time') or not hasattr(self._camera_ctrl,'get_exposure_time'):\n        qw.QMessageBox.critical(main_window, 'Error', 'Camera does not support exposure time setting')\n        return\n    try:\n        init_exposure_time = self._camera_ctrl.get_exposure_time()\n        new_exposure_time = messagebox_request_input(\n            parent=main_window,\n            title='Set exposure time',\n            message='Set exposure time in device unit',\n            default=str(init_exposure_time),\n            validator=validator_float_greaterThanZero,\n            invalid_msg='Exposure time must be a positive number',\n            loop_until_valid=True,\n        )\n        if new_exposure_time is None: \n            qw.QMessageBox.information(main_window, 'Exposure time not set', 'Exposure time not changed')\n            return\n        self._camera_ctrl.set_exposure_time(float(new_exposure_time))\n        qw.QMessageBox.information(main_window, 'Exposure time set', 'Exposure time set to {} ms'.format(self._camera_ctrl.get_exposure_time()))\n    except Exception as e:\n        qw.QMessageBox.critical(main_window, 'Error', 'Failed to set exposure time:\\n' + str(e))\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.set_vel_relative","title":"<code>set_vel_relative(vel_xy=-1.0, vel_z=-1.0, event_finish=None)</code>","text":"<p>Sets the velocity parameters for the motors</p> <p>Parameters:</p> Name Type Description Default <code>vel_xy</code> <code>float</code> <p>Velocity (percentage) for the xy-stage. Must be between 0[%] and 100[%]. If -1, uses the current velocity. Defaults to None.</p> <code>-1.0</code> <code>vel_z</code> <code>float</code> <p>Velocity (percentage) for the z-stage. Must be between 0[%] and 100[%]. If -1, uses the current velocity. Defaults to None.</p> <code>-1.0</code> Source code in <code>iris/gui/motion_video.py</code> <pre><code>@Slot(float,float,threading.Event)\ndef set_vel_relative(self,vel_xy:float=-1.0,vel_z:float=-1.0,event_finish:threading.Event|None=None):\n    \"\"\"\n    Sets the velocity parameters for the motors\n\n    Args:\n        vel_xy (float, optional): Velocity (percentage) for the xy-stage. Must be between 0[%] and 100[%]. If -1, uses the current velocity. Defaults to None.\n        vel_z (float, optional): Velocity (percentage) for the z-stage. Must be between 0[%] and 100[%]. If -1, uses the current velocity. Defaults to None.\n    \"\"\"\n    if vel_xy &lt;= 0.0 or vel_xy &gt; 100.0: vel_xy = self.ctrl_xy.get_vel_acc_relative()[1]\n    if vel_z &lt;= 0.0 or vel_z &gt; 100.0: vel_z = self.ctrl_z.get_vel_acc_relative()[1]\n\n    assert isinstance(vel_xy,(float,int)) and isinstance(vel_z,(float,int)), 'Invalid input type for the velocity parameters'\n\n    self.ctrl_xy.set_vel_acc_relative(vel_homing=vel_xy,vel_move=vel_xy)\n    self.ctrl_z.set_vel_acc_relative(vel_homing=vel_z,vel_move=vel_z)\n\n    speed_xy = self.ctrl_xy.get_vel_acc_relative()[1]\n    speed_z = self.ctrl_z.get_vel_acc_relative()[1]\n\n    if isinstance(event_finish,threading.Event): event_finish.set()\n\n    self._update_set_vel_labels()\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.status_update","title":"<code>status_update(message=None, bg_colour=None)</code>","text":"<p>To update the status bar at the bottom</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The update message. Defualts to None</p> <code>None</code> <code>bg_colour</code> <code>str</code> <p>Background colour. Defaults to 'default'.</p> <code>None</code> Source code in <code>iris/gui/motion_video.py</code> <pre><code>@Slot(str,str)\ndef status_update(self,message=None,bg_colour=None):\n    \"\"\"\n    To update the status bar at the bottom\n\n    Args:\n        message (str, optional): The update message. Defualts to None\n        bg_colour (str, optional): Background colour. Defaults to 'default'.\n    \"\"\"\n    if not message: message = 'Motion controller ready'\n\n    try:\n        self._statbar.showMessage(message)\n        self._statbar.setStyleSheet(f\"background-color: {bg_colour}\") if bg_colour is not None else self._statbar.setStyleSheet(\"\")\n    except Exception as e:\n        print(f'Status bar update failed: {e}')\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the motion controller</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def terminate(self):\n    \"\"\"\n    Terminates the motion controller\n    \"\"\"\n    self._flg_isrunning.clear()\n    self.video_terminate()  # Terminates the camera controller as well\n    self.ctrl_xy.terminate()\n    self.ctrl_z.terminate()\n    self._camera_ctrl.camera_termination()\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.video_initialise","title":"<code>video_initialise()</code>","text":"<p>Initialises the video: 1. Define the controller 2. Sets the first frame 3. Starts the multi-threading to start the autoupdater</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def video_initialise(self):\n    \"\"\"\n    Initialises the video:\n    1. Define the controller\n    2. Sets the first frame\n    3. Starts the multi-threading to start the autoupdater\n    \"\"\"\n    try:\n        if self._flg_isvideorunning: return\n        # Initialise the video capture\n        ## camera initialisation moved to self.video_update for responsiveness\n        # Start multithreading for the video to constantly update the captured frame\n        threading.Thread(target=self.video_update, daemon=True).start()\n\n        # Turn the button into a video stop button\n        self._btn_videotoggle.released.disconnect()\n        self._btn_videotoggle.setText('Turn camera OFF')\n        self._btn_videotoggle.released.connect(lambda: self.video_terminate())\n        self._btn_videotoggle.setStyleSheet('background-color: red')\n    except Exception as e:\n        print(f'Video feed cannot start:\\n{e}')\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.Wdg_MotionController.video_update","title":"<code>video_update()</code>","text":"<p>Updates the video feed, taking in mind Tkinter's single thread. Use in a worker thread, DO NOT use in the mainthread!!!</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def video_update(self):\n    \"\"\"\n    Updates the video feed, taking in mind Tkinter's single thread.\n    Use in a worker thread, DO NOT use in the mainthread!!!\n    \"\"\"\n    def draw_crosshair(img:Image.Image) -&gt; Image.Image:\n        width, height = img.size\n        draw = ImageDraw.Draw(img)\n        line_color = (255, 0, 0)\n        # Draw vertical line\n        draw.line([(width/2, 0), (width/2, height)], fill=line_color, width=3)\n        # Draw horizontal line\n        draw.line([(0, height/2), (width, height/2)], fill=line_color, width=3)\n        return img\n\n    # Initialise the camera controller and grabs the first image\n    if not self._camera_ctrl.get_initialisation_status(): self._camera_ctrl.__init__()\n    self._currentFrame = None            # Empties the current frame\n\n    # Loops the image updater to create outputs the video capture frame by frame\n    self._flg_isvideorunning = True  # Enables the autoupdater\n    while self._flg_isvideorunning:\n        try:\n            time1 = time.time()\n            # Triggers the frame capture from the camera\n            request = self._combo_vidcorrection.currentText()\n\n            if self._stageHub.Enum_CamCorrectionType[request] == self._stageHub.Enum_CamCorrectionType.RAW:\n                img = self._camera_ctrl.img_capture()\n            else:\n                img:Image.Image = self._stageHub.get_image(request=self._stageHub.Enum_CamCorrectionType[request])\n            # video_width = int(img.size[1]/img.size[0]*self._video_height)\n\n            # Add a scalebar to it\n            img = self._overlay_scalebar(img) if self._chkbox_scalebar.isChecked() else img\n\n            # Overlay a crosshair if requested\n            if self._chkbox_crosshair.isChecked(): img = draw_crosshair(img)\n            new_frame:QPixmap = ImageQt.toqpixmap(img)\n\n            # Update the image in the app window\n            # Only update if the frame is different. Sometimes the program isn't done taking the new image.\n            # In this case, it skips the frame update\n            if self._currentFrame != new_frame:\n                self._lbl_video.setPixmap(new_frame)\n                self._currentFrame = new_frame\n                self._currentImage = img\n\n            # Let the coordinate updater know that the frame is ready if any is waiting\n            self._flg_isNewFrmReady.set()\n            time_elapsed = time.time() - time1\n            if time_elapsed &lt; 1/AppVideoEnum.VIDEOFEED_REFRESH_RATE.value:\n                time.sleep(1/AppVideoEnum.VIDEOFEED_REFRESH_RATE.value - time_elapsed)\n        except Exception as e: print(f'Video feed failed: {e}'); time.sleep(0.02)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.generate_dummy_motion_controller","title":"<code>generate_dummy_motion_controller(parent)</code>","text":"<p>Generates a dummy motion controller for testing purposes.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent QWidget to attach the motion controller to.</p> required <p>Returns:</p> Name Type Description <code>Frm_MotionController</code> <code>Wdg_MotionController</code> <p>The dummy motion controller</p> Source code in <code>iris/gui/motion_video.py</code> <pre><code>def generate_dummy_motion_controller(parent:qw.QWidget) -&gt; Wdg_MotionController:\n    \"\"\"\n    Generates a dummy motion controller for testing purposes.\n\n    Args:\n        parent (qw.QWidget): The parent QWidget to attach the motion controller to.\n\n    Returns:\n        Frm_MotionController: The dummy motion controller\n    \"\"\"\n    from iris.multiprocessing.dataStreamer_StageCam import generate_dummy_stageHub\n\n    stagehub, xyproxy, zproxy, camproxy, stage_namespace = generate_dummy_stageHub()\n    stagehub.start()\n\n    frm_motion = Wdg_MotionController(\n        parent=parent,\n        xy_controller=xyproxy,\n        z_controller=zproxy,\n        stageHub=stagehub,\n        getter_imgcal=lambda: None\n    )\n\n    return frm_motion\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/motion_video/#iris.gui.motion_video.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/raman/","title":"raman","text":"<p>A class that manages the motion controller aspect for the Ocean Direct Raman spectrometer</p>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Enum_ContinuousMeasurementTrigger","title":"<code>Enum_ContinuousMeasurementTrigger</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for the continuous measurement trigger options.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>class Enum_ContinuousMeasurementTrigger(Enum):\n    \"\"\"\n    Enum for the continuous measurement trigger options.\n    \"\"\"\n    START = 'start'\n    PAUSE = 'pause'\n    FINISH = 'finish'\n    STORE = 'store'\n    IGNORE = 'ignore'\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.RamanMeasurement_Plotter","title":"<code>RamanMeasurement_Plotter</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A class defining the Raman measurement plotter worker.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>class RamanMeasurement_Plotter(QObject):\n    \"\"\"\n    A class defining the Raman measurement plotter worker.\n    \"\"\"\n    sig_plot_ready = Signal()\n\n    class PlotRequest(TypedDict):\n        measurement: MeaRaman\n        title: str\n        plot_Raman: bool\n        limits: tuple\n\n    def __init__(self, plotter:MeaRaman_Plotter) -&gt; None:\n        super().__init__()\n        self._is_plotting = False\n        self._pending_data = None\n        self._lock = threading.Lock()\n        self._plotter = plotter\n\n    def plot_measurement(self, data: PlotRequest) -&gt; None:\n        \"\"\"\n        Plots the given Raman measurement\n\n        Args:\n            data (PlotRequest): The plot request data\n        \"\"\"\n        measurement = data['measurement']\n        title = data['title']\n        plot_Raman = data['plot_Raman']\n        limits = data['limits']\n\n        self._plotter.plot(\n            measurement=measurement,\n            title=title,\n            flg_plot_ramanshift=plot_Raman,\n            plot_raw=True,\n            limits=limits,\n        )\n        self.sig_plot_ready.emit()\n\n        QTimer.singleShot(1, self._check_pending)\n\n    @Slot(MeaRaman, str, bool, tuple)\n    def request_plot(self, measurement:MeaRaman, title:str, plot_Raman:bool, limits:tuple):\n        \"\"\"\n        Plots the given Raman measurement\n\n        Args:\n            measurement (MeaRaman): The Raman measurement to be plotted\n            title (str): The title of the plot\n            plot_Raman (bool): Whether to plot in Raman shift or wavelength\n            limits (tuple): The limits for the plot (xmin, xmax, ymin, ymax)\n        \"\"\"\n        data = self.PlotRequest(\n            measurement=measurement,\n            title=title,\n            plot_Raman=plot_Raman,\n            limits=limits,\n        )\n        with self._lock:\n            if self._is_plotting:\n                self._pending_data = data\n                return\n\n            # If not busy, mark as busy and proceed\n            self._is_plotting = True\n        self.plot_measurement(data)\n\n    def _check_pending(self):\n        with self._lock:\n            if self._pending_data is not None:\n                data = self._pending_data\n                self._pending_data = None\n                self.plot_measurement(data)\n            else:\n                self._is_plotting = False\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.RamanMeasurement_Plotter.plot_measurement","title":"<code>plot_measurement(data)</code>","text":"<p>Plots the given Raman measurement</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PlotRequest</code> <p>The plot request data</p> required Source code in <code>iris/gui/raman.py</code> <pre><code>def plot_measurement(self, data: PlotRequest) -&gt; None:\n    \"\"\"\n    Plots the given Raman measurement\n\n    Args:\n        data (PlotRequest): The plot request data\n    \"\"\"\n    measurement = data['measurement']\n    title = data['title']\n    plot_Raman = data['plot_Raman']\n    limits = data['limits']\n\n    self._plotter.plot(\n        measurement=measurement,\n        title=title,\n        flg_plot_ramanshift=plot_Raman,\n        plot_raw=True,\n        limits=limits,\n    )\n    self.sig_plot_ready.emit()\n\n    QTimer.singleShot(1, self._check_pending)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.RamanMeasurement_Plotter.request_plot","title":"<code>request_plot(measurement, title, plot_Raman, limits)</code>","text":"<p>Plots the given Raman measurement</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>MeaRaman</code> <p>The Raman measurement to be plotted</p> required <code>title</code> <code>str</code> <p>The title of the plot</p> required <code>plot_Raman</code> <code>bool</code> <p>Whether to plot in Raman shift or wavelength</p> required <code>limits</code> <code>tuple</code> <p>The limits for the plot (xmin, xmax, ymin, ymax)</p> required Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot(MeaRaman, str, bool, tuple)\ndef request_plot(self, measurement:MeaRaman, title:str, plot_Raman:bool, limits:tuple):\n    \"\"\"\n    Plots the given Raman measurement\n\n    Args:\n        measurement (MeaRaman): The Raman measurement to be plotted\n        title (str): The title of the plot\n        plot_Raman (bool): Whether to plot in Raman shift or wavelength\n        limits (tuple): The limits for the plot (xmin, xmax, ymin, ymax)\n    \"\"\"\n    data = self.PlotRequest(\n        measurement=measurement,\n        title=title,\n        plot_Raman=plot_Raman,\n        limits=limits,\n    )\n    with self._lock:\n        if self._is_plotting:\n            self._pending_data = data\n            return\n\n        # If not busy, mark as busy and proceed\n        self._is_plotting = True\n    self.plot_measurement(data)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.RamanMeasurement_Worker","title":"<code>RamanMeasurement_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A class defining the worker functions for Raman measurement acquisition.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>class RamanMeasurement_Worker(QObject):\n    \"\"\"\n    A class defining the worker functions for Raman measurement acquisition.\n    \"\"\"\n    sig_acq_done = Signal()  # Signal emitted when the acquisition process is complete (both single and continuous)\n    sig_acq = Signal() # Signal emitted when a measurement is acquired\n    sig_mea_error = Signal(str) # Signal emitted when an error occurs during measurement acquisition\n\n    sig_mea = Signal(MeaRaman) # Signal emitted when a measurement is acquired (for burst mode)\n\n    mode_discrete = 0\n    mode_continuous = 1\n\n    def __init__(self, ramanHub: DataStreamer_Raman, syncer_acquisition: Syncer_Raman) -&gt; None:\n        super().__init__()\n        self._ramanHub = ramanHub\n        self._syncer_acquisition = syncer_acquisition\n        self._isacquiring = False\n\n        self._acquisition_params:AcquisitionParams|None = None\n        self._list_queue_observer:list[queue.Queue] = []    \n\n        self._last_measurement:MeaRaman|None = None\n\n    @Slot(queue.Queue, threading.Event)\n    def append_queue_observer_measurement(self, queue_observer: queue.Queue, done:threading.Event) -&gt; None:\n        \"\"\"\n        Appends a queue observer to the list of queue observers.\n\n        Args:\n            queue_observer (queue.Queue): The queue observer to be appended.\n            done (threading.Event): The event to signal when done.\n        \"\"\"\n        assert isinstance(queue_observer, queue.Queue), \"queue_observer must be an instance of queue.Queue\"\n        self._list_queue_observer.append(queue_observer)\n        done.set()\n\n    @Slot(queue.Queue)\n    def remove_queue_observer_measurement(self, queue_observer: queue.Queue) -&gt; None:\n        \"\"\"\n        Removes a queue observer from the list of queue observers.\n\n        Args:\n            queue_observer (queue.Queue): The queue observer to be removed.\n        \"\"\"\n        assert isinstance(queue_observer, queue.Queue), \"queue_observer must be an instance of queue.Queue\"\n        try: self._list_queue_observer.remove(queue_observer)\n        except: pass\n\n    @Slot()\n    def stop_acquisition(self) -&gt; None:\n        \"\"\"\n        Stops the continuous acquisition of Raman measurements.\n        \"\"\"\n        self._isacquiring = False\n\n    @Slot(AcquisitionParams)\n    def acquire_continuous_measurement(self, params: AcquisitionParams):\n        self._acquisition_params = params\n        self._ramanHub.resume_auto_measurement()\n\n        self._isacquiring = True\n        self._schedule_next_acquisition_cycle(params)\n\n    @Slot(AcquisitionParams)\n    def acquire_single_measurement(self, params:AcquisitionParams):\n        self._acquisition_params = params\n        self._ramanHub.resume_auto_measurement()\n\n        self._acquire_one_measurement(params)\n\n        self.sig_acq_done.emit()\n        self._ramanHub.pause_auto_measurement()\n\n\n    @Slot(AcquisitionParams, queue.Queue, queue.Queue)\n    def acquire_continuous_burst_measurement_trigger(\n        self,\n        params:AcquisitionParams,\n        q_trigger:queue.Queue[Enum_ContinuousMeasurementTrigger],\n        q_return:queue.Queue[MeaRaman],\n        ):\n        \"\"\"\n        Acquires the spectrum in a continuous manner (one after another consecutively)\n        and puts them in the return queue or ignore them based on the commands from q_trigger.\n        For the full list of available commands, refer to the Enum_ContinuousMeasurementTrigger class.\n\n        NOTE: The first command in q_trigger MUST be START to begin the measurement, followed by either\n        STORE or IGNORE commands. To stop the measurement, send the FINISH command.\n\n        NOTE: This function **blocks** the thread until the FINISH command is received.\n\n        Args:\n            params (AcquisitionParams): The acquisition parameters that will be fixed to the acquired measurements.\n            q_trigger (queue.Queue): The trigger queue to command the measurement actions.\n            q_return (queue.Queue): The return queue where the acquired measurements are put.\n\n        NOTE:\n            The event to signal when the process is ready for the next command is synced with the syncer_acquisition.\n            It is triggered after receiving the START command and after the measurements are put in the return queue\n            after each STORE command.\n        \"\"\"\n        self._acquisition_params = params\n        self._ramanHub.wait_MeasurementUpdate()\n\n        trigger = q_trigger.get()\n        if not trigger == Enum_ContinuousMeasurementTrigger.START:\n            raise ValueError('The first trigger command must be START to begin the continuous measurement.')\n\n        list_timestamp_trigger = [get_timestamp_us_int()]\n        self._isacquiring = True\n\n        EnumTrig = Enum_ContinuousMeasurementTrigger\n\n        self._syncer_acquisition.notify_ready()\n        while self._isacquiring:\n            # Wait for the trigger to start the next measurement or to stop\n            trigger = q_trigger.get()\n            print(f'\\nReceived trigger command: {trigger}')\n            if trigger == EnumTrig.FINISH: break\n\n            # Retrieve the measurements\n            list_timestamp_trigger.append(get_timestamp_us_int())\n            list_timestamp_mea_int,list_spectrum,list_integration_time_ms=\\\n                self._ramanHub.get_measurement(\n                    timestamp_start=list_timestamp_trigger[-2],\n                    timestamp_end=list_timestamp_trigger[-1],\n                    WaitForMeasurement=False,\n                    getNewOnly=True)\n            print(f'Acquired {len(list_spectrum)} spectra between {convert_timestamp_us_int_to_str(list_timestamp_trigger[-2])} and {convert_timestamp_us_int_to_str(list_timestamp_trigger[-1])}')\n            list_timestamp_trigger.pop(0) # Remove the first element (not needed anymore)\n\n            if trigger == EnumTrig.IGNORE:\n                self._syncer_acquisition.notify_ready()\n                continue\n\n            print('Processing acquired spectra...')\n            list_measurement = []\n            for ts_int,spectrum_raw,int_time_ms in zip(list_timestamp_mea_int,list_spectrum,list_integration_time_ms):\n                measurement = MeaRaman(\n                    timestamp=ts_int,\n                    int_time_ms=int_time_ms,\n                    laserPower_mW=params['laserpower_mW'],\n                    laserWavelength_nm=params['laserwavelength_nm'],\n                    extra_metadata=params['extra_metadata'])\n                measurement.set_raw_list(df_mea=spectrum_raw, timestamp_int=ts_int)\n                list_measurement.append(measurement)\n\n            print(f'Processing and returning {len(list_measurement)} measurements...')\n            # Return the measurement result\n            for mea in list_measurement:\n                print(f'Processing measurement at {convert_timestamp_us_int_to_str(mea.get_latest_timestamp())}...')\n                mea:MeaRaman\n                mea.calculate_analysed()\n                q_return.put(mea)\n                print(f'Return measurement queue size: {q_return.qsize()}')\n                self.sig_acq.emit()\n                self._notify_queue_observers(measurement=mea)\n                self._last_measurement = mea\n\n            self._syncer_acquisition.notify_ready()\n\n        self.sig_acq_done.emit()\n        self._ramanHub.pause_auto_measurement()\n        self._syncer_acquisition.notify_ready()\n\n    @Slot(AcquisitionParams)\n    def _schedule_next_acquisition_cycle(self, params:AcquisitionParams):\n        \"\"\"\n        Executes one measurement unit and schedules the next one if still running.\n        This is the core of the non-blocking loop.\n        \"\"\"\n        if not self._isacquiring:\n            self.sig_acq_done.emit()\n            self._ramanHub.pause_auto_measurement()\n            return\n\n        try:\n            self._acquire_one_measurement(params)\n            QTimer.singleShot(0, lambda: self._schedule_next_acquisition_cycle(params))\n        except Exception as e:\n            self._isacquiring = False\n            self.sig_mea_error.emit(f'Critical error in acquisition cycle: {e}')\n            self.sig_acq_done.emit()\n            self._ramanHub.pause_auto_measurement()\n\n    def _acquire_one_measurement(self, params:AcquisitionParams):\n        \"\"\"\n        Acquire a single measurement\n\n        Args:\n            params (AcquisitionParams | None, optional): The acquisition parameters. Defaults to None.\n            continuous (bool, optional): Whether the acquisition is continuous. Defaults to False.\n        \"\"\"\n        # try: print(f'Gap between measurements: {(time.time()-self._t1)*1e3:.0f} ms')\n        # except: pass\n        # self._t1 = time.time()\n        timestamp = get_timestamp_us_int()\n        measurement = MeaRaman(\n            timestamp=timestamp,\n            int_time_ms=params['int_time_ms'],\n            laserPower_mW=params['laserpower_mW'],\n            laserWavelength_nm=params['laserwavelength_nm'],\n            extra_metadata=params['extra_metadata'],\n            )\n\n        for _ in range(params['accumulation']):    \n            # Performs a measurement and add it to the storage\n            timestamp_request = get_timestamp_us_int()\n            result = self._ramanHub.get_measurement(timestamp_request,WaitForMeasurement=False,getNewOnly=True)\n            spectrum_raw = result[1][-1]\n\n            measurement.set_raw_list(\n                df_mea=spectrum_raw,\n                timestamp_int=timestamp_request,\n                max_accumulation=params['accumulation']\n                )\n\n            self._notify_queue_observers(measurement)\n            self.sig_acq.emit()\n\n        self._last_measurement = measurement\n        time.sleep(0.001) # Small delay to prevent overloading the CPU\n\n    @Slot()\n    def request_last_measurement(self) -&gt; None:\n        \"\"\"\n        Returns the last acquired measurement.\n        \"\"\"\n        if self._last_measurement is not None:\n            self.sig_mea.emit(self._last_measurement)\n\n    def _notify_queue_observers(self, measurement:MeaRaman) -&gt; None:\n        \"\"\"\n        Notifies all queue observers with the acquired measurement.\n\n        Args:\n            measurement (MeaRaman): The acquired Raman measurement.\n        \"\"\"\n        for q in self._list_queue_observer:\n            try: q.put(measurement)\n            except Exception as e: print(f'Error in _notify_queue_observers: {e}')\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.RamanMeasurement_Worker.acquire_continuous_burst_measurement_trigger","title":"<code>acquire_continuous_burst_measurement_trigger(params, q_trigger, q_return)</code>","text":"<p>Acquires the spectrum in a continuous manner (one after another consecutively) and puts them in the return queue or ignore them based on the commands from q_trigger. For the full list of available commands, refer to the Enum_ContinuousMeasurementTrigger class.</p> <p>NOTE: The first command in q_trigger MUST be START to begin the measurement, followed by either STORE or IGNORE commands. To stop the measurement, send the FINISH command.</p> <p>NOTE: This function blocks the thread until the FINISH command is received.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>AcquisitionParams</code> <p>The acquisition parameters that will be fixed to the acquired measurements.</p> required <code>q_trigger</code> <code>Queue</code> <p>The trigger queue to command the measurement actions.</p> required <code>q_return</code> <code>Queue</code> <p>The return queue where the acquired measurements are put.</p> required NOTE <p>The event to signal when the process is ready for the next command is synced with the syncer_acquisition. It is triggered after receiving the START command and after the measurements are put in the return queue after each STORE command.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot(AcquisitionParams, queue.Queue, queue.Queue)\ndef acquire_continuous_burst_measurement_trigger(\n    self,\n    params:AcquisitionParams,\n    q_trigger:queue.Queue[Enum_ContinuousMeasurementTrigger],\n    q_return:queue.Queue[MeaRaman],\n    ):\n    \"\"\"\n    Acquires the spectrum in a continuous manner (one after another consecutively)\n    and puts them in the return queue or ignore them based on the commands from q_trigger.\n    For the full list of available commands, refer to the Enum_ContinuousMeasurementTrigger class.\n\n    NOTE: The first command in q_trigger MUST be START to begin the measurement, followed by either\n    STORE or IGNORE commands. To stop the measurement, send the FINISH command.\n\n    NOTE: This function **blocks** the thread until the FINISH command is received.\n\n    Args:\n        params (AcquisitionParams): The acquisition parameters that will be fixed to the acquired measurements.\n        q_trigger (queue.Queue): The trigger queue to command the measurement actions.\n        q_return (queue.Queue): The return queue where the acquired measurements are put.\n\n    NOTE:\n        The event to signal when the process is ready for the next command is synced with the syncer_acquisition.\n        It is triggered after receiving the START command and after the measurements are put in the return queue\n        after each STORE command.\n    \"\"\"\n    self._acquisition_params = params\n    self._ramanHub.wait_MeasurementUpdate()\n\n    trigger = q_trigger.get()\n    if not trigger == Enum_ContinuousMeasurementTrigger.START:\n        raise ValueError('The first trigger command must be START to begin the continuous measurement.')\n\n    list_timestamp_trigger = [get_timestamp_us_int()]\n    self._isacquiring = True\n\n    EnumTrig = Enum_ContinuousMeasurementTrigger\n\n    self._syncer_acquisition.notify_ready()\n    while self._isacquiring:\n        # Wait for the trigger to start the next measurement or to stop\n        trigger = q_trigger.get()\n        print(f'\\nReceived trigger command: {trigger}')\n        if trigger == EnumTrig.FINISH: break\n\n        # Retrieve the measurements\n        list_timestamp_trigger.append(get_timestamp_us_int())\n        list_timestamp_mea_int,list_spectrum,list_integration_time_ms=\\\n            self._ramanHub.get_measurement(\n                timestamp_start=list_timestamp_trigger[-2],\n                timestamp_end=list_timestamp_trigger[-1],\n                WaitForMeasurement=False,\n                getNewOnly=True)\n        print(f'Acquired {len(list_spectrum)} spectra between {convert_timestamp_us_int_to_str(list_timestamp_trigger[-2])} and {convert_timestamp_us_int_to_str(list_timestamp_trigger[-1])}')\n        list_timestamp_trigger.pop(0) # Remove the first element (not needed anymore)\n\n        if trigger == EnumTrig.IGNORE:\n            self._syncer_acquisition.notify_ready()\n            continue\n\n        print('Processing acquired spectra...')\n        list_measurement = []\n        for ts_int,spectrum_raw,int_time_ms in zip(list_timestamp_mea_int,list_spectrum,list_integration_time_ms):\n            measurement = MeaRaman(\n                timestamp=ts_int,\n                int_time_ms=int_time_ms,\n                laserPower_mW=params['laserpower_mW'],\n                laserWavelength_nm=params['laserwavelength_nm'],\n                extra_metadata=params['extra_metadata'])\n            measurement.set_raw_list(df_mea=spectrum_raw, timestamp_int=ts_int)\n            list_measurement.append(measurement)\n\n        print(f'Processing and returning {len(list_measurement)} measurements...')\n        # Return the measurement result\n        for mea in list_measurement:\n            print(f'Processing measurement at {convert_timestamp_us_int_to_str(mea.get_latest_timestamp())}...')\n            mea:MeaRaman\n            mea.calculate_analysed()\n            q_return.put(mea)\n            print(f'Return measurement queue size: {q_return.qsize()}')\n            self.sig_acq.emit()\n            self._notify_queue_observers(measurement=mea)\n            self._last_measurement = mea\n\n        self._syncer_acquisition.notify_ready()\n\n    self.sig_acq_done.emit()\n    self._ramanHub.pause_auto_measurement()\n    self._syncer_acquisition.notify_ready()\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.RamanMeasurement_Worker.append_queue_observer_measurement","title":"<code>append_queue_observer_measurement(queue_observer, done)</code>","text":"<p>Appends a queue observer to the list of queue observers.</p> <p>Parameters:</p> Name Type Description Default <code>queue_observer</code> <code>Queue</code> <p>The queue observer to be appended.</p> required <code>done</code> <code>Event</code> <p>The event to signal when done.</p> required Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot(queue.Queue, threading.Event)\ndef append_queue_observer_measurement(self, queue_observer: queue.Queue, done:threading.Event) -&gt; None:\n    \"\"\"\n    Appends a queue observer to the list of queue observers.\n\n    Args:\n        queue_observer (queue.Queue): The queue observer to be appended.\n        done (threading.Event): The event to signal when done.\n    \"\"\"\n    assert isinstance(queue_observer, queue.Queue), \"queue_observer must be an instance of queue.Queue\"\n    self._list_queue_observer.append(queue_observer)\n    done.set()\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.RamanMeasurement_Worker.remove_queue_observer_measurement","title":"<code>remove_queue_observer_measurement(queue_observer)</code>","text":"<p>Removes a queue observer from the list of queue observers.</p> <p>Parameters:</p> Name Type Description Default <code>queue_observer</code> <code>Queue</code> <p>The queue observer to be removed.</p> required Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot(queue.Queue)\ndef remove_queue_observer_measurement(self, queue_observer: queue.Queue) -&gt; None:\n    \"\"\"\n    Removes a queue observer from the list of queue observers.\n\n    Args:\n        queue_observer (queue.Queue): The queue observer to be removed.\n    \"\"\"\n    assert isinstance(queue_observer, queue.Queue), \"queue_observer must be an instance of queue.Queue\"\n    try: self._list_queue_observer.remove(queue_observer)\n    except: pass\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.RamanMeasurement_Worker.request_last_measurement","title":"<code>request_last_measurement()</code>","text":"<p>Returns the last acquired measurement.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot()\ndef request_last_measurement(self) -&gt; None:\n    \"\"\"\n    Returns the last acquired measurement.\n    \"\"\"\n    if self._last_measurement is not None:\n        self.sig_mea.emit(self._last_measurement)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.RamanMeasurement_Worker.stop_acquisition","title":"<code>stop_acquisition()</code>","text":"<p>Stops the continuous acquisition of Raman measurements.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot()\ndef stop_acquisition(self) -&gt; None:\n    \"\"\"\n    Stops the continuous acquisition of Raman measurements.\n    \"\"\"\n    self._isacquiring = False\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Spectrometer_Control_Workers","title":"<code>Spectrometer_Control_Workers</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A class defining the worker functions for the Raman spectrometer controller.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>class Spectrometer_Control_Workers(QObject):\n    \"\"\"\n    A class defining the worker functions for the Raman spectrometer controller.\n    \"\"\"\n    sig_integration_time_us = Signal(int)\n\n    def __init__(self, controller: Controller_Spectrometer) -&gt; None:\n        super().__init__()\n        self._controller = controller\n\n    @Slot(int)\n    def set_integration_time_us(self, new_value_us: int) -&gt; None:\n        \"\"\"\n        Sets the integration time of the spectrometer.\n\n        Args:\n            new_value_us (int): New integration time [us]\n\n        Returns:\n            int: The actual integration time set [us]\n        \"\"\"\n        inttime_ms = self._controller.set_integration_time_us(new_value_us)\n        self.sig_integration_time_us.emit(inttime_ms)\n\n    @Slot()\n    def get_integration_time_us(self) -&gt; None:\n        \"\"\"\n        Gets the integration time of the spectrometer.\n\n        Returns:\n            int: The current integration time [us]\n        \"\"\"\n        current_time_us = self._controller.get_integration_time_us()\n        self.sig_integration_time_us.emit(current_time_us)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Spectrometer_Control_Workers.get_integration_time_us","title":"<code>get_integration_time_us()</code>","text":"<p>Gets the integration time of the spectrometer.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>None</code> <p>The current integration time [us]</p> Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot()\ndef get_integration_time_us(self) -&gt; None:\n    \"\"\"\n    Gets the integration time of the spectrometer.\n\n    Returns:\n        int: The current integration time [us]\n    \"\"\"\n    current_time_us = self._controller.get_integration_time_us()\n    self.sig_integration_time_us.emit(current_time_us)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Spectrometer_Control_Workers.set_integration_time_us","title":"<code>set_integration_time_us(new_value_us)</code>","text":"<p>Sets the integration time of the spectrometer.</p> <p>Parameters:</p> Name Type Description Default <code>new_value_us</code> <code>int</code> <p>New integration time [us]</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>None</code> <p>The actual integration time set [us]</p> Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot(int)\ndef set_integration_time_us(self, new_value_us: int) -&gt; None:\n    \"\"\"\n    Sets the integration time of the spectrometer.\n\n    Args:\n        new_value_us (int): New integration time [us]\n\n    Returns:\n        int: The actual integration time set [us]\n    \"\"\"\n    inttime_ms = self._controller.set_integration_time_us(new_value_us)\n    self.sig_integration_time_us.emit(inttime_ms)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Syncer_Raman","title":"<code>Syncer_Raman</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A class to synchronise the Raman measurement acquisition with the stage movement.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>class Syncer_Raman(QObject):\n    \"\"\"\n    A class to synchronise the Raman measurement acquisition with the stage movement.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.mutex = QMutex()\n        self.waitcondition = QWaitCondition()\n        self.ready = False\n\n    def wait_ready(self):\n        with QMutexLocker(self.mutex):\n            while not self.ready:\n                self.waitcondition.wait(self.mutex)\n\n    def notify_ready(self):\n        with QMutexLocker(self.mutex):\n            self.ready = True\n            self.waitcondition.wakeAll()\n\n    def is_ready(self) -&gt; bool:\n        with QMutexLocker(self.mutex):\n            return self.ready\n\n    def set_ready(self):\n        with QMutexLocker(self.mutex):\n            self.ready = True\n\n    def set_notready(self):\n        with QMutexLocker(self.mutex):\n            self.ready = False\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_Raman","title":"<code>Wdg_Raman</code>","text":"<p>               Bases: <code>QWidget</code>, <code>Ui_Raman</code></p> <p>A class defining the Raman spectrometer GUI.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>class Wdg_Raman(qw.QWidget, Ui_Raman):\n    \"\"\"\n    A class defining the Raman spectrometer GUI.\n    \"\"\"\n    def __init__(self, parent:Any) -&gt; None:\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        # Set the initial dock location\n        self.main_win = self.window()\n\n        self._register_videofeed_dock()\n        self.dock_plot.installEventFilter(self)\n        self.dock_plot.topLevelChanged.connect(self._handle_videofeed_docking_changed)\n\n    def _register_videofeed_dock(self):\n        if isinstance(self.main_win, qw.QMainWindow):\n            # This tells the Main Window: \"You are the boss of this dock now\"\n            self._dock_original_index = self.main_win.layout().indexOf(self.dock_plot)\n            self._dock_original_index = max(0,self._dock_original_index-1)\n            self.main_win.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.dock_plot)\n            self.dock_plot.setFloating(True)\n            self.dock_plot.setFloating(False)\n            self.main_layout.insertWidget(self._dock_original_index, self.dock_plot)\n\n    @Slot(bool)\n    def _handle_videofeed_docking_changed(self,floating:bool):\n        if floating:\n            if isinstance(self.main_win, qw.QMainWindow):\n                self.main_win.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.dock_plot)\n            self.dock_plot.setFloating(True)\n        else:\n            self.main_layout.insertWidget(self._dock_original_index, self.dock_plot)\n            self.main_layout.insertWidget(self._dock_original_index, self.dock_plot)\n            self.dock_plot.setFloating(False)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController","title":"<code>Wdg_SpectrometerController</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A class defining the app subwindow for the Raman spectrometer.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>class Wdg_SpectrometerController(qw.QWidget):\n    \"\"\"\n    A class defining the app subwindow for the Raman spectrometer.\n    \"\"\"\n    sig_set_integration_time_us = Signal(int)\n\n    _sig_request_mea_sngl = Signal(AcquisitionParams)\n    _sig_request_mea_cont = Signal(AcquisitionParams)\n    sig_request_mea_stop = Signal()\n\n    _sig_request_lastmea = Signal() # Signal to request the last measurement from the acquisition worker\n    _sig_append_queue_observer = Signal(queue.Queue, threading.Event)    # Signal to append a queue observer to the acquisition worker\n    _sig_remove_queue_observer = Signal(queue.Queue)    # Signal to remove a queue observer from the acquisition worker\n\n    _sig_update_plot = Signal(MeaRaman, str, bool, tuple)  # Signal to update the plotter worker with new data\n\n    def __init__(\n        self,\n        parent:Any,\n        processor:mpp.Pool,\n        controller:Controller_Spectrometer,\n        ramanHub:DataStreamer_Raman,\n        dataHub:Wdg_DataHub_Mapping|None,\n        main:bool=False\n        ) -&gt; None:\n        \"\"\"\n        Initialises the Raman spectrometer controller window\n\n        Args:\n            parent (Any): The parent PyQt widget, window, etc.\n            processor (mpp.Pool): The multiprocessing pool for the data processing\n            controller (raman_spectrometer_controller): The Raman spectrometer controller\n            ramanHub (RamanMeasurementHub): The Raman measurement hub to retrieve measurements from\n            dataHub (Frm_DataHub): The data hub for the measurements\n            main (bool, optional): If true, initialises the spectrometer and analyser. Defaults to False.\n\n        Note:\n            if not main, the initialisation of the spectrometer and analyser should be done manually when ready\n        \"\"\"\n# &gt;&gt;&gt; Main initialisation &lt;&lt;&lt;\n        super().__init__(parent)\n        self._processor = processor\n        self._controller = controller   # Raman spectrometer controller\n        self._ramanHub = ramanHub       # Raman measurement hub\n        self._dataHub = dataHub         # Data hub for the measurements\n\n\n# &gt;&gt;&gt; Threading and worker setups &lt;&lt;&lt;\n    # &gt;&gt; Communciation with the controller &lt;&lt;\n        self._thread_controller = QThread(self)\n        self._worker_controller = Spectrometer_Control_Workers(controller=self._controller)\n        self._worker_controller.moveToThread(self._thread_controller)\n        self.destroyed.connect(self._thread_controller.quit)\n        self._thread_controller.finished.connect(self._worker_controller.deleteLater)\n        self._thread_controller.finished.connect(self._thread_controller.deleteLater)\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread_controller.start)\n\n    # &gt;&gt; Acquisition &lt;&lt;\n        self._syncer_acquisition = Syncer_Raman()\n        self._thread_acquisition = QThread(self)\n        self._worker_acquisition = RamanMeasurement_Worker(\n            ramanHub=self._ramanHub,\n            syncer_acquisition=self._syncer_acquisition\n        )\n        self._worker_acquisition.moveToThread(self._thread_acquisition)\n        self.destroyed.connect(self._thread_acquisition.quit)\n        self._thread_acquisition.finished.connect(self._worker_acquisition.deleteLater)\n        self._thread_acquisition.finished.connect(self._thread_acquisition.deleteLater)\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread_acquisition.start)\n\n    # &gt;&gt; Connection setups &lt;&lt;\n        self._init_request_integration_time_connection()\n        self._init_btn_measurements_connection()\n\n# &gt;&gt;&gt; Get controller parameters &lt;&lt;&lt;\n        self._controller_id = self._controller.get_identifier()\n\n# &gt;&gt;&gt; GUI setup &lt;&lt;&lt;\n        self._main_layout = qw.QVBoxLayout()\n        self.setLayout(self._main_layout)\n\n        self._main_widget = Wdg_Raman(self)\n        self._main_layout.addWidget(self._main_widget)\n        widget = self._main_widget\n\n# &gt;&gt;&gt; Spectrometer control and data handling setup &lt;&lt;&lt;\n        # Spectrometer parameters setup\n        self.integration_time_ms = AppRamanEnum.DEFAULT_INTEGRATION_TIME_MS.value \n        self._accumulation = AppRamanEnum.DEFAULT_SINGMEA_ACCUMULATION.value\n\n        # Is-running flags\n        self._flg_isrunning = threading.Event()\n\n        # Spectrometer internal data storage setup\n        self._sngl_measurement:MeaRaman = MeaRaman(reconstruct=True)    # single measurement\n        self._cont_measurement:MeaRaman = MeaRaman(reconstruct=True)    # continuous measurement\n\n        # Plotter setup\n        self._q_plt_mea = queue.Queue() # Queue for plotting measurements (will plot the latest measurement only)\n        self._plt_timer = QTimer()\n        self._plt_timer.timeout.connect(self._auto_update_plot)\n        self._plt_timer.setSingleShot(True)\n        self._plt_timer.setInterval(50) # Update every 50 ms (will be dynamically adjusted later)\n        # Defer timer start to ensure event loop is running\n        QTimer.singleShot(0, self._plt_timer.start)\n\n# &gt;&gt;&gt; Control frames setup &lt;&lt;&lt;\n        # Initialise the statusbar\n        self._statbar = qw.QStatusBar(self)\n        self._statbar.showMessage(\"Raman controller initialisation\")\n        self._main_layout.addWidget(self._statbar)\n\n# &gt;&gt;&gt; Measurement control widgets setup &lt;&lt;&lt;\n    # Plot widget setup\n        self._plotter = MeaRaman_Plotter()\n        self._fig, self._ax = self._plotter.get_fig_ax()\n        self._canvas = FigureCanvas(figure=self._fig)\n        widget.lyt_plot.addWidget(self._canvas)\n        self._init_worker_plotter()\n\n    # Basic plot control widgets\n        # Add widgets for additional plot options\n        self._bool_PlotRamanShift = widget.chk_ramanshift\n        self._bool_PlotRamanShift.setChecked(True)\n\n    # Additional plot control widgets\n        # Widgets for the plot limits\n        self._entry_xmin = widget.ent_plt_xmin\n        self._entry_xmax = widget.ent_plt_xmax\n        self._entry_ymin = widget.ent_plt_ymin\n        self._entry_ymax = widget.ent_plt_ymax\n        widget.btn_reset_plot_limits.clicked.connect(self._reset_plot_limits)\n\n        @Slot(MeaRaman)\n        def _put_lastmea_into_plotqueue(measurement: MeaRaman): self._q_plt_mea.put(measurement)\n\n        self._worker_acquisition.sig_mea.connect(_put_lastmea_into_plotqueue)\n        self._sig_request_lastmea.connect(self._worker_acquisition.request_last_measurement)\n\n        [widget.textChanged.connect(self._sig_request_lastmea.emit)\\\n            for widget in get_all_widgets(widget.groupBox_plt) if isinstance(widget,qw.QLineEdit)]\n\n    # Raman controller setups\n        self._btn_sngl_mea = widget.btn_snglmea\n        self._btn_cont_mea = widget.btn_contmea\n\n        self._btn_sngl_mea.clicked.connect(self._perform_single_measurement)\n        self._btn_cont_mea.clicked.connect(self.perform_continuous_measurement)\n\n    # Add buttons and labels for device parameter setups\n        ## Label to notify the users of the current device parameters\n        self._lbl_dev_stat_inttime = widget.lbl_inttime_ms\n        self._lbl_dev_stat_accum = widget.lbl_accum\n\n        ## Label to show the current setting, spinbox to let the user enter new parameters,\n        ## button to call the command and update the label\n        ### for single measurement integration time\n        self._spin_inttime = widget.spin_inttime_ms\n\n        self._spin_inttime.editingFinished.connect(self._request_integration_time_spinbox)\n\n        ### for single measurement number of accumulation\n        self._lbl_sngl_acq = widget.lbl_accum\n        self._spin_sngl_acq = widget.spin_accum\n\n        self._spin_sngl_acq.editingFinished.connect(self.set_accumulation_spinbox)\n\n        if main: self.initialise_spectrometer_n_analyser()\n\n    # &gt;&gt;&gt; Data management widgets setup &lt;&lt;&lt;\n        # Datasave widget\n        self._btn_saveto_datahub = widget.btn_savetomanager\n        if isinstance(self._dataHub,Wdg_DataHub_Mapping):\n            self._btn_saveto_datahub.clicked.connect(\n                lambda data=self._sngl_measurement: self._dataHub.append_RamanMeasurement_multi(data)) # type: ignore ; it is guaranteed to be Frm_DataHub_Mapping here\n        else: self._btn_saveto_datahub.setEnabled(False)\n\n        # Metadata parameters\n        self._laserpower_mW = DataAnalysisConfigEnum.LASER_POWER_MILLIWATT.value\n        self._laserwavelength_nm = DataAnalysisConfigEnum.LASER_WAVELENGTH_NM.value\n        self._objective_info = DataAnalysisConfigEnum.OBJECTIVE_INFO.value\n\n        # Metadata widgets\n        self._lbl_laserpower = widget.lbl_laserpower_mW\n        self._lbl_laserwavelength = widget.lbl_laserwavelength_nm\n        self._lbl_objectiveinfo = qw.QLabel('Objective info: {}'.format(self._objective_info))\n        qw.QErrorMessage().showMessage('Objective info save not implemented yet!')\n\n        # Entry widgets and button to set the metadata\n        self._entry_laserpower = widget.ent_laserpower_mW\n        self._entry_laserwavelength = widget.ent_laserwavelength_nm\n\n        # Default values\n        self._entry_laserpower.setText(str(DataAnalysisConfigEnum.LASER_POWER_MILLIWATT.value))\n        self._entry_laserwavelength.setText(str(DataAnalysisConfigEnum.LASER_WAVELENGTH_NM.value))\n\n        # Bind the value change to setting the laser metadata\n        self._entry_laserpower.editingFinished.connect(self._set_laserMetadata)\n        self._entry_laserwavelength.editingFinished.connect(self._set_laserMetadata)\n        self._set_laserMetadata()\n\n    # &gt;&gt;&gt; Connections setup &lt;&lt;&lt;\n        # Connect the append queue observer signal to the acquisition worker\n        self._sig_append_queue_observer.connect(self._worker_acquisition.append_queue_observer_measurement)\n        self._sig_remove_queue_observer.connect(self._worker_acquisition.remove_queue_observer_measurement)\n        self._sig_append_queue_observer.emit(self._q_plt_mea, threading.Event())\n\n        # Connect the acquisition done signal to reset the widgets and statusbar\n        self._worker_acquisition.sig_acq_done.connect(lambda: self._statbar.showMessage(\"Raman controller ready\"))\n        self._worker_acquisition.sig_acq_done.connect(lambda: self._statbar.setStyleSheet(\"\"))\n        self._worker_acquisition.sig_acq_done.connect(lambda: self.reset_enable_widgets())\n\n    # &gt;&gt;&gt; Finalise the setup &lt;&lt;&lt;\n        # Update the statusbar\n        self._statbar.showMessage(\"Raman controller ready\")\n\n    def _init_worker_plotter(self) -&gt; None:\n        \"\"\"\n        Initialises the Raman measurement plotter worker.\n        \"\"\"\n        self._thread_plotter = QThread(self)\n        self._worker_plotter = RamanMeasurement_Plotter(plotter=self._plotter)\n        self._worker_plotter.moveToThread(self._thread_plotter)\n        self.destroyed.connect(self._thread_plotter.quit)\n        self._thread_plotter.finished.connect(self._worker_plotter.deleteLater)\n        self._thread_plotter.finished.connect(self._thread_plotter.deleteLater)\n\n        @Slot()\n        def on_plot_ready(): self._canvas.draw_idle()\n        self._sig_update_plot.connect(self._worker_plotter.request_plot)\n        self._worker_plotter.sig_plot_ready.connect(on_plot_ready)\n\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread_plotter.start)\n\n    def get_syncer_acquisition(self) -&gt; Syncer_Raman:\n        \"\"\"\n        Returns the acquisition syncer\n\n        Returns:\n            Syncer_Raman: The acquisition syncer\n        \"\"\"\n        return self._syncer_acquisition\n\n    def get_mea_worker(self) -&gt; RamanMeasurement_Worker:\n        \"\"\"\n        Returns the Raman measurement worker\n\n        Returns:\n            RamanMeasurement_Worker: The Raman measurement worker\n        \"\"\"\n        return self._worker_acquisition\n\n    @Slot()\n    def _set_laserMetadata(self):\n        \"\"\"\n        Sets the laser metadata based on the entry widgets\n        \"\"\"\n        try:\n            print('Setting laser metadata...')\n            laserpower_mW = float(self._entry_laserpower.text())\n            laserwavelength_nm = float(self._entry_laserwavelength.text())\n            self._lbl_laserpower.setText(f'{laserpower_mW:.1f}')\n            self._lbl_laserwavelength.setText(f'{laserwavelength_nm:.1f}')\n\n            self._laserpower_mW = laserpower_mW\n            self._laserwavelength_nm = laserwavelength_nm\n            print(f'Laser metadata set: {laserpower_mW} mW, {laserwavelength_nm} nm')\n        except Exception as e:\n            qw.QErrorMessage(self).showMessage('Invalid laser metadata input')\n            self._statbar.showMessage('Invalid laser metadata input',5000)\n\n    def _generate_metadata_dict(self) -&gt; dict:\n        \"\"\"\n        Generates the metadata dictionary for the measurement based on the current settings\n\n        Returns:\n            dict: The metadata dictionary\n        \"\"\"\n        dict_metadata = {\n            'objective_info': self._objective_info,\n            'spectrometer_id': self._controller_id\n        }\n        return dict_metadata\n\n    def get_controller_identifier(self):\n        \"\"\"\n        Returns the identifier of the spectrometer controller\n\n        Returns:\n            str: The identifier of the spectrometer controller\n        \"\"\"\n        return self._controller_id\n\n    def get_single_measurement(self):\n        return self._sngl_measurement\n\n    @Slot(int)\n    def update_label_device_parameters(self,int_time_ms:int|None=None,accum:int|None=None):\n        \"\"\"\n        Updates the label showing the device integration time from the device itself\n        and accumulation from the input\n\n        Args:\n            int_time (int): new integration time to be displayed\n            accum (int): new accumulation to be displayed\n        \"\"\"\n        if int_time_ms is not None:\n            self._lbl_dev_stat_inttime.setText(f'{int_time_ms}')\n            self.integration_time_ms = int_time_ms\n        if accum is not None:\n            self._lbl_dev_stat_accum.setText(f'{accum}')\n            self._accumulation = accum\n\n    def set_accumulation(self,new_value):\n        \"\"\"\n        Set the accumulation for measurements\n\n        Args:\n            new_value (int): The new accumulation value\n        \"\"\"\n        self._accumulation = new_value\n        self._lbl_sngl_acq.setText(f'{self._accumulation}')\n\n    @Slot()\n    def set_accumulation_spinbox(self):\n        \"\"\"\n        Set the accumulation for measurements\n\n        Args:\n            new_value (int): The new accumulation value\n        \"\"\"\n        new_value = self._spin_sngl_acq.value()\n        self._accumulation = new_value\n        self._lbl_sngl_acq.setText(f'{self._accumulation}')\n\n    def get_integration_time_ms(self):\n        \"\"\"\n        Returns the integration time in milliseconds\n\n        Returns:\n            int: Integration time in milliseconds\n        \"\"\"\n        return self.integration_time_ms\n\n    @Slot()\n    def _request_integration_time_spinbox(self):\n        \"\"\"\n        Updates the device's integration time using the spinbox value\n        \"\"\"\n        self._spin_inttime.setEnabled(False)\n        new_value_ms = self._spin_inttime.value()\n        if not isinstance(new_value_ms,int) or new_value_ms &lt;= 0:\n            qw.QErrorMessage(self).showMessage('Invalid integration time input')\n            self._statbar.showMessage('Invalid integration time input',5000)\n            self._spin_inttime.setEnabled(True)\n            return\n\n        self.sig_set_integration_time_us.emit(new_value_ms*1000)\n\n\n    def _request_integration_time(self,new_value_ms):\n        \"\"\"\n        Sets the integration time of the spectrometer by taking in a variable. It also updates the variable\n\n        Args:\n            new_value_ms (int): New integration time [ms]\n            tkcontainer (tk.label): Tkinter label which text is to be updated\n        \"\"\"\n        self._spin_inttime.setEnabled(False)\n        if not isinstance(new_value_ms,int) or new_value_ms &lt;= 0:\n            qw.QErrorMessage(self).showMessage('Invalid integration time input')\n            self._statbar.showMessage('Invalid integration time input',5000)\n            self._spin_inttime.setEnabled(True)\n            return\n\n        self.sig_set_integration_time_us.emit(new_value_ms*1000)\n\n    def _init_request_integration_time_connection(self):\n        \"\"\"\n        Initializes the connection for requesting integration time updates\n        \"\"\"\n        self.sig_set_integration_time_us.connect(self._worker_controller.set_integration_time_us)\n        self._worker_controller.sig_integration_time_us.connect(lambda: self._spin_inttime.setEnabled(True))\n        self._worker_controller.sig_integration_time_us.connect(\n            lambda int_time:self.update_label_device_parameters(int_time_ms=int_time//1000))\n\n    def _init_btn_measurements_connection(self):\n        \"\"\"\n        Initializes the connection for the measurement buttons\n        \"\"\"\n        # Connection to the acquisition worker\n        self._sig_request_mea_sngl.connect(self._worker_acquisition.acquire_single_measurement)\n        self._sig_request_mea_cont.connect(self._worker_acquisition.acquire_continuous_measurement)\n        self.sig_request_mea_stop.connect(self._worker_acquisition.stop_acquisition)\n\n        self._sig_request_mea_sngl.connect(self.disable_widgets)\n        self._sig_request_mea_cont.connect(lambda: self.disable_widgets(exclude_cont=True))\n\n    def get_running_status(self):\n        \"\"\"\n        Returns the status of scanning operation.\n\n        Returns:\n            bool: True if any of the scanning operations are running\n        \"\"\"\n        return self._flg_isrunning.is_set()\n\n    def _get_plot_limits(self) -&gt; tuple[float|None,float|None,float|None,float|None]:\n        \"\"\"\n        Reads the plot limit entry widgets and return the user-determined plot limits\n        for the plot to be displayed.\n\n        Returns:\n            tuple[float,float,float,float]: (xmin,xmax,ymin,ymax)\n        \"\"\"\n        try: xmin = float(self._entry_xmin.text())\n        except: xmin = None\n        try: xmax = float(self._entry_xmax.text())\n        except: xmax = None\n        try: ymin = float(self._entry_ymin.text())\n        except: ymin = None\n        try: ymax = float(self._entry_ymax.text())\n        except: ymax = None\n\n        return xmin,xmax,ymin,ymax\n\n    @Slot()\n    def _reset_plot_limits(self):\n        \"\"\"\n        Resets the entry inputs for the plot limits\n        \"\"\"\n        self._entry_xmin.setText('')\n        self._entry_xmax.setText('')\n        self._entry_ymin.setText('')\n        self._entry_ymax.setText('')\n\n    @Slot()\n    def perform_continuous_measurement(self):\n        \"\"\"\n        Perform continuous measurement until stopped.\n        \"\"\"\n        # Disable the widgets to prevent command overlaps\n        self._statbar.showMessage(\"Continuous measurement in progress\")\n        self._statbar.setStyleSheet(\"background-color: yellow;\")\n\n        # Turn the continuous measurement button into a stop button\n        self._btn_cont_mea.clicked.disconnect()\n        self._btn_cont_mea.setText('STOP')\n        self._btn_cont_mea.setStyleSheet(\"background-color: red;\")\n        self._btn_cont_mea.clicked.connect(self.sig_request_mea_stop.emit)\n\n        # Sets the integration time and accumulation\n        self.update_label_device_parameters(accum=self._accumulation)\n\n        dict_params = self.generate_acquisition_params()\n\n        # Start the measurement\n        self._sig_request_mea_cont.emit(dict_params)\n\n    def generate_acquisition_params(self) -&gt; AcquisitionParams:\n        \"\"\"\n        Generates the acquisition parameters based on the current settings\n\n        Returns:\n            AcquisitionParams: The acquisition parameters\n        \"\"\"\n        # Sets the integration time and accumulation\n        int_time_ms = self._controller.set_integration_time_us(int(self.integration_time_ms*1000))//1000\n\n        # Initialise the measurement parameters\n        dict_metadata_extra = self._generate_metadata_dict()\n        dict_params:AcquisitionParams = {\n            'accumulation': self._accumulation,\n            'int_time_ms': int_time_ms,\n            'laserpower_mW': self._laserpower_mW,\n            'laserwavelength_nm': self._laserwavelength_nm,\n            'extra_metadata': dict_metadata_extra,\n        }\n        return dict_params\n\n    @Slot()\n    def _perform_single_measurement(self):\n        \"\"\"\n        Perform multiple measurements based on the self.measurement_accumulation, averages, and \n        updates the displayed figure all the time.\n        \"\"\"\n        # Notify the user that the measurement is starting\n        self._statbar.showMessage(\"Single measurement in progress\")\n        self._statbar.setStyleSheet(\"background-color: yellow;\")\n\n        # Sets the integration time and accumulation\n        self.update_label_device_parameters(accum=self._accumulation)\n\n        dict_params = self.generate_acquisition_params()\n\n        # Start the measurement\n        self._sig_request_mea_sngl.emit(dict_params)\n\n    def _append_remove_observer_queue_to_worker(self, queue_observer:queue.Queue):\n        \"\"\"\n        Appends a queue observer to the measurement worker and removes it when the acquisition is done.\n\n        Args:\n            queue_observer (queue.Queue): The queue observer to be added\n        \"\"\"\n        append_done = threading.Event()\n        self._sig_append_queue_observer.emit(queue_observer, append_done)\n        self._worker_acquisition.sig_acq_done.connect(lambda: self._sig_remove_queue_observer.emit(queue_observer))\n        append_done.wait()\n\n    def _auto_update_plot(self):\n        \"\"\"\n        Auto-update the plot with the latest measurement in the queue\n        \"\"\"\n        try:\n            measurement:MeaRaman|None = None\n            while not self._q_plt_mea.empty():\n                measurement = self._q_plt_mea.get_nowait()\n            if not isinstance(measurement,MeaRaman) and not measurement is None:\n                raise TypeError(\"Invalid measurement type in the plot queue\") # pyright: ignore[reportPossiblyUnboundVariable] ; it is guaranteed to be assigned if no exception is raised\n            self._update_plot(measurement, title='Raw Raman Spectrum')\n        except queue.Empty: pass\n        finally: self._plt_timer.start()\n\n    def _update_plot(self, measurement:MeaRaman|None, title='Single Raman Measurement',):\n        if measurement is None or not measurement.check_measurement_exist(): return\n\n        self._sig_update_plot.emit(measurement,title, self._bool_PlotRamanShift.isChecked(), self._get_plot_limits())\n\n        # try: print(f'Gap between plots: {(time.time()-self._t1)*1e3:.0f} ms')\n        # except: pass\n        # self._t1 = time.time()\n\n    def initialise_spectrometer_n_analyser(self):\n        \"\"\"\n        Sets up the raman spectrometer controller and analyser in a worker thread\n        \"\"\"\n        # Configure the integration time config\n        intTime_min, intTime_max, intTime_inc = self._controller.get_integration_time_limits_us()\n        self._spin_inttime.setRange(int(intTime_min/1000), int(intTime_max/1000))\n\n        # Set and get the current device integration time\n        self._request_integration_time(self.integration_time_ms)\n        self.integration_time_ms = int(self._controller.get_integration_time_us()/1000)\n\n        # Update the current device integration time being\n        self.update_label_device_parameters()\n\n        # Activates all spectrometer controls once done with the initialisation\n        self.reset_enable_widgets()\n\n    def disable_widgets(self, exclude_cont:bool=False):\n        \"\"\"\n        Disables all widgets in a Tkinter frame and sub-frames\n        \"\"\"\n        widget:qw.QWidget\n        for widget in get_all_widgets(self._main_widget.groupBox_params):\n            widget.setEnabled(False)\n\n        if exclude_cont: self._btn_cont_mea.setEnabled(True)\n\n    def reset_enable_widgets(self):\n        \"\"\"\n        Enable all widgets in a Tkinter frame and sub-frames\n        \"\"\"\n        widget:qw.QWidget\n        for widget in get_all_widgets(self._main_widget.groupBox_params):\n            widget.setEnabled(True)\n\n        # Resets the continuous measurement button\n        self._btn_cont_mea.clicked.disconnect()\n        self._btn_cont_mea.setText('Continuous measurement')\n        self._btn_cont_mea.setStyleSheet(\"\")\n        self._btn_cont_mea.clicked.connect(self.perform_continuous_measurement)\n        self._btn_cont_mea.setEnabled(True)\n\n    def terminate(self):\n        \"\"\"Terminates the controller and the processor\n        \"\"\"\n        self._plt_timer.stop()\n        self._controller.terminate()\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.__init__","title":"<code>__init__(parent, processor, controller, ramanHub, dataHub, main=False)</code>","text":"<p>Initialises the Raman spectrometer controller window</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Any</code> <p>The parent PyQt widget, window, etc.</p> required <code>processor</code> <code>Pool</code> <p>The multiprocessing pool for the data processing</p> required <code>controller</code> <code>raman_spectrometer_controller</code> <p>The Raman spectrometer controller</p> required <code>ramanHub</code> <code>RamanMeasurementHub</code> <p>The Raman measurement hub to retrieve measurements from</p> required <code>dataHub</code> <code>Frm_DataHub</code> <p>The data hub for the measurements</p> required <code>main</code> <code>bool</code> <p>If true, initialises the spectrometer and analyser. Defaults to False.</p> <code>False</code> Note <p>if not main, the initialisation of the spectrometer and analyser should be done manually when ready</p> Source code in <code>iris/gui/raman.py</code> <pre><code>    def __init__(\n        self,\n        parent:Any,\n        processor:mpp.Pool,\n        controller:Controller_Spectrometer,\n        ramanHub:DataStreamer_Raman,\n        dataHub:Wdg_DataHub_Mapping|None,\n        main:bool=False\n        ) -&gt; None:\n        \"\"\"\n        Initialises the Raman spectrometer controller window\n\n        Args:\n            parent (Any): The parent PyQt widget, window, etc.\n            processor (mpp.Pool): The multiprocessing pool for the data processing\n            controller (raman_spectrometer_controller): The Raman spectrometer controller\n            ramanHub (RamanMeasurementHub): The Raman measurement hub to retrieve measurements from\n            dataHub (Frm_DataHub): The data hub for the measurements\n            main (bool, optional): If true, initialises the spectrometer and analyser. Defaults to False.\n\n        Note:\n            if not main, the initialisation of the spectrometer and analyser should be done manually when ready\n        \"\"\"\n# &gt;&gt;&gt; Main initialisation &lt;&lt;&lt;\n        super().__init__(parent)\n        self._processor = processor\n        self._controller = controller   # Raman spectrometer controller\n        self._ramanHub = ramanHub       # Raman measurement hub\n        self._dataHub = dataHub         # Data hub for the measurements\n\n\n# &gt;&gt;&gt; Threading and worker setups &lt;&lt;&lt;\n    # &gt;&gt; Communciation with the controller &lt;&lt;\n        self._thread_controller = QThread(self)\n        self._worker_controller = Spectrometer_Control_Workers(controller=self._controller)\n        self._worker_controller.moveToThread(self._thread_controller)\n        self.destroyed.connect(self._thread_controller.quit)\n        self._thread_controller.finished.connect(self._worker_controller.deleteLater)\n        self._thread_controller.finished.connect(self._thread_controller.deleteLater)\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread_controller.start)\n\n    # &gt;&gt; Acquisition &lt;&lt;\n        self._syncer_acquisition = Syncer_Raman()\n        self._thread_acquisition = QThread(self)\n        self._worker_acquisition = RamanMeasurement_Worker(\n            ramanHub=self._ramanHub,\n            syncer_acquisition=self._syncer_acquisition\n        )\n        self._worker_acquisition.moveToThread(self._thread_acquisition)\n        self.destroyed.connect(self._thread_acquisition.quit)\n        self._thread_acquisition.finished.connect(self._worker_acquisition.deleteLater)\n        self._thread_acquisition.finished.connect(self._thread_acquisition.deleteLater)\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, self._thread_acquisition.start)\n\n    # &gt;&gt; Connection setups &lt;&lt;\n        self._init_request_integration_time_connection()\n        self._init_btn_measurements_connection()\n\n# &gt;&gt;&gt; Get controller parameters &lt;&lt;&lt;\n        self._controller_id = self._controller.get_identifier()\n\n# &gt;&gt;&gt; GUI setup &lt;&lt;&lt;\n        self._main_layout = qw.QVBoxLayout()\n        self.setLayout(self._main_layout)\n\n        self._main_widget = Wdg_Raman(self)\n        self._main_layout.addWidget(self._main_widget)\n        widget = self._main_widget\n\n# &gt;&gt;&gt; Spectrometer control and data handling setup &lt;&lt;&lt;\n        # Spectrometer parameters setup\n        self.integration_time_ms = AppRamanEnum.DEFAULT_INTEGRATION_TIME_MS.value \n        self._accumulation = AppRamanEnum.DEFAULT_SINGMEA_ACCUMULATION.value\n\n        # Is-running flags\n        self._flg_isrunning = threading.Event()\n\n        # Spectrometer internal data storage setup\n        self._sngl_measurement:MeaRaman = MeaRaman(reconstruct=True)    # single measurement\n        self._cont_measurement:MeaRaman = MeaRaman(reconstruct=True)    # continuous measurement\n\n        # Plotter setup\n        self._q_plt_mea = queue.Queue() # Queue for plotting measurements (will plot the latest measurement only)\n        self._plt_timer = QTimer()\n        self._plt_timer.timeout.connect(self._auto_update_plot)\n        self._plt_timer.setSingleShot(True)\n        self._plt_timer.setInterval(50) # Update every 50 ms (will be dynamically adjusted later)\n        # Defer timer start to ensure event loop is running\n        QTimer.singleShot(0, self._plt_timer.start)\n\n# &gt;&gt;&gt; Control frames setup &lt;&lt;&lt;\n        # Initialise the statusbar\n        self._statbar = qw.QStatusBar(self)\n        self._statbar.showMessage(\"Raman controller initialisation\")\n        self._main_layout.addWidget(self._statbar)\n\n# &gt;&gt;&gt; Measurement control widgets setup &lt;&lt;&lt;\n    # Plot widget setup\n        self._plotter = MeaRaman_Plotter()\n        self._fig, self._ax = self._plotter.get_fig_ax()\n        self._canvas = FigureCanvas(figure=self._fig)\n        widget.lyt_plot.addWidget(self._canvas)\n        self._init_worker_plotter()\n\n    # Basic plot control widgets\n        # Add widgets for additional plot options\n        self._bool_PlotRamanShift = widget.chk_ramanshift\n        self._bool_PlotRamanShift.setChecked(True)\n\n    # Additional plot control widgets\n        # Widgets for the plot limits\n        self._entry_xmin = widget.ent_plt_xmin\n        self._entry_xmax = widget.ent_plt_xmax\n        self._entry_ymin = widget.ent_plt_ymin\n        self._entry_ymax = widget.ent_plt_ymax\n        widget.btn_reset_plot_limits.clicked.connect(self._reset_plot_limits)\n\n        @Slot(MeaRaman)\n        def _put_lastmea_into_plotqueue(measurement: MeaRaman): self._q_plt_mea.put(measurement)\n\n        self._worker_acquisition.sig_mea.connect(_put_lastmea_into_plotqueue)\n        self._sig_request_lastmea.connect(self._worker_acquisition.request_last_measurement)\n\n        [widget.textChanged.connect(self._sig_request_lastmea.emit)\\\n            for widget in get_all_widgets(widget.groupBox_plt) if isinstance(widget,qw.QLineEdit)]\n\n    # Raman controller setups\n        self._btn_sngl_mea = widget.btn_snglmea\n        self._btn_cont_mea = widget.btn_contmea\n\n        self._btn_sngl_mea.clicked.connect(self._perform_single_measurement)\n        self._btn_cont_mea.clicked.connect(self.perform_continuous_measurement)\n\n    # Add buttons and labels for device parameter setups\n        ## Label to notify the users of the current device parameters\n        self._lbl_dev_stat_inttime = widget.lbl_inttime_ms\n        self._lbl_dev_stat_accum = widget.lbl_accum\n\n        ## Label to show the current setting, spinbox to let the user enter new parameters,\n        ## button to call the command and update the label\n        ### for single measurement integration time\n        self._spin_inttime = widget.spin_inttime_ms\n\n        self._spin_inttime.editingFinished.connect(self._request_integration_time_spinbox)\n\n        ### for single measurement number of accumulation\n        self._lbl_sngl_acq = widget.lbl_accum\n        self._spin_sngl_acq = widget.spin_accum\n\n        self._spin_sngl_acq.editingFinished.connect(self.set_accumulation_spinbox)\n\n        if main: self.initialise_spectrometer_n_analyser()\n\n    # &gt;&gt;&gt; Data management widgets setup &lt;&lt;&lt;\n        # Datasave widget\n        self._btn_saveto_datahub = widget.btn_savetomanager\n        if isinstance(self._dataHub,Wdg_DataHub_Mapping):\n            self._btn_saveto_datahub.clicked.connect(\n                lambda data=self._sngl_measurement: self._dataHub.append_RamanMeasurement_multi(data)) # type: ignore ; it is guaranteed to be Frm_DataHub_Mapping here\n        else: self._btn_saveto_datahub.setEnabled(False)\n\n        # Metadata parameters\n        self._laserpower_mW = DataAnalysisConfigEnum.LASER_POWER_MILLIWATT.value\n        self._laserwavelength_nm = DataAnalysisConfigEnum.LASER_WAVELENGTH_NM.value\n        self._objective_info = DataAnalysisConfigEnum.OBJECTIVE_INFO.value\n\n        # Metadata widgets\n        self._lbl_laserpower = widget.lbl_laserpower_mW\n        self._lbl_laserwavelength = widget.lbl_laserwavelength_nm\n        self._lbl_objectiveinfo = qw.QLabel('Objective info: {}'.format(self._objective_info))\n        qw.QErrorMessage().showMessage('Objective info save not implemented yet!')\n\n        # Entry widgets and button to set the metadata\n        self._entry_laserpower = widget.ent_laserpower_mW\n        self._entry_laserwavelength = widget.ent_laserwavelength_nm\n\n        # Default values\n        self._entry_laserpower.setText(str(DataAnalysisConfigEnum.LASER_POWER_MILLIWATT.value))\n        self._entry_laserwavelength.setText(str(DataAnalysisConfigEnum.LASER_WAVELENGTH_NM.value))\n\n        # Bind the value change to setting the laser metadata\n        self._entry_laserpower.editingFinished.connect(self._set_laserMetadata)\n        self._entry_laserwavelength.editingFinished.connect(self._set_laserMetadata)\n        self._set_laserMetadata()\n\n    # &gt;&gt;&gt; Connections setup &lt;&lt;&lt;\n        # Connect the append queue observer signal to the acquisition worker\n        self._sig_append_queue_observer.connect(self._worker_acquisition.append_queue_observer_measurement)\n        self._sig_remove_queue_observer.connect(self._worker_acquisition.remove_queue_observer_measurement)\n        self._sig_append_queue_observer.emit(self._q_plt_mea, threading.Event())\n\n        # Connect the acquisition done signal to reset the widgets and statusbar\n        self._worker_acquisition.sig_acq_done.connect(lambda: self._statbar.showMessage(\"Raman controller ready\"))\n        self._worker_acquisition.sig_acq_done.connect(lambda: self._statbar.setStyleSheet(\"\"))\n        self._worker_acquisition.sig_acq_done.connect(lambda: self.reset_enable_widgets())\n\n    # &gt;&gt;&gt; Finalise the setup &lt;&lt;&lt;\n        # Update the statusbar\n        self._statbar.showMessage(\"Raman controller ready\")\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.disable_widgets","title":"<code>disable_widgets(exclude_cont=False)</code>","text":"<p>Disables all widgets in a Tkinter frame and sub-frames</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def disable_widgets(self, exclude_cont:bool=False):\n    \"\"\"\n    Disables all widgets in a Tkinter frame and sub-frames\n    \"\"\"\n    widget:qw.QWidget\n    for widget in get_all_widgets(self._main_widget.groupBox_params):\n        widget.setEnabled(False)\n\n    if exclude_cont: self._btn_cont_mea.setEnabled(True)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.generate_acquisition_params","title":"<code>generate_acquisition_params()</code>","text":"<p>Generates the acquisition parameters based on the current settings</p> <p>Returns:</p> Name Type Description <code>AcquisitionParams</code> <code>AcquisitionParams</code> <p>The acquisition parameters</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def generate_acquisition_params(self) -&gt; AcquisitionParams:\n    \"\"\"\n    Generates the acquisition parameters based on the current settings\n\n    Returns:\n        AcquisitionParams: The acquisition parameters\n    \"\"\"\n    # Sets the integration time and accumulation\n    int_time_ms = self._controller.set_integration_time_us(int(self.integration_time_ms*1000))//1000\n\n    # Initialise the measurement parameters\n    dict_metadata_extra = self._generate_metadata_dict()\n    dict_params:AcquisitionParams = {\n        'accumulation': self._accumulation,\n        'int_time_ms': int_time_ms,\n        'laserpower_mW': self._laserpower_mW,\n        'laserwavelength_nm': self._laserwavelength_nm,\n        'extra_metadata': dict_metadata_extra,\n    }\n    return dict_params\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.get_controller_identifier","title":"<code>get_controller_identifier()</code>","text":"<p>Returns the identifier of the spectrometer controller</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The identifier of the spectrometer controller</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def get_controller_identifier(self):\n    \"\"\"\n    Returns the identifier of the spectrometer controller\n\n    Returns:\n        str: The identifier of the spectrometer controller\n    \"\"\"\n    return self._controller_id\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.get_integration_time_ms","title":"<code>get_integration_time_ms()</code>","text":"<p>Returns the integration time in milliseconds</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Integration time in milliseconds</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def get_integration_time_ms(self):\n    \"\"\"\n    Returns the integration time in milliseconds\n\n    Returns:\n        int: Integration time in milliseconds\n    \"\"\"\n    return self.integration_time_ms\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.get_mea_worker","title":"<code>get_mea_worker()</code>","text":"<p>Returns the Raman measurement worker</p> <p>Returns:</p> Name Type Description <code>RamanMeasurement_Worker</code> <code>RamanMeasurement_Worker</code> <p>The Raman measurement worker</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def get_mea_worker(self) -&gt; RamanMeasurement_Worker:\n    \"\"\"\n    Returns the Raman measurement worker\n\n    Returns:\n        RamanMeasurement_Worker: The Raman measurement worker\n    \"\"\"\n    return self._worker_acquisition\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.get_running_status","title":"<code>get_running_status()</code>","text":"<p>Returns the status of scanning operation.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if any of the scanning operations are running</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def get_running_status(self):\n    \"\"\"\n    Returns the status of scanning operation.\n\n    Returns:\n        bool: True if any of the scanning operations are running\n    \"\"\"\n    return self._flg_isrunning.is_set()\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.get_syncer_acquisition","title":"<code>get_syncer_acquisition()</code>","text":"<p>Returns the acquisition syncer</p> <p>Returns:</p> Name Type Description <code>Syncer_Raman</code> <code>Syncer_Raman</code> <p>The acquisition syncer</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def get_syncer_acquisition(self) -&gt; Syncer_Raman:\n    \"\"\"\n    Returns the acquisition syncer\n\n    Returns:\n        Syncer_Raman: The acquisition syncer\n    \"\"\"\n    return self._syncer_acquisition\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.initialise_spectrometer_n_analyser","title":"<code>initialise_spectrometer_n_analyser()</code>","text":"<p>Sets up the raman spectrometer controller and analyser in a worker thread</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def initialise_spectrometer_n_analyser(self):\n    \"\"\"\n    Sets up the raman spectrometer controller and analyser in a worker thread\n    \"\"\"\n    # Configure the integration time config\n    intTime_min, intTime_max, intTime_inc = self._controller.get_integration_time_limits_us()\n    self._spin_inttime.setRange(int(intTime_min/1000), int(intTime_max/1000))\n\n    # Set and get the current device integration time\n    self._request_integration_time(self.integration_time_ms)\n    self.integration_time_ms = int(self._controller.get_integration_time_us()/1000)\n\n    # Update the current device integration time being\n    self.update_label_device_parameters()\n\n    # Activates all spectrometer controls once done with the initialisation\n    self.reset_enable_widgets()\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.perform_continuous_measurement","title":"<code>perform_continuous_measurement()</code>","text":"<p>Perform continuous measurement until stopped.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot()\ndef perform_continuous_measurement(self):\n    \"\"\"\n    Perform continuous measurement until stopped.\n    \"\"\"\n    # Disable the widgets to prevent command overlaps\n    self._statbar.showMessage(\"Continuous measurement in progress\")\n    self._statbar.setStyleSheet(\"background-color: yellow;\")\n\n    # Turn the continuous measurement button into a stop button\n    self._btn_cont_mea.clicked.disconnect()\n    self._btn_cont_mea.setText('STOP')\n    self._btn_cont_mea.setStyleSheet(\"background-color: red;\")\n    self._btn_cont_mea.clicked.connect(self.sig_request_mea_stop.emit)\n\n    # Sets the integration time and accumulation\n    self.update_label_device_parameters(accum=self._accumulation)\n\n    dict_params = self.generate_acquisition_params()\n\n    # Start the measurement\n    self._sig_request_mea_cont.emit(dict_params)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.reset_enable_widgets","title":"<code>reset_enable_widgets()</code>","text":"<p>Enable all widgets in a Tkinter frame and sub-frames</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def reset_enable_widgets(self):\n    \"\"\"\n    Enable all widgets in a Tkinter frame and sub-frames\n    \"\"\"\n    widget:qw.QWidget\n    for widget in get_all_widgets(self._main_widget.groupBox_params):\n        widget.setEnabled(True)\n\n    # Resets the continuous measurement button\n    self._btn_cont_mea.clicked.disconnect()\n    self._btn_cont_mea.setText('Continuous measurement')\n    self._btn_cont_mea.setStyleSheet(\"\")\n    self._btn_cont_mea.clicked.connect(self.perform_continuous_measurement)\n    self._btn_cont_mea.setEnabled(True)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.set_accumulation","title":"<code>set_accumulation(new_value)</code>","text":"<p>Set the accumulation for measurements</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>int</code> <p>The new accumulation value</p> required Source code in <code>iris/gui/raman.py</code> <pre><code>def set_accumulation(self,new_value):\n    \"\"\"\n    Set the accumulation for measurements\n\n    Args:\n        new_value (int): The new accumulation value\n    \"\"\"\n    self._accumulation = new_value\n    self._lbl_sngl_acq.setText(f'{self._accumulation}')\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.set_accumulation_spinbox","title":"<code>set_accumulation_spinbox()</code>","text":"<p>Set the accumulation for measurements</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>int</code> <p>The new accumulation value</p> required Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot()\ndef set_accumulation_spinbox(self):\n    \"\"\"\n    Set the accumulation for measurements\n\n    Args:\n        new_value (int): The new accumulation value\n    \"\"\"\n    new_value = self._spin_sngl_acq.value()\n    self._accumulation = new_value\n    self._lbl_sngl_acq.setText(f'{self._accumulation}')\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.terminate","title":"<code>terminate()</code>","text":"<p>Terminates the controller and the processor</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def terminate(self):\n    \"\"\"Terminates the controller and the processor\n    \"\"\"\n    self._plt_timer.stop()\n    self._controller.terminate()\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.Wdg_SpectrometerController.update_label_device_parameters","title":"<code>update_label_device_parameters(int_time_ms=None, accum=None)</code>","text":"<p>Updates the label showing the device integration time from the device itself and accumulation from the input</p> <p>Parameters:</p> Name Type Description Default <code>int_time</code> <code>int</code> <p>new integration time to be displayed</p> required <code>accum</code> <code>int</code> <p>new accumulation to be displayed</p> <code>None</code> Source code in <code>iris/gui/raman.py</code> <pre><code>@Slot(int)\ndef update_label_device_parameters(self,int_time_ms:int|None=None,accum:int|None=None):\n    \"\"\"\n    Updates the label showing the device integration time from the device itself\n    and accumulation from the input\n\n    Args:\n        int_time (int): new integration time to be displayed\n        accum (int): new accumulation to be displayed\n    \"\"\"\n    if int_time_ms is not None:\n        self._lbl_dev_stat_inttime.setText(f'{int_time_ms}')\n        self.integration_time_ms = int_time_ms\n    if accum is not None:\n        self._lbl_dev_stat_accum.setText(f'{accum}')\n        self._accumulation = accum\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.create_dummy_image","title":"<code>create_dummy_image(counter)</code>","text":"<p>Creates a white 250x250 image with a counter text displayed in the center.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <p>The number to display on the image.</p> required <p>Returns:</p> Type Description <p>A NumPy array representing the white image with the counter text.</p> Source code in <code>iris/gui/raman.py</code> <pre><code>def create_dummy_image(counter):\n    \"\"\"\n    Creates a white 250x250 image with a counter text displayed in the center.\n\n    Args:\n        counter: The number to display on the image.\n\n    Returns:\n        A NumPy array representing the white image with the counter text.\n    \"\"\"\n    # Create a white image\n    image = np.ones((250, 250, 3), dtype=np.uint8) * 255\n\n    # Set font properties\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    font_scale = 1.0\n    font_thickness = 2\n    text_color = (0, 0, 0)  # Black text color\n\n    # Get text size\n    text_size, _ = cv2.getTextSize(str(counter), font, font_scale, font_thickness)\n\n    # Calculate text placement coordinates\n    text_x = int((image.shape[1] - text_size[0]) / 2)\n    text_y = int((image.shape[0] + text_size[1]) / 2)\n\n    # Add counter text to the image\n    cv2.putText(image, str(counter), (text_x, text_y), font, font_scale, text_color, font_thickness)\n\n    return image\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.generate_dummy_spectrometer_controller","title":"<code>generate_dummy_spectrometer_controller(parent, processor, dataHub=None)</code>","text":"<p>Generates a dummy spectrometer controller for testing purposes.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the controller.</p> required <code>processor</code> <code>Pool</code> <p>The multiprocessing pool for data processing.</p> required Source code in <code>iris/gui/raman.py</code> <pre><code>def generate_dummy_spectrometer_controller(parent:qw.QWidget, processor:mpp.Pool,\n    dataHub:Wdg_DataHub_Mapping|None=None) -&gt; Wdg_SpectrometerController:\n    \"\"\"\n    Generates a dummy spectrometer controller for testing purposes.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the controller.\n        processor (mpp.Pool): The multiprocessing pool for data processing.\n    \"\"\"\n    base_manager = get_my_manager()\n    initialise_manager_raman(base_manager)\n    base_manager.start()\n    RamanController_proxy, dict_MeaRaman_proxy = initialise_proxy_raman(base_manager)\n    RamanHub = DataStreamer_Raman(RamanController_proxy,dict_MeaRaman_proxy)\n    RamanHub.start()\n\n    wdg_Raman = Wdg_SpectrometerController(\n        parent=parent,\n        processor=processor,\n        controller=RamanController_proxy,\n        ramanHub=RamanHub,\n        dataHub=dataHub,\n    )\n    return wdg_Raman\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/raman/#iris.gui.raman.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/shortcut_handler/","title":"shortcut_handler","text":""},{"location":"reference/iris/gui/shortcut_handler/#iris.gui.shortcut_handler.ShortcutHandler","title":"<code>ShortcutHandler</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Handles keybindings for the application by installing itself as an application-wide event filter to capture key press and key release events.</p> Source code in <code>iris/gui/shortcut_handler.py</code> <pre><code>class ShortcutHandler(QObject):\n    \"\"\"\n    Handles keybindings for the application by installing itself as an\n    application-wide event filter to capture key press and key release events.\n    \"\"\"\n\n    # MAPPING for simple keys (used for press/release pairs)\n    _KEY_MAP:Dict[str,Qt.Key] = {\n        'a': Qt.Key_A, 'b': Qt.Key_B, 'c': Qt.Key_C, 'd': Qt.Key_D, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'e': Qt.Key_E, 'f': Qt.Key_F, 'g': Qt.Key_G, 'h': Qt.Key_H, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'i': Qt.Key_I, 'j': Qt.Key_J, 'k': Qt.Key_K, 'l': Qt.Key_L, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'm': Qt.Key_M, 'n': Qt.Key_N, 'o': Qt.Key_O, 'p': Qt.Key_P, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'q': Qt.Key_Q, 'r': Qt.Key_R, 's': Qt.Key_S, 't': Qt.Key_T, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'u': Qt.Key_U, 'v': Qt.Key_V, 'w': Qt.Key_W, 'x': Qt.Key_X, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'y': Qt.Key_Y, 'z': Qt.Key_Z,                               # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'up': Qt.Key_Up, 'down': Qt.Key_Down, 'left': Qt.Key_Left, 'right': Qt.Key_Right,   # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'space': Qt.Key_Space,  # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'f1': Qt.Key_F1, 'f2': Qt.Key_F2, 'f3': Qt.Key_F3, 'f4': Qt.Key_F4, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'f5': Qt.Key_F5, 'f6': Qt.Key_F6, 'f7': Qt.Key_F7, 'f8': Qt.Key_F8, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'f9': Qt.Key_F9, 'f10': Qt.Key_F10, 'f11': Qt.Key_F11, 'f12': Qt.Key_F12, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n    }\n\n    _KEY_MAP_MODIFIERS:Dict[str,Qt.Key] = {\n        'ctrl': Qt.ControlModifier, # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'shift': Qt.ShiftModifier,  # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n        'alt': Qt.AltModifier,      # pyright: ignore[reportAttributeAccessIssue] ; Qt.Key exists\n    }\n\n    def __init__(self, parent: QObject):\n        # 2. QObject accepts QObject as parent\n        super().__init__(parent)\n\n        # Store callbacks for key press/release pairs (for motion control)\n        self._press_callbacks: Dict[int, Callable] = {}\n        self._release_callbacks: Dict[int, Callable] = {}\n\n        # Store modifier+key dict for press/release pairs\n        self._press_callbacks_modifiers: Dict[tuple[int, int], Callable] = {}\n        self._release_callbacks_modifiers: Dict[tuple[int, int], Callable] = {}\n\n        # Store QShortcut instances (for key combos like Ctrl+A)\n        self._shortcuts: list[QShortcut] = []\n\n    # --- Methods for QShortcut Bindings (Key Combos, Press Only) ---\n\n    def set_keybinding_press(self, keybinding: str, callback: Callable):\n        \"\"\"\n        Sets a press-only keybinding (often a combo like Ctrl+S) using QShortcut.\n        These are handled by Qt's built-in mechanism.\n        \"\"\"\n        if not isinstance(keybinding, str) or keybinding == '': return\n\n        # QShortcut MUST be parented by a QWidget, so we use the parent of this handler\n        # (which we assume is a QWidget like QMainWindow).\n        if not isinstance(self.parent(), qw.QWidget):\n            print(\"Error: ShortcutHandler's parent must be a QWidget for QShortcut.\")\n            return\n\n        shortcut = QShortcut(QKeySequence(keybinding), self.parent())\n        shortcut.setContext(Qt.ApplicationShortcut) # pyright: ignore[reportAttributeAccessIssue] ; Qt.ApplicationShortcut exists\n        shortcut.activated.connect(callback)\n\n        self._shortcuts.append(shortcut)\n        # print(f\"[QShortcut] Set: {keybinding}\")\n\n    # --- Methods for Raw Event Bindings (Press/Release Pairs) ---\n\n    def set_keybinding_press_release(self, key: str, on_press: Callable, on_release: Callable):\n        \"\"\"\n        Registers a raw key-down/key-up pair (e.g., 'w') for delegation.\n        \"\"\"\n        key_parts = [part.strip() for part in key.lower().split('+')]\n        if len(key_parts) &gt; 1: self._register_keybinding_press_release_with_modifier(key_parts, on_press, on_release)\n        elif len(key_parts) == 1: self._register_keybinding_press_release_no_modifier(key, on_press, on_release)\n        else:\n            qw.QMessageBox.warning(None, \"Shortcut Error\",\n                    f\"Invalid keybinding string for press/release: '{key}'\\n\"\n                    \"Currently, only one modifier keys (e.g., 'ctrl+w') are supported for raw key press/release bindings.\\n\"\n                    \"or simple keys without modifiers (e.g., 'w', 'a', 'up').\"\n                )\n            return\n\n    def _register_keybinding_press_release_with_modifier(self, key_parts: list[str], on_press: Callable, on_release: Callable):\n        \"\"\"\n        Handles keybinding strings with modifiers (e.g., 'ctrl+w').\n\n        Args:\n            key_parts (list[str]): List of parts split by '+'.\n            on_press (Callable): Callback for key press\n            on_release (Callable): Callback for key release\n        \"\"\"\n        assert len(key_parts) == 2, \"Currently, only one modifier is supported for raw key press/release bindings.\"\n\n        if not any([key_part in self._KEY_MAP_MODIFIERS for key_part in key_parts]):\n            qw.QMessageBox.warning(None, \"Shortcut Error\",\n                    f\"Invalid modifier in keybinding string for press/release: '{'+'.join(key_parts)}'\\n\"\n                    \"Currently supported modifiers are: \" + ', '.join(self._KEY_MAP_MODIFIERS.keys())\n                )\n            return\n\n        if key_parts[0] in self._KEY_MAP_MODIFIERS:\n            key_modifier = key_parts[0]\n            key_main = key_parts[1]\n        else:\n            key_modifier = key_parts[1]\n            key_main = key_parts[0]\n\n        if key_main not in self._KEY_MAP:\n            qw.QMessageBox.warning(None, \"Shortcut Error\",\n                    f\"Invalid main key in keybinding string for press/release: '{key_main}'\\n\"\n                    \"Please use simple keys (e.g., 'w', 'a', 'up') for raw bindings.\"\n                )\n            return\n\n        key_qt = self._KEY_MAP[key_main]\n        modifier_flag = self._KEY_MAP_MODIFIERS[key_modifier]\n\n        # Store using the bitmask flag\n        self._press_callbacks_modifiers[(modifier_flag, key_qt)] = on_press\n        self._release_callbacks_modifiers[(modifier_flag, key_qt)] = on_release\n\n    def _register_keybinding_press_release_no_modifier(self, key, on_press, on_release):\n        \"\"\"\n        Registers a raw key-down/key-up pair (e.g., 'w') for delegation.\n\n        Args:\n            key (str): The key string (e.g., 'w', 'a', 'up').\n            on_press (Callable): Callback for key press\n            on_release (Callable): Callback for key release\n\n        Raises:\n            ValueError: If the key string is invalid.\n        \"\"\"\n        key_qt = self._KEY_MAP.get(key.lower(), None)\n        if key_qt is None:\n            # Using print/exception here as QMessageBox may not be suitable in initialization\n            raise ValueError(f'Invalid keybinding string for press/release: {key}')\n\n        self._press_callbacks[key_qt] = on_press\n        self._release_callbacks[key_qt] = on_release\n        # print(f\"[RawEvent] Set: {key.upper()} (Press/Release)\")\n\n    def eventFilter(self, watched: QObject, event: QEvent) -&gt; bool:\n        \"\"\"\n        Intercepts all application events. Handles raw key press/release events.\n        Only processes events from QWidget objects to avoid issues with layout items.\n        \"\"\"\n        try:\n            # Only process events from actual widgets, not layout items or other QObjects\n            if not isinstance(watched, qw.QWidget):\n                return False\n\n            # Check for KeyPress or KeyRelease events\n            event_type = event.type()\n            if event_type not in (QEvent.KeyPress, QEvent.KeyRelease): # pyright: ignore[reportAttributeAccessIssue] ; QEvent.Type exists\n                return False\n\n            key_event: QKeyEvent = event # pyright: ignore[reportAssignmentType] ; event is QEvent but we know it's QKeyEvent here\n            is_release = event_type == QEvent.KeyRelease # pyright: ignore[reportAttributeAccessIssue] ; QEvent.Type exists\n\n            # We only process the initial press and final release events.\n            if key_event.isAutoRepeat():\n                return False \n\n            key_code = key_event.key()\n            modifiers = key_event.modifiers()\n\n            if modifiers == Qt.NoModifier and key_code in self._press_callbacks: # pyright: ignore[reportAttributeAccessIssue] ; Qt.Modifier exists and is int\n                if not is_release:\n                    self._press_callbacks[key_code]()\n                else:\n                    self._release_callbacks.get(key_code, lambda: None)()\n                return True\n            elif (modifiers, key_code) in self._press_callbacks_modifiers:\n                if not is_release:\n                    self._press_callbacks_modifiers[(modifiers, key_code)]() # pyright: ignore[reportArgumentType] ; Qt.Modifier is int\n                else:\n                    self._release_callbacks_modifiers.get((modifiers, key_code), lambda: None)() # pyright: ignore[reportArgumentType, reportCallIssue] ; Qt.Modifier is int ; modifiers is int\n                return True\n\n            return False\n        except Exception:\n            # If any error occurs in event filtering, just pass the event through\n            # This prevents recursive errors or crashes\n            return False\n</code></pre>"},{"location":"reference/iris/gui/shortcut_handler/#iris.gui.shortcut_handler.ShortcutHandler.eventFilter","title":"<code>eventFilter(watched, event)</code>","text":"<p>Intercepts all application events. Handles raw key press/release events. Only processes events from QWidget objects to avoid issues with layout items.</p> Source code in <code>iris/gui/shortcut_handler.py</code> <pre><code>def eventFilter(self, watched: QObject, event: QEvent) -&gt; bool:\n    \"\"\"\n    Intercepts all application events. Handles raw key press/release events.\n    Only processes events from QWidget objects to avoid issues with layout items.\n    \"\"\"\n    try:\n        # Only process events from actual widgets, not layout items or other QObjects\n        if not isinstance(watched, qw.QWidget):\n            return False\n\n        # Check for KeyPress or KeyRelease events\n        event_type = event.type()\n        if event_type not in (QEvent.KeyPress, QEvent.KeyRelease): # pyright: ignore[reportAttributeAccessIssue] ; QEvent.Type exists\n            return False\n\n        key_event: QKeyEvent = event # pyright: ignore[reportAssignmentType] ; event is QEvent but we know it's QKeyEvent here\n        is_release = event_type == QEvent.KeyRelease # pyright: ignore[reportAttributeAccessIssue] ; QEvent.Type exists\n\n        # We only process the initial press and final release events.\n        if key_event.isAutoRepeat():\n            return False \n\n        key_code = key_event.key()\n        modifiers = key_event.modifiers()\n\n        if modifiers == Qt.NoModifier and key_code in self._press_callbacks: # pyright: ignore[reportAttributeAccessIssue] ; Qt.Modifier exists and is int\n            if not is_release:\n                self._press_callbacks[key_code]()\n            else:\n                self._release_callbacks.get(key_code, lambda: None)()\n            return True\n        elif (modifiers, key_code) in self._press_callbacks_modifiers:\n            if not is_release:\n                self._press_callbacks_modifiers[(modifiers, key_code)]() # pyright: ignore[reportArgumentType] ; Qt.Modifier is int\n            else:\n                self._release_callbacks_modifiers.get((modifiers, key_code), lambda: None)() # pyright: ignore[reportArgumentType, reportCallIssue] ; Qt.Modifier is int ; modifiers is int\n            return True\n\n        return False\n    except Exception:\n        # If any error occurs in event filtering, just pass the event through\n        # This prevents recursive errors or crashes\n        return False\n</code></pre>"},{"location":"reference/iris/gui/shortcut_handler/#iris.gui.shortcut_handler.ShortcutHandler.set_keybinding_press","title":"<code>set_keybinding_press(keybinding, callback)</code>","text":"<p>Sets a press-only keybinding (often a combo like Ctrl+S) using QShortcut. These are handled by Qt's built-in mechanism.</p> Source code in <code>iris/gui/shortcut_handler.py</code> <pre><code>def set_keybinding_press(self, keybinding: str, callback: Callable):\n    \"\"\"\n    Sets a press-only keybinding (often a combo like Ctrl+S) using QShortcut.\n    These are handled by Qt's built-in mechanism.\n    \"\"\"\n    if not isinstance(keybinding, str) or keybinding == '': return\n\n    # QShortcut MUST be parented by a QWidget, so we use the parent of this handler\n    # (which we assume is a QWidget like QMainWindow).\n    if not isinstance(self.parent(), qw.QWidget):\n        print(\"Error: ShortcutHandler's parent must be a QWidget for QShortcut.\")\n        return\n\n    shortcut = QShortcut(QKeySequence(keybinding), self.parent())\n    shortcut.setContext(Qt.ApplicationShortcut) # pyright: ignore[reportAttributeAccessIssue] ; Qt.ApplicationShortcut exists\n    shortcut.activated.connect(callback)\n\n    self._shortcuts.append(shortcut)\n</code></pre>"},{"location":"reference/iris/gui/shortcut_handler/#iris.gui.shortcut_handler.ShortcutHandler.set_keybinding_press_release","title":"<code>set_keybinding_press_release(key, on_press, on_release)</code>","text":"<p>Registers a raw key-down/key-up pair (e.g., 'w') for delegation.</p> Source code in <code>iris/gui/shortcut_handler.py</code> <pre><code>def set_keybinding_press_release(self, key: str, on_press: Callable, on_release: Callable):\n    \"\"\"\n    Registers a raw key-down/key-up pair (e.g., 'w') for delegation.\n    \"\"\"\n    key_parts = [part.strip() for part in key.lower().split('+')]\n    if len(key_parts) &gt; 1: self._register_keybinding_press_release_with_modifier(key_parts, on_press, on_release)\n    elif len(key_parts) == 1: self._register_keybinding_press_release_no_modifier(key, on_press, on_release)\n    else:\n        qw.QMessageBox.warning(None, \"Shortcut Error\",\n                f\"Invalid keybinding string for press/release: '{key}'\\n\"\n                \"Currently, only one modifier keys (e.g., 'ctrl+w') are supported for raw key press/release bindings.\\n\"\n                \"or simple keys without modifiers (e.g., 'w', 'a', 'up').\"\n            )\n        return\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/","title":"timestamp_coorshift","text":"<p>A class that handles the coordinate shift of the measurements stored in a mapping measurement unit, calculated using the timestamps already stored in the measurement unit and the user-provided timestamp shift.</p>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.sFrm_xyCoorTimestampShift","title":"<code>sFrm_xyCoorTimestampShift</code>","text":"<p>               Bases: <code>Frame</code></p> Source code in <code>iris/gui/timestamp_coorshift.py</code> <pre><code>class sFrm_xyCoorTimestampShift(tk.Frame):\n    def __init__(self, parent: tk.Frame, dataHub:Wdg_DataHub_Mapping, callback:Callable|None=None):\n        super().__init__(parent)\n        self._dataHub = dataHub\n        self._callback = callback\n\n        # &gt; Top level frames &lt;\n        self._frm_heatmap_plotter = Wdg_MappingMeasurement_Plotter(\n            parent=self,\n            mappingHub=self._dataHub.get_MappingHub(),\n            figsize_pxl=AppPlotEnum.PLT_MAP_SIZE_PIXEL.value\n        )\n        self._frm_controls = tk.Frame(self)\n\n        self._frm_heatmap_plotter.grid(row=0, column=0, sticky='nsew')\n        self._frm_controls.grid(row=1, column=0, sticky='nsew')\n\n        self.grid_rowconfigure(0, weight=1)\n        self.grid_rowconfigure(1, weight=0)\n        self.grid_columnconfigure(0, weight=1)\n\n        # &gt; Controls frame &lt;\n        self._combo_sourceUnitName = ttk.Combobox(self._frm_controls, state='readonly')\n\n        self._lbl_tsShift_ms = tk.Label(self._frm_controls, text='Timestamp shift [ms]:')\n        self._ent_tsShift_ms = tk.Entry(self._frm_controls)\n        self._ent_tsShift_ms.insert(0, '0')\n        self._btn_setShift_ms = tk.Button(self._frm_controls, text='Set shift', command=self._apply_timestamp_shift)\n\n        self._combo_sourceUnitName.grid(row=0, column=0, columnspan=3, sticky='w')\n\n        self._lbl_tsShift_ms.grid(row=1, column=0, sticky='e')\n        self._ent_tsShift_ms.grid(row=1, column=1, sticky='w')\n        self._btn_setShift_ms.grid(row=1, column=2, sticky='w')\n\n        self._frm_controls.grid_columnconfigure(0, weight=0)\n        self._frm_controls.grid_columnconfigure(1, weight=1)\n        self._frm_controls.grid_columnconfigure(2, weight=0)\n        self._frm_controls.grid_rowconfigure(0, weight=0)\n        self._frm_controls.grid_rowconfigure(1, weight=0)\n\n        self._ent_tsShift_ms.bind('&lt;Return&gt;', lambda event: self._apply_timestamp_shift())\n\n        # &gt; Variables &lt;\n        self._dict_nameToID = None\n\n        # &gt; Threads &lt;\n        self._thread_update = threading.Thread(target=self._auto_update)\n        self._thread_update.start()\n\n    def _auto_update(self):\n        while True:\n            self._dict_nameToID = self._dataHub.get_MappingHub().get_dict_nameToID()\n            list_unitNames = list(self._dict_nameToID.keys())\n            self._combo_sourceUnitName.configure(values=list_unitNames)\n\n            time.sleep(0.5)\n\n    @thread_assign\n    def _apply_timestamp_shift(self):\n        \"\"\"\n        Apply the timestamp shift to the unit. Based on the user input, the timestamp shift is applied to the unit.\n        \"\"\"\n        try:\n            # Disable the button to prevent multiple clicks\n            self._btn_setShift_ms.configure(state='disabled')\n            self._ent_tsShift_ms.configure(state='disabled')\n\n            # Get the unit and its info\n            hub = self._dataHub.get_MappingHub()\n            unit_name = self._combo_sourceUnitName.get()\n            unit_id = self._dict_nameToID[unit_name]\n\n            # Apply the shift\n            shifted_unitname = hub.shift_xycoordinate_timestamp(\n                unit_id=unit_id,\n                timeshift_us=int(float(self._ent_tsShift_ms.get())*1e3)\n            )\n\n            # Update the plotter\n            self._frm_heatmap_plotter.replot_heatmap()\n\n            self._frm_heatmap_plotter.set_combobox_name(mappingUnit_name=shifted_unitname)\n\n            if self._callback is not None:\n                self._callback()\n\n        except Exception as e:\n            messagebox.showerror('Error', f\"Error: {e}\")\n            return\n\n        finally:\n            self._btn_setShift_ms.configure(state='normal')\n            self._ent_tsShift_ms.configure(state='normal')\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/timestamp_coorshift/#iris.gui.timestamp_coorshift.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/","title":"Canvas_ROIdefinition","text":""},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations","title":"<code>Canvas_Image_Annotations</code>","text":"<p>               Bases: <code>QGraphicsView</code></p> <p>A canvas to show a picture and record click button events</p> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>class Canvas_Image_Annotations(QGraphicsView):\n    \"\"\"\n    A canvas to show a picture and record click button events\n    \"\"\"\n    sig_leftclick = Signal(tuple)   # x,y coordinates in original image coordinate system\n    sig_rightclick = Signal(tuple)  # Signal emitted on right click (to clear annotations)\n\n    def __init__(self, parent:qw.QWidget, size_pixel=AppPlotEnum.IMGCAL_IMG_SIZE.value):\n        self.size_pixel:tuple[int,int] = size_pixel   # Size of the canvas (width,height)\n        super().__init__(parent)\n\n        # # --- Parameters for the View/Scene ---\n        self.setRenderHint(QPainter.Antialiasing) # pyright: ignore[reportAttributeAccessIssue] ; setRenderHint exists\n        self._scene = QGraphicsScene(self)\n        self.setScene(self._scene)\n\n        # Set the fixed size policy to mimic Tkinter's fixed size canvas initially\n        self.setFixedSize(QSize(size_pixel[0], size_pixel[1]))\n        self.size_pixel = size_pixel\n\n        # Parameters for the canvas\n        self._main = parent\n        self._img_ori = None\n        self._image_item = None\n        self._img_size = None\n        self._img_scale = 1.0\n\n        # Parameters for operation\n        self._flg_recordClicks = threading.Event()  # Event to record the clicks. Set to start recording click coordinates. Clear to stop.\n        self._flg_recordClicks.clear()\n        self._list_clickCoords = []  # List to store the click coordinates\n        self._annotations = []  # List to store the annotations\n\n        # Initialise the canvas with a white background\n        self._scene.setBackgroundBrush(QColor('white'))\n\n        # Store observers for image updates\n        self._list_observers_leftclick = []\n        self._list_observers_rightclick = []\n\n    def add_observer_rightclick(self,observer:Callable):\n        \"\"\"\n        Adds an observer to be notified when the annotations are cleared\n\n        Args:\n            observer (QObject): The observer to be added\n        \"\"\"\n        assert callable(observer), 'Observer must be a callable'\n        self._list_observers_rightclick.append(observer)\n\n    def remove_observer_rightclick(self,observer:Callable):\n        \"\"\"\n        Removes an observer from the list of observers\n\n        Args:\n            observer (QObject): The observer to be removed\n        \"\"\"\n        assert callable(observer), 'Observer must be a callable'\n        try: self._list_observers_rightclick.remove(observer)\n        except Exception as e: print(f'Error removing observer: {e}')\n\n    def notify_observers_rightclick(self):\n        \"\"\"\n        Notifies all observers that the annotations have been cleared\n        \"\"\"\n        for observer in self._list_observers_rightclick:\n            try: observer()\n            except Exception as e: print(f'Error notifying observer: {e}')\n\n    def mousePressEvent(self, event: QMouseEvent) -&gt; None:\n        scene_pos = self.mapToScene(event.position().toPoint())\n        if event.button() == Qt.LeftButton: # pyright: ignore[reportAttributeAccessIssue] ; Qt.LeftButton exists\n            self._record_clickCoordinates(scene_pos.x(), scene_pos.y())\n            self.sig_leftclick.emit((scene_pos.x()*self._img_scale, scene_pos.y()*self._img_scale))\n        elif event.button() == Qt.RightButton: # pyright: ignore[reportAttributeAccessIssue] ; Qt.RightButton exists\n            self.clear_all_annotations()\n            self.notify_observers_rightclick()\n            self.sig_rightclick.emit((scene_pos.x()*self._img_scale, scene_pos.y()*self._img_scale))\n        # print(f'Canvas mousePressEvent at ({event.position().x()}, {event.position().y()}), type: {event.button()}')\n        super().mousePressEvent(event)\n        # print(f'List of click coordinates: {self._list_clickCoords}')\n\n    @Slot()\n    def clear_all_annotations(self):\n        \"\"\"\n        Clears the coordinate annotations on the canvas and \n        the list of click coordinates\n        \"\"\"\n        for item in self._annotations:\n            self._scene.removeItem(item)\n        self._annotations.clear()\n        self._list_clickCoords.clear()\n\n        self.viewport().update()\n\n    @Slot(list,bool,bool)\n    def annotate_canvas_multi(self,coor_list:list[tuple[float,float]],scale:bool=True,\n                              flg_removePreviousAnnotations:bool=True):\n        \"\"\"\n        Annotates the image with the given coordinate list with a crosshair and a text label\n\n        Args:\n            coor_list (list[tuple[float,float]]): List of coordinates to be annotated\n            scale (bool): Scale the coordinates according to the scale factor of the\n            image being displayed. Default is True\n        \"\"\"\n        assert isinstance(coor_list, list), 'Coordinates must be a list'\n        assert all([isinstance(coor, (tuple,list)) and len(coor) == 2 for coor in coor_list]),\\\n            'Coordinates must be a list of tuples of (x,y)'\n        assert all([all([isinstance(coor[i], (float,int)) for i in range(2)]) for coor in coor_list]),\\\n            'Coordinates must be a list of tuples of (floats or integers)'\n\n        show = True\n        prev_annotations = []\n        if flg_removePreviousAnnotations:\n            prev_annotations = self._annotations.copy()\n            self._annotations.clear()\n            show = False\n\n        for coor in coor_list:\n            self.annotate_canvas(coor,scale=scale,show=show)\n\n        if flg_removePreviousAnnotations:\n            self.show_annotations()\n            for item in prev_annotations:\n                self._scene.removeItem(item)\n\n    def show_annotations(self):\n        \"\"\"\n        Shows the annotations on the canvas\n        \"\"\"\n        for item in self._annotations:\n            item.setVisible(True)\n\n    def annotate_canvas(self,coor:tuple[float,float],scale:bool=True,show=True):\n        \"\"\"\n        Annotates the image with the given coordinate with a crosshair and a text label\n\n        Args:\n            coor (tuple[float,float]): Coordinates to be annotated\n            scale (bool): Scale the coordinates according to the scale factor of the\n            image being displayed. Default is True\n\n        Note:\n            Coordinates outside the canvas are ignored (will not be annotated)\n        \"\"\"\n        assert isinstance(coor, (tuple,list)) and len(coor) == 2, 'Coordinates must be a tuple of (x,y)'\n        assert all([isinstance(coor[i], (float,int)) for i in range(len(coor))]),\\\n            'Coordinates must be a tuple of (floats or integers)'\n\n        if scale: scale_val = self._img_scale\n        else: scale_val = 1.0\n\n        x_ori, y_ori = coor\n        x_scene = int(x_ori/scale_val)\n        y_scene = int(y_ori/scale_val)\n\n        # Ignore the coordinates outside the canvas\n        if not self._scene.sceneRect().contains(QPointF(x_scene,y_scene)):\n            return\n\n        # Create a crosshair at the coordinates\n        size = 2\n        pen = QPen(QColor('red'), 2)\n        if show: state = 'normal'\n        else: state = 'hidden'\n        line1 = self._scene.addLine(x_scene - size, y_scene - size, x_scene + size, y_scene + size, pen)\n        line2 = self._scene.addLine(x_scene - size, y_scene + size, x_scene + size, y_scene - size, pen)\n        line1.setVisible(show)\n        line2.setVisible(show)\n        self._annotations.extend([line1,line2])\n\n        # Create a text label at the coordinates\n        text_index = len(self._annotations) // 3 + 1\n        text_item = self._scene.addSimpleText(str(text_index))\n        text_item.setPos(x_scene + size, y_scene + size) # Offset text from crosshair\n        text_item.setFont(QFont(\"Arial\", 12))\n        text_item.setBrush(QColor('red'))\n        text_item.setVisible(show)\n        self._annotations.append(text_item)\n        self.viewport().update()\n\n    @Slot(tuple,tuple,bool)\n    def draw_rectangle_canvas(self,coor1:tuple[float,float],coor2:tuple[float,float],scale:bool=True):\n        \"\"\"\n        Draws a rectangle on the canvas with the given coordinates\n\n        Args:\n            coor1 (tuple[float,float]): Coordinates of the top-left corner of the rectangle\n            coor2 (tuple[float,float]): Coordinates of the bottom-right corner of the rectangle\n            scale (bool): Scale the coordinates according to the scale factor of the\n            image being displayed. Default is True\n        \"\"\"\n        assert isinstance(coor1, (tuple,list)) and len(coor1) == 2, 'Coordinates must be a tuple of (x,y)'\n        assert all([isinstance(coor1[i], (float,int)) for i in range(2)]), 'Coordinates must be a tuple of (floats or integers)'\n        assert isinstance(coor2, (tuple,list)) and len(coor2) == 2, 'Coordinates must be a tuple of (x,y)'\n        assert all([isinstance(coor2[i], (float,int)) for i in range(2)]), 'Coordinates must be a tuple of (floats or integers)'\n\n        if scale: scale_val = self._img_scale\n        else: scale_val = 1.0\n\n        x1, y1 = coor1\n        x2, y2 = coor2\n        x1 = (x1/scale_val)\n        y1 = (y1/scale_val)\n        x2 = (x2/scale_val)\n        y2 = (y2/scale_val)\n\n        # Ignore the coordinates outside the canvas\n        x1 = max(0,x1)\n        y1 = max(0,y1)\n        x2 = min(self.size_pixel[0],x2)\n        y2 = min(self.size_pixel[1],y2)\n\n        # print(f'Drawing rectangle at ({x1}, {y1}) to ({x2}, {y2}) on canvas')\n\n        # Create a rectangle on the canvas\n        # set transparency level to 50%\n        alpha = 0.35\n        rectangle = self._scene.addRect(x1, y1, x2 - x1, y2 - y1, QPen(QColor('red')), QColor(255,0,0,int(255*alpha)))\n        rectangle.setVisible(True)\n        self._annotations.append(rectangle)\n        self.viewport().update()\n\n    @Slot(bool)\n    def stop_recordClicks(self,clear_annotations:bool=True) -&gt; None:\n        \"\"\"\n        Stops the recording:\n        1. Stops recording the click coordinates\n        2. Clears the list of click coordinates\n        3. Clears the annotations on the canvas\n\n        Args:\n            clear_annotations (bool): Clear the annotations on the canvas. Default is True\n        \"\"\"\n        self._flg_recordClicks.clear()\n        self._list_clickCoords.clear()\n        if clear_annotations: self.clear_all_annotations()\n        return\n\n    @Slot(bool)\n    def start_recordClicks(self,reset:bool=True) -&gt; list[tuple[float,float]]:\n        \"\"\"\n        Starts recording the click coordinates\n\n        Args:\n            reset (bool): Reset the list of click coordinates. Default is True\n\n        Returns:\n            list[tuples[float,float]]: List of click coordinates (x,y)\n\n        Note:\n            !!! Returns the coordinates in the original image coordinate system !!!\n        \"\"\"\n        if reset: self._list_clickCoords.clear()\n        self._flg_recordClicks.set()\n        return self._list_clickCoords\n\n    def get_clickCoordinates(self) -&gt; list[tuple[float,float]]:\n        \"\"\"\n        Returns the list of click coordinates\n\n        Note:\n            !!! Returns the coordinates in the original image coordinate system !!!\n        \"\"\"\n        return self._list_clickCoords\n\n    def _record_clickCoordinates(self, x_scene:float, y_scene:float) -&gt; None:\n        \"\"\"\n        Records the coordinates of the click event.\n\n        Args:\n            x_scene (float): x-coordinate of the click event\n            y_scene (float): y-coordinate of the click event\n\n        Note:\n            !!! Recores the coordinates in the original image coordinate system !!!\n        \"\"\"\n        # print(f'Clicked at ({x}, {y})')\n        if self._flg_recordClicks.is_set():\n            x_ori = x_scene * self._img_scale\n            y_ori = y_scene * self._img_scale\n            self._list_clickCoords.append((x_ori, y_ori))\n            self.annotate_canvas((x_ori,y_ori),scale=True)\n\n    @Slot(Image.Image)\n    def set_image(self,img:Image.Image):\n        \"\"\"\n        Sets the image to be displayed on the canvas\n        \"\"\"\n        assert isinstance(img, Image.Image), 'Image must be a PIL Image object'\n\n        img_scale = max(img.size[0]/self.size_pixel[0],img.size[1]/self.size_pixel[1])\n        img_resized = img.resize((int(img.size[0]/img_scale),int(img.size[1]/img_scale)),Image.LANCZOS) # pyright: ignore[reportAttributeAccessIssue] ; LANCOZOS is supported\n\n        qimg_resized = ImageQt.ImageQt(img_resized)\n        pixmap = QPixmap.fromImage(qimg_resized)\n\n        if qimg_resized != self._image_item:\n            # Double buffer: Create a new image item on the canvas, but don't display it yet\n            canvas_newImage = QGraphicsPixmapItem(pixmap)\n            canvas_newImage.setZValue(-1)  # Set the image item to be at the back\n            canvas_newImage.setVisible(False)  # Hide the new image item initially\n            self._scene.addItem(canvas_newImage)\n            # Now that the new image item is created, we can remove the old one\n            if self._image_item is not None:\n                self._scene.removeItem(self._image_item)\n            # Finally, display the new image item\n            canvas_newImage.setVisible(True)\n\n            # Update the annotations to be on top of the image\n            [annotation.setZValue(0) for annotation in self._annotations]\n\n            self._img_ori = img\n            self._image_item = canvas_newImage\n            self._img_size = img.size\n            self._img_scale = img_scale\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.add_observer_rightclick","title":"<code>add_observer_rightclick(observer)</code>","text":"<p>Adds an observer to be notified when the annotations are cleared</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>QObject</code> <p>The observer to be added</p> required Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>def add_observer_rightclick(self,observer:Callable):\n    \"\"\"\n    Adds an observer to be notified when the annotations are cleared\n\n    Args:\n        observer (QObject): The observer to be added\n    \"\"\"\n    assert callable(observer), 'Observer must be a callable'\n    self._list_observers_rightclick.append(observer)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.annotate_canvas","title":"<code>annotate_canvas(coor, scale=True, show=True)</code>","text":"<p>Annotates the image with the given coordinate with a crosshair and a text label</p> <p>Parameters:</p> Name Type Description Default <code>coor</code> <code>tuple[float, float]</code> <p>Coordinates to be annotated</p> required <code>scale</code> <code>bool</code> <p>Scale the coordinates according to the scale factor of the</p> <code>True</code> Note <p>Coordinates outside the canvas are ignored (will not be annotated)</p> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>def annotate_canvas(self,coor:tuple[float,float],scale:bool=True,show=True):\n    \"\"\"\n    Annotates the image with the given coordinate with a crosshair and a text label\n\n    Args:\n        coor (tuple[float,float]): Coordinates to be annotated\n        scale (bool): Scale the coordinates according to the scale factor of the\n        image being displayed. Default is True\n\n    Note:\n        Coordinates outside the canvas are ignored (will not be annotated)\n    \"\"\"\n    assert isinstance(coor, (tuple,list)) and len(coor) == 2, 'Coordinates must be a tuple of (x,y)'\n    assert all([isinstance(coor[i], (float,int)) for i in range(len(coor))]),\\\n        'Coordinates must be a tuple of (floats or integers)'\n\n    if scale: scale_val = self._img_scale\n    else: scale_val = 1.0\n\n    x_ori, y_ori = coor\n    x_scene = int(x_ori/scale_val)\n    y_scene = int(y_ori/scale_val)\n\n    # Ignore the coordinates outside the canvas\n    if not self._scene.sceneRect().contains(QPointF(x_scene,y_scene)):\n        return\n\n    # Create a crosshair at the coordinates\n    size = 2\n    pen = QPen(QColor('red'), 2)\n    if show: state = 'normal'\n    else: state = 'hidden'\n    line1 = self._scene.addLine(x_scene - size, y_scene - size, x_scene + size, y_scene + size, pen)\n    line2 = self._scene.addLine(x_scene - size, y_scene + size, x_scene + size, y_scene - size, pen)\n    line1.setVisible(show)\n    line2.setVisible(show)\n    self._annotations.extend([line1,line2])\n\n    # Create a text label at the coordinates\n    text_index = len(self._annotations) // 3 + 1\n    text_item = self._scene.addSimpleText(str(text_index))\n    text_item.setPos(x_scene + size, y_scene + size) # Offset text from crosshair\n    text_item.setFont(QFont(\"Arial\", 12))\n    text_item.setBrush(QColor('red'))\n    text_item.setVisible(show)\n    self._annotations.append(text_item)\n    self.viewport().update()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.annotate_canvas_multi","title":"<code>annotate_canvas_multi(coor_list, scale=True, flg_removePreviousAnnotations=True)</code>","text":"<p>Annotates the image with the given coordinate list with a crosshair and a text label</p> <p>Parameters:</p> Name Type Description Default <code>coor_list</code> <code>list[tuple[float, float]]</code> <p>List of coordinates to be annotated</p> required <code>scale</code> <code>bool</code> <p>Scale the coordinates according to the scale factor of the</p> <code>True</code> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>@Slot(list,bool,bool)\ndef annotate_canvas_multi(self,coor_list:list[tuple[float,float]],scale:bool=True,\n                          flg_removePreviousAnnotations:bool=True):\n    \"\"\"\n    Annotates the image with the given coordinate list with a crosshair and a text label\n\n    Args:\n        coor_list (list[tuple[float,float]]): List of coordinates to be annotated\n        scale (bool): Scale the coordinates according to the scale factor of the\n        image being displayed. Default is True\n    \"\"\"\n    assert isinstance(coor_list, list), 'Coordinates must be a list'\n    assert all([isinstance(coor, (tuple,list)) and len(coor) == 2 for coor in coor_list]),\\\n        'Coordinates must be a list of tuples of (x,y)'\n    assert all([all([isinstance(coor[i], (float,int)) for i in range(2)]) for coor in coor_list]),\\\n        'Coordinates must be a list of tuples of (floats or integers)'\n\n    show = True\n    prev_annotations = []\n    if flg_removePreviousAnnotations:\n        prev_annotations = self._annotations.copy()\n        self._annotations.clear()\n        show = False\n\n    for coor in coor_list:\n        self.annotate_canvas(coor,scale=scale,show=show)\n\n    if flg_removePreviousAnnotations:\n        self.show_annotations()\n        for item in prev_annotations:\n            self._scene.removeItem(item)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.clear_all_annotations","title":"<code>clear_all_annotations()</code>","text":"<p>Clears the coordinate annotations on the canvas and  the list of click coordinates</p> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>@Slot()\ndef clear_all_annotations(self):\n    \"\"\"\n    Clears the coordinate annotations on the canvas and \n    the list of click coordinates\n    \"\"\"\n    for item in self._annotations:\n        self._scene.removeItem(item)\n    self._annotations.clear()\n    self._list_clickCoords.clear()\n\n    self.viewport().update()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.draw_rectangle_canvas","title":"<code>draw_rectangle_canvas(coor1, coor2, scale=True)</code>","text":"<p>Draws a rectangle on the canvas with the given coordinates</p> <p>Parameters:</p> Name Type Description Default <code>coor1</code> <code>tuple[float, float]</code> <p>Coordinates of the top-left corner of the rectangle</p> required <code>coor2</code> <code>tuple[float, float]</code> <p>Coordinates of the bottom-right corner of the rectangle</p> required <code>scale</code> <code>bool</code> <p>Scale the coordinates according to the scale factor of the</p> <code>True</code> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>@Slot(tuple,tuple,bool)\ndef draw_rectangle_canvas(self,coor1:tuple[float,float],coor2:tuple[float,float],scale:bool=True):\n    \"\"\"\n    Draws a rectangle on the canvas with the given coordinates\n\n    Args:\n        coor1 (tuple[float,float]): Coordinates of the top-left corner of the rectangle\n        coor2 (tuple[float,float]): Coordinates of the bottom-right corner of the rectangle\n        scale (bool): Scale the coordinates according to the scale factor of the\n        image being displayed. Default is True\n    \"\"\"\n    assert isinstance(coor1, (tuple,list)) and len(coor1) == 2, 'Coordinates must be a tuple of (x,y)'\n    assert all([isinstance(coor1[i], (float,int)) for i in range(2)]), 'Coordinates must be a tuple of (floats or integers)'\n    assert isinstance(coor2, (tuple,list)) and len(coor2) == 2, 'Coordinates must be a tuple of (x,y)'\n    assert all([isinstance(coor2[i], (float,int)) for i in range(2)]), 'Coordinates must be a tuple of (floats or integers)'\n\n    if scale: scale_val = self._img_scale\n    else: scale_val = 1.0\n\n    x1, y1 = coor1\n    x2, y2 = coor2\n    x1 = (x1/scale_val)\n    y1 = (y1/scale_val)\n    x2 = (x2/scale_val)\n    y2 = (y2/scale_val)\n\n    # Ignore the coordinates outside the canvas\n    x1 = max(0,x1)\n    y1 = max(0,y1)\n    x2 = min(self.size_pixel[0],x2)\n    y2 = min(self.size_pixel[1],y2)\n\n    # print(f'Drawing rectangle at ({x1}, {y1}) to ({x2}, {y2}) on canvas')\n\n    # Create a rectangle on the canvas\n    # set transparency level to 50%\n    alpha = 0.35\n    rectangle = self._scene.addRect(x1, y1, x2 - x1, y2 - y1, QPen(QColor('red')), QColor(255,0,0,int(255*alpha)))\n    rectangle.setVisible(True)\n    self._annotations.append(rectangle)\n    self.viewport().update()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.get_clickCoordinates","title":"<code>get_clickCoordinates()</code>","text":"<p>Returns the list of click coordinates</p> Note <p>!!! Returns the coordinates in the original image coordinate system !!!</p> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>def get_clickCoordinates(self) -&gt; list[tuple[float,float]]:\n    \"\"\"\n    Returns the list of click coordinates\n\n    Note:\n        !!! Returns the coordinates in the original image coordinate system !!!\n    \"\"\"\n    return self._list_clickCoords\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.notify_observers_rightclick","title":"<code>notify_observers_rightclick()</code>","text":"<p>Notifies all observers that the annotations have been cleared</p> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>def notify_observers_rightclick(self):\n    \"\"\"\n    Notifies all observers that the annotations have been cleared\n    \"\"\"\n    for observer in self._list_observers_rightclick:\n        try: observer()\n        except Exception as e: print(f'Error notifying observer: {e}')\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.remove_observer_rightclick","title":"<code>remove_observer_rightclick(observer)</code>","text":"<p>Removes an observer from the list of observers</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>QObject</code> <p>The observer to be removed</p> required Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>def remove_observer_rightclick(self,observer:Callable):\n    \"\"\"\n    Removes an observer from the list of observers\n\n    Args:\n        observer (QObject): The observer to be removed\n    \"\"\"\n    assert callable(observer), 'Observer must be a callable'\n    try: self._list_observers_rightclick.remove(observer)\n    except Exception as e: print(f'Error removing observer: {e}')\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.set_image","title":"<code>set_image(img)</code>","text":"<p>Sets the image to be displayed on the canvas</p> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>@Slot(Image.Image)\ndef set_image(self,img:Image.Image):\n    \"\"\"\n    Sets the image to be displayed on the canvas\n    \"\"\"\n    assert isinstance(img, Image.Image), 'Image must be a PIL Image object'\n\n    img_scale = max(img.size[0]/self.size_pixel[0],img.size[1]/self.size_pixel[1])\n    img_resized = img.resize((int(img.size[0]/img_scale),int(img.size[1]/img_scale)),Image.LANCZOS) # pyright: ignore[reportAttributeAccessIssue] ; LANCOZOS is supported\n\n    qimg_resized = ImageQt.ImageQt(img_resized)\n    pixmap = QPixmap.fromImage(qimg_resized)\n\n    if qimg_resized != self._image_item:\n        # Double buffer: Create a new image item on the canvas, but don't display it yet\n        canvas_newImage = QGraphicsPixmapItem(pixmap)\n        canvas_newImage.setZValue(-1)  # Set the image item to be at the back\n        canvas_newImage.setVisible(False)  # Hide the new image item initially\n        self._scene.addItem(canvas_newImage)\n        # Now that the new image item is created, we can remove the old one\n        if self._image_item is not None:\n            self._scene.removeItem(self._image_item)\n        # Finally, display the new image item\n        canvas_newImage.setVisible(True)\n\n        # Update the annotations to be on top of the image\n        [annotation.setZValue(0) for annotation in self._annotations]\n\n        self._img_ori = img\n        self._image_item = canvas_newImage\n        self._img_size = img.size\n        self._img_scale = img_scale\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.show_annotations","title":"<code>show_annotations()</code>","text":"<p>Shows the annotations on the canvas</p> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>def show_annotations(self):\n    \"\"\"\n    Shows the annotations on the canvas\n    \"\"\"\n    for item in self._annotations:\n        item.setVisible(True)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.start_recordClicks","title":"<code>start_recordClicks(reset=True)</code>","text":"<p>Starts recording the click coordinates</p> <p>Parameters:</p> Name Type Description Default <code>reset</code> <code>bool</code> <p>Reset the list of click coordinates. Default is True</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[float, float]]</code> <p>list[tuples[float,float]]: List of click coordinates (x,y)</p> Note <p>!!! Returns the coordinates in the original image coordinate system !!!</p> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>@Slot(bool)\ndef start_recordClicks(self,reset:bool=True) -&gt; list[tuple[float,float]]:\n    \"\"\"\n    Starts recording the click coordinates\n\n    Args:\n        reset (bool): Reset the list of click coordinates. Default is True\n\n    Returns:\n        list[tuples[float,float]]: List of click coordinates (x,y)\n\n    Note:\n        !!! Returns the coordinates in the original image coordinate system !!!\n    \"\"\"\n    if reset: self._list_clickCoords.clear()\n    self._flg_recordClicks.set()\n    return self._list_clickCoords\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.Canvas_Image_Annotations.stop_recordClicks","title":"<code>stop_recordClicks(clear_annotations=True)</code>","text":"<p>Stops the recording: 1. Stops recording the click coordinates 2. Clears the list of click coordinates 3. Clears the annotations on the canvas</p> <p>Parameters:</p> Name Type Description Default <code>clear_annotations</code> <code>bool</code> <p>Clear the annotations on the canvas. Default is True</p> <code>True</code> Source code in <code>iris/gui/image_calibration/Canvas_ROIdefinition.py</code> <pre><code>@Slot(bool)\ndef stop_recordClicks(self,clear_annotations:bool=True) -&gt; None:\n    \"\"\"\n    Stops the recording:\n    1. Stops recording the click coordinates\n    2. Clears the list of click coordinates\n    3. Clears the annotations on the canvas\n\n    Args:\n        clear_annotations (bool): Clear the annotations on the canvas. Default is True\n    \"\"\"\n    self._flg_recordClicks.clear()\n    self._list_clickCoords.clear()\n    if clear_annotations: self.clear_all_annotations()\n    return\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/Canvas_ROIdefinition/#iris.gui.image_calibration.Canvas_ROIdefinition.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/","title":"objective_calibration","text":""},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Calibration_Worker","title":"<code>Calibration_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>class Calibration_Worker(QObject):\n    # Calibration signals\n    event_operationDone = threading.Event()\n    sig_set_image = Signal(Image.Image) # Signal to set the image on the canvas\n    sig_start_record_clicks = Signal(bool)  # Signal to start recording clicks on the canvas\n    sig_stop_record_clicks = Signal(bool)   # Signal to stop recording clicks on the canvas\n    sig_set_record_clicks_mm = Signal(list)  # Signal to set the recorded clicks in mm coordinates\n\n    sig_pause_vid_norm = Signal()   # Signal to pause the video feed (normal, unannotated)\n    sig_resume_vid_norm = Signal()  # Signal to resume the video feed (normal, unannotated)\n\n    sig_pause_vid_anno = Signal()   # Signal to pause the annotated video feed\n    sig_resume_vid_anno = Signal()  # Signal to resume the annotated video feed\n\n    sig_set_btnCal = Signal(str,str)    # Signal to set up the calibration button\n    sig_finished = Signal(str)          # Signal to indicate the calibration process is finished\n    sig_save_cal = Signal(MeaImg_Unit)  # Signal to save the calibration file (stored in the MeaImg_Unit\n    sig_set_imgUnit = Signal(MeaImg_Unit)   # Signal to set the image unit being stored in the main widget\n\n    msg_cal_success = 'Calibration completed successfully'\n    msg_cal_error = 'Error during calibration: '\n\n    button_texts = (\n        '1. Capture the first state',\n        '2. Complete laser selection',\n        '3. Complete the first selections',\n        '4. Capture the second state',\n        '5. Complete the second selection',\n        '6. Capture the third state',\n        '7. Complete the third selection',\n        '8. Complete calibration'\n    )\n    lines = (\n        f'1. Wait for the stage to stage coordinates to stabilise and click \"{button_texts[0]}\"',\n        f'2. Click the center of the laser spot and click \"{button_texts[1]}\"',\n        f'3. Click on some features to be tracked and click \"{button_texts[2]}\"',\n        f'4. Move the stage HORIZONTALLY, ensuring that the features are still visible, and click \"{button_texts[3]}\"',\n        f'5. Click on the features in the same order and click \"{button_texts[4]}\"',\n        f'6. Move the stage VERTICALLY, ensuring that the features are still visible, and click \"{button_texts[5]}\"',\n        f'7. Click on the features in the same order and click \"{button_texts[6]}\"',\n        f'8. Move the stage around, confirm that the features are tracked correctly, and click \"{button_texts[7]}\"'\n    )\n\n    # Finetune calibration signals\n    event_operationDone_finetune = threading.Event()\n    sig_done_picking_points_finetune = Signal()\n    sig_finished_finetune = Signal()\n\n    def __init__(\n        self,\n        getter_coor:Callable[[],tuple[float|None,float|None,float|None]],\n        getter_cameraImage:Callable[[],Image.Image|None],\n        canvas:Canvas_Image_Annotations,\n        ):\n        \"\"\"\n        Worker to perform the objective calibration\n\n        Args:\n            getter_coor (Callable[[],tuple[float,float,float]]): Getter function to get the stage coordinate\n            getter_cameraImage (Callable[[],Image.Image]): Getter function to get the camera image\n            canvas (Canvas_Image_Annotations): Canvas to display the image and record clicks\n        \"\"\"\n        super().__init__()\n        self._getter_coor = getter_coor\n        self._getter_img = getter_cameraImage\n        self._canvas = canvas\n\n    @Slot()\n    def perform_calibration(self) -&gt; None:\n        \"\"\"\n        Main function to perform the calibration setup, to be used in a separate thread, communicating with the main thread using events for GUI interaction.\n\n        Args:\n            list_tracking_coors (list): List to store the tracking coordinates to be used throughout the entire calibration process\n        \"\"\"\n        try:\n            def capture_state(message:str,button_text:str) -&gt; tuple[float|None,float|None,float|None]:\n                # print('Capture state: waiting for the user to click the button')\n                self.event_operationDone.clear()\n                self.sig_set_btnCal.emit(message,button_text)\n                self.sig_resume_vid_anno.emit()\n                self._canvas.clear_all_annotations()\n\n                # Wait for the user to finish the \n                self.event_operationDone.wait()\n                self.sig_pause_vid_anno.emit()\n                img_ori = self._getter_img()\n                self.sig_set_image.emit(img_ori)\n\n                stage_coor = self._getter_coor()\n\n                # print('Captured state at stage coordinates:',stage_coor)\n\n                return stage_coor\n\n            def feature_selection(message:str,button_text:str,limit1:bool=False) -&gt; list[tuple[float,float]]:\n                # print('Feature selection: waiting for the user to click the button')\n                self.event_operationDone.clear()\n                self.sig_set_btnCal.emit(message,button_text)\n                self.sig_start_record_clicks.emit(True)\n                self.sig_pause_vid_anno.emit()\n\n                self.event_operationDone.wait()\n                list_ret = self._canvas.get_clickCoordinates().copy()\n                self.sig_stop_record_clicks.emit(True)\n                if len(list_ret) == 0:\n                    raise ValueError('At least one feature must be selected')\n                if limit1 and len(list_ret) != 1:\n                    raise ValueError('Only laser spot must be selected')\n\n                # print('Selected features at image pixel coordinates:',list_ret)\n                return list_ret\n\n            lines = self.lines\n            button_texts = self.button_texts\n\n        # &gt; 1. Capture initial state &lt;\n            # print('\\nCalibration step 1: Capture initial state')\n            v1s = capture_state(lines[0],button_texts[0])\n            v1s = np.array(v1s[:2])\n            v1s_track = v1s.copy()\n\n        # &gt; 2. Select the laser spot &lt;\n            # print('\\nCalibration step 2: Select laser spot')\n            vlc = feature_selection(lines[1],button_texts[1],True)[-1]\n            vlc = np.array(vlc)\n\n        # &gt; 3. Select the first tracking features &lt;\n            # print('\\nCalibration step 3: Select first tracking features')\n            list_coor_pixel = feature_selection(lines[2],button_texts[2])\n            list_coor_pixel_v1 = list_coor_pixel.copy()\n            v1c = np.mean(list_coor_pixel,axis=0)\n\n        # &gt; 4. Capture second state &lt;\n            # print('\\nCalibration step 4: Capture second state')\n            v2s = capture_state(lines[3],button_texts[3])\n            v2s = np.array(v2s[:2])\n            y_diff = v2s[1] - v1s[1]\n            if not y_diff &lt; 10e-3: raise ValueError('The stage must be moved horizontally') # 10e-3 [mm] is the threshold\n\n        # &gt; 5. Select the tracking features &lt;\n            # print('\\nCalibration step 5: Select second tracking features')\n            num_features = len(list_coor_pixel)\n            list_coor_pixel = feature_selection(lines[4],button_texts[4])\n            v2c = np.mean(list_coor_pixel,axis=0)\n            if len(list_coor_pixel) != num_features: raise ValueError('The number of selected features must be the same')\n\n        # &gt; 6. Capture third state &lt;\n            # print('\\nCalibration step 6: Capture third state')\n            v3s = capture_state(lines[5],button_texts[5])\n            v3s = np.array(v3s[:2])\n            x_diff = v3s[0] - v2s[0]\n            if not x_diff &lt; 10e-3: raise ValueError('The stage must be moved vertically') # 10e-3 [mm] is the threshold\n\n        # &gt; 7. Select the tracking features &lt;\n            # print('\\nCalibration step 7: Select third tracking features')\n            list_coor_pixel = feature_selection(lines[6],button_texts[6])\n            v3c = np.mean(list_coor_pixel,axis=0)\n            v3c = np.array(v3c[:2])\n            if len(list_coor_pixel) != num_features: raise ValueError('The number of selected features must be the same')\n\n            # Set the calibration object\n            cal = ImgMea_Cal('calibration')\n            cal.set_calibration_vector(v1s,v2s,v3s,v1c,v2c,v3c,vlc)\n\n            # Save the calibration parameters (corrects for the image coordinate to the stage coordinate inversion)\n            img_unit = MeaImg_Unit(unit_name=f'Calibration {get_timestamp_us_str()}',calibration=cal)\n\n        # &gt; 8. Show the live feature tracking and complete the calibration\n            # print('\\nCalibration step 8: Show live feature tracking and complete the calibration')\n            self.event_operationDone.clear()\n            self.sig_set_btnCal.emit(lines[7],button_texts[7])\n\n            # Add the initial tracked features to the list, adjusted for the real coordinates by \n            # adding the initial stage coordinates\n            list_tracking_coors_mm = [cal.convert_imgpt2stg(coor_img_pixel=np.array(coor_img),\\\n                coor_stage_mm=v1s_track) for coor_img in list_coor_pixel_v1]\n            self.sig_set_imgUnit.emit(img_unit)\n            self.sig_set_record_clicks_mm.emit(list_tracking_coors_mm)\n            self.sig_resume_vid_anno.emit()\n\n            # Wait for the user to finish the calibration\n            self.event_operationDone.wait()\n\n        # &gt; 7. Ask the user to save the calibration file\n            self.sig_save_cal.emit(img_unit)\n\n        except Exception as e: self.sig_finished.emit(self.msg_cal_error + str(e))\n        finally:\n            self.sig_stop_record_clicks.emit(True)\n            self.sig_pause_vid_anno.emit()\n            self.sig_resume_vid_norm.emit()\n            self.sig_finished.emit(self.msg_cal_success)\n\n    @Slot(MeaImg_Unit)\n    def perform_calibration_finetune(self) -&gt; None:\n        \"\"\"\n        Performs a finetune calibration based on the current clicked coordinates on the canvas\n        \"\"\"\n        self.event_operationDone_finetune.wait()\n        self.event_operationDone_finetune.clear()\n        self.sig_done_picking_points_finetune.emit()\n\n        self.event_operationDone_finetune.wait()\n        self.event_operationDone_finetune.clear()\n        self.sig_finished_finetune.emit()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Calibration_Worker.__init__","title":"<code>__init__(getter_coor, getter_cameraImage, canvas)</code>","text":"<p>Worker to perform the objective calibration</p> <p>Parameters:</p> Name Type Description Default <code>getter_coor</code> <code>Callable[[], tuple[float, float, float]]</code> <p>Getter function to get the stage coordinate</p> required <code>getter_cameraImage</code> <code>Callable[[], Image]</code> <p>Getter function to get the camera image</p> required <code>canvas</code> <code>Canvas_Image_Annotations</code> <p>Canvas to display the image and record clicks</p> required Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def __init__(\n    self,\n    getter_coor:Callable[[],tuple[float|None,float|None,float|None]],\n    getter_cameraImage:Callable[[],Image.Image|None],\n    canvas:Canvas_Image_Annotations,\n    ):\n    \"\"\"\n    Worker to perform the objective calibration\n\n    Args:\n        getter_coor (Callable[[],tuple[float,float,float]]): Getter function to get the stage coordinate\n        getter_cameraImage (Callable[[],Image.Image]): Getter function to get the camera image\n        canvas (Canvas_Image_Annotations): Canvas to display the image and record clicks\n    \"\"\"\n    super().__init__()\n    self._getter_coor = getter_coor\n    self._getter_img = getter_cameraImage\n    self._canvas = canvas\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Calibration_Worker.perform_calibration","title":"<code>perform_calibration()</code>","text":"<p>Main function to perform the calibration setup, to be used in a separate thread, communicating with the main thread using events for GUI interaction.</p> <p>Parameters:</p> Name Type Description Default <code>list_tracking_coors</code> <code>list</code> <p>List to store the tracking coordinates to be used throughout the entire calibration process</p> required Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>@Slot()\ndef perform_calibration(self) -&gt; None:\n    \"\"\"\n    Main function to perform the calibration setup, to be used in a separate thread, communicating with the main thread using events for GUI interaction.\n\n    Args:\n        list_tracking_coors (list): List to store the tracking coordinates to be used throughout the entire calibration process\n    \"\"\"\n    try:\n        def capture_state(message:str,button_text:str) -&gt; tuple[float|None,float|None,float|None]:\n            # print('Capture state: waiting for the user to click the button')\n            self.event_operationDone.clear()\n            self.sig_set_btnCal.emit(message,button_text)\n            self.sig_resume_vid_anno.emit()\n            self._canvas.clear_all_annotations()\n\n            # Wait for the user to finish the \n            self.event_operationDone.wait()\n            self.sig_pause_vid_anno.emit()\n            img_ori = self._getter_img()\n            self.sig_set_image.emit(img_ori)\n\n            stage_coor = self._getter_coor()\n\n            # print('Captured state at stage coordinates:',stage_coor)\n\n            return stage_coor\n\n        def feature_selection(message:str,button_text:str,limit1:bool=False) -&gt; list[tuple[float,float]]:\n            # print('Feature selection: waiting for the user to click the button')\n            self.event_operationDone.clear()\n            self.sig_set_btnCal.emit(message,button_text)\n            self.sig_start_record_clicks.emit(True)\n            self.sig_pause_vid_anno.emit()\n\n            self.event_operationDone.wait()\n            list_ret = self._canvas.get_clickCoordinates().copy()\n            self.sig_stop_record_clicks.emit(True)\n            if len(list_ret) == 0:\n                raise ValueError('At least one feature must be selected')\n            if limit1 and len(list_ret) != 1:\n                raise ValueError('Only laser spot must be selected')\n\n            # print('Selected features at image pixel coordinates:',list_ret)\n            return list_ret\n\n        lines = self.lines\n        button_texts = self.button_texts\n\n    # &gt; 1. Capture initial state &lt;\n        # print('\\nCalibration step 1: Capture initial state')\n        v1s = capture_state(lines[0],button_texts[0])\n        v1s = np.array(v1s[:2])\n        v1s_track = v1s.copy()\n\n    # &gt; 2. Select the laser spot &lt;\n        # print('\\nCalibration step 2: Select laser spot')\n        vlc = feature_selection(lines[1],button_texts[1],True)[-1]\n        vlc = np.array(vlc)\n\n    # &gt; 3. Select the first tracking features &lt;\n        # print('\\nCalibration step 3: Select first tracking features')\n        list_coor_pixel = feature_selection(lines[2],button_texts[2])\n        list_coor_pixel_v1 = list_coor_pixel.copy()\n        v1c = np.mean(list_coor_pixel,axis=0)\n\n    # &gt; 4. Capture second state &lt;\n        # print('\\nCalibration step 4: Capture second state')\n        v2s = capture_state(lines[3],button_texts[3])\n        v2s = np.array(v2s[:2])\n        y_diff = v2s[1] - v1s[1]\n        if not y_diff &lt; 10e-3: raise ValueError('The stage must be moved horizontally') # 10e-3 [mm] is the threshold\n\n    # &gt; 5. Select the tracking features &lt;\n        # print('\\nCalibration step 5: Select second tracking features')\n        num_features = len(list_coor_pixel)\n        list_coor_pixel = feature_selection(lines[4],button_texts[4])\n        v2c = np.mean(list_coor_pixel,axis=0)\n        if len(list_coor_pixel) != num_features: raise ValueError('The number of selected features must be the same')\n\n    # &gt; 6. Capture third state &lt;\n        # print('\\nCalibration step 6: Capture third state')\n        v3s = capture_state(lines[5],button_texts[5])\n        v3s = np.array(v3s[:2])\n        x_diff = v3s[0] - v2s[0]\n        if not x_diff &lt; 10e-3: raise ValueError('The stage must be moved vertically') # 10e-3 [mm] is the threshold\n\n    # &gt; 7. Select the tracking features &lt;\n        # print('\\nCalibration step 7: Select third tracking features')\n        list_coor_pixel = feature_selection(lines[6],button_texts[6])\n        v3c = np.mean(list_coor_pixel,axis=0)\n        v3c = np.array(v3c[:2])\n        if len(list_coor_pixel) != num_features: raise ValueError('The number of selected features must be the same')\n\n        # Set the calibration object\n        cal = ImgMea_Cal('calibration')\n        cal.set_calibration_vector(v1s,v2s,v3s,v1c,v2c,v3c,vlc)\n\n        # Save the calibration parameters (corrects for the image coordinate to the stage coordinate inversion)\n        img_unit = MeaImg_Unit(unit_name=f'Calibration {get_timestamp_us_str()}',calibration=cal)\n\n    # &gt; 8. Show the live feature tracking and complete the calibration\n        # print('\\nCalibration step 8: Show live feature tracking and complete the calibration')\n        self.event_operationDone.clear()\n        self.sig_set_btnCal.emit(lines[7],button_texts[7])\n\n        # Add the initial tracked features to the list, adjusted for the real coordinates by \n        # adding the initial stage coordinates\n        list_tracking_coors_mm = [cal.convert_imgpt2stg(coor_img_pixel=np.array(coor_img),\\\n            coor_stage_mm=v1s_track) for coor_img in list_coor_pixel_v1]\n        self.sig_set_imgUnit.emit(img_unit)\n        self.sig_set_record_clicks_mm.emit(list_tracking_coors_mm)\n        self.sig_resume_vid_anno.emit()\n\n        # Wait for the user to finish the calibration\n        self.event_operationDone.wait()\n\n    # &gt; 7. Ask the user to save the calibration file\n        self.sig_save_cal.emit(img_unit)\n\n    except Exception as e: self.sig_finished.emit(self.msg_cal_error + str(e))\n    finally:\n        self.sig_stop_record_clicks.emit(True)\n        self.sig_pause_vid_anno.emit()\n        self.sig_resume_vid_norm.emit()\n        self.sig_finished.emit(self.msg_cal_success)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Calibration_Worker.perform_calibration_finetune","title":"<code>perform_calibration_finetune()</code>","text":"<p>Performs a finetune calibration based on the current clicked coordinates on the canvas</p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>@Slot(MeaImg_Unit)\ndef perform_calibration_finetune(self) -&gt; None:\n    \"\"\"\n    Performs a finetune calibration based on the current clicked coordinates on the canvas\n    \"\"\"\n    self.event_operationDone_finetune.wait()\n    self.event_operationDone_finetune.clear()\n    self.sig_done_picking_points_finetune.emit()\n\n    self.event_operationDone_finetune.wait()\n    self.event_operationDone_finetune.clear()\n    self.sig_finished_finetune.emit()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.ImageProcessor_Worker","title":"<code>ImageProcessor_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>class ImageProcessor_Worker(QObject):\n\n    sig_img = Signal(Image.Image)\n\n    def __init__(self):\n        super().__init__()\n\n    @Slot(MeaImg_Unit,bool)\n    def get_stitched_image(self,meaImg:MeaImg_Unit,low_res:bool) -&gt; None:\n        \"\"\"\n        Gets the stitched image from the measurement image\n\n        Args:\n            meaImg (MeaImg_Unit): Measurement image unit\n            low_res (bool): Whether to get the low resolution image. Default is False\n\n        Returns:\n            tuple: Stitched image and list of coordinates\n        \"\"\"\n        stitched_img = meaImg.get_image_all_stitched(low_res=low_res)[0]\n        self.sig_img.emit(stitched_img)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.ImageProcessor_Worker.get_stitched_image","title":"<code>get_stitched_image(meaImg, low_res)</code>","text":"<p>Gets the stitched image from the measurement image</p> <p>Parameters:</p> Name Type Description Default <code>meaImg</code> <code>MeaImg_Unit</code> <p>Measurement image unit</p> required <code>low_res</code> <code>bool</code> <p>Whether to get the low resolution image. Default is False</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>None</code> <p>Stitched image and list of coordinates</p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>@Slot(MeaImg_Unit,bool)\ndef get_stitched_image(self,meaImg:MeaImg_Unit,low_res:bool) -&gt; None:\n    \"\"\"\n    Gets the stitched image from the measurement image\n\n    Args:\n        meaImg (MeaImg_Unit): Measurement image unit\n        low_res (bool): Whether to get the low resolution image. Default is False\n\n    Returns:\n        tuple: Stitched image and list of coordinates\n    \"\"\"\n    stitched_img = meaImg.get_image_all_stitched(low_res=low_res)[0]\n    self.sig_img.emit(stitched_img)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration","title":"<code>Wdg_Calibration</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Sub-frame to form the calibration file of an ImageMeasurement object. I.e., to perform an objective calibration.</p> Note <p>initialise_auto_updaters must be called after the object is created</p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>class Wdg_Calibration(qw.QWidget):\n    \"\"\"\n    Sub-frame to form the calibration file of an ImageMeasurement object.\n    I.e., to perform an objective calibration.\n\n    Note:\n        initialise_auto_updaters must be called after the object is created\n    \"\"\"\n    sig_get_stitched_img = Signal(MeaImg_Unit,bool)\n    sig_perform_calibration = Signal()\n    sig_perform_finetune_calibration = Signal()\n    sig_saved_calibration = Signal()    # Signal emitted when a calibration is saved in the calibration folder\n\n    def __init__(self,\n                 parent:qw.QWidget,\n                 processor:mpp.Pool,\n                 dataHub_img:Wdg_DataHub_Image,\n                 dataHub_imgcal:Wdg_DataHub_ImgCal,\n                 getter_coor:Callable[[],tuple[float|None,float|None,float|None]],\n                 getter_cameraImage:Callable[[],Image.Image|None],):\n        \"\"\"\n        Args:\n            parent (qw.QWidget): Main frame to put the sub-frame in\n            processor (mpp.Pool): Multiprocessing pool for parallel processing\n            dataHub_img (Wdg_DataHub_Image): DataHub for the measurement images\n            dataHub_imgcal (Wdg_DataHub_ImgCal): DataHub for the image calibrations\n            getter_coor (Callable): Callable to get the stage coordinate\n            getter_cameraImage (Callable): Callable to get the camera image\n        \"\"\"\n        super().__init__(parent)\n        self._processor = processor\n        self._getter_cameraImage = getter_cameraImage\n        self._getter_coordinate = getter_coor\n\n        self._dataHub_img = dataHub_img\n        self._dataHub_imgcal = dataHub_imgcal\n\n        self._showHints = AppPlotEnum.IMGCAL_SHOWHINTS.value\n\n    # &gt;&gt;&gt; Main parameters &lt;&lt;&lt;\n        self._getter_calibration = self._dataHub_imgcal.get_selected_calibration\n        self._meaImgUnit = MeaImg_Unit(\n            unit_name='Calibration',\n            calibration=self._getter_calibration(),\n            reconstruct=True\n        )\n\n    # &gt;&gt;&gt; Main widget setup &lt;&lt;&lt;\n        self._widget = Calibration_Main_Design(self)\n        lyt = qw.QVBoxLayout(self)\n        lyt.addWidget(self._widget)\n        self.setLayout(lyt)\n        wdg = self._widget\n\n        # Statusbar setup\n        self._statbar = qw.QStatusBar(self)\n        lyt.addWidget(self._statbar)\n\n        lbl_statbar = qw.QLabel('Ready')\n        self._statbar.addWidget(lbl_statbar)\n\n    # &gt;&gt;&gt; Display widget &lt;&lt;&lt;\n        # Canvas to display the image and button to show current image\n        self._canvas_img = Canvas_Image_Annotations(wdg.wdg_holder_canvas)\n        self._chk_lowres = wdg.chk_lres\n        self._btn_showImage = wdg.btn_showimage\n        self._btn_showLiveFeed = wdg.btn_refresh\n        self._btn_showLiveFeed.setEnabled(False)\n\n        self._btn_showImage.clicked.connect(lambda:self._show_stitched_images())\n        # self._btn_showLiveFeed.clicked.connect(lambda:self.initialise_auto_updaters())\n\n    # &gt;&gt;&gt; Capture widgets &lt;&lt;&lt;\n        # Buttons for image capture\n        self._btn_capture = wdg.btn_capture\n        self._btn_resetCapture = wdg.btn_resetcapture\n        self._btn_save = wdg.btn_savecaptured\n\n        self._btn_capture.clicked.connect(lambda:self._capture_image())\n        self._btn_resetCapture.clicked.connect(lambda:self._reset_capture())\n        self._btn_save.clicked.connect(lambda:self._save_image())\n\n    # &gt;&gt;&gt; Calibration adjustment &lt;&lt;&lt;\n        # Sub-frame for calibration adjustment\n        self._wdg_cal_adj=Wdg_Calibration_Finetuning(\n            parent=self,\n            processor=self._processor,\n            imgUnit_getter=lambda:self._meaImgUnit\n            )\n        wdg.lyt_holder_calibration_controls.addWidget(self._wdg_cal_adj)\n\n        self._wdg_cal_adj.config_finetune_calibration_button(callback=self._initialise_finetune_calibration)\n        self._wdg_cal_adj.config_calibrate_button(callback=self._start_calibration)\n\n    # &gt;&gt;&gt; Display parameters &lt;&lt;&lt;\n        self._videoRefreshRate = 25    # Refresh rate of the video feed in Hz\n\n    # Thread for a live video feed\n        self._flg_video_pause = threading.Event()\n        self._timer_videofeed = QTimer()\n        self._timer_videofeed.setInterval(1000//self._videoRefreshRate)\n        self._timer_videofeed.timeout.connect(lambda: self._show_camera_feed())\n        self.destroyed.connect(self._timer_videofeed.stop)\n        self._timer_videofeed.start()\n\n    # Thread for an annotated video feed during calibration\n        self._flg_video_anno_pause = threading.Event()\n        self._anno_vid_custom_coors = False\n        self._anno_vid_list_coors_mm = []\n        self._anno_vid_annotate = False\n\n        self._timer_videofeed_anno = QTimer()\n        self._timer_videofeed_anno.setInterval(1000//self._videoRefreshRate)\n        self._timer_videofeed_anno.timeout.connect(lambda: self._show_annotated_video_feed())\n        self.destroyed.connect(self._timer_videofeed_anno.stop)\n        self._timer_videofeed_anno.start()\n\n        self._init_worker()\n\n    def _init_worker(self) -&gt; None:\n        \"\"\"\n        Initialises the worker for image processing\n        \"\"\"\n        # Image processing worker\n        self._thread_worker_img = QThread()\n        self._worker_img = ImageProcessor_Worker()\n        self._worker_img.moveToThread(self._thread_worker_img)\n        self._thread_worker_img.start()\n\n        self.sig_get_stitched_img.connect(self._worker_img.get_stitched_image)\n        self._worker_img.sig_img.connect(lambda img:self._canvas_img.set_image(img))\n\n        # Calibration worker\n        self._thread_worker_cal = QThread()\n        self._worker_cal = Calibration_Worker(\n            getter_coor=self._getter_coordinate,\n            getter_cameraImage=self._getter_cameraImage,\n            canvas=self._canvas_img,\n        )\n        self._worker_cal.moveToThread(self._thread_worker_cal)\n        self._thread_worker_cal.start()\n\n        self.sig_perform_calibration.connect(self._worker_cal.perform_calibration)\n\n        self._worker_cal.sig_set_image.connect(self._canvas_img.set_image)\n        self._worker_cal.sig_start_record_clicks.connect(self._canvas_img.start_recordClicks)\n        self._worker_cal.sig_stop_record_clicks.connect(self._canvas_img.stop_recordClicks)\n        self._worker_cal.sig_set_record_clicks_mm.connect(self._setup_annotated_video_feed)\n\n        self._worker_cal.sig_pause_vid_norm.connect(self._pause_video_feed)\n        self._worker_cal.sig_resume_vid_norm.connect(self._resume_video_feed)\n\n        self._worker_cal.sig_pause_vid_anno.connect(self._flg_video_anno_pause.set)\n        self._worker_cal.sig_resume_vid_anno.connect(self._flg_video_anno_pause.clear)\n\n        self._worker_cal.sig_set_btnCal.connect(self._calibration_button_setup_duringCalibration)\n        self._worker_cal.sig_finished.connect(self._handle_calibration_finished)\n        self._worker_cal.sig_save_cal.connect(self._save_calibration_file)\n        self._worker_cal.sig_set_imgUnit.connect(self._set_internal_meaImgUnit)\n\n        # Finetune calibration connections\n        self._worker_cal.sig_finished_finetune.connect(self._finalise_finetune_calibration)\n        self.sig_perform_finetune_calibration.connect(self._worker_cal.perform_calibration_finetune)\n\n    def _save_image(self):\n        \"\"\"\n        Saves the local image to the Image DataHub\n        \"\"\"\n        self._dataHub_img.append_ImageMeasurementUnit(self._meaImgUnit, flg_nameprompt=True)\n        self._meaImgUnit = MeaImg_Unit(\n            unit_name='Calibration',\n            calibration=self._getter_calibration(),\n            reconstruct=True\n        )\n\n    def _show_camera_feed(self):\n        \"\"\"\n        Updates the video feed on the canvas\n        \"\"\"\n        if self._flg_video_pause.is_set(): return\n\n        try:\n            img_ori = self._getter_cameraImage()\n            self._canvas_img.set_image(img_ori)\n        except Exception as e:\n            print('_update_video_feed error:',e)\n\n    def _reset_capture(self):\n        \"\"\"\n        Resets the capture process\n        \"\"\"\n        result = qw.QMessageBox.question(\n            self, 'Reset capture', 'This will delete all stored image. Are you sure you want to proceed?',\n            qw.QMessageBox.Yes | qw.QMessageBox.No, qw.QMessageBox.No # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes, No exist\n        )\n        if result != qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes exists\n            return\n\n        self._meaImgUnit.reset_measurement()\n\n    def _capture_image(self):\n        \"\"\"\n        Captures the image from the camera and saves it to the image measurement\n        \"\"\"\n        try:\n            # Set a style to show a yellow background\n            style = \"QStatusBar{background-color: %s;}\" % 'yellow'\n            self._statbar.setStyleSheet(style)\n            self._statbar.showMessage('Capturing image...')\n            img:Image.Image|None = self._getter_cameraImage()\n            coor = self._getter_coordinate()\n\n            # Validate the inputs\n            if img is None: raise ValueError('No image captured from the camera')\n            if not all([isinstance(c,float) for c in coor]): raise ValueError('Stage coordinates are not valid')\n\n            # Save the image to the measurement image\n            meaImg = self._meaImgUnit\n            cal = self._getter_calibration()\n            meaImg.set_calibration_ImageMeasurement_Calibration(cal)\n\n            timestamp = get_timestamp_us_str()\n\n            meaImg.add_measurement(\n                timestamp=timestamp,\n                x_coor=coor[0], # pyright: ignore[reportArgumentType] ; the check is done above to ensure coor is float\n                y_coor=coor[1], # pyright: ignore[reportArgumentType] ; the check is done above to ensure coor is float\n                z_coor=coor[2], # pyright: ignore[reportArgumentType] ; the check is done above to ensure coor is float\n                image=img\n            )\n\n            self._show_stitched_images()\n\n            style = \"QStatusBar{background-color: %s;}\" % 'green'\n            self._statbar.setStyleSheet(style)\n            self._statbar.showMessage('Image captured successfully')\n        except Exception as e:\n            self._statbar.setStyleSheet(\"QStatusBar{background-color: %s;}\" % 'red')\n            self._statbar.showMessage('Error capturing image: {}'.format(e))\n            print(f'_capture_image error: {e}')\n        finally:\n            timer = QTimer()\n            timer.setSingleShot(True)\n            timer.setInterval(5000)\n            timer.timeout.connect(self._statbar.clearMessage)\n            timer.timeout.connect(lambda: self._statbar.setStyleSheet(\"\"))\n            timer.start()\n\n    def _show_stitched_images(self) -&gt; None:\n        \"\"\"\n        Shows the stitched images on the canvas\n        \"\"\"\n        ori_text = self._btn_showImage.text()\n\n        self._pause_video_feed()\n        self._btn_showImage.clicked.disconnect()\n        self._btn_showImage.clicked.connect(lambda: self._reset_btn_showImage(ori_text))\n        self._btn_showImage.setText('Show live feed')\n\n        meaImg = self._meaImgUnit\n        flg_lowResImg = self._chk_lowres.isChecked()\n        self.sig_get_stitched_img.emit(meaImg,flg_lowResImg)\n\n    def _reset_btn_showImage(self, text:str):\n        \"\"\"\n        Resets the show image button to its original state\n        \"\"\"\n        self._btn_showImage.setEnabled(True)\n        self._btn_showImage.setText(text)\n        self._btn_showImage.clicked.disconnect()\n        self._btn_showImage.clicked.connect(lambda: self._show_stitched_images())\n\n        self._resume_video_feed()\n\n    @Slot(list)\n    def _setup_annotated_video_feed(self, list_coors_mm:list[tuple[float,float]]|None):\n        \"\"\"\n        Sets up the annotated video feed for calibration. If list_coors_mm is None,\n        the annotated video feed will use the clicked coordinates on the canvas.\n        (Refer to _show_annotated_video_feed for more details)\n\n        Args:\n            list_coors_mm (list): List of coordinates to be annotated on the canvas\n        \"\"\"\n        if list_coors_mm is None:\n            self._anno_vid_custom_coors = False\n            self._anno_vid_list_coors_mm = []\n            self._anno_vid_annotate = False\n        else:\n            self._anno_vid_custom_coors = True\n            self._anno_vid_list_coors_mm = list_coors_mm\n            self._anno_vid_annotate = True\n\n    def _show_annotated_video_feed(self):\n        \"\"\"\n        Displays the video feed on the canvas with annotations. For specific coordinates to be annotated,\n        use _setup_annotated_video_feed to specify them up, which will be stored in the _anno_vid_list_coors_mm.\n        \"\"\"\n        if self._flg_video_anno_pause.is_set(): return\n\n        img_ori = self._getter_cameraImage()\n        self._canvas_img.set_image(img_ori)\n\n        if self._anno_vid_custom_coors: coor_list_mm = self._anno_vid_list_coors_mm\n        else: coor_list_mm = self._canvas_img.get_clickCoordinates().copy()\n\n        if len(coor_list_mm) &lt;= 0: return\n\n        try:\n            if not self._anno_vid_annotate: return\n            stage_coor = self._getter_coordinate()\n            low_res = self._chk_lowres.isChecked()\n\n            assert all([isinstance(c,float) for c in stage_coor]), 'Stage coordinates are not valid'\n\n            list_coor_pixel = [self._meaImgUnit.convert_stg2imgpt(coor_stage_mm=stage_coor,coor_point_mm=coor, # pyright: ignore[reportArgumentType]\n                correct_rot=False,low_res=low_res) for coor in coor_list_mm]\n            list_coor_pixel = [(float(coor[0]),float(coor[1])) for coor in list_coor_pixel]\n\n            self._canvas_img.annotate_canvas_multi(list_coor_pixel,scale=True,flg_removePreviousAnnotations=True)\n        except Exception as e: print('Error annotating the image:',e)\n\n    @Slot()\n    def _pause_video_feed(self):\n        \"\"\"\n        Pauses the video feed\n        \"\"\"\n        self._flg_video_pause.set()\n\n    @Slot()\n    def _resume_video_feed(self):\n        \"\"\"\n        Resumes the video feed\n        \"\"\"\n        self._flg_video_pause.clear()\n\n    def _initialise_finetune_calibration(self):\n        \"\"\"\n        Finetunes the calibration manually using the spinbox widgets\n        \"\"\" \n        try:\n            self._pause_video_feed()\n            meaImg = self._meaImgUnit\n            current_cal = self._getter_calibration()\n            meaImg.set_calibration_ImageMeasurement_Calibration(current_cal)\n            if not meaImg.check_calibration_exist(): qw.QMessageBox.warning(self,'Finetune calibration','Calibration does not exist. Please perform calibration first.'); return\n\n        # &gt; Parameters initialisation &lt;\n            # Reset the values, enable the spinboxes, and set the button to save the calibration\n            try: self._wdg_cal_adj.initialise_fineadjuster()\n            except Exception as e: qw.QMessageBox.warning(self,'Finetune calibration','Error initialising fineadjuster: {}'.format(e)); return\n\n        # &gt; Tracking initialisation &lt;\n            # Ask the user to pick some points to track\n            stage_coor = self._getter_coordinate()\n            img = self._getter_cameraImage()\n            self._canvas_img.set_image(img)\n\n            self._statbar.setStyleSheet(\"QStatusBar{background-color: %s;}\" % 'yellow')\n            self._statbar.showMessage('Click on the features to be tracked and click \"Finish feature selection\". Right-click to clear the current selections.')\n            list_coors_pixel = self._canvas_img.start_recordClicks()\n\n            try: self._worker_cal.sig_done_picking_points_finetune.disconnect()\n            except Exception: pass\n\n            self._worker_cal.sig_done_picking_points_finetune.connect(\n                lambda: self._perform_finetune_calibration(\n                    meaImg, stage_coor, list_coors_pixel # pyright: ignore[reportArgumentType] ; the error will be catched elsewhere, and is not critical here\n                )\n            )\n\n            self._wdg_cal_adj.config_finetune_calibration_button(\n                callback=self._worker_cal.event_operationDone_finetune.set,\n                text='Finish feature selection',enabled=True)\n\n            self.sig_perform_finetune_calibration.emit()\n\n        except Exception as e:\n            qw.QMessageBox.warning(self,'Finetune calibration','Error initialising finetune calibration: {}'.format(e))\n            self._resume_video_feed()\n            self._reset_status_bar(after_sec=5)\n            self._wdg_cal_adj.config_finetune_calibration_button(callback=self._initialise_finetune_calibration)\n\n    def _perform_finetune_calibration(self, meaImg: MeaImg_Unit, stage_coor: tuple[float, float, float],\n            list_coors_pixel: list[tuple[float, float]]):\n        \"\"\"\n        Performs the finetuning of the calibration using the selected features\n\n        Args:\n            meaImg (MeaImg_Unit): Measurement image unit of which the calibration will be used for the finetuning process\n            stage_coor (tuple[float, float, float]): Stage coordinate\n            list_coors_pixel (list[tuple[float, float]]): List of pixel coordinates of the selected features\n        \"\"\"\n        try:\n            list_coors_mm = [meaImg.convert_imgpt2stg(stage_coor,coor,False,low_res=self._chk_lowres.isChecked()) for coor in list_coors_pixel]\n            self._canvas_img.stop_recordClicks()\n\n            self._statbar.setStyleSheet(\"QStatusBar{background-color: %s;}\" % 'yellow')\n            self._statbar.showMessage('Finetune the calibration using the spinboxes and move the stage around to monitor the effect')\n\n            # &gt; Calibration finetuning by video feed &lt;\n                # Enable the spinboxes and start the video feed\n            self._wdg_cal_adj.enable_finetuneCalibration_widgets(\n                callback=self._wdg_cal_adj.apply_temp_fineadjustment,\n                readonly=True)\n\n            # &gt; Set up the annotated video feed and the widgets to finalise the finetuning &lt;\n            self._flg_video_pause.set()\n            self._flg_video_anno_pause.clear()\n            self._setup_annotated_video_feed(list_coors_mm)\n\n            self._wdg_cal_adj.config_finetune_calibration_button(\n                callback=self._worker_cal.event_operationDone_finetune.set,text='End finetune calibration')\n        except Exception as e:\n            qw.QMessageBox.warning(self,'Error in finetune calibration',str(e))\n            self._statbar.setStyleSheet(\"QStatusBar{background-color: %s;}\" % 'red')\n            self._statbar.showMessage(f'Error in finetuning: {e}')\n            self._reset_status_bar(after_sec=5)\n            self._wdg_cal_adj.config_finetune_calibration_button(callback=self._initialise_finetune_calibration)\n\n    @Slot()\n    def _finalise_finetune_calibration(self):\n        \"\"\"\n        Finalise the calibration finetuning\n        \"\"\"\n        self._flg_video_anno_pause.set()\n        self._resume_video_feed()\n        try:\n            self._wdg_cal_adj.finalise_fineadjustment()\n            self._statbar.setStyleSheet(\"QStatusBar{background-color: %s;}\" % 'green')\n            self._statbar.showMessage('Calibration finetuning finished: Please save the calibration file manually if required')\n            self._reset_status_bar(after_sec=5)\n        except Exception as e:\n            qw.QMessageBox.warning(self,'Error in finetune calibration',str(e))\n            self._statbar.setStyleSheet(\"QStatusBar{background-color: %s;}\" % 'red')\n            self._statbar.showMessage(f'Error in finetuning: {e}')\n        finally:\n            self._wdg_cal_adj.config_finetune_calibration_button(callback=self._initialise_finetune_calibration)\n\n    @Slot(str, str)\n    def _calibration_button_setup_duringCalibration(self, msg:str, btn_text:str) -&gt; None:\n        \"\"\"\n        Sets up the calibration button to perform the state capture operation (image and coordinate,\n        handled by the worker))\n\n        Args:\n            msg (str): Message to display on the status bar\n            btn_text (str): Text to display on the button\n        \"\"\"\n        callback = self._worker_cal.event_operationDone.set\n        self._wdg_cal_adj.config_calibrate_button(callback=callback,text=btn_text)\n        self._statbar.setStyleSheet(\"QStatusBar{background-color: %s;}\" % 'yellow')\n        self._statbar.showMessage(msg)\n\n    @Slot(MeaImg_Unit)\n    def _save_calibration_file(self, meaImg:MeaImg_Unit) -&gt; None:\n        \"\"\"\n        Saves the calibration file from the measurement image unit\n\n        Args:\n            meaImg (MeaImg_Unit): Measurement image unit containing the calibration to be saved\n        \"\"\"\n        self._meaImgUnit = meaImg\n        ans = qw.QMessageBox.question(\n            self, 'Save calibration file', 'Do you want to save the calibration file now?',\n            qw.QMessageBox.Yes | qw.QMessageBox.No, qw.QMessageBox.Yes # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes, No exist\n        )\n        if ans != qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes exists\n            button_text = self._btn_save.text()\n            qw.QMessageBox.information(self,'Warning',f'The calibration file was not saved, it can still be saved manually using the \"{button_text}\" button.\"')\n            return\n\n        savepath = os.path.abspath(LibraryConfigEnum.OBJECTIVE_CALIBRATION_DIR.value)\n        savepath = os.path.join(savepath, meaImg.get_ImageMeasurement_Calibration().id + '.json')\n\n        MeaImg_Handler().save_calibration_json_from_ImgMea(meaImg,savepath)\n        qw.QMessageBox.information(self,'Calibration saved','Calibration file saved successfully')\n        self.sig_saved_calibration.emit()\n\n    @Slot()\n    def _set_internal_meaImgUnit(self, imgunit:MeaImg_Unit):\n        \"\"\"\n        Sets the MeaIng_Unit being stored internally (e.g., for the pixel -&gt; mm coordinate conversion)\n\n        Args:\n            imgunit (MeaImg_Unit): The image unit to be stored\n        \"\"\"\n        self._meaImgUnit = imgunit\n\n    @Slot(str)\n    def _handle_calibration_finished(self, message:str) -&gt; None:\n        \"\"\"\n        Handles the calibration finished signal\n\n        Args:\n            message (str): Message to display on the status bar\n        \"\"\"\n        colour = 'green' if message.startswith(self._worker_cal.msg_cal_success) else 'red'\n        self._statbar.setStyleSheet(\"QStatusBar{background-color: %s;}\" % colour)\n        self._statbar.showMessage(message)\n        self._reset_status_bar(after_sec=5)\n\n        # Reset the button state\n        self._wdg_cal_adj.config_calibrate_button(callback=self._start_calibration)\n\n    def _start_calibration(self):\n        \"\"\"\n        Perform the calibration to:\n            - Calculate the mm/pixel ratio\n            - Measure the laser coordinate offset of the image coordinate from the stage coordinate\n        \"\"\"\n        self._pause_video_feed()\n\n        timer_vid_anno = QTimer()\n        timer_vid_anno.setInterval(1000//self._videoRefreshRate)\n        timer_vid_anno.timeout.connect(lambda: self._show_annotated_video_feed())\n        timer_vid_anno.start()\n\n        if self._showHints:\n            message = \"\\n\".join(self._worker_cal.lines)\n            qw.QMessageBox.information(self,'Calibration procedure',message)\n\n        self._setup_annotated_video_feed(None)\n        self.sig_perform_calibration.emit()\n\n    def _reset_status_bar(self, after_sec:float=0):\n        \"\"\"\n        Resets the status bar after a delay\n\n        Args:\n            after_sec (float): Delay in seconds before resetting the status bar\n        \"\"\"\n        if after_sec &lt;= 0:\n            self._statbar.clearMessage()\n            self._statbar.setStyleSheet(\"\")\n        else:\n            timer = QTimer()\n            timer.setSingleShot(True)\n            timer.setInterval(int(after_sec*1000))\n            timer.timeout.connect(self._statbar.clearMessage)\n            timer.timeout.connect(lambda: self._statbar.setStyleSheet(\"\"))\n            timer.start()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration.__init__","title":"<code>__init__(parent, processor, dataHub_img, dataHub_imgcal, getter_coor, getter_cameraImage)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Main frame to put the sub-frame in</p> required <code>processor</code> <code>Pool</code> <p>Multiprocessing pool for parallel processing</p> required <code>dataHub_img</code> <code>Wdg_DataHub_Image</code> <p>DataHub for the measurement images</p> required <code>dataHub_imgcal</code> <code>Wdg_DataHub_ImgCal</code> <p>DataHub for the image calibrations</p> required <code>getter_coor</code> <code>Callable</code> <p>Callable to get the stage coordinate</p> required <code>getter_cameraImage</code> <code>Callable</code> <p>Callable to get the camera image</p> required Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def __init__(self,\n             parent:qw.QWidget,\n             processor:mpp.Pool,\n             dataHub_img:Wdg_DataHub_Image,\n             dataHub_imgcal:Wdg_DataHub_ImgCal,\n             getter_coor:Callable[[],tuple[float|None,float|None,float|None]],\n             getter_cameraImage:Callable[[],Image.Image|None],):\n    \"\"\"\n    Args:\n        parent (qw.QWidget): Main frame to put the sub-frame in\n        processor (mpp.Pool): Multiprocessing pool for parallel processing\n        dataHub_img (Wdg_DataHub_Image): DataHub for the measurement images\n        dataHub_imgcal (Wdg_DataHub_ImgCal): DataHub for the image calibrations\n        getter_coor (Callable): Callable to get the stage coordinate\n        getter_cameraImage (Callable): Callable to get the camera image\n    \"\"\"\n    super().__init__(parent)\n    self._processor = processor\n    self._getter_cameraImage = getter_cameraImage\n    self._getter_coordinate = getter_coor\n\n    self._dataHub_img = dataHub_img\n    self._dataHub_imgcal = dataHub_imgcal\n\n    self._showHints = AppPlotEnum.IMGCAL_SHOWHINTS.value\n\n# &gt;&gt;&gt; Main parameters &lt;&lt;&lt;\n    self._getter_calibration = self._dataHub_imgcal.get_selected_calibration\n    self._meaImgUnit = MeaImg_Unit(\n        unit_name='Calibration',\n        calibration=self._getter_calibration(),\n        reconstruct=True\n    )\n\n# &gt;&gt;&gt; Main widget setup &lt;&lt;&lt;\n    self._widget = Calibration_Main_Design(self)\n    lyt = qw.QVBoxLayout(self)\n    lyt.addWidget(self._widget)\n    self.setLayout(lyt)\n    wdg = self._widget\n\n    # Statusbar setup\n    self._statbar = qw.QStatusBar(self)\n    lyt.addWidget(self._statbar)\n\n    lbl_statbar = qw.QLabel('Ready')\n    self._statbar.addWidget(lbl_statbar)\n\n# &gt;&gt;&gt; Display widget &lt;&lt;&lt;\n    # Canvas to display the image and button to show current image\n    self._canvas_img = Canvas_Image_Annotations(wdg.wdg_holder_canvas)\n    self._chk_lowres = wdg.chk_lres\n    self._btn_showImage = wdg.btn_showimage\n    self._btn_showLiveFeed = wdg.btn_refresh\n    self._btn_showLiveFeed.setEnabled(False)\n\n    self._btn_showImage.clicked.connect(lambda:self._show_stitched_images())\n    # self._btn_showLiveFeed.clicked.connect(lambda:self.initialise_auto_updaters())\n\n# &gt;&gt;&gt; Capture widgets &lt;&lt;&lt;\n    # Buttons for image capture\n    self._btn_capture = wdg.btn_capture\n    self._btn_resetCapture = wdg.btn_resetcapture\n    self._btn_save = wdg.btn_savecaptured\n\n    self._btn_capture.clicked.connect(lambda:self._capture_image())\n    self._btn_resetCapture.clicked.connect(lambda:self._reset_capture())\n    self._btn_save.clicked.connect(lambda:self._save_image())\n\n# &gt;&gt;&gt; Calibration adjustment &lt;&lt;&lt;\n    # Sub-frame for calibration adjustment\n    self._wdg_cal_adj=Wdg_Calibration_Finetuning(\n        parent=self,\n        processor=self._processor,\n        imgUnit_getter=lambda:self._meaImgUnit\n        )\n    wdg.lyt_holder_calibration_controls.addWidget(self._wdg_cal_adj)\n\n    self._wdg_cal_adj.config_finetune_calibration_button(callback=self._initialise_finetune_calibration)\n    self._wdg_cal_adj.config_calibrate_button(callback=self._start_calibration)\n\n# &gt;&gt;&gt; Display parameters &lt;&lt;&lt;\n    self._videoRefreshRate = 25    # Refresh rate of the video feed in Hz\n\n# Thread for a live video feed\n    self._flg_video_pause = threading.Event()\n    self._timer_videofeed = QTimer()\n    self._timer_videofeed.setInterval(1000//self._videoRefreshRate)\n    self._timer_videofeed.timeout.connect(lambda: self._show_camera_feed())\n    self.destroyed.connect(self._timer_videofeed.stop)\n    self._timer_videofeed.start()\n\n# Thread for an annotated video feed during calibration\n    self._flg_video_anno_pause = threading.Event()\n    self._anno_vid_custom_coors = False\n    self._anno_vid_list_coors_mm = []\n    self._anno_vid_annotate = False\n\n    self._timer_videofeed_anno = QTimer()\n    self._timer_videofeed_anno.setInterval(1000//self._videoRefreshRate)\n    self._timer_videofeed_anno.timeout.connect(lambda: self._show_annotated_video_feed())\n    self.destroyed.connect(self._timer_videofeed_anno.stop)\n    self._timer_videofeed_anno.start()\n\n    self._init_worker()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning","title":"<code>Wdg_Calibration_Finetuning</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Sub-frame for calibration adjustment to be used in the ROI_definition_controller</p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>class Wdg_Calibration_Finetuning(qw.QWidget):\n    \"\"\"\n    Sub-frame for calibration adjustment to be used in the ROI_definition_controller\n    \"\"\"\n    def __init__(self, parent, processor:mpp.Pool, imgUnit_getter:Callable[[],MeaImg_Unit|None],\n        getter_flipx:Callable[[],bool]=lambda:False, getter_flipy:Callable[[],bool]=lambda:False):\n        \"\"\"\n        Args:\n            main (tk.Frame): Main frame to put the sub-frame in\n            imgUnit_getter (Callable): Callable to get the measurement image\n        \"\"\"\n        super().__init__(parent)\n        self._processor = processor\n\n    # &gt;&gt;&gt; Image file handler &lt;&lt;&lt;\n        assert callable(imgUnit_getter), 'Measurement image getter must be a callable'\n        self._getter_measurement_image = imgUnit_getter\n        self._getter_flipx = getter_flipx\n        self._getter_flipy = getter_flipy\n\n        self._handler_img = MeaImg_Handler()\n        self._lastDirPath = SaveParamsEnum.DEFAULT_SAVE_PATH.value\n\n    # &gt;&gt; Main widget setup &lt;&lt;\n        self._widget = Calibration_Finetune_Design(self)\n        lyt = qw.QVBoxLayout(self)\n        lyt.addWidget(self._widget)\n        self.setLayout(lyt)\n        wdg = self._widget\n\n    # &gt;&gt; Calibration &lt;&lt;\n    # Auto calibration process related\n        # Calibration objects\n        self._cal_ori:ImgMea_Cal|None = None\n        self._cal_temp:ImgMea_Cal|None = None\n        self._cal_last:ImgMea_Cal|None = None\n\n        # Calibration parameters\n        self._cal_sclx = wdg.spin_scalex\n        self._cal_scly = wdg.spin_scaley\n        self._cal_offsetx = wdg.spin_offsetx\n        self._cal_offsety = wdg.spin_offsety\n        self._cal_rot_deg = wdg.spin_rotdeg\n\n        # Buttons for auto calibration\n        self._btn_calibrate = wdg.btn_calibrate\n        self._btn_calibrate.clicked.connect(lambda: None)\n        self._btn_loadCalibrationFile = wdg.btn_loadcal\n        self._btn_saveCalibrationFile = wdg.btn_savecal\n\n        self._btn_loadCalibrationFile.clicked.connect(lambda: self._load_calibration_file())\n        self._btn_saveCalibrationFile.clicked.connect(lambda: self._save_calibration_file())\n\n        # Label to display the calibration filename\n        self._lbl_calibration = wdg.lbl_calfile\n\n    # Manual calibration process related\n        # Widgets for manual calibration\n        self._btn_cal_finetune = wdg.btn_perform_finetune\n        self._btn_cal_finetune.clicked.connect(lambda: None)\n        self._spin_sclx = wdg.spin_scalex\n        self._spin_scly = wdg.spin_scaley\n        self._spin_offsetx = wdg.spin_offsetx\n        self._spin_offsety = wdg.spin_offsety\n        self._spin_rotdeg = wdg.spin_rotdeg\n\n    def initialise_fineadjuster(self) -&gt; None:\n        \"\"\"\n        Initialises the calibration parameters in the measurement image using\n        the calibration parameters stored in the image\n        \"\"\"\n        img_unit = self._getter_measurement_image()\n        assert img_unit is not None, 'Measurement image not initialised'\n        self._cal_ori = deepcopy(img_unit.get_ImageMeasurement_Calibration())\n        self._cal_temp = deepcopy(self._cal_ori)\n\n        assert isinstance(self._cal_ori, ImgMea_Cal), 'Calibration object not initialised'\n        assert self._cal_ori.check_calibration_set() == True, 'Calibration parameters not set'\n\n    def get_last_calibration(self) -&gt; ImgMea_Cal|None:\n        \"\"\"\n        Returns the last created calibration object\n\n        Returns:\n            ImageMeasurement_Calibration|None: Last calibration object or None if not initialised\n        \"\"\"\n        return self._cal_last\n\n    def finalise_fineadjustment(self,apply:bool=False) -&gt; None:\n        \"\"\"\n        Finalises the calibration parameters in the measurement image using\n        the calibration parameters stored in the temporary calibration object\n\n        Args:\n            apply (bool): Apply the calibration parameters to the measurement image. Default is False\n        \"\"\"\n        assert self._cal_temp is not None, 'Temporary calibration not initialised'\n\n        if apply:\n            meaImg = self._getter_measurement_image()\n            if not isinstance(meaImg, MeaImg_Unit): raise ValueError('Measurement image not initialised')\n            meaImg.set_calibration_ImageMeasurement_Calibration(self._cal_temp)\n\n        self._cal_last = deepcopy(self._cal_temp)\n        self._cal_temp = None\n        self._cal_ori = None\n\n        self.reset_calibrationSpinbox_values()\n        self._disable_finetuneCalibration_widgets()\n\n    def apply_temp_fineadjustment(self) -&gt; None:\n        \"\"\"\n        Updates the calibration parameters in the measurement image using\n        the calibration parameters in the spinbox widgets\n        \"\"\"\n        assert self._cal_temp is not None and self._cal_ori is not None, 'Calibration parameters not initialised'\n\n        img_cal = self._cal_ori\n        sclx = img_cal.scale_x_pixelPerMm\n        scly = img_cal.scale_y_pixelPerMm\n        offsetx = img_cal.laser_coor_x_mm\n        offsety = img_cal.laser_coor_y_mm\n        rot_rad = img_cal.rotation_rad\n\n        # Get the calibration parameters in percentage and degrees\n        sclx_rel,scly_rel,offsetx_rel,offsety_rel,rotdeg_rel = self.get_calibration_params_percent()\n\n        # Update the calibration parameters\n        sclx += sclx_rel/100 * sclx\n        scly += scly_rel/100 * scly\n        offsetx += offsetx_rel/100 * offsetx\n        offsety += offsety_rel/100 * offsety\n        rot_rad += np.deg2rad(rotdeg_rel)\n\n        # Setup a new calibration object\n        id = img_cal.id + f'_finetuned_{get_timestamp_sec()}'\n        self._cal_temp = ImgMea_Cal(id=id)\n        self._cal_temp.set_calibration_params(\n            scale_x_pixelPerMm=sclx,\n            scale_y_pixelPerMm=scly,\n            laser_coor_x_mm=offsetx,\n            laser_coor_y_mm=offsety,\n            rotation_rad=rot_rad,\n            flip_y=img_cal.flip_y,\n        )\n\n        # Update the calibration parameters in the measurement image\n        img_unit = self._getter_measurement_image()\n        if not isinstance(img_unit, MeaImg_Unit): raise ValueError('Measurement image not initialised')\n        img_unit.set_calibration_ImageMeasurement_Calibration(self._cal_temp)\n\n    def _disable_finetuneCalibration_widgets(self) -&gt; None:\n        \"\"\"\n        Disables the calibration widgets\n        \"\"\"\n        widgets = get_all_widgets_from_layout(self._widget.lyt_finetune_spins)\n        [widget.setEnabled(False) for widget in widgets if isinstance(widget, qw.QDoubleSpinBox)]\n\n    def enable_finetuneCalibration_widgets(self,callback:Callable|None=None,readonly:bool=True) -&gt; None:\n        \"\"\"\n        Configures the calibration widgets\n\n        Args:\n            callback (Callable): Callback function for the finetune calibration button. Default is None\n            readonly (bool): Set the calibration widgets to read-only. Default is True\n\n        Note:\n            - If callback is None, the callback will default to changing the calibration parameters\n                in the measurement image from the getter provided in the constructor\n        \"\"\"\n        if callback is None: callback = self.apply_temp_fineadjustment\n\n        widgets = get_all_widgets_from_layout(self._widget.lyt_finetune_spins)\n        widgets = [widget for widget in widgets if isinstance(widget, qw.QDoubleSpinBox)]\n        for widget in widgets:\n            widget.setReadOnly(not readonly)\n            widget.setEnabled(True)\n            widget.valueChanged.connect(callback)\n\n    def config_finetune_calibration_button(self,callback:Callable,text:str='Finetune calibration',enabled:bool=True) -&gt; None:\n        \"\"\"\n        Sets the text of the finetune calibration button\n\n        Args:\n            callback (Callable): Callback function for the finetune calibration button\n            text (str): Text to be displayed on the finetune calibration button. Default is 'Finetune calibration'\n            enabled (bool): Enable the finetune calibration button. Default is True\n        \"\"\"\n        assert isinstance(text, str), 'Text must be a string'\n\n        try: self._btn_cal_finetune.clicked.disconnect()\n        except RuntimeWarning: pass\n        self._btn_cal_finetune.setEnabled(enabled)\n        self._btn_cal_finetune.setText(text)\n        self._btn_cal_finetune.clicked.connect(callback)\n\n    def config_calibrate_button(self,callback:Callable,text:str='Calibrate',enabled:bool=True) -&gt; None:\n        \"\"\"\n        Sets the text of the calibrate button\n\n        Args:\n            callback (Callable): Callback function for the calibrate button\n            text (str): Text to be displayed on the calibrate button. Default is 'Calibrate'\n            enabled (bool): Enable the calibrate button. Default is True\n        \"\"\"\n        if not isinstance(text, str): raise ValueError('Text must be a string')\n\n        try: self._btn_calibrate.clicked.disconnect()\n        except RuntimeWarning: pass\n        self._btn_calibrate.setEnabled(enabled)\n        self._btn_calibrate.setText(text)\n        self._btn_calibrate.clicked.connect(callback)\n\n    def get_calibration_params_percent(self) -&gt; tuple[float,float,float,float,float]:\n        \"\"\"\n        Returns the calibration parameters in percentage and in degrees\n\n        Returns:\n            tuple[float,float,float,float,float]: Calibration parameters in the order (scl_x,scl_y,offset_x,offset_y,rot_deg)\n        \"\"\"\n\n        return self._cal_sclx.value(),self._cal_scly.value(),self._cal_offsetx.value(),self._cal_offsety.value(),self._cal_rot_deg.value()\n\n    def reset_calibrationSpinbox_values(self) -&gt; None:\n        \"\"\"Resets the calibration parameters\"\"\"\n        self._cal_sclx.setValue(0.0)\n        self._cal_scly.setValue(0.0)\n        self._cal_offsetx.setValue(0.0)\n        self._cal_offsety.setValue(0.0)\n        self._cal_rot_deg.setValue(0.0)\n\n    def _load_calibration_file(self):\n        \"\"\"\n        Loads the calibration file\n        \"\"\"\n        ori_text = self._btn_loadCalibrationFile.text()\n        try:\n            self._btn_loadCalibrationFile.setEnabled(False)\n            self._btn_loadCalibrationFile.setText('Loading...')\n\n            mea_img = self._getter_measurement_image()\n            img_cal = self._handler_img.load_calibration_json()\n            if img_cal is None: raise ValueError('No calibration file loaded')\n\n            if not isinstance(mea_img, MeaImg_Unit): raise ValueError('Measurement image not initialised')\n            mea_img.set_calibration_ImageMeasurement_Calibration(img_cal)\n\n            self._cal_filename = img_cal.id\n            self._lbl_calibration.setText('Objective: {}'.format(self._cal_filename))\n\n        except Exception as e:\n            qw.QMessageBox.warning(self,'Error loading objective file',str(e))\n            print('_load_calibration_file &gt;&gt; Error loading objective file:',e)\n        finally:\n            self._btn_loadCalibrationFile.setEnabled(True)\n            self._btn_loadCalibrationFile.setText(ori_text)\n\n    def _save_calibration_file(self):\n        \"\"\"\n        Saves the calibration file\n        \"\"\"\n        ori_text = self._btn_saveCalibrationFile.text()\n        try:\n            self._btn_saveCalibrationFile.setEnabled(False)\n            self._btn_saveCalibrationFile.setText('Saving...')\n\n            mea_img = self._getter_measurement_image()\n            assert isinstance(mea_img, MeaImg_Unit), 'Measurement image not initialised'\n\n            result = self._handler_img.save_calibration_json_from_ImgMea(mea_img)\n            self._lastDirPath,self._cal_filename = result\n            self._lbl_calibration.setText('Objective: {}'.format(self._cal_filename))\n\n        except Exception as e: print('_save_calibration_file &gt;&gt; Error saving objective file:',e)\n        finally:\n            self._btn_saveCalibrationFile.setEnabled(True)\n            self._btn_saveCalibrationFile.setText(ori_text)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.__init__","title":"<code>__init__(parent, processor, imgUnit_getter, getter_flipx=lambda: False, getter_flipy=lambda: False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>main</code> <code>Frame</code> <p>Main frame to put the sub-frame in</p> required <code>imgUnit_getter</code> <code>Callable</code> <p>Callable to get the measurement image</p> required Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def __init__(self, parent, processor:mpp.Pool, imgUnit_getter:Callable[[],MeaImg_Unit|None],\n    getter_flipx:Callable[[],bool]=lambda:False, getter_flipy:Callable[[],bool]=lambda:False):\n    \"\"\"\n    Args:\n        main (tk.Frame): Main frame to put the sub-frame in\n        imgUnit_getter (Callable): Callable to get the measurement image\n    \"\"\"\n    super().__init__(parent)\n    self._processor = processor\n\n# &gt;&gt;&gt; Image file handler &lt;&lt;&lt;\n    assert callable(imgUnit_getter), 'Measurement image getter must be a callable'\n    self._getter_measurement_image = imgUnit_getter\n    self._getter_flipx = getter_flipx\n    self._getter_flipy = getter_flipy\n\n    self._handler_img = MeaImg_Handler()\n    self._lastDirPath = SaveParamsEnum.DEFAULT_SAVE_PATH.value\n\n# &gt;&gt; Main widget setup &lt;&lt;\n    self._widget = Calibration_Finetune_Design(self)\n    lyt = qw.QVBoxLayout(self)\n    lyt.addWidget(self._widget)\n    self.setLayout(lyt)\n    wdg = self._widget\n\n# &gt;&gt; Calibration &lt;&lt;\n# Auto calibration process related\n    # Calibration objects\n    self._cal_ori:ImgMea_Cal|None = None\n    self._cal_temp:ImgMea_Cal|None = None\n    self._cal_last:ImgMea_Cal|None = None\n\n    # Calibration parameters\n    self._cal_sclx = wdg.spin_scalex\n    self._cal_scly = wdg.spin_scaley\n    self._cal_offsetx = wdg.spin_offsetx\n    self._cal_offsety = wdg.spin_offsety\n    self._cal_rot_deg = wdg.spin_rotdeg\n\n    # Buttons for auto calibration\n    self._btn_calibrate = wdg.btn_calibrate\n    self._btn_calibrate.clicked.connect(lambda: None)\n    self._btn_loadCalibrationFile = wdg.btn_loadcal\n    self._btn_saveCalibrationFile = wdg.btn_savecal\n\n    self._btn_loadCalibrationFile.clicked.connect(lambda: self._load_calibration_file())\n    self._btn_saveCalibrationFile.clicked.connect(lambda: self._save_calibration_file())\n\n    # Label to display the calibration filename\n    self._lbl_calibration = wdg.lbl_calfile\n\n# Manual calibration process related\n    # Widgets for manual calibration\n    self._btn_cal_finetune = wdg.btn_perform_finetune\n    self._btn_cal_finetune.clicked.connect(lambda: None)\n    self._spin_sclx = wdg.spin_scalex\n    self._spin_scly = wdg.spin_scaley\n    self._spin_offsetx = wdg.spin_offsetx\n    self._spin_offsety = wdg.spin_offsety\n    self._spin_rotdeg = wdg.spin_rotdeg\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.apply_temp_fineadjustment","title":"<code>apply_temp_fineadjustment()</code>","text":"<p>Updates the calibration parameters in the measurement image using the calibration parameters in the spinbox widgets</p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def apply_temp_fineadjustment(self) -&gt; None:\n    \"\"\"\n    Updates the calibration parameters in the measurement image using\n    the calibration parameters in the spinbox widgets\n    \"\"\"\n    assert self._cal_temp is not None and self._cal_ori is not None, 'Calibration parameters not initialised'\n\n    img_cal = self._cal_ori\n    sclx = img_cal.scale_x_pixelPerMm\n    scly = img_cal.scale_y_pixelPerMm\n    offsetx = img_cal.laser_coor_x_mm\n    offsety = img_cal.laser_coor_y_mm\n    rot_rad = img_cal.rotation_rad\n\n    # Get the calibration parameters in percentage and degrees\n    sclx_rel,scly_rel,offsetx_rel,offsety_rel,rotdeg_rel = self.get_calibration_params_percent()\n\n    # Update the calibration parameters\n    sclx += sclx_rel/100 * sclx\n    scly += scly_rel/100 * scly\n    offsetx += offsetx_rel/100 * offsetx\n    offsety += offsety_rel/100 * offsety\n    rot_rad += np.deg2rad(rotdeg_rel)\n\n    # Setup a new calibration object\n    id = img_cal.id + f'_finetuned_{get_timestamp_sec()}'\n    self._cal_temp = ImgMea_Cal(id=id)\n    self._cal_temp.set_calibration_params(\n        scale_x_pixelPerMm=sclx,\n        scale_y_pixelPerMm=scly,\n        laser_coor_x_mm=offsetx,\n        laser_coor_y_mm=offsety,\n        rotation_rad=rot_rad,\n        flip_y=img_cal.flip_y,\n    )\n\n    # Update the calibration parameters in the measurement image\n    img_unit = self._getter_measurement_image()\n    if not isinstance(img_unit, MeaImg_Unit): raise ValueError('Measurement image not initialised')\n    img_unit.set_calibration_ImageMeasurement_Calibration(self._cal_temp)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.config_calibrate_button","title":"<code>config_calibrate_button(callback, text='Calibrate', enabled=True)</code>","text":"<p>Sets the text of the calibrate button</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>Callback function for the calibrate button</p> required <code>text</code> <code>str</code> <p>Text to be displayed on the calibrate button. Default is 'Calibrate'</p> <code>'Calibrate'</code> <code>enabled</code> <code>bool</code> <p>Enable the calibrate button. Default is True</p> <code>True</code> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def config_calibrate_button(self,callback:Callable,text:str='Calibrate',enabled:bool=True) -&gt; None:\n    \"\"\"\n    Sets the text of the calibrate button\n\n    Args:\n        callback (Callable): Callback function for the calibrate button\n        text (str): Text to be displayed on the calibrate button. Default is 'Calibrate'\n        enabled (bool): Enable the calibrate button. Default is True\n    \"\"\"\n    if not isinstance(text, str): raise ValueError('Text must be a string')\n\n    try: self._btn_calibrate.clicked.disconnect()\n    except RuntimeWarning: pass\n    self._btn_calibrate.setEnabled(enabled)\n    self._btn_calibrate.setText(text)\n    self._btn_calibrate.clicked.connect(callback)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.config_finetune_calibration_button","title":"<code>config_finetune_calibration_button(callback, text='Finetune calibration', enabled=True)</code>","text":"<p>Sets the text of the finetune calibration button</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>Callback function for the finetune calibration button</p> required <code>text</code> <code>str</code> <p>Text to be displayed on the finetune calibration button. Default is 'Finetune calibration'</p> <code>'Finetune calibration'</code> <code>enabled</code> <code>bool</code> <p>Enable the finetune calibration button. Default is True</p> <code>True</code> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def config_finetune_calibration_button(self,callback:Callable,text:str='Finetune calibration',enabled:bool=True) -&gt; None:\n    \"\"\"\n    Sets the text of the finetune calibration button\n\n    Args:\n        callback (Callable): Callback function for the finetune calibration button\n        text (str): Text to be displayed on the finetune calibration button. Default is 'Finetune calibration'\n        enabled (bool): Enable the finetune calibration button. Default is True\n    \"\"\"\n    assert isinstance(text, str), 'Text must be a string'\n\n    try: self._btn_cal_finetune.clicked.disconnect()\n    except RuntimeWarning: pass\n    self._btn_cal_finetune.setEnabled(enabled)\n    self._btn_cal_finetune.setText(text)\n    self._btn_cal_finetune.clicked.connect(callback)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.enable_finetuneCalibration_widgets","title":"<code>enable_finetuneCalibration_widgets(callback=None, readonly=True)</code>","text":"<p>Configures the calibration widgets</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>Callback function for the finetune calibration button. Default is None</p> <code>None</code> <code>readonly</code> <code>bool</code> <p>Set the calibration widgets to read-only. Default is True</p> <code>True</code> Note <ul> <li>If callback is None, the callback will default to changing the calibration parameters     in the measurement image from the getter provided in the constructor</li> </ul> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def enable_finetuneCalibration_widgets(self,callback:Callable|None=None,readonly:bool=True) -&gt; None:\n    \"\"\"\n    Configures the calibration widgets\n\n    Args:\n        callback (Callable): Callback function for the finetune calibration button. Default is None\n        readonly (bool): Set the calibration widgets to read-only. Default is True\n\n    Note:\n        - If callback is None, the callback will default to changing the calibration parameters\n            in the measurement image from the getter provided in the constructor\n    \"\"\"\n    if callback is None: callback = self.apply_temp_fineadjustment\n\n    widgets = get_all_widgets_from_layout(self._widget.lyt_finetune_spins)\n    widgets = [widget for widget in widgets if isinstance(widget, qw.QDoubleSpinBox)]\n    for widget in widgets:\n        widget.setReadOnly(not readonly)\n        widget.setEnabled(True)\n        widget.valueChanged.connect(callback)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.finalise_fineadjustment","title":"<code>finalise_fineadjustment(apply=False)</code>","text":"<p>Finalises the calibration parameters in the measurement image using the calibration parameters stored in the temporary calibration object</p> <p>Parameters:</p> Name Type Description Default <code>apply</code> <code>bool</code> <p>Apply the calibration parameters to the measurement image. Default is False</p> <code>False</code> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def finalise_fineadjustment(self,apply:bool=False) -&gt; None:\n    \"\"\"\n    Finalises the calibration parameters in the measurement image using\n    the calibration parameters stored in the temporary calibration object\n\n    Args:\n        apply (bool): Apply the calibration parameters to the measurement image. Default is False\n    \"\"\"\n    assert self._cal_temp is not None, 'Temporary calibration not initialised'\n\n    if apply:\n        meaImg = self._getter_measurement_image()\n        if not isinstance(meaImg, MeaImg_Unit): raise ValueError('Measurement image not initialised')\n        meaImg.set_calibration_ImageMeasurement_Calibration(self._cal_temp)\n\n    self._cal_last = deepcopy(self._cal_temp)\n    self._cal_temp = None\n    self._cal_ori = None\n\n    self.reset_calibrationSpinbox_values()\n    self._disable_finetuneCalibration_widgets()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.get_calibration_params_percent","title":"<code>get_calibration_params_percent()</code>","text":"<p>Returns the calibration parameters in percentage and in degrees</p> <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float]</code> <p>tuple[float,float,float,float,float]: Calibration parameters in the order (scl_x,scl_y,offset_x,offset_y,rot_deg)</p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def get_calibration_params_percent(self) -&gt; tuple[float,float,float,float,float]:\n    \"\"\"\n    Returns the calibration parameters in percentage and in degrees\n\n    Returns:\n        tuple[float,float,float,float,float]: Calibration parameters in the order (scl_x,scl_y,offset_x,offset_y,rot_deg)\n    \"\"\"\n\n    return self._cal_sclx.value(),self._cal_scly.value(),self._cal_offsetx.value(),self._cal_offsety.value(),self._cal_rot_deg.value()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.get_last_calibration","title":"<code>get_last_calibration()</code>","text":"<p>Returns the last created calibration object</p> <p>Returns:</p> Type Description <code>ImgMea_Cal | None</code> <p>ImageMeasurement_Calibration|None: Last calibration object or None if not initialised</p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def get_last_calibration(self) -&gt; ImgMea_Cal|None:\n    \"\"\"\n    Returns the last created calibration object\n\n    Returns:\n        ImageMeasurement_Calibration|None: Last calibration object or None if not initialised\n    \"\"\"\n    return self._cal_last\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.initialise_fineadjuster","title":"<code>initialise_fineadjuster()</code>","text":"<p>Initialises the calibration parameters in the measurement image using the calibration parameters stored in the image</p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def initialise_fineadjuster(self) -&gt; None:\n    \"\"\"\n    Initialises the calibration parameters in the measurement image using\n    the calibration parameters stored in the image\n    \"\"\"\n    img_unit = self._getter_measurement_image()\n    assert img_unit is not None, 'Measurement image not initialised'\n    self._cal_ori = deepcopy(img_unit.get_ImageMeasurement_Calibration())\n    self._cal_temp = deepcopy(self._cal_ori)\n\n    assert isinstance(self._cal_ori, ImgMea_Cal), 'Calibration object not initialised'\n    assert self._cal_ori.check_calibration_set() == True, 'Calibration parameters not set'\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.Wdg_Calibration_Finetuning.reset_calibrationSpinbox_values","title":"<code>reset_calibrationSpinbox_values()</code>","text":"<p>Resets the calibration parameters</p> Source code in <code>iris/gui/image_calibration/objective_calibration.py</code> <pre><code>def reset_calibrationSpinbox_values(self) -&gt; None:\n    \"\"\"Resets the calibration parameters\"\"\"\n    self._cal_sclx.setValue(0.0)\n    self._cal_scly.setValue(0.0)\n    self._cal_offsetx.setValue(0.0)\n    self._cal_offsety.setValue(0.0)\n    self._cal_rot_deg.setValue(0.0)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/objective_calibration/#iris.gui.image_calibration.objective_calibration.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/","title":"plotter_heatmap_overlay","text":""},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.ImageProcessor_Worker","title":"<code>ImageProcessor_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Worker class to process images in a separate thread</p> Source code in <code>iris/gui/image_calibration/plotter_heatmap_overlay.py</code> <pre><code>class ImageProcessor_Worker(QObject):\n    \"\"\"\n    Worker class to process images in a separate thread\n    \"\"\"\n    sig_finished = Signal()\n    def __init__(self, plotter:MappingPlotter_ImageOverlay):\n        super().__init__()\n        self._plotter = plotter\n\n    @Slot(MeaImg_Unit,bool)\n    def overlay_stitched_image(self, imgUnit:MeaImg_Unit, low_res:bool) -&gt; None:\n        \"\"\"\n        Get the stitched image from the ImageUnit\n\n        Args:\n            imgUnit (MeaImg_Unit): Image unit to process\n            low_res (bool): Whether to get low resolution image\n        \"\"\"\n        try:\n            img_stitched,img_stitched_limit_min,img_stitched_limit_max =\\\n                imgUnit.get_image_all_stitched(low_res=low_res)\n\n            img_stitched_extent = (\n                min(img_stitched_limit_min[0],img_stitched_limit_max[0]),\n                max(img_stitched_limit_max[0],img_stitched_limit_min[0]),\n                min(img_stitched_limit_min[1],img_stitched_limit_max[1]),\n                max(img_stitched_limit_max[1],img_stitched_limit_min[1])\n            )\n\n            self._plotter.overlay_image(image=img_stitched,extent=img_stitched_extent)\n            self.sig_finished.emit()\n        except Exception as e:\n            print('Error in get_stitched_image:', e)\n            self.sig_finished.emit()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.ImageProcessor_Worker.overlay_stitched_image","title":"<code>overlay_stitched_image(imgUnit, low_res)</code>","text":"<p>Get the stitched image from the ImageUnit</p> <p>Parameters:</p> Name Type Description Default <code>imgUnit</code> <code>MeaImg_Unit</code> <p>Image unit to process</p> required <code>low_res</code> <code>bool</code> <p>Whether to get low resolution image</p> required Source code in <code>iris/gui/image_calibration/plotter_heatmap_overlay.py</code> <pre><code>@Slot(MeaImg_Unit,bool)\ndef overlay_stitched_image(self, imgUnit:MeaImg_Unit, low_res:bool) -&gt; None:\n    \"\"\"\n    Get the stitched image from the ImageUnit\n\n    Args:\n        imgUnit (MeaImg_Unit): Image unit to process\n        low_res (bool): Whether to get low resolution image\n    \"\"\"\n    try:\n        img_stitched,img_stitched_limit_min,img_stitched_limit_max =\\\n            imgUnit.get_image_all_stitched(low_res=low_res)\n\n        img_stitched_extent = (\n            min(img_stitched_limit_min[0],img_stitched_limit_max[0]),\n            max(img_stitched_limit_max[0],img_stitched_limit_min[0]),\n            min(img_stitched_limit_min[1],img_stitched_limit_max[1]),\n            max(img_stitched_limit_max[1],img_stitched_limit_min[1])\n        )\n\n        self._plotter.overlay_image(image=img_stitched,extent=img_stitched_extent)\n        self.sig_finished.emit()\n    except Exception as e:\n        print('Error in get_stitched_image:', e)\n        self.sig_finished.emit()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.MappingPlotter_ImageOverlay","title":"<code>MappingPlotter_ImageOverlay</code>","text":"<p>               Bases: <code>MeaRMap_Plotter</code></p> <p>A modified version of the raman_plot class to allow image overlay on the heatmap plot function</p> Source code in <code>iris/gui/image_calibration/plotter_heatmap_overlay.py</code> <pre><code>class MappingPlotter_ImageOverlay(MeaRMap_Plotter):\n    \"\"\"\n    A modified version of the raman_plot class to allow image overlay on the heatmap\n    plot function\n    \"\"\"\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    def overlay_image(self, image: Image.Image, extent:tuple[float,float,float,float],\n                      callback=None) -&gt; None:\n        \"\"\"\n        Overlay an image on the heatmap plot\n\n        Args:\n            ax (Axes): Axis object to plot the image\n            image (Image.Image): Image object to overlay\n            extent (tuple): Extent of the image in the plot (left,right,bottom,top) coordinates\n        \"\"\"\n        assert isinstance(image,Image.Image), \"Invalid image object.\"\n        assert isinstance(extent,tuple) and len(extent)==4, \"Invalid extent object.\"\n\n        ax = self._ax\n\n        # Get current min and max values\n        x_min, x_max = ax.get_xlim()\n        y_min, y_max = ax.get_ylim()\n\n        x_min_all = min(x_min, min(extent[0], extent[1]))\n        y_min_all = min(y_min, min(extent[2], extent[3]))\n        x_max_all = max(x_max, max(extent[0], extent[1]))\n        y_max_all = max(y_max, max(extent[2], extent[3]))\n\n        ax.imshow(image, extent=extent, interpolation='lanczos')\n\n        ax.set_xlim(x_min_all, x_max_all)\n        ax.set_ylim(y_min_all, y_max_all)\n        ax.set_aspect(AppPlotEnum.PLT_ASPECT.value)\n\n        # Callback function\n        if callback is not None: callback()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.MappingPlotter_ImageOverlay.overlay_image","title":"<code>overlay_image(image, extent, callback=None)</code>","text":"<p>Overlay an image on the heatmap plot</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axis object to plot the image</p> required <code>image</code> <code>Image</code> <p>Image object to overlay</p> required <code>extent</code> <code>tuple</code> <p>Extent of the image in the plot (left,right,bottom,top) coordinates</p> required Source code in <code>iris/gui/image_calibration/plotter_heatmap_overlay.py</code> <pre><code>def overlay_image(self, image: Image.Image, extent:tuple[float,float,float,float],\n                  callback=None) -&gt; None:\n    \"\"\"\n    Overlay an image on the heatmap plot\n\n    Args:\n        ax (Axes): Axis object to plot the image\n        image (Image.Image): Image object to overlay\n        extent (tuple): Extent of the image in the plot (left,right,bottom,top) coordinates\n    \"\"\"\n    assert isinstance(image,Image.Image), \"Invalid image object.\"\n    assert isinstance(extent,tuple) and len(extent)==4, \"Invalid extent object.\"\n\n    ax = self._ax\n\n    # Get current min and max values\n    x_min, x_max = ax.get_xlim()\n    y_min, y_max = ax.get_ylim()\n\n    x_min_all = min(x_min, min(extent[0], extent[1]))\n    y_min_all = min(y_min, min(extent[2], extent[3]))\n    x_max_all = max(x_max, max(extent[0], extent[1]))\n    y_max_all = max(y_max, max(extent[2], extent[3]))\n\n    ax.imshow(image, extent=extent, interpolation='lanczos')\n\n    ax.set_xlim(x_min_all, x_max_all)\n    ax.set_ylim(y_min_all, y_max_all)\n    ax.set_aspect(AppPlotEnum.PLT_ASPECT.value)\n\n    # Callback function\n    if callback is not None: callback()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.Wdg_HeatmapOverlay","title":"<code>Wdg_HeatmapOverlay</code>","text":"<p>               Bases: <code>Wdg_MappingMeasurement_Plotter</code>, <code>QWidget</code></p> <p>A modified version of the plot_mapping_measurements class to allow image overlay on the heatmap</p> Source code in <code>iris/gui/image_calibration/plotter_heatmap_overlay.py</code> <pre><code>class Wdg_HeatmapOverlay(Wdg_MappingMeasurement_Plotter, qw.QWidget):\n    \"\"\"\n    A modified version of the plot_mapping_measurements class to allow image overlay\n    on the heatmap\n    \"\"\"\n\n    sig_update_img_combobox = Signal()\n    sig_update_plot_overlay = Signal()\n\n    sig_overlay_stitched_image = Signal(MeaImg_Unit,bool)\n\n    def __init__(\n        self,\n        parent:qw.QWidget,\n        processor:mpp.Pool,\n        mappingHub:MeaRMap_Hub,\n        imghub_getter:Callable[[],MeaImg_Hub],\n        dataHub_imgcal:Wdg_DataHub_ImgCal,\n        figsize_pxl:tuple=(440,400)):\n        \"\"\"\n        Args:\n            master (tk.Frame): Master frame to put the sub-frames in\n            processor (multiprocessing.pool.Pool): Processor to handle the data\n            mappingHub (MappingMeasurement_Hub): Mapping measurement hub object\n            imghub_getter (Callable): Callable to get the ImageMeasurement_Hub object\n            dataHub_imgcal (Frm_DataHub_ImgCal): Image calibration data hub\n            figsize_pxl (tuple): Figure size in pixels\n\n        Note:\n            The mea_img_getter is not implemented yet and will be used along with a DataHub_Image, a \n            class to handle the image measurement management.\n        \"\"\"\n        self._processor = processor\n        self._getter_imghub = imghub_getter\n        self._mappingHub = mappingHub\n        self._dataHub_imgcal = dataHub_imgcal\n\n        # &gt;&gt;&gt; Main widget setup &lt;&lt;&lt;\n        self._widget_overlay = HeatmapOverlay_Design(parent)\n        wdg_ovl = self._widget_overlay\n        super().__init__(parent=parent, mappingHub=self._mappingHub, layout=wdg_ovl.lyt_holder_plotter)\n\n        lyt = qw.QVBoxLayout()\n        lyt.addWidget(self._widget_overlay)\n        self.setLayout(lyt)\n\n        # Parameters to control the plots\n        self._alpha = 0.5\n\n        # Plotter\n        self._plotter = MappingPlotter_ImageOverlay()\n\n    # &gt;&gt;&gt; Calibration fine-tuning widgets &lt;&lt;&lt;\n        self._frm_calAdjust = Wdg_Calibration_Finetuning(\n            parent=self,\n            processor=self._processor,\n            imgUnit_getter=self._get_ImageUnit,\n            )\n        wdg_ovl.lyt_holder_finetuning.addWidget(self._frm_calAdjust)\n\n        # Set the behaviour of the calibration fine-tuning widgets\n        self._frm_calAdjust.config_calibrate_button(text='Disabled',enabled=False,callback=lambda:None)\n        self._frm_calAdjust.config_finetune_calibration_button(text='Finetune calibration',callback=self._finetune_calibration)\n\n    # &gt;&gt;&gt; Control widgets &lt;&lt;&lt;\n        self._combo_ImageUnits = wdg_ovl.combo_imgUnit\n        self._chk_lres = wdg_ovl.chk_lres\n\n        self._combo_ImageUnits.currentTextChanged.connect(self.plot_heatmap)\n        self._chk_lres.stateChanged.connect(self.plot_heatmap)\n        self._combo_plot_mappingUnitName.currentTextChanged.connect(self.plot_heatmap)\n        self._combo_plot_SpectralPosition.currentTextChanged.connect(self.plot_heatmap)\n        self._entry_plot_clim_min.editingFinished.connect(self.plot_heatmap)\n        self._entry_plot_clim_max.editingFinished.connect(self.plot_heatmap)\n        self._chk_auto_clim.stateChanged.connect(self.plot_heatmap)\n        self._entry_plot_xlim_max.editingFinished.connect(self.plot_heatmap)\n        self._entry_plot_xlim_min.editingFinished.connect(self.plot_heatmap)\n        self._entry_plot_ylim_max.editingFinished.connect(self.plot_heatmap)\n        self._entry_plot_ylim_min.editingFinished.connect(self.plot_heatmap)\n\n    # &gt;&gt;&gt; Signal connections &lt;&lt;&lt;\n        self._getter_imghub().add_observer(self.sig_update_img_combobox.emit)\n        self.sig_update_img_combobox.connect(self._update_img_combobox)\n        self.sig_update_plot_overlay.connect(self.plot_heatmap)\n\n    # &gt;&gt;&gt; Initialise the widgets &lt;&lt;&lt;\n        self._initialise_widgets()\n\n    def _initialise_widgets(self):\n        \"\"\"\n        Initialise the widgets\n        \"\"\"\n        self.sig_update_img_combobox.emit()\n\n    def _init_worker(self):\n        \"\"\"\n        Initialise the worker thread and object\n        \"\"\"\n        self._thread_worker = QThread()\n        self._worker = ImageProcessor_Worker(plotter=self._plotter)\n        self._worker.moveToThread(self._thread_worker)\n        self._thread_worker.start()\n\n        # Connect signals\n        self._worker.sig_finished.connect(self.handle_plot_overlay_finished)\n        self.sig_overlay_stitched_image.connect(self._worker.overlay_stitched_image)\n\n    @Slot()\n    def _update_img_combobox(self):\n        \"\"\"\n        Initialises the ImageMeasurementUnit selection combo box\n        \"\"\"\n        # Disable the combo box while updating\n        self._combo_ImageUnits.setEnabled(False)\n        self._combo_ImageUnits.blockSignals(True)\n\n        # Get the list of image units from the image measurement hub\n        imghub = self._getter_imghub()\n        if not isinstance(imghub,MeaImg_Hub): print('_initialise_img_combobox: Invalid image measurement hub object.'); return\n        list_imgUnit_ids = imghub.get_list_ImageUnit_ids()\n        dict_IDToName = imghub.get_dict_IDtoName()\n        list_imgUnits_name = [dict_IDToName[ID] for ID in list_imgUnit_ids]\n\n        # Update the combo box items while retaining the current selection if possible\n        current_name = self._combo_ImageUnits.currentText()\n        self._combo_ImageUnits.clear()\n        self._combo_ImageUnits.addItems(list_imgUnits_name)\n        if current_name in list_imgUnits_name:\n            self._combo_ImageUnits.setCurrentText(current_name)\n\n        # Re-enable the combo box\n        self._combo_ImageUnits.blockSignals(False)\n        self._combo_ImageUnits.setEnabled(True)\n\n    def _finetune_calibration(self) -&gt; None:\n        \"\"\"\n        Grabs the calibration fine-tuning data and updates the image measurement object\n        \"\"\"\n        meaImg = self._get_ImageUnit()\n        if not isinstance(meaImg,MeaImg_Unit): return\n\n        def apply_finetune_calibration():\n            \"\"\"Apply the calibration fine-tuning data\"\"\"\n            self._frm_calAdjust.apply_temp_fineadjustment()\n            self.sig_update_plot_overlay.emit()\n\n        self._frm_calAdjust.config_calibrate_button(text='Reset calibration',enabled=True,callback=\n                                                    self._frm_calAdjust.reset_calibrationSpinbox_values)\n        self._frm_calAdjust.config_finetune_calibration_button(text='Finish finetuning',callback=self.handle_finetuning_finished)\n        self._frm_calAdjust.initialise_fineadjuster()\n        self._frm_calAdjust.enable_finetuneCalibration_widgets(callback=apply_finetune_calibration)\n\n    @Slot()\n    def handle_finetuning_finished(self) -&gt; None:\n        # Ask the user to apply the calibration changes\n        flg_apply = qw.QMessageBox.question(self, 'Apply calibration', 'Apply the calibration changes?',\n            qw.QMessageBox.Yes | qw.QMessageBox.No) == qw.QMessageBox.Yes # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes exists\n\n        if not flg_apply: qw.QMessageBox.information(self, 'Calibration changes','Calibration changes are not applied.')\n        self._frm_calAdjust.finalise_fineadjustment(apply=flg_apply)\n\n        # Apply the calibration changes\n        flg_save = qw.QMessageBox.question(self, 'Save calibration', 'Save the calibration changes to the local disk?',\n            qw.QMessageBox.Yes | qw.QMessageBox.No) == qw.QMessageBox.Yes # pyright: ignore[reportAttributeAccessIssue] ; QMessageBox.Yes exists\n        if not flg_save: qw.QMessageBox.information(self, 'Calibration changes','Calibration changes are not saved.')\n        else:\n            new_cal = self._frm_calAdjust.get_last_calibration()\n            if not isinstance(new_cal,ImgMea_Cal):\n                qw.QMessageBox.critical(self, 'Save calibration','Failed to get the new calibration object.')\n                return\n            new_id = messagebox_request_input('Calibration ID','Enter the new calibration ID to save the calibration changes',default=new_cal.id)\n            if not isinstance(new_id,str) or new_id == '':\n                qw.QMessageBox.warning(self, 'Save calibration','Invalid calibration ID.')\n                return\n\n            new_cal.id = new_id\n            MeaImg_Handler().save_calibration_json(new_cal)\n\n    def reset_finetune_calibration_button(self) -&gt; None:\n        \"\"\"\n        Reset the calibration fine-tuning button to its default state\n        \"\"\"\n        self._frm_calAdjust.config_finetune_calibration_button(callback=self._finetune_calibration)\n\n    def _get_ImageUnit(self) -&gt; MeaImg_Unit|None:\n        \"\"\"\n        Get the ImageMeasurement_Unit object from the combo box selection\n        \"\"\"\n        hub = self._getter_imghub()\n        if not hub.check_measurement_exist(): return None\n\n        imgUnit_name = self._combo_ImageUnits.currentText()\n        dict_nameToID = hub.get_dict_nameToID()\n\n        if not imgUnit_name in dict_nameToID: return None\n        imgUnit_id = dict_nameToID[imgUnit_name]\n\n        return hub.get_ImageMeasurementUnit(unit_id=imgUnit_id)\n\n    @Slot()\n    def plot_heatmap(self) -&gt; None:\n        \"\"\"\n        Plot the heatmap with the image overlay.\n\n        Args:\n            measurement_img (image_measurement): Image measurement object. If none, the getter function will be used\n        \"\"\"\n        def correct_MappingMeasurementCoordinates(mapping_unit:MeaRMap_Unit,\n                measurement_img:MeaImg_Unit) -&gt; MeaRMap_Unit:\n            \"\"\"Correct the mapping measurement coordinates to match the image measurement\n            coordinates.\"\"\"\n            label_x,label_y,_,_,_ = mapping_unit.get_labels()\n            dict_measurement = mapping_unit.get_dict_measurements(copy=True)\n\n            list_coorx:list = dict_measurement[label_x]\n            list_coory:list = dict_measurement[label_y]\n\n            list_coor = [(coorx,coory) for coorx,coory in zip(list_coorx,list_coory)]\n            list_coor_corr = [measurement_img.convert_stg2mea(coor) for coor in list_coor]\n\n            list_coorx_corr = [coor[0] for coor in list_coor_corr]\n            list_coory_corr = [coor[1] for coor in list_coor_corr]\n\n            # Update the values in the list, which are referenced by the mapping unit measurement dict\n            list_coorx.clear()\n            list_coorx.extend(list_coorx_corr)\n            list_coory.clear()\n            list_coory.extend(list_coory_corr)\n\n            return mapping_unit\n\n        if self._isplotting: return\n        self._isplotting = True\n\n        mapping_hub = self._mappingHub\n        img_unit = self._get_ImageUnit()\n\n        if not isinstance(mapping_hub,MeaRMap_Hub): return\n        if not isinstance(img_unit,MeaImg_Unit): return\n\n        try:    # Get the stitched image, its limit, and rotation\n            flg_lowResImg = self._chk_lres.isChecked()\n        except Exception as e:\n            print('plot_heatmap:\\n',e)\n            return None\n\n        mappingUnit_name = self._combo_plot_mappingUnitName.currentText()\n        dict_nameToID = mapping_hub.get_dict_nameToID()\n        if not mappingUnit_name in dict_nameToID: return\n        mappingUnit_id = dict_nameToID[mappingUnit_name]\n        wavelength = self.get_current_wavelength()\n        if wavelength is None: return\n\n        mapping_unit_corr = mapping_hub.copy_mapping_unit(mappingUnit_id,mappingUnit_name+'_LaserCoorCorrected',appendToHub=False)\n\n        mapping_unit_corr = correct_MappingMeasurementCoordinates(\n            mapping_unit=mapping_unit_corr,\n            measurement_img=img_unit\n        )\n\n        _,laser_wavelength = mapping_unit_corr.get_laser_params()\n\n        try: clim_min = float(self._entry_plot_clim_min.text())\n        except: clim_min = None\n        try: clim_max = float(self._entry_plot_clim_max.text())\n        except: clim_max = None\n        clim = (clim_min,clim_max)\n        if self._chk_auto_clim.isChecked(): clim = (None,None)\n\n        try:\n            title = mapping_unit_corr.get_unit_name()+'\\n{:.0f}cm^-1 [{:.1f}nm]'.format(convert_wavelength_to_ramanshift(float(wavelength),laser_wavelength),\n                float(wavelength))\n            kwargs = self._get_plotter_kwargs()\n            self._func_current_plotter(\n                mapping_unit=mapping_unit_corr,\n                wavelength=wavelength,\n                clim=clim,\n                title=title,\n                **kwargs\n            )\n        except Exception as e:\n            print('plot_heatmap:\\n',e)\n            return None\n\n        self._plotter._ax.set_alpha(self._alpha)\n        self._set_plot_xylim()\n\n        self.sig_overlay_stitched_image.emit(img_unit, flg_lowResImg)\n\n    def handle_plot_overlay_finished(self) -&gt; None:\n        \"\"\"\n        Handle the plot overlay finished signal\n        \"\"\"\n        self._canvas_widget.draw_idle()\n        self._isplotting = False\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.Wdg_HeatmapOverlay.__init__","title":"<code>__init__(parent, processor, mappingHub, imghub_getter, dataHub_imgcal, figsize_pxl=(440, 400))</code>","text":"<p>Parameters:</p> Name Type Description Default <code>master</code> <code>Frame</code> <p>Master frame to put the sub-frames in</p> required <code>processor</code> <code>Pool</code> <p>Processor to handle the data</p> required <code>mappingHub</code> <code>MappingMeasurement_Hub</code> <p>Mapping measurement hub object</p> required <code>imghub_getter</code> <code>Callable</code> <p>Callable to get the ImageMeasurement_Hub object</p> required <code>dataHub_imgcal</code> <code>Frm_DataHub_ImgCal</code> <p>Image calibration data hub</p> required <code>figsize_pxl</code> <code>tuple</code> <p>Figure size in pixels</p> <code>(440, 400)</code> Note <p>The mea_img_getter is not implemented yet and will be used along with a DataHub_Image, a  class to handle the image measurement management.</p> Source code in <code>iris/gui/image_calibration/plotter_heatmap_overlay.py</code> <pre><code>def __init__(\n    self,\n    parent:qw.QWidget,\n    processor:mpp.Pool,\n    mappingHub:MeaRMap_Hub,\n    imghub_getter:Callable[[],MeaImg_Hub],\n    dataHub_imgcal:Wdg_DataHub_ImgCal,\n    figsize_pxl:tuple=(440,400)):\n    \"\"\"\n    Args:\n        master (tk.Frame): Master frame to put the sub-frames in\n        processor (multiprocessing.pool.Pool): Processor to handle the data\n        mappingHub (MappingMeasurement_Hub): Mapping measurement hub object\n        imghub_getter (Callable): Callable to get the ImageMeasurement_Hub object\n        dataHub_imgcal (Frm_DataHub_ImgCal): Image calibration data hub\n        figsize_pxl (tuple): Figure size in pixels\n\n    Note:\n        The mea_img_getter is not implemented yet and will be used along with a DataHub_Image, a \n        class to handle the image measurement management.\n    \"\"\"\n    self._processor = processor\n    self._getter_imghub = imghub_getter\n    self._mappingHub = mappingHub\n    self._dataHub_imgcal = dataHub_imgcal\n\n    # &gt;&gt;&gt; Main widget setup &lt;&lt;&lt;\n    self._widget_overlay = HeatmapOverlay_Design(parent)\n    wdg_ovl = self._widget_overlay\n    super().__init__(parent=parent, mappingHub=self._mappingHub, layout=wdg_ovl.lyt_holder_plotter)\n\n    lyt = qw.QVBoxLayout()\n    lyt.addWidget(self._widget_overlay)\n    self.setLayout(lyt)\n\n    # Parameters to control the plots\n    self._alpha = 0.5\n\n    # Plotter\n    self._plotter = MappingPlotter_ImageOverlay()\n\n# &gt;&gt;&gt; Calibration fine-tuning widgets &lt;&lt;&lt;\n    self._frm_calAdjust = Wdg_Calibration_Finetuning(\n        parent=self,\n        processor=self._processor,\n        imgUnit_getter=self._get_ImageUnit,\n        )\n    wdg_ovl.lyt_holder_finetuning.addWidget(self._frm_calAdjust)\n\n    # Set the behaviour of the calibration fine-tuning widgets\n    self._frm_calAdjust.config_calibrate_button(text='Disabled',enabled=False,callback=lambda:None)\n    self._frm_calAdjust.config_finetune_calibration_button(text='Finetune calibration',callback=self._finetune_calibration)\n\n# &gt;&gt;&gt; Control widgets &lt;&lt;&lt;\n    self._combo_ImageUnits = wdg_ovl.combo_imgUnit\n    self._chk_lres = wdg_ovl.chk_lres\n\n    self._combo_ImageUnits.currentTextChanged.connect(self.plot_heatmap)\n    self._chk_lres.stateChanged.connect(self.plot_heatmap)\n    self._combo_plot_mappingUnitName.currentTextChanged.connect(self.plot_heatmap)\n    self._combo_plot_SpectralPosition.currentTextChanged.connect(self.plot_heatmap)\n    self._entry_plot_clim_min.editingFinished.connect(self.plot_heatmap)\n    self._entry_plot_clim_max.editingFinished.connect(self.plot_heatmap)\n    self._chk_auto_clim.stateChanged.connect(self.plot_heatmap)\n    self._entry_plot_xlim_max.editingFinished.connect(self.plot_heatmap)\n    self._entry_plot_xlim_min.editingFinished.connect(self.plot_heatmap)\n    self._entry_plot_ylim_max.editingFinished.connect(self.plot_heatmap)\n    self._entry_plot_ylim_min.editingFinished.connect(self.plot_heatmap)\n\n# &gt;&gt;&gt; Signal connections &lt;&lt;&lt;\n    self._getter_imghub().add_observer(self.sig_update_img_combobox.emit)\n    self.sig_update_img_combobox.connect(self._update_img_combobox)\n    self.sig_update_plot_overlay.connect(self.plot_heatmap)\n\n# &gt;&gt;&gt; Initialise the widgets &lt;&lt;&lt;\n    self._initialise_widgets()\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.Wdg_HeatmapOverlay.handle_plot_overlay_finished","title":"<code>handle_plot_overlay_finished()</code>","text":"<p>Handle the plot overlay finished signal</p> Source code in <code>iris/gui/image_calibration/plotter_heatmap_overlay.py</code> <pre><code>def handle_plot_overlay_finished(self) -&gt; None:\n    \"\"\"\n    Handle the plot overlay finished signal\n    \"\"\"\n    self._canvas_widget.draw_idle()\n    self._isplotting = False\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.Wdg_HeatmapOverlay.plot_heatmap","title":"<code>plot_heatmap()</code>","text":"<p>Plot the heatmap with the image overlay.</p> <p>Parameters:</p> Name Type Description Default <code>measurement_img</code> <code>image_measurement</code> <p>Image measurement object. If none, the getter function will be used</p> required Source code in <code>iris/gui/image_calibration/plotter_heatmap_overlay.py</code> <pre><code>@Slot()\ndef plot_heatmap(self) -&gt; None:\n    \"\"\"\n    Plot the heatmap with the image overlay.\n\n    Args:\n        measurement_img (image_measurement): Image measurement object. If none, the getter function will be used\n    \"\"\"\n    def correct_MappingMeasurementCoordinates(mapping_unit:MeaRMap_Unit,\n            measurement_img:MeaImg_Unit) -&gt; MeaRMap_Unit:\n        \"\"\"Correct the mapping measurement coordinates to match the image measurement\n        coordinates.\"\"\"\n        label_x,label_y,_,_,_ = mapping_unit.get_labels()\n        dict_measurement = mapping_unit.get_dict_measurements(copy=True)\n\n        list_coorx:list = dict_measurement[label_x]\n        list_coory:list = dict_measurement[label_y]\n\n        list_coor = [(coorx,coory) for coorx,coory in zip(list_coorx,list_coory)]\n        list_coor_corr = [measurement_img.convert_stg2mea(coor) for coor in list_coor]\n\n        list_coorx_corr = [coor[0] for coor in list_coor_corr]\n        list_coory_corr = [coor[1] for coor in list_coor_corr]\n\n        # Update the values in the list, which are referenced by the mapping unit measurement dict\n        list_coorx.clear()\n        list_coorx.extend(list_coorx_corr)\n        list_coory.clear()\n        list_coory.extend(list_coory_corr)\n\n        return mapping_unit\n\n    if self._isplotting: return\n    self._isplotting = True\n\n    mapping_hub = self._mappingHub\n    img_unit = self._get_ImageUnit()\n\n    if not isinstance(mapping_hub,MeaRMap_Hub): return\n    if not isinstance(img_unit,MeaImg_Unit): return\n\n    try:    # Get the stitched image, its limit, and rotation\n        flg_lowResImg = self._chk_lres.isChecked()\n    except Exception as e:\n        print('plot_heatmap:\\n',e)\n        return None\n\n    mappingUnit_name = self._combo_plot_mappingUnitName.currentText()\n    dict_nameToID = mapping_hub.get_dict_nameToID()\n    if not mappingUnit_name in dict_nameToID: return\n    mappingUnit_id = dict_nameToID[mappingUnit_name]\n    wavelength = self.get_current_wavelength()\n    if wavelength is None: return\n\n    mapping_unit_corr = mapping_hub.copy_mapping_unit(mappingUnit_id,mappingUnit_name+'_LaserCoorCorrected',appendToHub=False)\n\n    mapping_unit_corr = correct_MappingMeasurementCoordinates(\n        mapping_unit=mapping_unit_corr,\n        measurement_img=img_unit\n    )\n\n    _,laser_wavelength = mapping_unit_corr.get_laser_params()\n\n    try: clim_min = float(self._entry_plot_clim_min.text())\n    except: clim_min = None\n    try: clim_max = float(self._entry_plot_clim_max.text())\n    except: clim_max = None\n    clim = (clim_min,clim_max)\n    if self._chk_auto_clim.isChecked(): clim = (None,None)\n\n    try:\n        title = mapping_unit_corr.get_unit_name()+'\\n{:.0f}cm^-1 [{:.1f}nm]'.format(convert_wavelength_to_ramanshift(float(wavelength),laser_wavelength),\n            float(wavelength))\n        kwargs = self._get_plotter_kwargs()\n        self._func_current_plotter(\n            mapping_unit=mapping_unit_corr,\n            wavelength=wavelength,\n            clim=clim,\n            title=title,\n            **kwargs\n        )\n    except Exception as e:\n        print('plot_heatmap:\\n',e)\n        return None\n\n    self._plotter._ax.set_alpha(self._alpha)\n    self._set_plot_xylim()\n\n    self.sig_overlay_stitched_image.emit(img_unit, flg_lowResImg)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.Wdg_HeatmapOverlay.reset_finetune_calibration_button","title":"<code>reset_finetune_calibration_button()</code>","text":"<p>Reset the calibration fine-tuning button to its default state</p> Source code in <code>iris/gui/image_calibration/plotter_heatmap_overlay.py</code> <pre><code>def reset_finetune_calibration_button(self) -&gt; None:\n    \"\"\"\n    Reset the calibration fine-tuning button to its default state\n    \"\"\"\n    self._frm_calAdjust.config_finetune_calibration_button(callback=self._finetune_calibration)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/image_calibration/plotter_heatmap_overlay/#iris.gui.image_calibration.plotter_heatmap_overlay.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/","title":"heatmap_plotter_MeaRMap","text":"<p>A class to control the plot for SERS mapping measurements. To be used inside the high level controller module.</p>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.HeatmapPlotter_Worker","title":"<code>HeatmapPlotter_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>class HeatmapPlotter_Worker(QObject):\n\n    sig_plotready = Signal()  # Signal emitted when the plot is ready to be drawn in the main thread\n    sig_finished_plotting = Signal()  # Signal emitted when the plotting is finished\n\n    def __init__(self, plotter:MeaRMap_Plotter):\n        super().__init__()\n        self._plotter = plotter\n\n    @Slot(PlotterOptions, PlotterParams, PlotterExtraParamsBase, XYLimits)\n    def plot_heatmap(self, option:PlotterOptions, params:PlotterParams, extra_params:PlotterExtraParamsBase,\n                     limits_xy:XYLimits) -&gt; None:\n        \"\"\"\n        Extracts the necessary measurement data to make the heatmap plot and then pass it onto the\n        plotting queue\n        \"\"\"\n        mappingUnit = params.mapping_unit\n        if not isinstance(mappingUnit, MeaRMap_Unit) or not mappingUnit.check_measurement_and_metadata_exist():\n            self.sig_finished_plotting.emit()\n            return\n\n        wavelength = params.wavelength\n        if isinstance(wavelength, (int,float)):\n            ramanshift = mappingUnit.convert(wavelength=wavelength) # pyright: ignore[reportAssignmentType] ; In this case wavelength is guaranteed to be float\n            ramanshift_str = '{:.1f}'.format(ramanshift)\n        else:\n            ramanshift_str = 'N/A'\n\n        title = f'{mappingUnit.get_unit_name()}\\n{ramanshift_str}cm\u207b\u00b9 [{wavelength}nm]'\n        params.title = title\n        self._plotter.plot_heatmap(\n            plotter=option,\n            params=params,\n            params_extra=extra_params,\n        )\n        ax = self._plotter.get_figure_axes()[1]\n\n        ax.set_xlim(limits_xy.x_min, limits_xy.x_max)\n        ax.set_ylim(limits_xy.y_min, limits_xy.y_max)\n\n        self.sig_plotready.emit()\n        self.sig_finished_plotting.emit()\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.HeatmapPlotter_Worker.plot_heatmap","title":"<code>plot_heatmap(option, params, extra_params, limits_xy)</code>","text":"<p>Extracts the necessary measurement data to make the heatmap plot and then pass it onto the plotting queue</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>@Slot(PlotterOptions, PlotterParams, PlotterExtraParamsBase, XYLimits)\ndef plot_heatmap(self, option:PlotterOptions, params:PlotterParams, extra_params:PlotterExtraParamsBase,\n                 limits_xy:XYLimits) -&gt; None:\n    \"\"\"\n    Extracts the necessary measurement data to make the heatmap plot and then pass it onto the\n    plotting queue\n    \"\"\"\n    mappingUnit = params.mapping_unit\n    if not isinstance(mappingUnit, MeaRMap_Unit) or not mappingUnit.check_measurement_and_metadata_exist():\n        self.sig_finished_plotting.emit()\n        return\n\n    wavelength = params.wavelength\n    if isinstance(wavelength, (int,float)):\n        ramanshift = mappingUnit.convert(wavelength=wavelength) # pyright: ignore[reportAssignmentType] ; In this case wavelength is guaranteed to be float\n        ramanshift_str = '{:.1f}'.format(ramanshift)\n    else:\n        ramanshift_str = 'N/A'\n\n    title = f'{mappingUnit.get_unit_name()}\\n{ramanshift_str}cm\u207b\u00b9 [{wavelength}nm]'\n    params.title = title\n    self._plotter.plot_heatmap(\n        plotter=option,\n        params=params,\n        params_extra=extra_params,\n    )\n    ax = self._plotter.get_figure_axes()[1]\n\n    ax.set_xlim(limits_xy.x_min, limits_xy.x_max)\n    ax.set_ylim(limits_xy.y_min, limits_xy.y_max)\n\n    self.sig_plotready.emit()\n    self.sig_finished_plotting.emit()\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter","title":"<code>Wdg_MappingMeasurement_Plotter</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>class Wdg_MappingMeasurement_Plotter(qw.QWidget):\n\n    sig_plotclicked_id = Signal(str)  # Signal emitted when the plot is clicked, sends (mappingUnit_ID (str))\n    sig_plotclicked_coor = Signal(tuple)  # Signal emitted when the plot is clicked, sends (x_mm, y_mm)\n    sig_mappingUnit_changed = Signal(str)  # Signal emitted when the mappingUnit selection is changed, sends (mappingUnit_name (str))\n\n    _sig_request_update_plot = Signal()  # Signal to update the plot in the main thread\n    _sig_request_update_comboboxes = Signal()  # Signal to update the comboboxes in the main thread\n\n    _sig_udpate_plot = Signal(PlotterOptions, PlotterParams, PlotterExtraParamsBase, XYLimits)  # Signal to update the plot in the worker thread\n\n    def __init__(\n        self,\n        parent,\n        mappingHub:MeaRMap_Hub,\n        layout:qw.QLayout|None = None,\n        ):\n        \"\"\"\n        Initialise the plot_mapping_measurements class\n\n        Args:\n            parent (qw.QWidget): Parent widget.\n            mappingHub (MappingMeasurement_Hub): Mapping measurement hub to be used for plotting.\n            callback_click (Callable[[tuple[str,tuple[float,float]]], None]|None): Callback function to be called on click events,\n                it will call the function with the measurement ID and the coordinates of the click.\n            layout (qw.QLayout|None): Optional layout to set for this widget.\n        \"\"\"\n        assert isinstance(mappingHub,MeaRMap_Hub),'mappingHub must be an instance of MappingMeasurement_Hub'\n\n        super().__init__(parent)\n        self._mappingHub:MeaRMap_Hub = mappingHub\n\n    # &gt;&gt;&gt; Main widget setup &lt;&lt;&lt;\n        self._widget = HeatmapPlotter_Design(self)\n        if layout is None:\n            layout = qw.QVBoxLayout(self)\n        self._main_layout = layout\n        self._main_layout.addWidget(self._widget)\n        wdg = self._widget\n\n    # &gt;&gt;&gt; Plot widgets and parameters set up &lt;&lt;&lt;\n    # &gt; Parameters &lt;\n        # Analysers for data analysis:\n        self._plotter = MeaRMap_Plotter()\n        self._fig, self._ax = self._plotter.get_figure_axes()\n\n        # Latest measurement data storage for plotting purposes only\n        self._eve_plot_req = threading.Event()  # Event to request a plot update\n        self._eve_combo_req = threading.Event()  # Event to request a combobox update\n        self._current_mappingUnit:MeaRMap_Unit = MeaRMap_Unit()\n        # Defer observer registration to prevent signals during initialization\n        QTimer.singleShot(0, lambda: self._current_mappingUnit.add_observer(self._sig_request_update_plot.emit))\n\n    # &gt;&gt;&gt; Plotter selection setup &lt;&lt;&lt;\n        self._init_plotter_options_widgets()\n\n    # &gt;&gt;&gt; Plotter setup &lt;&lt;&lt;\n    # &gt; Matplotlib plot setup &lt;\n        holder = wdg.lyt_heatmap_holder\n        self._canvas_widget = FigureCanvas(figure=self._fig) # The plot widget\n        holder.addWidget(self._canvas_widget)\n        self._canvas_id_interaction = self._canvas_widget.mpl_connect('button_press_event', self._retrieve_click_idxcol) # The plot widget's canvas ID for interaction setups\n        self._isplotting = False\n        self._isupdating_comboboxes = False\n        self._plotter.initialise_empty_plot()\n        self._canvas_widget.draw_idle()\n\n    # &gt; Plot control widgets &lt;\n        # Subframes\n        self._init_plot_control_widgets()\n\n    # &gt; General control widgets &lt;\n        # Set up the other widgets\n        # self._btn_restart_threads = tk.Button(self._frm_generalControls,text='Restart auto-updater',command=self._reinitialise_auto_plot)\n        self._lbl_coordinates = wdg.lbl_clickedcoor\n        self._lbl_coordinates_ori = wdg.lbl_clickedcoor.text()\n\n        lineedit_specpos = self._combo_plot_SpectralPosition.lineEdit()\n        assert isinstance(lineedit_specpos, qw.QLineEdit), \"lineedit_specpos must be a QLineEdit\"\n        lineedit_specpos.editingFinished.connect(lambda: self._set_combobox_closest_value(lineedit_specpos.text()))\n\n        # Set the callbacks - defer to prevent signals during initialization\n        QTimer.singleShot(0, lambda: self._mappingHub.add_observer(lambda:\n            self._update_currentMappingUnit_observer(\n            mappingUnit_name=self._current_mappingUnit.get_unit_name()\n        )))\n\n    # &gt; Set the connections &lt;&lt;\n        # Plot update timer\n        # self._sig_request_update_plot.connect(lambda: self.plot_heatmap())\n        self._sig_request_update_plot.connect(self.request_plot_heatmap)\n        self._timer_plot = QTimer(self)\n        self._timer_plot.setInterval(1000)\n        self._timer_plot.timeout.connect(self._process_plot_request)\n        self.destroyed.connect(self._timer_plot.stop)\n        # Defer timer start until after event loop is running\n        QTimer.singleShot(0, self._timer_plot.start)\n\n        # Combobox update timer\n        # self._sig_request_update_comboboxes.connect(lambda: self._update_comboboxes())\n        self._sig_request_update_comboboxes.connect(lambda: self.request_combobox_update())\n        self._timer_combobox = QTimer(self)\n        self._timer_combobox.setInterval(1000)\n        self._timer_combobox.timeout.connect(self._process_combobox_request)\n        self.destroyed.connect(self._timer_combobox.stop)\n        # Defer timer start until after event loop is running\n        QTimer.singleShot(0, self._timer_combobox.start)\n\n    # &gt; Reset button &lt;\n        self._widget.btn_plotterreset.clicked.connect(lambda: self.reinitialise_plotter())\n\n        self._init_worker_thread()\n\n    def _init_worker_thread(self):\n        \"\"\"\n        Initializes the worker thread for plotting\n        \"\"\"\n        self._thread_plotter = QThread()\n        self._worker_plotter = HeatmapPlotter_Worker(plotter=self._plotter)\n        self._worker_plotter.moveToThread(self._thread_plotter)\n\n        # Connect the signals\n        self._sig_udpate_plot.connect(self._worker_plotter.plot_heatmap)\n        self._worker_plotter.sig_plotready.connect(self.on_plotter_worker_plotready)\n        self._worker_plotter.sig_finished_plotting.connect(self.on_plotter_worker_finished)\n\n        # Defer thread start until after initialization is complete\n        QTimer.singleShot(0, lambda: self._thread_plotter.start(QThread.Priority.NormalPriority))\n\n    def _init_plot_control_widgets(self):\n        \"\"\"\n        Initializes the widgets for the plot controls (save options, color limits, axis limits)\n        \"\"\"\n        wdg = self._widget\n        self._lbl_SpectralPosition = wdg.lbl_specposunit\n\n        # Set up the comboboxes\n        self._combo_plot_mappingUnitName = wdg.combo_unitchoise\n        self._combo_plot_SpectralPosition = wdg.combo_spectralpos\n\n        # Bind selections to plot the latest measurement_data df\n        self._combo_plot_mappingUnitName.currentIndexChanged.connect(lambda: self._sig_request_update_comboboxes.emit())\n        self._combo_plot_SpectralPosition.currentIndexChanged.connect(lambda: self._sig_request_update_plot.emit())\n\n        self._combo_plot_mappingUnitName.currentTextChanged.connect(self._emit_current_mappingUnit_name)\n\n        # &gt; Set up the save widgets\n        wdg.btn_saveplot.clicked.connect(self.save_plot)\n        wdg.btn_savedata.clicked.connect(self.save_plot_data)\n\n        # &gt; Set up the colour bar limit widgets\n        self._entry_plot_clim_min = wdg.ent_cbar_min\n        self._entry_plot_clim_max = wdg.ent_cbar_max\n        self._chk_auto_clim = wdg.chk_autocbar\n        wdg.chk_autocbar.stateChanged.connect(lambda: self._sig_request_update_plot.emit())\n\n\n        # Bind enter key and changes to replot the heatmap\n        def bind_enter_replot():\n            wdg.chk_autocbar.setChecked(False)\n            self._sig_request_update_plot.emit()\n        self._entry_plot_clim_min.editingFinished.connect(bind_enter_replot)\n        self._entry_plot_clim_max.editingFinished.connect(bind_enter_replot)\n\n        # &gt; Set up the xy limit widgets\n        self._entry_plot_xlim_min = wdg.ent_xmin\n        self._entry_plot_xlim_max = wdg.ent_xmax\n        self._entry_plot_ylim_min = wdg.ent_ymin\n        self._entry_plot_ylim_max = wdg.ent_ymax\n\n        self._entry_plot_xlim_min.editingFinished.connect(lambda: self._sig_request_update_plot.emit())\n        self._entry_plot_xlim_max.editingFinished.connect(lambda: self._sig_request_update_plot.emit())\n        self._entry_plot_ylim_min.editingFinished.connect(lambda: self._sig_request_update_plot.emit())\n        self._entry_plot_ylim_max.editingFinished.connect(lambda: self._sig_request_update_plot.emit())\n\n        # &gt; Set up the Raman shift / wavelength toggle\n        self._chk_plot_in_RamanShift = wdg.chk_Ramanshift\n\n    def _init_plotter_options_widgets(self):\n        \"\"\"\n        Initialize the plotter option widgets\n        \"\"\"\n        self._dict_plotter_opts = {option.value: option for option in PlotterOptions}\n        self._dict_plotter_opts_kwargs = {\n            option.value: self._plotter.get_plotter_params(option)\n            for option in PlotterOptions\n        }\n        self._dict_plotter_kwargs_widgets:dict[str,qw.QLineEdit] = {}\n\n        self._combo_plotter = self._widget.combo_plotoption\n        self._combo_plotter.addItems(list(self._dict_plotter_opts.keys()))\n        self._combo_plotter.currentTextChanged.connect(self._setup_plotter_options)\n        self._combo_plotter.setCurrentIndex(0)\n\n        self._setup_plotter_options()\n\n    def reinitialise_plotter(self):\n        \"\"\"\n        Reinitialise the plotter to its default state\n        \"\"\"\n        print('Reinitialising plotter... (not yet implemented)')\n        self._update_comboboxes()\n\n    @Slot()\n    def _setup_plotter_options(self):\n        \"\"\"\n        Set up the plotter options for the current mapping plot\n        \"\"\"\n        chosen_option = self._combo_plotter.currentText()\n        self._plotter_extra_params:PlotterExtraParamsBase= self._dict_plotter_opts_kwargs[chosen_option]\n\n        # Destroy the previous widgets\n        holder = self._widget.lyt_plot_params # Form layout\n        for widget in get_all_widgets_from_layout(holder):\n            widget.deleteLater()\n        QCoreApplication.processEvents()\n\n        # Auto generate widgets for the plotter options\n        self._dict_plotter_kwargs_widgets.clear()\n\n        for field in fields(self._plotter_extra_params):\n            key = field.name\n            entry = qw.QLineEdit()\n            entry.editingFinished.connect(lambda: self._sig_request_update_plot.emit())\n            holder.addRow(f'{key}:',entry)\n            self._dict_plotter_kwargs_widgets[key] = entry\n\n        self._sig_request_update_plot.emit()\n\n    def _emit_current_mappingUnit_name(self):\n        \"\"\"\n        Emit the current mappingUnit name through the sig_mappingUnit_changed signal\n        \"\"\"\n        mappingUnit_name = self._combo_plot_mappingUnitName.currentText()\n        self.sig_mappingUnit_changed.emit(mappingUnit_name)\n\n    def _get_plotter_kwargs(self) -&gt; dict:\n        \"\"\"\n        Get the plotter options for the current mapping plot\n\n        Returns:\n            dict: Plotter options for the current mapping plot\n        \"\"\"\n        kwargs = {}\n        for key in self._dict_plotter_kwargs_widgets.keys():\n            entry = self._dict_plotter_kwargs_widgets[key]\n            try: kwargs[key] = float(entry.text())\n            except: kwargs[key] = entry.text()\n        return kwargs\n\n    def _set_current_mappingUnit(self,mappingUnit:MeaRMap_Unit):\n        \"\"\"\n        Set a new mappingUnit to be observed\n\n        Args:\n            mappingUnit (MeaRMap_Unit): The mapping unit to be set\n        \"\"\"\n        assert mappingUnit in self._mappingHub.get_list_MappingUnit(),\\\n            \"This is a private method, only to be used when setting up a new mappingUnit to be observed\"\\\n            \"the mappingUnit set must be obtained from the internal self._mappingHub.\"\n        self._current_mappingUnit = mappingUnit\n        self._current_mappingUnit.add_observer(self._sig_request_update_plot.emit)\n\n    def _set_combobox_closest_value(self, new_val:str):\n        \"\"\"\n        Set the combobox to the closest wavelength to the entered value\n        \"\"\"\n        if not self._current_mappingUnit.check_measurement_and_metadata_exist(): return\n        try: current_spectralPosition = float(new_val)\n        except Exception as e: print('_set_combobox_closest_value', e); return\n\n        if self._chk_plot_in_RamanShift.isChecked():\n            idx = self._current_mappingUnit.get_raman_shift_idx(current_spectralPosition)\n        else:\n            idx = self._current_mappingUnit.get_wavelength_idx(current_spectralPosition)\n        self._combo_plot_SpectralPosition.setCurrentIndex(idx)\n\n        self._sig_request_update_plot.emit()\n\n    @Slot(str)\n    def set_combobox_name(self,mappingUnit_name:str) -&gt; None:\n        \"\"\"\n        Set the mappingUnit and spectralPosition selection in the combobox\n\n        Args:\n            mappingUnit_id (str): MappingUnit_ID to be selected. If None, no change is made.\n        \"\"\"\n        list_names = self._mappingHub.get_list_MappingUnit_names()\n        if not mappingUnit_name in list_names: return\n\n        self._combo_plot_mappingUnitName.blockSignals(True)\n        self._combo_plot_mappingUnitName.setCurrentText(mappingUnit_name)\n        self._combo_plot_mappingUnitName.blockSignals(False)\n\n        self._update_currentMappingUnit_observer(mappingUnit_name=mappingUnit_name)\n\n    @Slot()\n    def _process_combobox_request(self) -&gt; None:\n        \"\"\"\n        Store a combobox update request to be executed in the main thread\n        \"\"\"\n        if not self._eve_combo_req.is_set(): return\n        self._eve_combo_req.clear()\n        self._update_comboboxes()\n\n    @Slot()\n    def request_combobox_update(self) -&gt; None:\n        \"\"\"\n        Request an update of the comboboxes\n        \"\"\"\n        self._eve_combo_req.set()\n\n    def _update_comboboxes(self, set_unit_name:str|None=None, set_wavelength:float|None=None) -&gt; None:\n        \"\"\"\n        Refreshes the plotter's combobox according to the mappingUnits in the mappingHub\n\n        Args:\n            set_unit_name (str|None): Unit name to be selected after the refresh if possible.\n            set_wavelength (float|None): Wavelength to be selected after the refresh if possible. It will\\\n                be set to Raman shift automatically according to the checkbox state.\n        \"\"\"\n        if self._isupdating_comboboxes: return\n        if self._combo_plot_mappingUnitName.hasFocus() or self._combo_plot_SpectralPosition.hasFocus():\n            self._eve_combo_req.set()   # Re-request the update later\n            return\n\n        self._isupdating_comboboxes = True\n        self._combo_plot_mappingUnitName.blockSignals(True)\n        self._combo_plot_SpectralPosition.blockSignals(True)\n\n        if set_unit_name is None: set_unit_name = self._combo_plot_mappingUnitName.currentText()\n        set_wavelength = self.get_current_wavelength()\n\n        # Check if there are any measurements in the mappingHub for the refresh. Returns if not\n        if not self._mappingHub.check_measurement_exist():\n            self._isupdating_comboboxes = False\n            return\n\n        list_valid_names = [unit.get_unit_name() for unit in self._mappingHub.get_list_MappingUnit()\\\n            if unit.check_measurement_and_metadata_exist()]\n\n        if len(list_valid_names) == 0:\n            self._isupdating_comboboxes = False\n            return\n\n        # Get the mappingUnit to be set\n        list_names = self._mappingHub.get_list_MappingUnit_names()\n        if set_unit_name in list_valid_names:\n            mappingUnit = self._mappingHub.get_MappingUnit(unit_name=set_unit_name)\n        elif self._current_mappingUnit.get_unit_name() in list_valid_names and\\\n            self._current_mappingUnit.check_measurement_and_metadata_exist():\n            mappingUnit = self._current_mappingUnit\n        else: mappingUnit = self._mappingHub.get_MappingUnit(unit_name=list_valid_names[0])\n        unit_name = mappingUnit.get_unit_name()\n\n        # Get the wavelength or Raman shift list to be set\n        current_wavelength = self.get_current_wavelength()\n        if isinstance(set_wavelength, (int,float)): set_wavelength = float(set_wavelength)\n        elif isinstance(current_wavelength, (int,float)): set_wavelength = float(current_wavelength)\n        else: set_wavelength = 0.0\n\n        if self._chk_plot_in_RamanShift.isChecked(): list_spectral_position = mappingUnit.get_list_Raman_shift()\n        else: list_spectral_position = mappingUnit.get_list_wavelengths()\n        idx_spectral_position = mappingUnit.get_wavelength_idx(set_wavelength)\n        list_spectral_position = [f'{pos:.2f}' for pos in list_spectral_position]\n\n        # Check if the new list is different from the current one\n        flg_update_name = False\n        flg_update_specpos = False\n        if self._combo_plot_mappingUnitName.count() != len(list_names):\n            flg_update_name = True\n        elif not all(self._combo_plot_mappingUnitName.itemText(i) == list_names[i] for i in range(len(list_names))):\n            flg_update_name = True\n        if self._combo_plot_SpectralPosition.count() != len(list_spectral_position):\n            flg_update_specpos = True\n        elif not all(self._combo_plot_SpectralPosition.itemText(i) == list_spectral_position[i] for i in range(len(list_spectral_position))):\n            flg_update_specpos = True\n\n        if flg_update_name:\n            self._combo_plot_mappingUnitName.clear()\n            self._combo_plot_mappingUnitName.addItems(list_names)\n        self._combo_plot_mappingUnitName.setCurrentText(unit_name)\n\n        if flg_update_specpos:\n            self._combo_plot_SpectralPosition.clear()\n            self._combo_plot_SpectralPosition.addItems(list_spectral_position)\n        self._combo_plot_SpectralPosition.setCurrentIndex(idx_spectral_position)\n\n        # Store the values\n        self._current_mappingUnit = mappingUnit\n\n        # Plot the changes\n        if flg_update_name or flg_update_specpos:\n            self._sig_request_update_plot.emit()\n\n        self._combo_plot_mappingUnitName.blockSignals(False)\n        self._combo_plot_SpectralPosition.blockSignals(False)\n        self._isupdating_comboboxes = False\n\n    def _get_plotter_option(self) -&gt; PlotterOptions:\n        \"\"\"\n        Get the current plotter option from the combobox\n\n        Returns:\n            PlotterOptions: The current plotter option\n        \"\"\"\n        chosen_option = self._combo_plotter.currentText()\n        return self._dict_plotter_opts[chosen_option]\n\n    def _get_plotter_extra_params(self) -&gt; PlotterExtraParamsBase:\n        \"\"\"\n        Get the current plotter extra parameters from the widgets\n\n        Returns:\n            PlotterExtraParamsBase: The current plotter extra parameters\n        \"\"\"\n        for field in fields(self._plotter_extra_params):\n            key = field.name\n            entry = self._dict_plotter_kwargs_widgets[key]\n            val_type = field.type\n            try:\n                if val_type == float:\n                    setattr(self._plotter_extra_params, key, float(entry.text()))\n                elif val_type == int:\n                    setattr(self._plotter_extra_params, key, int(float(entry.text())))\n                else:\n                    setattr(self._plotter_extra_params, key, entry.text())\n            except:\n                setattr(self._plotter_extra_params, key, field.default)\n        return self._plotter_extra_params\n\n    @Slot()\n    def request_plot_heatmap(self) -&gt; None:\n        \"\"\"\n        Replot the heatmap using the current mappingHub and the selected mappingUnit_ID and SpectralPosition\n        \"\"\"\n        self._eve_plot_req.set()\n\n    @Slot()\n    def _process_plot_request(self) -&gt; None:\n        \"\"\"\n        Store a plot request to be executed in the main thread\n        \"\"\"\n        if not self._eve_plot_req.is_set(): return\n        self._eve_plot_req.clear()\n        self.plot_heatmap()\n\n    def get_selected_mappingUnit(self) -&gt; MeaRMap_Unit|None:\n        \"\"\"\n        Get the currently selected mapping unit from the combo box.\n\n        Returns:\n            MappingMeasurement_Unit: The currently selected mapping unit.\n        \"\"\"\n        return self._current_mappingUnit\n\n    def _update_currentMappingUnit_observer(self, mappingUnit_name:str) -&gt; None:\n        \"\"\"\n        Update the currently selected mapping unit according to the new combobox selection\n\n        Args:\n            mappingUnit_name (str): The name of the mapping unit to be set. If it doesn't exist, the\n                first valid mapping unit will be selected.\n        \"\"\"\n        # Remove observer\n        try: self._current_mappingUnit.remove_observer(self._sig_request_update_plot.emit)\n        except Exception as e: print('_update_currentMappingUnit_observer',e)\n\n        try:\n            # Set the new mapping unit and check if it's valid\n            self._current_mappingUnit = self._mappingHub.get_MappingUnit(unit_name=mappingUnit_name)\n            assert self._current_mappingUnit.check_measurement_and_metadata_exist(),\\\n                \"Mapping unit is not valid.\"\n        except Exception as e:\n            # Set to the first valid mapping unit if the selected one is not valid\n            list_valid_names = [unit.get_unit_name() for unit in self._mappingHub.get_list_MappingUnit() if unit.check_measurement_and_metadata_exist()]\n            if len(list_valid_names) &gt; 0: self._current_mappingUnit = self._mappingHub.get_MappingUnit(unit_name=list_valid_names[0])\n            else: self._current_mappingUnit = MeaRMap_Unit()\n        finally:\n            self._current_mappingUnit.add_observer(self._sig_request_update_plot.emit)\n\n        self._sig_request_update_comboboxes.emit()\n\n    @Slot()\n    def on_plotter_worker_finished(self) -&gt; None:\n        \"\"\"\n        Slot called when the plotter worker has finished plotting\n        \"\"\"\n        self._isplotting = False\n\n    @Slot()\n    def on_plotter_worker_plotready(self) -&gt; None:\n        \"\"\"\n        Slot called when the plotter worker has finished plotting and the plot is ready to be drawn\n        \"\"\"\n        self._canvas_widget.draw_idle()\n\n    def plot_heatmap(self):\n        \"\"\"\n        Extracts the necessary measurement data to make the heatmap plot and then pass it onto the\n        plotting queue\n        \"\"\"\n        if not self._widget.dock_plot.isVisible(): return\n        if self._isplotting: return\n        assert isinstance(self._mappingHub,MeaRMap_Hub),\\\n            \"plot_heatmap: Measurement data is not of the correct type. Expected: MappingMeasurement_Hub\"\n\n        mappingUnit = self._current_mappingUnit\n        if not isinstance(mappingUnit, MeaRMap_Unit) or not mappingUnit.check_measurement_and_metadata_exist(): return\n\n        # &gt;&gt;&gt; Find the wavelength\n        wavelength = self.get_current_wavelength()\n        if wavelength is None: return\n\n        self._isplotting = True\n        self._current_mappingUnit = mappingUnit\n\n        #PlotterOptions, PlotterParams, PlotterExtraParamsBase, XYLimits\n        options = self._get_plotter_option()\n        params = PlotterParams(\n            mapping_unit=mappingUnit,\n            wavelength=wavelength,\n            clim=None,\n        )\n        params_extra = self._get_plotter_extra_params()\n        limits_xy = self._get_plot_xylim()\n\n        try: clim_min = float(self._entry_plot_clim_min.text())\n        except: clim_min = None\n        try: clim_max = float(self._entry_plot_clim_max.text())\n        except: clim_max = None\n        clim = (clim_min,clim_max)\n        if self._chk_auto_clim.isChecked(): clim = (None,None)\n        params.clim = clim\n\n        self._sig_udpate_plot.emit(\n            options,\n            params,\n            params_extra,\n            limits_xy,\n        )\n\n        self._isplotting = False\n\n    @thread_assign\n    def save_plot(self):\n        \"\"\"\n        Save the current plot as an image, asks the user for the file path\n        \"\"\"\n        try:\n            filename = self._combo_plot_mappingUnitName.currentText()\n            filepath = qw.QFileDialog.getSaveFileName(\n                self,\n                'Save plot as PNG',\n                filename,\n                'PNG files (*.png)')[0]\n            if filepath == '': return\n\n            self._fig.tight_layout()\n            self._canvas_widget.draw_idle()\n            self._canvas_widget.update_idletasks() # Process pending idle tasks\n            self._canvas_widget.update() # Process pending events\n            self._canvas_widget.after_idle(self._canvas_widget.print_png,filepath)\n\n            qw.QMessageBox.information(self, 'Save plot', 'Plot saved successfully')\n        except Exception as e: print('save_plot',e); return\n\n    @thread_assign\n    def save_plot_data(self):\n        \"\"\"\n        Save the current plot data as a csv file, asks the user for the file path\n        \"\"\"\n        try:\n            if not isinstance(self._current_mappingUnit, MeaRMap_Unit) or\\\n                not self._current_mappingUnit.check_measurement_and_metadata_exist(): return\n            filepath = qw.QFileDialog.getSaveFileName(self,\n                'Save plot data', '',\n                'data.csv',\n                'CSV files (*.csv)')[0]\n\n            spectralPosition_idx = self._combo_plot_SpectralPosition.currentIndex()\n            list_wavelength = self._current_mappingUnit.get_list_wavelengths()\n            wavelength = list_wavelength[spectralPosition_idx]\n            df = self._current_mappingUnit.get_heatmap_table(wavelength)\n            df.to_csv(filepath)\n            qw.QMessageBox.information(self, 'Save data', 'Data saved successfully')\n        except Exception as e: print('save_plot_data',e); return\n\n    def _get_plot_xylim(self) -&gt; XYLimits:\n        \"\"\"\n        Gets the x and y limits of the plot using the values in the widgets\n\n        Returns:\n            XYLimits: The x and y limits of the plot\n        \"\"\"\n        # Get the x and y limits\n        try: xlim_min = float(self._entry_plot_xlim_min.text())\n        except: xlim_min = None\n        try: xlim_max = float(self._entry_plot_xlim_max.text())\n        except: xlim_max = None\n        try: ylim_min = float(self._entry_plot_ylim_min.text())\n        except: ylim_min = None\n        try: ylim_max = float(self._entry_plot_ylim_max.text())\n        except: ylim_max = None\n\n        return XYLimits(\n            x_min=xlim_min,\n            x_max=xlim_max,\n            y_min=ylim_min,\n            y_max=ylim_max,\n        )\n\n    def get_current_wavelength(self) -&gt; float|None:\n        \"\"\"\n        Retrieves the current wavelength being plotted.\n        Returns:\n            float|None: The current wavelength or None if not set.\n        \"\"\"\n        if not isinstance(self._current_mappingUnit, MeaRMap_Unit) or\\\n            not self._current_mappingUnit.check_measurement_and_metadata_exist():\n            return None\n\n        # TODO: This often gets called before the comboboxes are fully populated, triggering the exceptions\n        try:\n            qw.QApplication.processEvents()\n            current_val = float(self._combo_plot_SpectralPosition.currentText())\n        except Exception as e: return None\n\n        if self._chk_plot_in_RamanShift.isChecked():\n            ret = self._current_mappingUnit.convert(Raman_shift=current_val)\n        else: ret = current_val\n        ret = self._current_mappingUnit.get_closest_wavelength(ret) # pyright: ignore[reportArgumentType] ; In this case ret is guaranteed to be float\n\n        return ret\n\n    def _retrieve_click_idxcol(self,event:matplotlib.backend_bases.MouseEvent|Any):\n        \"\"\"\n        Retrieve the index and the column where the figure is clicked\n        \"\"\"\n        if event.inaxes and isinstance(self._current_mappingUnit, MeaRMap_Unit)\\\n            and self._current_mappingUnit.check_measurement_and_metadata_exist():\n            coorx,coory = event.xdata,event.ydata\n            if coorx is None or coory is None: return\n\n            clicked_measurementId = self._current_mappingUnit.get_measurementId_from_coor(coor=(coorx,coory))\n            ramanMea = self._current_mappingUnit.get_RamanMeasurement(clicked_measurementId)\n            try:\n                wavelength = self.get_current_wavelength()\n                if wavelength is None: raise ValueError('Wavelength is None')\n                intensity = ramanMea.get_intensity(wavelength=wavelength)\n                intensity_str = f\"{intensity:.1f}\"\n            except Exception as e:\n                print('_retrieve_click_idxcol: ',e)\n                intensity_str = 'error'\n\n            self._lbl_coordinates.setText(\n                f\"x={coorx:.3f} mm, y={coory:.3f} mm, intensity={intensity_str} (a.u.)\"\n            )\n\n            self.sig_plotclicked_id.emit(str(clicked_measurementId))\n            self.sig_plotclicked_coor.emit((coorx,coory))\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.__init__","title":"<code>__init__(parent, mappingHub, layout=None)</code>","text":"<p>Initialise the plot_mapping_measurements class</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget.</p> required <code>mappingHub</code> <code>MappingMeasurement_Hub</code> <p>Mapping measurement hub to be used for plotting.</p> required <code>callback_click</code> <code>Callable[[tuple[str, tuple[float, float]]], None] | None</code> <p>Callback function to be called on click events, it will call the function with the measurement ID and the coordinates of the click.</p> required <code>layout</code> <code>QLayout | None</code> <p>Optional layout to set for this widget.</p> <code>None</code> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>def __init__(\n    self,\n    parent,\n    mappingHub:MeaRMap_Hub,\n    layout:qw.QLayout|None = None,\n    ):\n    \"\"\"\n    Initialise the plot_mapping_measurements class\n\n    Args:\n        parent (qw.QWidget): Parent widget.\n        mappingHub (MappingMeasurement_Hub): Mapping measurement hub to be used for plotting.\n        callback_click (Callable[[tuple[str,tuple[float,float]]], None]|None): Callback function to be called on click events,\n            it will call the function with the measurement ID and the coordinates of the click.\n        layout (qw.QLayout|None): Optional layout to set for this widget.\n    \"\"\"\n    assert isinstance(mappingHub,MeaRMap_Hub),'mappingHub must be an instance of MappingMeasurement_Hub'\n\n    super().__init__(parent)\n    self._mappingHub:MeaRMap_Hub = mappingHub\n\n# &gt;&gt;&gt; Main widget setup &lt;&lt;&lt;\n    self._widget = HeatmapPlotter_Design(self)\n    if layout is None:\n        layout = qw.QVBoxLayout(self)\n    self._main_layout = layout\n    self._main_layout.addWidget(self._widget)\n    wdg = self._widget\n\n# &gt;&gt;&gt; Plot widgets and parameters set up &lt;&lt;&lt;\n# &gt; Parameters &lt;\n    # Analysers for data analysis:\n    self._plotter = MeaRMap_Plotter()\n    self._fig, self._ax = self._plotter.get_figure_axes()\n\n    # Latest measurement data storage for plotting purposes only\n    self._eve_plot_req = threading.Event()  # Event to request a plot update\n    self._eve_combo_req = threading.Event()  # Event to request a combobox update\n    self._current_mappingUnit:MeaRMap_Unit = MeaRMap_Unit()\n    # Defer observer registration to prevent signals during initialization\n    QTimer.singleShot(0, lambda: self._current_mappingUnit.add_observer(self._sig_request_update_plot.emit))\n\n# &gt;&gt;&gt; Plotter selection setup &lt;&lt;&lt;\n    self._init_plotter_options_widgets()\n\n# &gt;&gt;&gt; Plotter setup &lt;&lt;&lt;\n# &gt; Matplotlib plot setup &lt;\n    holder = wdg.lyt_heatmap_holder\n    self._canvas_widget = FigureCanvas(figure=self._fig) # The plot widget\n    holder.addWidget(self._canvas_widget)\n    self._canvas_id_interaction = self._canvas_widget.mpl_connect('button_press_event', self._retrieve_click_idxcol) # The plot widget's canvas ID for interaction setups\n    self._isplotting = False\n    self._isupdating_comboboxes = False\n    self._plotter.initialise_empty_plot()\n    self._canvas_widget.draw_idle()\n\n# &gt; Plot control widgets &lt;\n    # Subframes\n    self._init_plot_control_widgets()\n\n# &gt; General control widgets &lt;\n    # Set up the other widgets\n    # self._btn_restart_threads = tk.Button(self._frm_generalControls,text='Restart auto-updater',command=self._reinitialise_auto_plot)\n    self._lbl_coordinates = wdg.lbl_clickedcoor\n    self._lbl_coordinates_ori = wdg.lbl_clickedcoor.text()\n\n    lineedit_specpos = self._combo_plot_SpectralPosition.lineEdit()\n    assert isinstance(lineedit_specpos, qw.QLineEdit), \"lineedit_specpos must be a QLineEdit\"\n    lineedit_specpos.editingFinished.connect(lambda: self._set_combobox_closest_value(lineedit_specpos.text()))\n\n    # Set the callbacks - defer to prevent signals during initialization\n    QTimer.singleShot(0, lambda: self._mappingHub.add_observer(lambda:\n        self._update_currentMappingUnit_observer(\n        mappingUnit_name=self._current_mappingUnit.get_unit_name()\n    )))\n\n# &gt; Set the connections &lt;&lt;\n    # Plot update timer\n    # self._sig_request_update_plot.connect(lambda: self.plot_heatmap())\n    self._sig_request_update_plot.connect(self.request_plot_heatmap)\n    self._timer_plot = QTimer(self)\n    self._timer_plot.setInterval(1000)\n    self._timer_plot.timeout.connect(self._process_plot_request)\n    self.destroyed.connect(self._timer_plot.stop)\n    # Defer timer start until after event loop is running\n    QTimer.singleShot(0, self._timer_plot.start)\n\n    # Combobox update timer\n    # self._sig_request_update_comboboxes.connect(lambda: self._update_comboboxes())\n    self._sig_request_update_comboboxes.connect(lambda: self.request_combobox_update())\n    self._timer_combobox = QTimer(self)\n    self._timer_combobox.setInterval(1000)\n    self._timer_combobox.timeout.connect(self._process_combobox_request)\n    self.destroyed.connect(self._timer_combobox.stop)\n    # Defer timer start until after event loop is running\n    QTimer.singleShot(0, self._timer_combobox.start)\n\n# &gt; Reset button &lt;\n    self._widget.btn_plotterreset.clicked.connect(lambda: self.reinitialise_plotter())\n\n    self._init_worker_thread()\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.get_current_wavelength","title":"<code>get_current_wavelength()</code>","text":"<p>Retrieves the current wavelength being plotted. Returns:     float|None: The current wavelength or None if not set.</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>def get_current_wavelength(self) -&gt; float|None:\n    \"\"\"\n    Retrieves the current wavelength being plotted.\n    Returns:\n        float|None: The current wavelength or None if not set.\n    \"\"\"\n    if not isinstance(self._current_mappingUnit, MeaRMap_Unit) or\\\n        not self._current_mappingUnit.check_measurement_and_metadata_exist():\n        return None\n\n    # TODO: This often gets called before the comboboxes are fully populated, triggering the exceptions\n    try:\n        qw.QApplication.processEvents()\n        current_val = float(self._combo_plot_SpectralPosition.currentText())\n    except Exception as e: return None\n\n    if self._chk_plot_in_RamanShift.isChecked():\n        ret = self._current_mappingUnit.convert(Raman_shift=current_val)\n    else: ret = current_val\n    ret = self._current_mappingUnit.get_closest_wavelength(ret) # pyright: ignore[reportArgumentType] ; In this case ret is guaranteed to be float\n\n    return ret\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.get_selected_mappingUnit","title":"<code>get_selected_mappingUnit()</code>","text":"<p>Get the currently selected mapping unit from the combo box.</p> <p>Returns:</p> Name Type Description <code>MappingMeasurement_Unit</code> <code>MeaRMap_Unit | None</code> <p>The currently selected mapping unit.</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>def get_selected_mappingUnit(self) -&gt; MeaRMap_Unit|None:\n    \"\"\"\n    Get the currently selected mapping unit from the combo box.\n\n    Returns:\n        MappingMeasurement_Unit: The currently selected mapping unit.\n    \"\"\"\n    return self._current_mappingUnit\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.on_plotter_worker_finished","title":"<code>on_plotter_worker_finished()</code>","text":"<p>Slot called when the plotter worker has finished plotting</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>@Slot()\ndef on_plotter_worker_finished(self) -&gt; None:\n    \"\"\"\n    Slot called when the plotter worker has finished plotting\n    \"\"\"\n    self._isplotting = False\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.on_plotter_worker_plotready","title":"<code>on_plotter_worker_plotready()</code>","text":"<p>Slot called when the plotter worker has finished plotting and the plot is ready to be drawn</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>@Slot()\ndef on_plotter_worker_plotready(self) -&gt; None:\n    \"\"\"\n    Slot called when the plotter worker has finished plotting and the plot is ready to be drawn\n    \"\"\"\n    self._canvas_widget.draw_idle()\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.plot_heatmap","title":"<code>plot_heatmap()</code>","text":"<p>Extracts the necessary measurement data to make the heatmap plot and then pass it onto the plotting queue</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>def plot_heatmap(self):\n    \"\"\"\n    Extracts the necessary measurement data to make the heatmap plot and then pass it onto the\n    plotting queue\n    \"\"\"\n    if not self._widget.dock_plot.isVisible(): return\n    if self._isplotting: return\n    assert isinstance(self._mappingHub,MeaRMap_Hub),\\\n        \"plot_heatmap: Measurement data is not of the correct type. Expected: MappingMeasurement_Hub\"\n\n    mappingUnit = self._current_mappingUnit\n    if not isinstance(mappingUnit, MeaRMap_Unit) or not mappingUnit.check_measurement_and_metadata_exist(): return\n\n    # &gt;&gt;&gt; Find the wavelength\n    wavelength = self.get_current_wavelength()\n    if wavelength is None: return\n\n    self._isplotting = True\n    self._current_mappingUnit = mappingUnit\n\n    #PlotterOptions, PlotterParams, PlotterExtraParamsBase, XYLimits\n    options = self._get_plotter_option()\n    params = PlotterParams(\n        mapping_unit=mappingUnit,\n        wavelength=wavelength,\n        clim=None,\n    )\n    params_extra = self._get_plotter_extra_params()\n    limits_xy = self._get_plot_xylim()\n\n    try: clim_min = float(self._entry_plot_clim_min.text())\n    except: clim_min = None\n    try: clim_max = float(self._entry_plot_clim_max.text())\n    except: clim_max = None\n    clim = (clim_min,clim_max)\n    if self._chk_auto_clim.isChecked(): clim = (None,None)\n    params.clim = clim\n\n    self._sig_udpate_plot.emit(\n        options,\n        params,\n        params_extra,\n        limits_xy,\n    )\n\n    self._isplotting = False\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.reinitialise_plotter","title":"<code>reinitialise_plotter()</code>","text":"<p>Reinitialise the plotter to its default state</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>def reinitialise_plotter(self):\n    \"\"\"\n    Reinitialise the plotter to its default state\n    \"\"\"\n    print('Reinitialising plotter... (not yet implemented)')\n    self._update_comboboxes()\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.request_combobox_update","title":"<code>request_combobox_update()</code>","text":"<p>Request an update of the comboboxes</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>@Slot()\ndef request_combobox_update(self) -&gt; None:\n    \"\"\"\n    Request an update of the comboboxes\n    \"\"\"\n    self._eve_combo_req.set()\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.request_plot_heatmap","title":"<code>request_plot_heatmap()</code>","text":"<p>Replot the heatmap using the current mappingHub and the selected mappingUnit_ID and SpectralPosition</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>@Slot()\ndef request_plot_heatmap(self) -&gt; None:\n    \"\"\"\n    Replot the heatmap using the current mappingHub and the selected mappingUnit_ID and SpectralPosition\n    \"\"\"\n    self._eve_plot_req.set()\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.save_plot","title":"<code>save_plot()</code>","text":"<p>Save the current plot as an image, asks the user for the file path</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>@thread_assign\ndef save_plot(self):\n    \"\"\"\n    Save the current plot as an image, asks the user for the file path\n    \"\"\"\n    try:\n        filename = self._combo_plot_mappingUnitName.currentText()\n        filepath = qw.QFileDialog.getSaveFileName(\n            self,\n            'Save plot as PNG',\n            filename,\n            'PNG files (*.png)')[0]\n        if filepath == '': return\n\n        self._fig.tight_layout()\n        self._canvas_widget.draw_idle()\n        self._canvas_widget.update_idletasks() # Process pending idle tasks\n        self._canvas_widget.update() # Process pending events\n        self._canvas_widget.after_idle(self._canvas_widget.print_png,filepath)\n\n        qw.QMessageBox.information(self, 'Save plot', 'Plot saved successfully')\n    except Exception as e: print('save_plot',e); return\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.save_plot_data","title":"<code>save_plot_data()</code>","text":"<p>Save the current plot data as a csv file, asks the user for the file path</p> Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>@thread_assign\ndef save_plot_data(self):\n    \"\"\"\n    Save the current plot data as a csv file, asks the user for the file path\n    \"\"\"\n    try:\n        if not isinstance(self._current_mappingUnit, MeaRMap_Unit) or\\\n            not self._current_mappingUnit.check_measurement_and_metadata_exist(): return\n        filepath = qw.QFileDialog.getSaveFileName(self,\n            'Save plot data', '',\n            'data.csv',\n            'CSV files (*.csv)')[0]\n\n        spectralPosition_idx = self._combo_plot_SpectralPosition.currentIndex()\n        list_wavelength = self._current_mappingUnit.get_list_wavelengths()\n        wavelength = list_wavelength[spectralPosition_idx]\n        df = self._current_mappingUnit.get_heatmap_table(wavelength)\n        df.to_csv(filepath)\n        qw.QMessageBox.information(self, 'Save data', 'Data saved successfully')\n    except Exception as e: print('save_plot_data',e); return\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.Wdg_MappingMeasurement_Plotter.set_combobox_name","title":"<code>set_combobox_name(mappingUnit_name)</code>","text":"<p>Set the mappingUnit and spectralPosition selection in the combobox</p> <p>Parameters:</p> Name Type Description Default <code>mappingUnit_id</code> <code>str</code> <p>MappingUnit_ID to be selected. If None, no change is made.</p> required Source code in <code>iris/gui/submodules/heatmap_plotter_MeaRMap.py</code> <pre><code>@Slot(str)\ndef set_combobox_name(self,mappingUnit_name:str) -&gt; None:\n    \"\"\"\n    Set the mappingUnit and spectralPosition selection in the combobox\n\n    Args:\n        mappingUnit_id (str): MappingUnit_ID to be selected. If None, no change is made.\n    \"\"\"\n    list_names = self._mappingHub.get_list_MappingUnit_names()\n    if not mappingUnit_name in list_names: return\n\n    self._combo_plot_mappingUnitName.blockSignals(True)\n    self._combo_plot_mappingUnitName.setCurrentText(mappingUnit_name)\n    self._combo_plot_mappingUnitName.blockSignals(False)\n\n    self._update_currentMappingUnit_observer(mappingUnit_name=mappingUnit_name)\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/heatmap_plotter_MeaRMap/#iris.gui.submodules.heatmap_plotter_MeaRMap.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/","title":"image_tiling","text":"<p>A class to automatically take images and tile them into a single image</p>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.ImageProcessor_Worker","title":"<code>ImageProcessor_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Worker class to process images in a separate thread</p> Source code in <code>iris/gui/submodules/image_tiling.py</code> <pre><code>class ImageProcessor_Worker(QObject):\n    \"\"\"\n    Worker class to process images in a separate thread\n    \"\"\"\n    sig_ret_image_processed = Signal(Image.Image)\n    sig_gotocoor = Signal(tuple, threading.Event)\n    sig_statbar_update = Signal(str)\n\n    flg_stop_imgCapture = threading.Event()\n    sig_midMea_error = Signal(str)  # Signal to indicate an error during mid-measurement\n    sig_finished_msg = Signal(str, MeaImg_Unit)      # Signal to indicate the process has finished (even due to errors)\n\n    msg_success = 'Image capture complete'\n    msg_error = 'Error in ImageTiling_Worker: '\n\n    def __init__(self, motion_controller:Wdg_MotionController):\n        super().__init__()\n        self._motion_ctrl = motion_controller\n\n        self.sig_gotocoor.connect(self._motion_ctrl.get_goto_worker().work)\n\n    @Slot(MeaImg_Unit,bool)\n    def get_stitched_image(self, imgUnit:MeaImg_Unit, low_res:bool) -&gt; None:\n        \"\"\"\n        Get the stitched image from the ImageUnit\n\n        Args:\n            imgUnit (MeaImg_Unit): Image unit to process\n            low_res (bool): Whether to get low resolution image\n        \"\"\"\n        try:\n            img_stitched = imgUnit.get_image_all_stitched(low_res=low_res)[0]\n            self.sig_ret_image_processed.emit(img_stitched)\n        except Exception as e:\n            print('Error in get_stitched_image:', e)\n\n    @Slot(MeaCoor_mm,MeaImg_Unit,ImageTiling_Params)\n    def take_image(self, meaCoor_mm:MeaCoor_mm, imgUnit:MeaImg_Unit,\n        tiling_params:ImageTiling_Params) -&gt; None:\n        \"\"\"\n        Take an image at the given measurement coordinates and store it in the given image unit.\n\n        Args:\n            meacoor (MeaCoor_mm): Measurement coordinates\n            imgUnit (MeaImg_Unit): Image unit to store the captured image\n            tiling_params (ImageTiling_Params): Parameters for tiling\n        \"\"\"\n        flg_stop = self.flg_stop_imgCapture\n        if flg_stop.is_set(): return\n\n        # Check that all tiling parameters are valid\n        try: tiling_params.check_validity()\n        except Exception as e: \n            self.sig_midMea_error.emit(self.msg_error + f'Invalid tiling parameters: {e}')\n            return\n\n        # Extract tiling parameters\n        shape = tiling_params.shape\n        cropx_pixel = tiling_params.cropx_pixel\n        cropy_pixel = tiling_params.cropy_pixel\n        cropx_mm = tiling_params.cropx_mm\n        cropy_mm = tiling_params.cropy_mm\n\n        totalcoor = len(meaCoor_mm.mapping_coordinates)\n        flg_stop.clear()\n        self.sig_statbar_update.emit('Taking images: {} of {}'.format(1,totalcoor))\n\n        msg = self.msg_success\n        for i,coor in enumerate(meaCoor_mm.mapping_coordinates):\n            x, y, z = coor\n            if flg_stop.is_set():\n                msg = self.msg_error + 'Image capture stopped by user'\n                break\n\n            flg_mvmt_done = threading.Event()\n            self.sig_gotocoor.emit(coor, flg_mvmt_done)\n            flg_mvmt_done.wait()\n\n            img = self._motion_ctrl.get_current_image(wait_newimage=True)\n\n            if not isinstance(img,Image.Image):\n                self.sig_midMea_error.emit(self.msg_error + 'No image received from the controller')\n                continue\n\n            img = img.crop((cropx_pixel,cropy_pixel,shape[0]-cropx_pixel,shape[1]-cropy_pixel))\n\n            imgUnit.add_measurement(\n                    timestamp=get_timestamp_us_str(),\n                    x_coor=x-cropx_mm,\n                    y_coor=y-cropy_mm,\n                    z_coor=z,\n                    image=img\n                )\n\n            self.sig_statbar_update.emit('Taking images: {} of {}'.format(i+1,totalcoor))\n            img = imgUnit.get_image_all_stitched(low_res=True)[0]\n            self.sig_ret_image_processed.emit(img)\n\n        self.sig_finished_msg.emit(msg, imgUnit)\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.ImageProcessor_Worker.get_stitched_image","title":"<code>get_stitched_image(imgUnit, low_res)</code>","text":"<p>Get the stitched image from the ImageUnit</p> <p>Parameters:</p> Name Type Description Default <code>imgUnit</code> <code>MeaImg_Unit</code> <p>Image unit to process</p> required <code>low_res</code> <code>bool</code> <p>Whether to get low resolution image</p> required Source code in <code>iris/gui/submodules/image_tiling.py</code> <pre><code>@Slot(MeaImg_Unit,bool)\ndef get_stitched_image(self, imgUnit:MeaImg_Unit, low_res:bool) -&gt; None:\n    \"\"\"\n    Get the stitched image from the ImageUnit\n\n    Args:\n        imgUnit (MeaImg_Unit): Image unit to process\n        low_res (bool): Whether to get low resolution image\n    \"\"\"\n    try:\n        img_stitched = imgUnit.get_image_all_stitched(low_res=low_res)[0]\n        self.sig_ret_image_processed.emit(img_stitched)\n    except Exception as e:\n        print('Error in get_stitched_image:', e)\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.ImageProcessor_Worker.take_image","title":"<code>take_image(meaCoor_mm, imgUnit, tiling_params)</code>","text":"<p>Take an image at the given measurement coordinates and store it in the given image unit.</p> <p>Parameters:</p> Name Type Description Default <code>meacoor</code> <code>MeaCoor_mm</code> <p>Measurement coordinates</p> required <code>imgUnit</code> <code>MeaImg_Unit</code> <p>Image unit to store the captured image</p> required <code>tiling_params</code> <code>ImageTiling_Params</code> <p>Parameters for tiling</p> required Source code in <code>iris/gui/submodules/image_tiling.py</code> <pre><code>@Slot(MeaCoor_mm,MeaImg_Unit,ImageTiling_Params)\ndef take_image(self, meaCoor_mm:MeaCoor_mm, imgUnit:MeaImg_Unit,\n    tiling_params:ImageTiling_Params) -&gt; None:\n    \"\"\"\n    Take an image at the given measurement coordinates and store it in the given image unit.\n\n    Args:\n        meacoor (MeaCoor_mm): Measurement coordinates\n        imgUnit (MeaImg_Unit): Image unit to store the captured image\n        tiling_params (ImageTiling_Params): Parameters for tiling\n    \"\"\"\n    flg_stop = self.flg_stop_imgCapture\n    if flg_stop.is_set(): return\n\n    # Check that all tiling parameters are valid\n    try: tiling_params.check_validity()\n    except Exception as e: \n        self.sig_midMea_error.emit(self.msg_error + f'Invalid tiling parameters: {e}')\n        return\n\n    # Extract tiling parameters\n    shape = tiling_params.shape\n    cropx_pixel = tiling_params.cropx_pixel\n    cropy_pixel = tiling_params.cropy_pixel\n    cropx_mm = tiling_params.cropx_mm\n    cropy_mm = tiling_params.cropy_mm\n\n    totalcoor = len(meaCoor_mm.mapping_coordinates)\n    flg_stop.clear()\n    self.sig_statbar_update.emit('Taking images: {} of {}'.format(1,totalcoor))\n\n    msg = self.msg_success\n    for i,coor in enumerate(meaCoor_mm.mapping_coordinates):\n        x, y, z = coor\n        if flg_stop.is_set():\n            msg = self.msg_error + 'Image capture stopped by user'\n            break\n\n        flg_mvmt_done = threading.Event()\n        self.sig_gotocoor.emit(coor, flg_mvmt_done)\n        flg_mvmt_done.wait()\n\n        img = self._motion_ctrl.get_current_image(wait_newimage=True)\n\n        if not isinstance(img,Image.Image):\n            self.sig_midMea_error.emit(self.msg_error + 'No image received from the controller')\n            continue\n\n        img = img.crop((cropx_pixel,cropy_pixel,shape[0]-cropx_pixel,shape[1]-cropy_pixel))\n\n        imgUnit.add_measurement(\n                timestamp=get_timestamp_us_str(),\n                x_coor=x-cropx_mm,\n                y_coor=y-cropy_mm,\n                z_coor=z,\n                image=img\n            )\n\n        self.sig_statbar_update.emit('Taking images: {} of {}'.format(i+1,totalcoor))\n        img = imgUnit.get_image_all_stitched(low_res=True)[0]\n        self.sig_ret_image_processed.emit(img)\n\n    self.sig_finished_msg.emit(msg, imgUnit)\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.ImageTiling_Params","title":"<code>ImageTiling_Params</code>  <code>dataclass</code>","text":"Source code in <code>iris/gui/submodules/image_tiling.py</code> <pre><code>@dataclass\nclass ImageTiling_Params:\n    shape:tuple[int,int]\n    cropx_pixel:int\n    cropy_pixel:int\n    cropx_mm:float\n    cropy_mm:float\n\n    def check_validity(self) -&gt; bool:\n        \"\"\"\n        Check if the parameters are valid\n\n        Returns:\n            bool: True if valid, False otherwise\n        \"\"\"\n        assert isinstance(self.shape, tuple) and len(self.shape) == 2, 'shape must be a tuple of length 2'\n        assert all(isinstance(i, int) and i &gt; 0 for i in self.shape), 'shape must be positive integers'\n        assert isinstance(self.cropx_pixel, int) and self.cropx_pixel &gt;= 0, 'cropx_pixel must be a non-negative integer'\n        assert isinstance(self.cropy_pixel, int) and self.cropy_pixel &gt;= 0, 'cropy_pixel must be a non-negative integer'\n        assert isinstance(self.cropx_mm, (int, float)), 'cropx_mm must be a number'\n        assert isinstance(self.cropy_mm, (int, float)), 'cropy_mm must be a number'\n        return True    \n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.ImageTiling_Params.check_validity","title":"<code>check_validity()</code>","text":"<p>Check if the parameters are valid</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/gui/submodules/image_tiling.py</code> <pre><code>def check_validity(self) -&gt; bool:\n    \"\"\"\n    Check if the parameters are valid\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    assert isinstance(self.shape, tuple) and len(self.shape) == 2, 'shape must be a tuple of length 2'\n    assert all(isinstance(i, int) and i &gt; 0 for i in self.shape), 'shape must be positive integers'\n    assert isinstance(self.cropx_pixel, int) and self.cropx_pixel &gt;= 0, 'cropx_pixel must be a non-negative integer'\n    assert isinstance(self.cropy_pixel, int) and self.cropy_pixel &gt;= 0, 'cropy_pixel must be a non-negative integer'\n    assert isinstance(self.cropx_mm, (int, float)), 'cropx_mm must be a number'\n    assert isinstance(self.cropy_mm, (int, float)), 'cropy_mm must be a number'\n    return True    \n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.Wdg_HiLvlTiling","title":"<code>Wdg_HiLvlTiling</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A high level controller to take images, tile them into a single image, and save them  as an ImageMeasurement_Unit obj</p> Source code in <code>iris/gui/submodules/image_tiling.py</code> <pre><code>class Wdg_HiLvlTiling(qw.QWidget):\n    \"\"\"\n    A high level controller to take images, tile them into a single image, and save them \n    as an ImageMeasurement_Unit obj\n    \"\"\"\n    sig_req_plot_imgunit = Signal(MeaImg_Unit,bool)\n    sig_req_takeImage = Signal()\n    sig_update_combobox = Signal()\n\n    sig_capture_img = Signal(MeaCoor_mm,MeaImg_Unit,ImageTiling_Params)\n\n\n    def __init__(\n        self,\n        parent:qw.QWidget,\n        motion_controller:Wdg_MotionController,\n        stageHub:DataStreamer_StageCam,\n        dataHub_img:Wdg_DataHub_Image,\n        dataHub_imgcal:Wdg_DataHub_ImgCal,\n        coorHub:List_MeaCoor_Hub,\n        processor:mpp.Pool\n        ) -&gt; None:\n        \"\"\"\n        Args:\n            parent (qw.QWidget): Parent widget\n            motion_controller (Wdg_MotionController): Motion controller object\n            stageHub (DataStreamer_StageCam): Stage measurement hub\n            dataHub_img (Wdg_DataHub_Image): Data hub for the image data\n            dataHub_imgcal (Wdg_DataHub_ImgCal): Data hub for the image calibration data\n            processor (multiprocessing.pool.Pool): Processor pool\n        \"\"\"\n        assert isinstance(motion_controller, Wdg_MotionController), 'motion_controller must be a Frm_MotionController object'\n        assert isinstance(stageHub, DataStreamer_StageCam), 'stageHub must be a stage_measurement_hub object'\n        assert isinstance(dataHub_img, Wdg_DataHub_Image), 'dataHub_img must be a Frm_DataHub_Image object'\n        assert isinstance(dataHub_imgcal, Wdg_DataHub_ImgCal), 'dataHub_imgcal must be a Frm_DataHub_ImgCal object'\n        assert isinstance(processor, mpp.Pool), 'processor must be a multiprocessing.pool.Pool object'\n\n        super().__init__(parent)\n        self._motion_controller = motion_controller\n        self._stageHub = stageHub\n        self._dataHub_img = dataHub_img\n        self._dataHub_imgcal = dataHub_imgcal\n        self._coorHub = coorHub\n        self._processor = processor\n\n    # &gt;&gt;&gt; Main parameters &lt;&lt;&lt;\n        self._getter_calibration = self._dataHub_imgcal.get_selected_calibration\n\n    # &gt;&gt;&gt; Top level layout &lt;&lt;&lt;\n        self._widget = TilingMethod_Design(self)\n        lyt = qw.QVBoxLayout(self)\n        lyt.addWidget(self._widget)\n        self.setLayout(lyt)\n        wdg = self._widget\n\n        self._statbar = qw.QStatusBar(self)\n        lyt.addWidget(self._statbar)\n\n    # &gt;&gt;&gt; Image frame &lt;&lt;&lt;\n        self._canvas_img = Canvas_Image_Annotations(\n            parent=wdg,\n            size_pixel=AppPlotEnum.IMGCAL_IMG_SIZE.value,\n            )\n        wdg.lyt_holder_img.addWidget(self._canvas_img)\n        self._chk_lres = wdg.chk_lres\n\n    # &gt;&gt;&gt; Image control frame &lt;&lt;&lt;\n        self._list_imgunit_names = []\n        self._combo_imgunits = wdg.combo_img\n\n        self._combo_imgunits.currentIndexChanged.connect(self._plot_imgunit_combobox)\n        self._btn_takeImages = wdg.btn_capture\n        self._btn_takeImages_txt = self._btn_takeImages.text()\n        self._btn_takeImages.clicked.connect(self._take_image)\n\n    # &gt;&gt;&gt; Coordinate generation frame &lt;&lt;&lt;\n        wdg_tree = Wdg_Treeview_MappingCoordinates(parent=self, mappingCoorHub=self._coorHub)\n        wdg.lyt_holder_tree.addWidget(wdg_tree)\n\n        self._coorgen = TileMethod(\n            parent=self,\n            motion_controller=self._motion_controller,\n            coorHub=self._coorHub,\n            tree_coor=wdg_tree,\n            getter_cal=self._getter_calibration,\n        )\n        wdg.lyt_holder_controls.addWidget(self._coorgen)\n\n    # &gt;&gt;&gt; Worker setup &lt;&lt;&lt;\n        self._init_worker()\n\n    def _init_worker(self):\n        \"\"\"\n        Initialises the worker for the tiling and the image processing\n        \"\"\"\n        # &gt;&gt;&gt; Worker setup &lt;&lt;&lt;\n        self._thread = QThread()\n        self._worker = ImageProcessor_Worker(self._motion_controller)\n        self._worker.moveToThread(self._thread)\n        self._thread.start()\n        self.destroyed.connect(self._thread.quit)\n        self._thread.finished.connect(self._thread.deleteLater)\n        self._thread.finished.connect(self._worker.deleteLater)\n\n        self._worker.sig_ret_image_processed.connect(self._canvas_img.set_image)\n        self.sig_req_plot_imgunit.connect(self._worker.get_stitched_image)\n\n        # Other signal/connection setups\n        self._dataHub_img.get_ImageMeasurement_Hub().add_observer(self.sig_update_combobox.emit)\n        self.sig_update_combobox.connect(self._update_combobox)\n\n        # Image capture signals\n        self.sig_capture_img.connect(self._worker.take_image)\n        self._worker.sig_finished_msg.connect(self._handle_imageCapture_finished)\n\n    def _plot_imgunit_combobox(self):\n        \"\"\"\n        Plot the ImageUnit selected in the combobox\n        \"\"\"\n        try:\n            self._combo_imgunits.setEnabled(False)\n\n            imgUnit = self._get_selected_ImageUnit()\n            if not isinstance(imgUnit,MeaImg_Unit): raise ValueError('No ImageUnit found')\n            if not(imgUnit.check_measurement_exist() and imgUnit.check_calibration_exist()):\n                raise ValueError('No image or calibration found')\n\n            self.sig_req_plot_imgunit.emit(imgUnit, self._chk_lres.isChecked())\n        except Exception as e:\n            qw.QMessageBox.warning(self,'Error in _plot_imgunit',str(e))\n        finally:\n            self._combo_imgunits.setEnabled(True)\n\n    def _update_combobox(self):\n        \"\"\"\n        Update the combobox with the ImageUnits stored in the ImageHub\n        using the DataHubImage\n        \"\"\"\n        self._combo_imgunits.blockSignals(True)\n        self._combo_imgunits.setEnabled(False)\n\n        hub = self._dataHub_img.get_ImageMeasurement_Hub()\n        list_ids = hub.get_list_ImageUnit_ids()\n        dict_idToName = hub.get_dict_IDtoName()\n        list_names = [dict_idToName[id] for id in list_ids]\n\n        # Only update when needed\n        if list_names == self._list_imgunit_names: return\n\n        current_name = self._combo_imgunits.currentText()\n\n        self._list_imgunit_names = list_names.copy()\n        self._combo_imgunits.clear()\n        self._combo_imgunits.addItems(list_names)\n\n        if current_name in list_names:\n            self._combo_imgunits.setCurrentText(current_name)\n        else:\n            self._combo_imgunits.setCurrentIndex(0)\n            self.sig_req_plot_imgunit.emit(hub.get_ImageMeasurementUnit(unit_id=list_ids[0]), self._chk_lres.isChecked())\n\n        self._combo_imgunits.setEnabled(True)\n        self._combo_imgunits.blockSignals(False)\n\n    @Slot(str, MeaImg_Unit)\n    def _handle_imageCapture_finished(self, msg:str, imgUnit:MeaImg_Unit):\n        \"\"\"\n        Handle the image capture finished signal\n\n        Args:\n            msg (str): Message to display\n        \"\"\"\n        # Save the image unit into the hub\n        self._dataHub_img.get_ImageMeasurement_Hub().append_ImageMeasurementUnit(imgUnit)\n\n        # Handle the GUI\n        self._statbar.showMessage(msg,5000)\n        self.reset_imgCapture_button()\n        self._motion_controller.enable_widgets()\n\n        # Plot the image unit\n        self._combo_imgunits.setCurrentText(imgUnit.get_IdName()[1])\n\n    def reset_imgCapture_button(self):\n        self._btn_takeImages.setText(self._btn_takeImages_txt)\n        self._btn_takeImages.setStyleSheet('')\n\n        try: self._btn_takeImages.clicked.disconnect()\n        except: pass\n        self._btn_takeImages.clicked.connect(self._take_image)\n\n        self._motion_controller.enable_widgets()\n\n    def _get_selected_ImageUnit(self) -&gt; MeaImg_Unit:\n        \"\"\"\n        Get the selected ImageUnit from the combobox\n\n        Returns:\n            ImageMeasurement_Unit: The selected ImageUnit\n        \"\"\"\n        hub = self._dataHub_img.get_ImageMeasurement_Hub()\n        dict_nameToID = hub.get_dict_nameToID()\n\n        name = self._combo_imgunits.currentText()\n        id = dict_nameToID[name]\n        return hub.get_ImageMeasurementUnit(unit_id=id)\n\n    def _take_image(self):\n        \"\"\"\n        Take images and tile them into a single image\n\n        Args:\n            flg_stop (threading.Event): Event to stop the function\n        \"\"\"\n        # &gt; Setup the button &lt;\n        try: self._btn_takeImages.clicked.disconnect()\n        except: pass\n        self._btn_takeImages.setText('STOP')\n        self._btn_takeImages.setStyleSheet('background-color: red; color: white;')\n        self._btn_takeImages.clicked.connect(self._worker.flg_stop_imgCapture.set)\n        self._motion_controller.disable_widgets()\n\n        # &gt; Initial checks &lt;\n        cal = deepcopy(self._getter_calibration())\n        if not isinstance(cal,ImgMea_Cal) or not cal.check_calibration_set():\n            qw.QMessageBox.warning(self,'Error','No calibration found')\n            self.reset_imgCapture_button()\n            return\n\n        try: result = self._coorgen.get_tiling_coordinates_mm_and_cropFactors_rel()\n        except Exception as e:\n            qw.QMessageBox.warning(self,'Error',f'Error generating coordinates: {e}')\n            self.reset_imgCapture_button()\n            return\n        if result is None:\n            qw.QMessageBox.warning(self,'Error','No coordinates generated')\n            self.reset_imgCapture_button()\n            return\n\n        list_meaCoor_mm, cropx_ratio_red, cropy_ratio_red = result\n        if not list_meaCoor_mm:\n            qw.QMessageBox.warning(self,'Error','No coordinates found')\n            self.reset_imgCapture_button()\n            return\n\n        # &gt; Modify the calibration file\n        img_test = self._motion_controller.get_current_image(wait_newimage=True)\n        if not isinstance(img_test,Image.Image):\n            qw.QMessageBox.warning(self,'Error','No image received from the controller')\n            self.reset_imgCapture_button()\n            return\n\n        shape = img_test.size\n        laserx = cal.laser_coor_x_mm\n        lasery = cal.laser_coor_y_mm\n        cropx_pixel = int(shape[0]*cropx_ratio_red)//2  # Cropped pixel x-distance from the edge (one of the two sides!!)\n        cropy_pixel = int(shape[1]*cropy_ratio_red)//2  # Cropped pixel y-distance from the edge (one of the two sides!!)\n        cropx_mm,cropy_mm = cal.convert_imgpt2stg(\n            coor_img_pixel=np.array((cropx_pixel,cropy_pixel)),\n            coor_stage_mm=np.array((0,0)))\n\n        laserx -= cropx_mm\n        lasery -= cropy_mm\n\n        cal.set_calibration_params(\n            scale_x_pixelPerMm=cal.scale_x_pixelPerMm,\n            scale_y_pixelPerMm=cal.scale_y_pixelPerMm,\n            laser_coor_x_mm=laserx,\n            laser_coor_y_mm=lasery,\n            rotation_rad=cal.rotation_rad,\n            flip_y=cal.flip_y,\n        )\n\n        cal.id += f'_{cropx_ratio_red}X,{cropy_ratio_red}Ycrop'\n\n        # &gt; Prep the image storage &lt;\n        list_imgUnit = []\n        for meaCoor_mm in list_meaCoor_mm:\n            list_Hub_names = self._dataHub_img.get_ImageMeasurement_Hub().get_list_ImageUnit_ids()\n            # Request for the names and check its validity\n            while True:\n                result = qw.QInputDialog.getText(\n                    self,\n                    'Image name',\n                    'Enter the name of the image:',\n                    qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue] ; Normal line edit exists\n                    meaCoor_mm.mappingUnit_name\n                )\n                imgname, ok = result\n                if not ok: # User cancelled\n                    self.reset_imgCapture_button()\n                    return\n                if imgname in list_Hub_names:\n                    retry = qw.QMessageBox.question(\n                        self,\n                        'Error',\n                        'Image name already exists. Please enter a different name.',\n                        qw.QMessageBox.Retry | qw.QMessageBox.Cancel, # pyright: ignore[reportAttributeAccessIssue] ; Retry and Cancel buttons exist\n                        qw.QMessageBox.Retry # pyright: ignore[reportAttributeAccessIssue] ; Retry button exists\n                    )\n                    if retry == qw.QMessageBox.Cancel:  # pyright: ignore[reportAttributeAccessIssue] ; Cancel button exists\n                        return\n                    else: continue\n                break\n            list_imgUnit.append(MeaImg_Unit(unit_name=imgname,calibration=cal))\n\n        # &gt; Send the coordinates to the worker for the image capture &lt;\n        tiling_params = ImageTiling_Params(\n            shape=shape,\n            cropx_pixel=cropx_pixel,\n            cropy_pixel=cropy_pixel,\n            cropx_mm=cropx_mm,\n            cropy_mm=cropy_mm,\n        )\n        for imgUnit, meaCoor_mm in zip(list_imgUnit,list_meaCoor_mm):\n            self.sig_capture_img.emit(meaCoor_mm, imgUnit, tiling_params)\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.Wdg_HiLvlTiling.__init__","title":"<code>__init__(parent, motion_controller, stageHub, dataHub_img, dataHub_imgcal, coorHub, processor)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>Parent widget</p> required <code>motion_controller</code> <code>Wdg_MotionController</code> <p>Motion controller object</p> required <code>stageHub</code> <code>DataStreamer_StageCam</code> <p>Stage measurement hub</p> required <code>dataHub_img</code> <code>Wdg_DataHub_Image</code> <p>Data hub for the image data</p> required <code>dataHub_imgcal</code> <code>Wdg_DataHub_ImgCal</code> <p>Data hub for the image calibration data</p> required <code>processor</code> <code>Pool</code> <p>Processor pool</p> required Source code in <code>iris/gui/submodules/image_tiling.py</code> <pre><code>def __init__(\n    self,\n    parent:qw.QWidget,\n    motion_controller:Wdg_MotionController,\n    stageHub:DataStreamer_StageCam,\n    dataHub_img:Wdg_DataHub_Image,\n    dataHub_imgcal:Wdg_DataHub_ImgCal,\n    coorHub:List_MeaCoor_Hub,\n    processor:mpp.Pool\n    ) -&gt; None:\n    \"\"\"\n    Args:\n        parent (qw.QWidget): Parent widget\n        motion_controller (Wdg_MotionController): Motion controller object\n        stageHub (DataStreamer_StageCam): Stage measurement hub\n        dataHub_img (Wdg_DataHub_Image): Data hub for the image data\n        dataHub_imgcal (Wdg_DataHub_ImgCal): Data hub for the image calibration data\n        processor (multiprocessing.pool.Pool): Processor pool\n    \"\"\"\n    assert isinstance(motion_controller, Wdg_MotionController), 'motion_controller must be a Frm_MotionController object'\n    assert isinstance(stageHub, DataStreamer_StageCam), 'stageHub must be a stage_measurement_hub object'\n    assert isinstance(dataHub_img, Wdg_DataHub_Image), 'dataHub_img must be a Frm_DataHub_Image object'\n    assert isinstance(dataHub_imgcal, Wdg_DataHub_ImgCal), 'dataHub_imgcal must be a Frm_DataHub_ImgCal object'\n    assert isinstance(processor, mpp.Pool), 'processor must be a multiprocessing.pool.Pool object'\n\n    super().__init__(parent)\n    self._motion_controller = motion_controller\n    self._stageHub = stageHub\n    self._dataHub_img = dataHub_img\n    self._dataHub_imgcal = dataHub_imgcal\n    self._coorHub = coorHub\n    self._processor = processor\n\n# &gt;&gt;&gt; Main parameters &lt;&lt;&lt;\n    self._getter_calibration = self._dataHub_imgcal.get_selected_calibration\n\n# &gt;&gt;&gt; Top level layout &lt;&lt;&lt;\n    self._widget = TilingMethod_Design(self)\n    lyt = qw.QVBoxLayout(self)\n    lyt.addWidget(self._widget)\n    self.setLayout(lyt)\n    wdg = self._widget\n\n    self._statbar = qw.QStatusBar(self)\n    lyt.addWidget(self._statbar)\n\n# &gt;&gt;&gt; Image frame &lt;&lt;&lt;\n    self._canvas_img = Canvas_Image_Annotations(\n        parent=wdg,\n        size_pixel=AppPlotEnum.IMGCAL_IMG_SIZE.value,\n        )\n    wdg.lyt_holder_img.addWidget(self._canvas_img)\n    self._chk_lres = wdg.chk_lres\n\n# &gt;&gt;&gt; Image control frame &lt;&lt;&lt;\n    self._list_imgunit_names = []\n    self._combo_imgunits = wdg.combo_img\n\n    self._combo_imgunits.currentIndexChanged.connect(self._plot_imgunit_combobox)\n    self._btn_takeImages = wdg.btn_capture\n    self._btn_takeImages_txt = self._btn_takeImages.text()\n    self._btn_takeImages.clicked.connect(self._take_image)\n\n# &gt;&gt;&gt; Coordinate generation frame &lt;&lt;&lt;\n    wdg_tree = Wdg_Treeview_MappingCoordinates(parent=self, mappingCoorHub=self._coorHub)\n    wdg.lyt_holder_tree.addWidget(wdg_tree)\n\n    self._coorgen = TileMethod(\n        parent=self,\n        motion_controller=self._motion_controller,\n        coorHub=self._coorHub,\n        tree_coor=wdg_tree,\n        getter_cal=self._getter_calibration,\n    )\n    wdg.lyt_holder_controls.addWidget(self._coorgen)\n\n# &gt;&gt;&gt; Worker setup &lt;&lt;&lt;\n    self._init_worker()\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/image_tiling/#iris.gui.submodules.image_tiling.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/","title":"peakfinder_plotter_MeaRaman","text":""},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.PeakFinderPlotter_Worker","title":"<code>PeakFinderPlotter_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/submodules/peakfinder_plotter_MeaRaman.py</code> <pre><code>class PeakFinderPlotter_Worker(QObject):\n\n    sig_peaks = Signal(list,list,list)\n    sig_error = Signal(str)\n    sig_drawPlot = Signal()\n\n    def __init__(self,plotter:MeaRaman_Plotter):\n        \"\"\"\n        Initialises the Peak Finder Plotter Worker.\n\n        Args:\n            canvas (FigureCanvas): The matplotlib figure canvas\n        \"\"\"\n        super().__init__()\n        self._plotter = plotter\n\n    @Slot(MeaRaman, dict, tuple, bool)\n    def plot_spectra(self, mea:MeaRaman, options:dict, limits:tuple,\n                     flg_RamanShift:bool) -&gt; None:\n        \"\"\"\n        Plots the Raman spectra.\n\n        Args:\n            mea (RamanMeasurement): The Raman measurement\n            options (dict): The options for peak finding\n            limits (tuple): The plot limits\n            flg_RamanShift (bool): Whether to plot Raman shift or wavelength\n        \"\"\"\n        list_wavelength = mea.get_measurements()[-1][mea.label_wavelength]\n        list_intensity = mea.get_measurements()[-1][mea.label_intensity]\n\n        try:\n            peaks_idx = find_peaks(list_intensity,**options)[0]\n            peak_wavelength = [list_wavelength[i] for i in peaks_idx]\n            peak_intensity = [list_intensity[i] for i in peaks_idx]\n\n            laser_wavelength = mea.get_laser_params()[1]\n            list_peak_Ramanshift_str = ['{:1f}'.format(convert_wavelength_to_ramanshift(wavelength,laser_wavelength)) for wavelength in peak_wavelength]\n            list_peak_intensity_str = ['{:3f}'.format(list_intensity[i]) for i in peaks_idx]\n            list_peak_wavelength_str = ['{:1f}'.format(list_wavelength[i]) for i in peaks_idx]\n\n            # Update the treeview\n            self._plotter.plot_scatter(\n                measurement=mea,\n                title='Raman spectra of {}'.format(str(mea.get_latest_timestamp())),\n                list_scatter_wavelength=peak_wavelength,\n                list_scatter_intensity=peak_intensity,\n                flg_plot_ramanshift=flg_RamanShift,\n                limits=limits,\n            )\n\n            self.sig_peaks.emit(list_peak_wavelength_str,list_peak_Ramanshift_str,list_peak_intensity_str)\n            self.sig_drawPlot.emit()\n        except Exception as e:\n            self.sig_error.emit(str(e))\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.PeakFinderPlotter_Worker.__init__","title":"<code>__init__(plotter)</code>","text":"<p>Initialises the Peak Finder Plotter Worker.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>FigureCanvasQTAgg</code> <p>The matplotlib figure canvas</p> required Source code in <code>iris/gui/submodules/peakfinder_plotter_MeaRaman.py</code> <pre><code>def __init__(self,plotter:MeaRaman_Plotter):\n    \"\"\"\n    Initialises the Peak Finder Plotter Worker.\n\n    Args:\n        canvas (FigureCanvas): The matplotlib figure canvas\n    \"\"\"\n    super().__init__()\n    self._plotter = plotter\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.PeakFinderPlotter_Worker.plot_spectra","title":"<code>plot_spectra(mea, options, limits, flg_RamanShift)</code>","text":"<p>Plots the Raman spectra.</p> <p>Parameters:</p> Name Type Description Default <code>mea</code> <code>RamanMeasurement</code> <p>The Raman measurement</p> required <code>options</code> <code>dict</code> <p>The options for peak finding</p> required <code>limits</code> <code>tuple</code> <p>The plot limits</p> required <code>flg_RamanShift</code> <code>bool</code> <p>Whether to plot Raman shift or wavelength</p> required Source code in <code>iris/gui/submodules/peakfinder_plotter_MeaRaman.py</code> <pre><code>@Slot(MeaRaman, dict, tuple, bool)\ndef plot_spectra(self, mea:MeaRaman, options:dict, limits:tuple,\n                 flg_RamanShift:bool) -&gt; None:\n    \"\"\"\n    Plots the Raman spectra.\n\n    Args:\n        mea (RamanMeasurement): The Raman measurement\n        options (dict): The options for peak finding\n        limits (tuple): The plot limits\n        flg_RamanShift (bool): Whether to plot Raman shift or wavelength\n    \"\"\"\n    list_wavelength = mea.get_measurements()[-1][mea.label_wavelength]\n    list_intensity = mea.get_measurements()[-1][mea.label_intensity]\n\n    try:\n        peaks_idx = find_peaks(list_intensity,**options)[0]\n        peak_wavelength = [list_wavelength[i] for i in peaks_idx]\n        peak_intensity = [list_intensity[i] for i in peaks_idx]\n\n        laser_wavelength = mea.get_laser_params()[1]\n        list_peak_Ramanshift_str = ['{:1f}'.format(convert_wavelength_to_ramanshift(wavelength,laser_wavelength)) for wavelength in peak_wavelength]\n        list_peak_intensity_str = ['{:3f}'.format(list_intensity[i]) for i in peaks_idx]\n        list_peak_wavelength_str = ['{:1f}'.format(list_wavelength[i]) for i in peaks_idx]\n\n        # Update the treeview\n        self._plotter.plot_scatter(\n            measurement=mea,\n            title='Raman spectra of {}'.format(str(mea.get_latest_timestamp())),\n            list_scatter_wavelength=peak_wavelength,\n            list_scatter_intensity=peak_intensity,\n            flg_plot_ramanshift=flg_RamanShift,\n            limits=limits,\n        )\n\n        self.sig_peaks.emit(list_peak_wavelength_str,list_peak_Ramanshift_str,list_peak_intensity_str)\n        self.sig_drawPlot.emit()\n    except Exception as e:\n        self.sig_error.emit(str(e))\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.Wdg_RamanMeasurement_Peakfinder_Plotter","title":"<code>Wdg_RamanMeasurement_Peakfinder_Plotter</code>","text":"<p>               Bases: <code>Ui_spectra_peak_finder</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/peakfinder_plotter_MeaRaman.py</code> <pre><code>class Wdg_RamanMeasurement_Peakfinder_Plotter(Ui_spectra_peak_finder, qw.QWidget):\n\n    sig_request_plot = Signal(MeaRaman, dict, tuple, bool)\n\n    def __init__(self, parent:qw.QWidget):\n        \"\"\"\n        Initialises the Raman measurement plotter.\n\n        Args:\n            parent (QWidget): The parent widget\n        \"\"\"\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n    # &gt;&gt;&gt; Storage setup &lt;&lt;&lt;\n        self._RamanMeasurement:MeaRaman|None = None\n\n    # &gt;&gt;&gt; Plotter setup &lt;&lt;&lt;\n        self._plotter = MeaRaman_Plotter()\n\n        # Plot setup\n        self._fig, self._ax = self._plotter.get_fig_ax()\n\n        self._fig_canvas = FigureCanvas(figure=self._fig)\n        self.lyt_plot.addWidget(self._fig_canvas)\n        self._fig_canvas.draw_idle()\n\n        self.btn_savePlotPng.clicked.connect(lambda: qw.QMessageBox.information(self,'Info','Not implemented yet.'))\n        self.btn_savePlotTxt.clicked.connect(self._save_txt)\n\n        # Replot parameters\n        self._dict_replot_params = {}\n\n    # &gt; Treeview to show the peaks found &lt;\n        self.tree_peaks.setColumnCount(3)\n        self.tree_peaks.setHeaderLabels(['Wavelength','Raman-shift','Intensity'])\n\n    # &gt; Entry widgets for peak finder parameters &lt;\n        self._init_entry_widgets_peakfinder()\n        self._init_workers_and_signals()\n\n    def _init_workers_and_signals(self):\n        \"\"\"\n        Initialises the workers and signals for the peak finder plotter.\n        \"\"\"\n        # Worker setup\n        self._worker_thread = QThread()\n        self._worker = PeakFinderPlotter_Worker(self._plotter)\n        self._worker.moveToThread(self._worker_thread)\n        self._worker_thread.start(QThread.Priority.LowPriority)\n\n        # Signals setup\n        self._worker.sig_peaks.connect(self._update_treeview_peaks)\n        self._worker.sig_error.connect(self._handle_error)\n        self._worker.sig_drawPlot.connect(self._update_plot)\n\n        self.sig_request_plot.connect(self._worker.plot_spectra)\n\n    @Slot()\n    def _update_plot(self):\n        \"\"\"\n        Updates the plot.\n        \"\"\"\n        self._fig_canvas.draw_idle()\n\n    @Slot(list,list,list)\n    def _update_treeview_peaks(self,list_wavelength_str:list,list_Ramanshift_str:list,\n                               list_intensity_str:list):\n        \"\"\"\n        Updates the treeview with the found peaks.\n\n        Args:\n            list_wavelength_str (list): The list of peak wavelengths as strings\n            list_Ramanshift_str (list): The list of peak Raman shifts as strings\n            list_intensity_str (list): The list of peak intensities as strings\n        \"\"\"\n        self.tree_peaks.clear()\n        assert len(list_wavelength_str) == len(list_Ramanshift_str) == len(list_intensity_str),\\\n            'Error in _update_treeview_peaks: Length of peak lists are not equal.'\n\n        for i in range(len(list_wavelength_str)):\n            item = qw.QTreeWidgetItem([list_wavelength_str[i],list_Ramanshift_str[i],list_intensity_str[i]])\n            self.tree_peaks.addTopLevelItem(item)\n\n    @Slot(str)\n    def _handle_error(self,error_msg:str): qw.QMessageBox.warning(self,'Error',error_msg)\n\n    def _init_entry_widgets_peakfinder(self) -&gt; None:\n        \"\"\"\n        Initialises the entry widgets for peak finder parameters.\n        \"\"\"\n        self._dict_widgets_peakfinder:Dict[str, qw.QLineEdit] = {}\n        lyt = self.lyt_form_parmas\n\n        self._peakfinder_options = PeakFinderOptions()\n        for i,key in enumerate(asdict(self._peakfinder_options).keys()):\n            lbl = qw.QLabel(key,self)\n            ent = qw.QLineEdit(self)\n            ent.textChanged.connect(self._replot_spectra)\n\n            # Place the widgets in the form layout\n            lyt.setWidget(i, qw.QFormLayout.LabelRole, lbl) # pyright: ignore[reportAttributeAccessIssue] ; QFormLayout has setWidget method\n            lyt.setWidget(i, qw.QFormLayout.FieldRole, ent) # pyright: ignore[reportAttributeAccessIssue] ; QFormLayout has setWidget method\n            self._dict_widgets_peakfinder[key] = ent\n\n        widgets = get_all_widgets_from_layout(self.lyt_limits)\n        [wdg.textChanged.connect(self._replot_spectra) for wdg in widgets if isinstance(wdg,qw.QLineEdit)]\n\n    def _get_dict_peakfinder_options(self) -&gt; dict:\n        \"\"\"\n        Updates the peak finder options based on the entry widgets.\n\n        Returns:\n            dict: The updated peak finder options\n        \"\"\"\n        dict_options = asdict(self._peakfinder_options)\n        dict_options_return = {}\n        for key in dict_options.keys():\n            val = self._dict_widgets_peakfinder[key].text()\n            try: dict_options_return[key] = float(val)\n            except: pass\n\n        return dict_options_return\n\n    @Slot()\n    def _save_txt(self):\n        \"\"\"\n        Saves the Raman Measurement currently shown in the plot as a text file.\n        \"\"\"\n        if not isinstance(self._RamanMeasurement,MeaRaman):\n            qw.QMessageBox.warning(self,'Error','No Raman measurement to save.'); return\n\n        savepath = qw.QFileDialog.getSaveFileName(self,'Save Raman Measurement as Text File','','Text files (*.txt)')[0]\n\n        handler = MeaRaman_Handler()\n        handler.save_measurement_to_txt(self._RamanMeasurement,savepath,save_raw=False)\n\n    @Slot()\n    def _reset_plot_limits(self):\n        \"\"\"\n        Resets the plot limits.\n        \"\"\"\n        self.ent_xmin.clear()\n        self.ent_xmax.clear()\n        self.ent_ymin.clear()\n        self.ent_ymax.clear()\n\n    def _get_plot_limits(self) -&gt; tuple[float|None,float|None,float|None,float|None]:\n        \"\"\"\n        Gets the plot limits.\n\n        Returns:\n            tuple[float|None,float|None,float|None,float|None]: The x-min, x-max, y-min, and y-max\n        \"\"\"\n        try: xmin = float(self.ent_xmin.text())\n        except: xmin = None\n        try: xmax = float(self.ent_xmax.text())\n        except: xmax = None\n        try: ymin = float(self.ent_ymin.text())\n        except: ymin = None\n        try: ymax = float(self.ent_ymax.text())\n        except: ymax = None\n\n        return xmin,xmax,ymin,ymax\n\n    @Slot()\n    def _replot_spectra(self):\n        \"\"\"\n        Replots the Raman spectra based on the last plot parameters (and arguments).\n        \"\"\"\n        self.plot_spectra(**self._dict_replot_params)\n\n    @Slot(MeaRaman)\n    def plot_spectra(self,mea:MeaRaman|None=None) -&gt; None:\n        \"\"\"\n        Plots the Raman spectra.\n\n        Args:\n            mea (RamanMeasurement): The Raman measurement\n            mea_id (str): The ID of the Raman measurement for the plot title\n\n        Returns:\n            tuple[list,list]: The list of peak wavelengths and intensities\n        \"\"\"\n        if mea is None: mea = self._RamanMeasurement\n        if mea is None: qw.QMessageBox.warning(self,'Error','No Raman measurement to plot.'); return\n\n        self._dict_replot_params = {\n            'mea': mea,\n        }\n\n        dict_options = self._get_dict_peakfinder_options()\n        limits = self._get_plot_limits()\n        flg_RamanShift = self.chk_RamanShift.isChecked()\n\n        self.sig_request_plot.emit(mea,dict_options,limits,flg_RamanShift)\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.Wdg_RamanMeasurement_Peakfinder_Plotter.__init__","title":"<code>__init__(parent)</code>","text":"<p>Initialises the Raman measurement plotter.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required Source code in <code>iris/gui/submodules/peakfinder_plotter_MeaRaman.py</code> <pre><code>def __init__(self, parent:qw.QWidget):\n    \"\"\"\n    Initialises the Raman measurement plotter.\n\n    Args:\n        parent (QWidget): The parent widget\n    \"\"\"\n    super().__init__(parent)\n    self.setupUi(self)\n    self.setLayout(self.main_layout)\n\n# &gt;&gt;&gt; Storage setup &lt;&lt;&lt;\n    self._RamanMeasurement:MeaRaman|None = None\n\n# &gt;&gt;&gt; Plotter setup &lt;&lt;&lt;\n    self._plotter = MeaRaman_Plotter()\n\n    # Plot setup\n    self._fig, self._ax = self._plotter.get_fig_ax()\n\n    self._fig_canvas = FigureCanvas(figure=self._fig)\n    self.lyt_plot.addWidget(self._fig_canvas)\n    self._fig_canvas.draw_idle()\n\n    self.btn_savePlotPng.clicked.connect(lambda: qw.QMessageBox.information(self,'Info','Not implemented yet.'))\n    self.btn_savePlotTxt.clicked.connect(self._save_txt)\n\n    # Replot parameters\n    self._dict_replot_params = {}\n\n# &gt; Treeview to show the peaks found &lt;\n    self.tree_peaks.setColumnCount(3)\n    self.tree_peaks.setHeaderLabels(['Wavelength','Raman-shift','Intensity'])\n\n# &gt; Entry widgets for peak finder parameters &lt;\n    self._init_entry_widgets_peakfinder()\n    self._init_workers_and_signals()\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.Wdg_RamanMeasurement_Peakfinder_Plotter.plot_spectra","title":"<code>plot_spectra(mea=None)</code>","text":"<p>Plots the Raman spectra.</p> <p>Parameters:</p> Name Type Description Default <code>mea</code> <code>RamanMeasurement</code> <p>The Raman measurement</p> <code>None</code> <code>mea_id</code> <code>str</code> <p>The ID of the Raman measurement for the plot title</p> required <p>Returns:</p> Type Description <code>None</code> <p>tuple[list,list]: The list of peak wavelengths and intensities</p> Source code in <code>iris/gui/submodules/peakfinder_plotter_MeaRaman.py</code> <pre><code>@Slot(MeaRaman)\ndef plot_spectra(self,mea:MeaRaman|None=None) -&gt; None:\n    \"\"\"\n    Plots the Raman spectra.\n\n    Args:\n        mea (RamanMeasurement): The Raman measurement\n        mea_id (str): The ID of the Raman measurement for the plot title\n\n    Returns:\n        tuple[list,list]: The list of peak wavelengths and intensities\n    \"\"\"\n    if mea is None: mea = self._RamanMeasurement\n    if mea is None: qw.QMessageBox.warning(self,'Error','No Raman measurement to plot.'); return\n\n    self._dict_replot_params = {\n        'mea': mea,\n    }\n\n    dict_options = self._get_dict_peakfinder_options()\n    limits = self._get_plot_limits()\n    flg_RamanShift = self.chk_RamanShift.isChecked()\n\n    self.sig_request_plot.emit(mea,dict_options,limits,flg_RamanShift)\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.test","title":"<code>test()</code>","text":"<p>Test function for the PeakFinderPlotter.</p> Source code in <code>iris/gui/submodules/peakfinder_plotter_MeaRaman.py</code> <pre><code>def test():\n    \"\"\"\n    Test function for the PeakFinderPlotter.\n    \"\"\"\n    import sys\n    from PySide6.QtWidgets import QApplication\n\n    app = QApplication(sys.argv)\n    mw = qw.QMainWindow()\n    mwdg = Wdg_RamanMeasurement_Peakfinder_Plotter(mw)\n    mw.setCentralWidget(mwdg)\n    mw.show()\n\n    mea = MeaRaman(reconstruct=True)\n    mea.test_generate_dummy()\n\n    mwdg.plot_spectra(\n        mea=mea,\n    )\n\n    sys.exit(app.exec())\n</code></pre>"},{"location":"reference/iris/gui/submodules/peakfinder_plotter_MeaRaman/#iris.gui.submodules.peakfinder_plotter_MeaRaman.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/","title":"line_zScan","text":"<p>An instance that manages the linear z-scan method for the mapping methods. To be used in conjunction with the 2D mapping coordinate generators.</p>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.Wdg_ZScanMethod_linear","title":"<code>Wdg_ZScanMethod_linear</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A class that manages the linear z-scan method for the mapping methods.</p> Source code in <code>iris/gui/submodules/meaCoor_generator/line_zScan.py</code> <pre><code>class Wdg_ZScanMethod_linear(qw.QWidget):\n    \"\"\"\n    A class that manages the linear z-scan method for the mapping methods.\n    \"\"\"\n    def __init__(self,parent,getter_stagecoor:Callable[[],tuple[float|None,float|None,float|None]],\n                 *args, **kwargs) -&gt; None:\n        \"\"\"\n        Initialises the class with the necessary parameters.\n\n        Args:\n            parent: The parent widget\n            getter_stagecoor (Callable[[],tuple[float,float,float]]): A function that returns the current stage coordinates.\n        \"\"\"\n        super().__init__(parent)\n\n        # Set the motion controller\n        self._getter_stagecoor = getter_stagecoor\n\n        # Main UI setup\n        self._widget = Converter_2Dto3D_design(self)\n        self._lyt_main = qw.QVBoxLayout(self)\n        self._lyt_main.addWidget(self._widget)\n        wdg = self._widget\n\n        self._ent_start = wdg.ent_zstart_um\n        self._ent_end = wdg.ent_zend_um\n        self._ent_res_pt = wdg.ent_res_pt\n        self._ent_res_um = wdg.ent_res_um\n\n        wdg.btn_currcoor_start.clicked.connect(lambda: self._updatefield_with_stagecoor(self._ent_start))\n        wdg.btn_currcoor_end.clicked.connect(lambda: self._updatefield_with_stagecoor(self._ent_end))\n\n        self._ent_start.textChanged.connect(self._updatefield_zres_points)\n        self._ent_end.textChanged.connect(self._updatefield_zres_points)\n\n        self._ent_res_pt.editingFinished.connect(self._updatefield_zres_um)\n        self._ent_res_um.editingFinished.connect(self._updatefield_zres_points)\n\n    @Slot()\n    def _updatefield_with_stagecoor(self,field:qw.QLineEdit) -&gt; None:\n        \"\"\"\n        Updates the given field with the current stage coordinate.\n\n        Args:\n            field (qw.QLineEdit): The field to update.\n        \"\"\"\n        try:\n            stage_coor = self._getter_stagecoor()\n            assert isinstance(stage_coor, (list, tuple)) and len(stage_coor) == 3, 'Invalid stage coordinates'\n            assert all(isinstance(c, (int, float)) for c in stage_coor), 'Stage coordinates must be numeric'\n            field.setText('{:.3f}'.format(stage_coor[2]*1000))  # Convert to um\n        except Exception as e: print('Error in _update_field_with_stagecoor: {}'.format(e))\n\n    @Slot()\n    def _updatefield_zres_points(self) -&gt; None:\n        \"\"\"\n        Updates the z-resolution in points based on the z-resolution in micrometers.\n        \"\"\"\n        try:\n            z_start = float(self._ent_start.text())\n            z_end = float(self._ent_end.text())\n            z_res_um = float(self._ent_res_um.text())\n            assert z_res_um &gt; 0, 'Z-resolution must be positive'\n            num_points = max(2, int(np.ceil(abs(z_end - z_start) / z_res_um)) + 1)\n            self._ent_res_pt.setText(str(num_points))\n        except Exception as e: pass\n\n    @Slot()\n    def _updatefield_zres_um(self) -&gt; None:\n        \"\"\"\n        Updates the z-resolution in micrometers based on the z-resolution in points.\n        \"\"\"\n        try:\n            z_start = float(self._ent_start.text())\n            z_end = float(self._ent_end.text())\n            z_res_pt = int(self._ent_res_pt.text())\n            assert z_res_pt &gt;= 2, 'Z-resolution must be at least 2 points'\n            z_res_um = abs(z_end - z_start) / (z_res_pt - 1)\n            self._ent_res_um.setText('{:.3f}'.format(z_res_um))\n        except Exception as e: pass\n\n    def get_coordinates_mm(self,mapping_coor:list[tuple[float,float,float]]) -&gt; list[list[tuple[float,float,float]]]|None:\n        \"\"\"\n        Converts the 2D mapping coordinates to 3D coordinates for the z-scan method.\n\n        Args:\n            mapping_coor (list[tuple[float,float,float]]): The mapping coordinates\n\n        Returns:\n            list[list[tuple[float,float,float]]]|None: List of 2D mapping coordinates with varying z-scan coordinates OR\n                None if the z-scan parameters are not set.\n        \"\"\"\n        try:\n            z_start = float(self._ent_start.text())\n            z_end = float(self._ent_end.text())\n            z_res = int(self._ent_res_pt.text())\n            mapping_coor_3D = []\n            zcoors = np.linspace(z_start/1000,z_end/1000,z_res)  # Convert to mm\n            for z in zcoors:\n                mapping_coor_2D = [(coor[0],coor[1],z) for coor in mapping_coor]\n                mapping_coor_3D.append(mapping_coor_2D)\n            return mapping_coor_3D\n        except Exception as e:\n            qw.QMessageBox.warning(self,'Z-scan Error',\n                                   'An error occurred while generating Z-scan coordinates:\\n{}'.format(e))\n            return None\n\n    def report_params(self) -&gt; None:\n        \"\"\"\n        Prints the current parameters to the console.\n        \"\"\"\n        try:\n            print('Z-scan parameters: {}'.format(get_timestamp_us_str()))\n            print(f'Z-start: {self._ent_start.text()} um')\n            print(f'Z-end: {self._ent_end.text()} um')\n            print(f'Z-resolution: {self._ent_res_um.text()} um')\n            print('Z-scan coors: {}'.format(np.linspace(\n                float(self._ent_start.text()),float(self._ent_end.text()),int(self._ent_res_pt.text()))))\n        except:\n            pass\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.Wdg_ZScanMethod_linear.__init__","title":"<code>__init__(parent, getter_stagecoor, *args, **kwargs)</code>","text":"<p>Initialises the class with the necessary parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <p>The parent widget</p> required <code>getter_stagecoor</code> <code>Callable[[], tuple[float, float, float]]</code> <p>A function that returns the current stage coordinates.</p> required Source code in <code>iris/gui/submodules/meaCoor_generator/line_zScan.py</code> <pre><code>def __init__(self,parent,getter_stagecoor:Callable[[],tuple[float|None,float|None,float|None]],\n             *args, **kwargs) -&gt; None:\n    \"\"\"\n    Initialises the class with the necessary parameters.\n\n    Args:\n        parent: The parent widget\n        getter_stagecoor (Callable[[],tuple[float,float,float]]): A function that returns the current stage coordinates.\n    \"\"\"\n    super().__init__(parent)\n\n    # Set the motion controller\n    self._getter_stagecoor = getter_stagecoor\n\n    # Main UI setup\n    self._widget = Converter_2Dto3D_design(self)\n    self._lyt_main = qw.QVBoxLayout(self)\n    self._lyt_main.addWidget(self._widget)\n    wdg = self._widget\n\n    self._ent_start = wdg.ent_zstart_um\n    self._ent_end = wdg.ent_zend_um\n    self._ent_res_pt = wdg.ent_res_pt\n    self._ent_res_um = wdg.ent_res_um\n\n    wdg.btn_currcoor_start.clicked.connect(lambda: self._updatefield_with_stagecoor(self._ent_start))\n    wdg.btn_currcoor_end.clicked.connect(lambda: self._updatefield_with_stagecoor(self._ent_end))\n\n    self._ent_start.textChanged.connect(self._updatefield_zres_points)\n    self._ent_end.textChanged.connect(self._updatefield_zres_points)\n\n    self._ent_res_pt.editingFinished.connect(self._updatefield_zres_um)\n    self._ent_res_um.editingFinished.connect(self._updatefield_zres_points)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.Wdg_ZScanMethod_linear.get_coordinates_mm","title":"<code>get_coordinates_mm(mapping_coor)</code>","text":"<p>Converts the 2D mapping coordinates to 3D coordinates for the z-scan method.</p> <p>Parameters:</p> Name Type Description Default <code>mapping_coor</code> <code>list[tuple[float, float, float]]</code> <p>The mapping coordinates</p> required <p>Returns:</p> Type Description <code>list[list[tuple[float, float, float]]] | None</code> <p>list[list[tuple[float,float,float]]]|None: List of 2D mapping coordinates with varying z-scan coordinates OR None if the z-scan parameters are not set.</p> Source code in <code>iris/gui/submodules/meaCoor_generator/line_zScan.py</code> <pre><code>def get_coordinates_mm(self,mapping_coor:list[tuple[float,float,float]]) -&gt; list[list[tuple[float,float,float]]]|None:\n    \"\"\"\n    Converts the 2D mapping coordinates to 3D coordinates for the z-scan method.\n\n    Args:\n        mapping_coor (list[tuple[float,float,float]]): The mapping coordinates\n\n    Returns:\n        list[list[tuple[float,float,float]]]|None: List of 2D mapping coordinates with varying z-scan coordinates OR\n            None if the z-scan parameters are not set.\n    \"\"\"\n    try:\n        z_start = float(self._ent_start.text())\n        z_end = float(self._ent_end.text())\n        z_res = int(self._ent_res_pt.text())\n        mapping_coor_3D = []\n        zcoors = np.linspace(z_start/1000,z_end/1000,z_res)  # Convert to mm\n        for z in zcoors:\n            mapping_coor_2D = [(coor[0],coor[1],z) for coor in mapping_coor]\n            mapping_coor_3D.append(mapping_coor_2D)\n        return mapping_coor_3D\n    except Exception as e:\n        qw.QMessageBox.warning(self,'Z-scan Error',\n                               'An error occurred while generating Z-scan coordinates:\\n{}'.format(e))\n        return None\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.Wdg_ZScanMethod_linear.report_params","title":"<code>report_params()</code>","text":"<p>Prints the current parameters to the console.</p> Source code in <code>iris/gui/submodules/meaCoor_generator/line_zScan.py</code> <pre><code>def report_params(self) -&gt; None:\n    \"\"\"\n    Prints the current parameters to the console.\n    \"\"\"\n    try:\n        print('Z-scan parameters: {}'.format(get_timestamp_us_str()))\n        print(f'Z-start: {self._ent_start.text()} um')\n        print(f'Z-end: {self._ent_end.text()} um')\n        print(f'Z-resolution: {self._ent_res_um.text()} um')\n        print('Z-scan coors: {}'.format(np.linspace(\n            float(self._ent_start.text()),float(self._ent_end.text()),int(self._ent_res_pt.text()))))\n    except:\n        pass\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/line_zScan/#iris.gui.submodules.meaCoor_generator.line_zScan.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/","title":"points_image","text":"<p>An instance that manages a basic mapping method in tkinter. This is similar to that of the mapping_method_rectxy_scan_constz mapping method but this one can set it using an image (with an objective calibration file/params) instead.</p>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.CanvasUpdater_Worker","title":"<code>CanvasUpdater_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A worker class to automatically update the video feed canvas with the image unit and the clicked coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_generator/points_image.py</code> <pre><code>class CanvasUpdater_Worker(QObject):\n    \"\"\"\n    A worker class to automatically update the video feed canvas\n    with the image unit and the clicked coordinates\n    \"\"\"\n    sig_error = Signal(str)\n\n    sig_img_stageCoor_mm = Signal(tuple)\n\n    sig_updateImage = Signal(Image)\n    sig_annotateRectangle = Signal(tuple,tuple,bool)\n\n    sig_finished = Signal() # To indicate that the canvas update is finished\n\n    def __init__(self, canvas_image:Canvas_Image_Annotations, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._canvas_image = canvas_image\n        self.sig_updateImage.connect(self._canvas_image.set_image)\n        self.sig_annotateRectangle.connect(self._canvas_image.draw_rectangle_canvas)\n\n    @Slot(MeaImg_Unit,bool)\n    def _update_image_shown(self, imgUnit:MeaImg_Unit, low_resolution:bool) -&gt; None:\n        \"\"\"\n        Updates the image shown on the canvas\n        \"\"\"\n        img, stage_coor_mm, _ = imgUnit.get_image_all_stitched(low_res=low_resolution)\n        self.sig_updateImage.emit(img)\n        self.sig_img_stageCoor_mm.emit(stage_coor_mm)\n        self.sig_finished.emit()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.Points_Image","title":"<code>Points_Image</code>","text":"<p>               Bases: <code>Ui_Point_Image</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_generator/points_image.py</code> <pre><code>class Points_Image(Ui_Point_Image, qw.QWidget):\n\n    sig_updateImageCombobox = Signal()\n    sig_updateResPt = Signal()\n    sig_updateResUm = Signal()\n\n    sig_resetStoredCoors = Signal() # To reset the stored coordinates\n\n    sig_updateCanvasRectangle = Signal(MeaImg_Unit,bool,list)\n    sig_updateCanvasImage = Signal(MeaImg_Unit,bool)\n\n    def __init__(\n        self,\n        parent: qw.QWidget,\n        motion_controller:Wdg_MotionController,\n        dataHub_img:Wdg_DataHub_Image,\n        *args, **kwargs\n        ):\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n    # &gt;&gt;&gt; General setup &lt;&lt;&lt;\n        self._motion_controller = motion_controller\n        self._dataHub_img = dataHub_img\n\n        video_feed_size = AppPlotEnum.MAP_METHOD_IMAGE_VIDEO_SIZE.value\n\n        # Parameters\n        self._imgUnit:MeaImg_Unit|None = None    # The image unit object\n        self._img:Image|None = None                  # The image shown on the canvas\n        self._img_coor_stage_mm:tuple|None = None    # The stage coordinates corresponding to the self._img camera frame of reference\n\n    # &gt;&gt;&gt; Video feed setup &lt;&lt;&lt;\n        # Parameters\n        self._list_imgunit_names:list[str] = []\n\n        # Canvas setup\n        self._canvas_image = Canvas_Image_Annotations(self,size_pixel=video_feed_size)\n        self.lyt_canvas.addWidget(self._canvas_image)\n        self._canvas_image.start_recordClicks()\n\n        self.combo_image.activated.connect(self._update_image_shown)\n\n        # Params\n        self._list_clickMeaCoor_mm = []     # The list of clicked coordinates in mm\n\n    # &gt; Z-coordinate setup widgets &lt;\n        self.btn_storeZ.clicked.connect(self._store_current_coorz)\n\n    # &gt;&gt;&gt; Worker and signals setup &lt;&lt;&lt;\n        self._init_signals()\n        self._init_workers()\n\n    def _init_signals(self):\n        \"\"\"\n        Initialises the signals and slots for the GUI\n        \"\"\"\n        # Set scan area button\n        self.btn_instruction.clicked.connect(self._show_instructions)\n\n        # Image unit combobox\n        self.combo_image.setEnabled(False)\n        self._dataHub_img.get_ImageMeasurement_Hub().add_observer(self.sig_updateImageCombobox.emit)\n        self.sig_updateImageCombobox.connect(self._update_combobox_imageUnits)\n        self.sig_updateImageCombobox.emit()\n\n        # Canvas clear annotations observer\n        self._canvas_image.add_observer_rightclick(self.sig_resetStoredCoors.emit)\n        self.sig_resetStoredCoors.connect(self._reset_click_coors)\n\n    def _init_workers(self):\n        \"\"\"\n        Initialises the worker threads for automatic image updating\n        \"\"\"\n        # Worker thread for automatic image updating\n        self._thread_canvas = QThread()\n        self._worker_canvas = CanvasUpdater_Worker(self._canvas_image)\n        self._worker_canvas.moveToThread(self._thread_canvas)\n\n        # Connect signals\n        self.sig_updateCanvasImage.connect(self._worker_canvas._update_image_shown)\n\n        self._worker_canvas.sig_error.connect(lambda msg: qw.QMessageBox.warning(self, 'Error', msg))\n        self._worker_canvas.sig_img_stageCoor_mm.connect(self._update_img_stageCoor_mm)\n        self._thread_canvas.start()\n\n    @Slot()\n    def _show_instructions(self):\n        \"\"\"\n        Shows the instructions for using the rectangle image mapping method\n        \"\"\"\n        instructions = (\n            \"Instructions:\\n\"\n            \"1. Select an image to display\\n\"\n            \"2. Left-click on the image to include points in the ROI\\n\"\n            \"3. Right-click on the image to reset the selected points.\\n\"\n        )\n        qw.QMessageBox.information(self, 'Instructions - Rectangle Image Mapping Method', instructions)\n\n    @Slot(tuple)\n    def _update_img_stageCoor_mm(self,coor_mm:tuple):\n        \"\"\"\n        Updates the image stage coordinates\n\n        Args:\n            coor_mm (tuple): The stage coordinates in mm\n        \"\"\"\n        assert isinstance(coor_mm,tuple), 'coor_mm must be a tuple'\n        assert all(isinstance(c,float) for c in coor_mm), 'coor_mm must be a tuple of floats'\n        self._img_coor_stage_mm = coor_mm\n\n    @Slot(tuple)\n    def _append_clickCoor_mm(self, coor_pixel:tuple):\n        \"\"\"\n        Appends the clicked coordinate in pixels to the list of clicked coordinates\n        after converting it to stage coordinates in mm\n\n        Args:\n            coor_pixel (tuple): The clicked coordinate in pixels\n        \"\"\"\n        imgUnit = self._get_selected_ImageUnit()\n        if not isinstance(imgUnit,MeaImg_Unit) or not imgUnit.check_calibration_exist():\n            print('No image unit or calibration selected')\n            return\n\n        stage_coor_mm = self._img_coor_stage_mm\n\n        if not isinstance(stage_coor_mm,tuple):\n            print('Invalid stage coordinates')\n            return\n\n        if not all(isinstance(c,float) for c in stage_coor_mm):\n            print('Invalid stage coordinates')\n            return\n\n        coor_stage_mm = imgUnit.convert_imgpt2stg(\n            frame_coor_mm=stage_coor_mm,\n            coor_pixel=coor_pixel,\n            correct_rot=True,\n            low_res=self.chk_lres.isChecked()\n        )\n\n        self._list_clickMeaCoor_mm.append(coor_stage_mm[:2])   # Only store x,y coordinates\n\n    @Slot()\n    def _store_current_coorz(self):\n        \"\"\"\n        Gets the current stage coordinate and store it as the initial position\n        \"\"\"\n        try:\n            coor_z_mm = self._motion_controller.get_coordinates_closest_mm()[2]\n            if not isinstance(coor_z_mm,float): raise ValueError('Z coordinate is not a float')\n        except Exception as e:\n            print(e)\n            qw.QMessageBox.warning(self, 'Error', str(e))\n            return\n\n        self.spin_z.setValue(coor_z_mm*1e3)\n\n    @Slot()\n    def _reset_click_coors(self):\n        \"\"\"\n        Resets the click coordinates\n        \"\"\"\n        self._list_clickMeaCoor_mm.clear()\n        self.lbl_scanEdges.setText('None')\n\n        self._canvas_image.clear_all_annotations()\n        self._canvas_image.start_recordClicks()\n\n    @Slot()\n    def _update_combobox_imageUnits(self):\n        \"\"\"\n        Automatically updates the combobox with the image units\n        \"\"\"\n        self.combo_image.setEnabled(False)\n        hub = self._dataHub_img.get_ImageMeasurement_Hub()\n        list_unit_ids = hub.get_list_ImageUnit_ids()\n        dict_idToName = hub.get_dict_IDtoName()\n        list_unit_names = [dict_idToName[unit_id] for unit_id in list_unit_ids]\n\n        # Only updates when necessary\n        if list_unit_names == self._list_imgunit_names: return\n\n        self._list_imgunit_names = list_unit_names.copy()\n        name = self.combo_image.currentText()\n        self.combo_image.clear()\n        self.combo_image.addItems(self._list_imgunit_names)\n\n        if name in self._list_imgunit_names:\n            self.combo_image.setCurrentText(name)\n        elif len(self._list_imgunit_names) &gt; 0:\n            self.combo_image.setCurrentIndex(0)\n\n        self.combo_image.setEnabled(len(self._list_imgunit_names) &gt; 0)\n\n    def _get_selected_ImageUnit(self) -&gt; MeaImg_Unit|None:\n        \"\"\"\n        Returns the selected image unit in the combobox\n\n        Returns:\n            ImageMeasurement_Unit|None: The selected image unit or None\n        \"\"\"\n        unit_name = self.combo_image.currentText()\n        hub = self._dataHub_img.get_ImageMeasurement_Hub()\n        ret = None\n        try: ret = hub.get_ImageMeasurementUnit(unit_name=unit_name)\n        except Exception as e:\n            print(f'Error getting selected ImageUnit: {e}')\n        return ret\n\n    @Slot()\n    def _update_image_shown(self) -&gt; None:\n        \"\"\"\n        Updates the image shown on the canvas\n        \"\"\"\n        img = self._get_selected_ImageUnit()\n        if img is None:\n            print('No image unit selected')\n            return\n        # print(f'Updating image shown: {img.get_IdName()}')\n\n        self._reset_click_coors()\n\n        self.sig_updateCanvasImage.emit(\n            img,\n            self.chk_lres.isChecked()\n        )\n\n    def get_mapping_coordinates_mm(self):\n        z = self.spin_z.value()*1e-3\n        list_coors = [(x,y,z) for (x,y) in self._list_clickMeaCoor_mm]\n        return list_coors\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/points_image/#iris.gui.submodules.meaCoor_generator.points_image.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/","title":"rectangle_aroundCentre","text":""},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.Rect_AroundCentre","title":"<code>Rect_AroundCentre</code>","text":"<p>               Bases: <code>Ui_meaCoor_Rect_StartEnd</code>, <code>QWidget</code></p> <p>A basic class that manage a mapping method</p> <p>Parameters:</p> Name Type Description Default <code>tk</code> <code>tkinter</code> <p>tkinter library</p> required Source code in <code>iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre.py</code> <pre><code>class Rect_AroundCentre(Ui_meaCoor_Rect_StartEnd, qw.QWidget):\n    \"\"\"A basic class that manage a mapping method\n\n    Args:\n        tk (tkinter): tkinter library\n    \"\"\"\n    sig_updateResPt = Signal()\n    sig_updateResUm = Signal()\n    sig_error = Signal(str)\n\n    msg_error = 'Error: '\n\n    def __init__(self,parent:qw.QWidget,motion_controller:Wdg_MotionController,\n                 *args, **kwargs) -&gt; None:\n        # Place itself in the given master frame (container)\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        # Sets up the other controllers\n        self._motion_controller = motion_controller\n\n        # Make the widgets to store the coordinates\n        self.btn_storecentre.clicked.connect(self._store_current_coor_center)\n        self.btn_storez.clicked.connect(self._store_current_coorz)\n\n        self._init_signals()\n\n    def _init_signals(self):\n        self.spin_centrex.valueChanged.connect(self._update_resolution_pt)\n        self.spin_centrey.valueChanged.connect(self._update_resolution_pt)\n        self.spin_widx.valueChanged.connect(self._update_resolution_pt)\n        self.spin_heiy.valueChanged.connect(self._update_resolution_pt)\n\n        self.spin_resxpt.valueChanged.connect(self._update_resolution_um)\n        self.spin_resypt.valueChanged.connect(self._update_resolution_um)\n        self.spin_resxum.valueChanged.connect(self._update_resolution_pt)\n        self.spin_resyum.valueChanged.connect(self._update_resolution_pt)\n\n    def get_mapping_coordinates_mm(self) -&gt; list[tuple[float,float,float]]|None:\n        \"\"\" \n        Returns the mapping coordinates\n\n        Returns:\n            list: List of tuple (x,y,z) coordinates\n        \"\"\"\n        # Define the grid boundaries\n        centre_x = self.spin_centrex.value()/1e3\n        centre_y = self.spin_centrey.value()/1e3\n        dist_x = self.spin_widx.value()/1e3/2\n        dist_y = self.spin_heiy.value()/1e3/2\n\n        x_min = centre_x - dist_x\n        y_min = centre_y - dist_y\n        x_max = centre_x + dist_x\n        y_max = centre_y + dist_y\n        z_const = self.spin_z.value()/1e3  # Convert from um to mm\n\n        # Number of points in each direction\n        num_pointsx = self.spin_resxpt.value()\n        num_pointsy = self.spin_resypt.value()\n\n        # Generate linearly spaced points along each axis\n        x_points = np.linspace(x_min, x_max, num_pointsx)\n        y_points = np.linspace(y_min, y_max, num_pointsy)\n\n        # Create the grid\n        X, Y = np.meshgrid(x_points, y_points)\n        return [(x, y, z_const) for x, y in zip(X.flatten(), Y.flatten())]\n\n    @Slot()\n    def _store_current_coorz(self):\n        \"\"\"\n        Gets the current stage coordinate and store it as the initial position\n        \"\"\"\n        try:\n            coor_z_mm = self._motion_controller.get_coordinates_closest_mm()[2]\n            if not isinstance(coor_z_mm,float): raise ValueError('Z coordinate is not a float')\n        except Exception as e:\n            print(e)\n            self.sig_error.emit(self.msg_error + str(e))\n            return\n\n        self.spin_z.setValue(coor_z_mm*1e3)\n\n    @Slot()\n    def _store_current_coor_center(self):\n        \"\"\"\n        Gets the current stage coordinate and store it as the initial position\n        \"\"\"\n        try:\n            # Get the current coordinates from the device\n            coor_x_mm,coor_y_mm = self._motion_controller.get_coordinates_closest_mm()[:2]\n            if not isinstance(coor_x_mm,float) or not isinstance(coor_y_mm,float):\n                raise ValueError('X or Y coordinate is not a float')\n        except Exception as e:\n            print(e)\n            self.sig_error.emit(self.msg_error + str(e))\n            return\n\n        self.spin_centrex.setValue(coor_x_mm*1e3)\n        self.spin_centrey.setValue(coor_y_mm*1e3)\n\n    def _block_signals_resolution(self,block:bool):\n        \"\"\"\n        Blocks or unblocks the resolution spinbox signals\n\n        Args:\n            block (bool): True to block, False to unblock\n        \"\"\"\n        self.spin_resxpt.blockSignals(block)\n        self.spin_resypt.blockSignals(block)\n        self.spin_resxum.blockSignals(block)\n        self.spin_resyum.blockSignals(block)\n\n    @Slot()\n    def _update_resolution_um(self):\n        \"\"\"\n        Updates the um resolution entry based on the other entries\n        \"\"\"\n        self._block_signals_resolution(True)\n\n        dist_x = self.spin_widx.value()\n        dist_y = self.spin_heiy.value()\n\n        points_x = self.spin_resxpt.value()\n        points_y = self.spin_resypt.value()\n\n        resUm_x = dist_x/(points_x-1) if points_x&gt;1 else 0\n        resUm_y = dist_y/(points_y-1) if points_y&gt;1 else 0\n\n        self.spin_resxum.setValue(resUm_x)\n        self.spin_resyum.setValue(resUm_y)\n\n        self._block_signals_resolution(False)\n\n    @Slot()\n    def _update_resolution_pt(self):\n        \"\"\"\n        Updates the point resolution entry based on the other entries\n        \"\"\"\n        self._block_signals_resolution(True)\n\n        dist_x = self.spin_widx.value()\n        dist_y = self.spin_heiy.value()\n\n        resUm_x = self.spin_resxum.value()\n        resUm_y = self.spin_resyum.value()\n\n        points_x = int(dist_x/resUm_x)+1 if resUm_x&gt;0 else 1\n        points_y = int(dist_y/resUm_y)+1 if resUm_y&gt;0 else 1\n\n        # print(f'Res pt update requested: distx={dist_x}, resUmx={resUm_x} =&gt; pointsx={points_x}, disty={dist_y}, resUmy={resUm_y} =&gt; pointsy={points_y}')\n\n        self.spin_resxpt.setValue(points_x)\n        self.spin_resypt.setValue(points_y)\n\n        self._block_signals_resolution(False)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.Rect_AroundCentre.get_mapping_coordinates_mm","title":"<code>get_mapping_coordinates_mm()</code>","text":"<p>Returns the mapping coordinates</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[float, float, float]] | None</code> <p>List of tuple (x,y,z) coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre.py</code> <pre><code>def get_mapping_coordinates_mm(self) -&gt; list[tuple[float,float,float]]|None:\n    \"\"\" \n    Returns the mapping coordinates\n\n    Returns:\n        list: List of tuple (x,y,z) coordinates\n    \"\"\"\n    # Define the grid boundaries\n    centre_x = self.spin_centrex.value()/1e3\n    centre_y = self.spin_centrey.value()/1e3\n    dist_x = self.spin_widx.value()/1e3/2\n    dist_y = self.spin_heiy.value()/1e3/2\n\n    x_min = centre_x - dist_x\n    y_min = centre_y - dist_y\n    x_max = centre_x + dist_x\n    y_max = centre_y + dist_y\n    z_const = self.spin_z.value()/1e3  # Convert from um to mm\n\n    # Number of points in each direction\n    num_pointsx = self.spin_resxpt.value()\n    num_pointsy = self.spin_resypt.value()\n\n    # Generate linearly spaced points along each axis\n    x_points = np.linspace(x_min, x_max, num_pointsx)\n    y_points = np.linspace(y_min, y_max, num_pointsy)\n\n    # Create the grid\n    X, Y = np.meshgrid(x_points, y_points)\n    return [(x, y, z_const) for x, y in zip(X.flatten(), Y.flatten())]\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_aroundCentre/#iris.gui.submodules.meaCoor_generator.rectangle_aroundCentre.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/","title":"rectangle_endToEnd","text":"<p>An instance that manages a basic mapping method in tkinter</p>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.Wdg_Rect_StartEnd","title":"<code>Wdg_Rect_StartEnd</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_generator/rectangle_endToEnd.py</code> <pre><code>class Wdg_Rect_StartEnd(qw.QWidget):\n\n    sig_res_pt_changed = Signal()   # Signal emitted when the resolution points are changed\n    sig_res_um_changed = Signal()   # Signal emitted when the resolution in um is changed\n\n    def __init__(self,parent,motion_controller:Wdg_MotionController,*args, **kwargs) -&gt; None:\n        \"\"\"Initializes the mapping method\n\n        Args:\n            parent (qw.QWidget): The frame to place the mapping method\n            motion_controller (Wdg_MotionController): The motion controller to control the stage\n        \"\"\"\n        # Place itself in the given master frame (container)\n        super().__init__(parent)\n\n        # Initialise the main widget\n        self._widget = Rect_EndToEnd(self)\n        wdg = self._widget\n\n        self._main_layout = qw.QHBoxLayout(self)\n        self._main_layout.addWidget(self._widget)\n\n        # Sets up the other controllers\n        self._motion_controller = motion_controller\n\n        # Mapping parameters\n        self._coor_xy1_mm = [None,None]     # Stores the start coordinates for the mapping. Required for movement boundary setting. Type: float\n        self._coor_xy2_mm = [None,None]     # Stores the end coordinates for the mapping. Required for movement boundary setting. Type: float\n        self._coor_z_mm = None              # Stores the start z-coordinate for the mapping. Required for movement boundary setting. Type: float\n        self._m1_pointsx = None             # Stores the mapping resolution in the x-direction\n        self._m1_pointsy = None             # Stores the mapping resolution in the y-direction\n        self._m1_resx_um = None             # Stores the mapping resolution in the x-direction\n        self._m1_resy_um = None             # Stores the mapping resolution in the y-direction\n        self._mapping_coordinates = None # Stores the mapping coordinates in a (x,y,z) list\n\n        # Make the widgets to store the coordinates\n        self._ent_startx_um = wdg.ent_startx_um\n        self._ent_starty_um = wdg.ent_starty_um\n        self._btn_storexy_start = wdg.btn_curr_start_xy\n\n        self._ent_endx_um = wdg.ent_endx_um\n        self._ent_endy_um = wdg.ent_endy_um\n        self._btn_storexy_end = wdg.btn_curr_end_xy\n\n        self._ent_z_um = wdg.ent_z_um\n        self._btn_storez = wdg.btn_curr_z\n\n        # Make the widgets to manage the rest of the mapping parameters\n        self._ent_xres = wdg.ent_res_pt_x\n        self._ent_yres = wdg.ent_res_pt_y\n\n        # Bind return to the set_coor buttons\n        self._ent_startx_um.textChanged.connect(self._update_resolution_field_um)\n        self._ent_starty_um.textChanged.connect(self._update_resolution_field_um)\n        self._ent_startx_um.returnPressed.connect(self._update_resolution_field_um)\n        self._ent_starty_um.returnPressed.connect(self._update_resolution_field_um)\n\n        self._ent_endx_um.textChanged.connect(self._update_resolution_field_um)\n        self._ent_endy_um.textChanged.connect(self._update_resolution_field_um)\n        self._ent_endx_um.returnPressed.connect(self._update_resolution_field_um)\n        self._ent_endy_um.returnPressed.connect(self._update_resolution_field_um)\n\n        self._ent_xres.textChanged.connect(self._update_resolution_field_um)\n        self._ent_yres.textChanged.connect(self._update_resolution_field_um)\n        self._ent_xres.returnPressed.connect(self._update_resolution_field_um)\n        self._ent_yres.returnPressed.connect(self._update_resolution_field_um)\n\n        self._widget.ent_res_um_x.textChanged.connect(self._update_resolution_field_points)\n        self._widget.ent_res_um_y.textChanged.connect(self._update_resolution_field_points)\n        self._widget.ent_res_um_x.returnPressed.connect(self._update_resolution_field_points)\n        self._widget.ent_res_um_y.returnPressed.connect(self._update_resolution_field_points)\n\n        self._btn_storexy_start.clicked.connect(self._grab_startxy)\n        self._btn_storexy_end.clicked.connect(self._grab_endxy)\n        self._btn_storez.clicked.connect(self._grab_z)\n\n    def get_mapping_coordinates_mm(self) -&gt; list[tuple[float,float,float]]:\n        \"\"\" \n        Returns the mapping coordinates\n\n        Returns:\n            list: List of tuple (x,y,z) coordinates\n        \"\"\"\n        # Make sure to keep the generated coordinates up to date\n        self._generate_mapping_coordinates()\n        assert isinstance(self._mapping_coordinates,list)\n        assert all([isinstance(coor,tuple) and len(coor)==3 for coor in self._mapping_coordinates])\n        assert all([all([isinstance(val,float) for val in coor]) for coor in self._mapping_coordinates])\n        return self._mapping_coordinates\n\n    @Slot()\n    def _generate_mapping_coordinates(self):\n        \"\"\"\n        Generates the mapping coordinates. Also stores them in its own variable and the main\n        operation variable\n        \"\"\"\n        try: x1,y1,x2,y2,z = self._get_startendz_coor_mm()\n        except ValueError as e:\n            self._mapping_coordinates = None\n            qw.QMessageBox.warning(None,'Warning',str(e))\n            return\n\n        try: res_pt_x, res_pt_y = self._get_resolution_points()\n        except ValueError as e:\n            self._mapping_coordinates = None\n            qw.QMessageBox.warning(None,'Warning',str(e))\n            return\n\n        # Generate linearly spaced points along each axis\n        x_points = np.linspace(x1, x2, res_pt_x) # type: ignore\n        y_points = np.linspace(y1, y2, res_pt_y) # type: ignore\n\n        # Create the grid\n        X, Y = np.meshgrid(x_points, y_points)\n        self._mapping_coordinates = [(float(x), float(y), float(z)) for x, y in zip(X.flatten(), Y.flatten())]\n\n    def _reset_mapping_coordinates(self):\n        self._m1_pointsx = None             # Stores the mapping resolution in the x-direction\n        self._m1_pointsy = None             # Stores the mapping resolution in the y-direction\n        self._m1_resx_um = None             # Stores the mapping resolution in the x-direction\n        self._m1_resy_um = None             # Stores the mapping resolution in the y-direction\n        self._mapping_coordinates = None    # Stores the mapping coordinates in a (x,y,z) list\n\n    def _get_startendz_coor_mm(self) -&gt; tuple[float,float,float,float,float]:\n        \"\"\"\n        Returns the start and end coordinates in mm\n\n        Returns:\n            tuple: (x1_mm,y1_mm,x2_mm,y2_mm,z_mm)\n        \"\"\"\n        try:\n            coor_x1_mm = float(self._ent_startx_um.text())/1e3\n            coor_y1_mm = float(self._ent_starty_um.text())/1e3\n            coor_x2_mm = float(self._ent_endx_um.text())/1e3\n            coor_y2_mm = float(self._ent_endy_um.text())/1e3\n            coor_z_mm = float(self._ent_z_um.text())/1e3\n        except ValueError as e:\n            raise ValueError('Please enter numbers for the coordinates')\n        return coor_x1_mm,coor_y1_mm,coor_x2_mm,coor_y2_mm,coor_z_mm\n\n    def _get_resolution_points(self) -&gt; tuple[int,int]:\n        \"\"\"\n        Returns the resolution points in x and y direction\n        \"\"\"\n        try:\n            res_x_pts = int(self._ent_xres.text())\n            res_y_pts = int(self._ent_yres.text())\n        except ValueError as e:\n            raise ValueError('Please enter integer numbers for the resolution points')\n\n        return res_x_pts,res_y_pts\n\n    def _get_resolution_um(self) -&gt; tuple[float,float]:\n        \"\"\"\n        Returns the resolution points in x and y direction\n        \"\"\"\n        try:\n            res_x_um = float(self._widget.ent_res_um_x.text())\n            res_y_um = float(self._widget.ent_res_um_y.text())\n        except ValueError as e:\n            raise ValueError('Please enter integer numbers for the resolution points')\n\n        return res_x_um,res_y_um\n\n\n    @Slot()\n    def _update_resolution_field_points(self):\n        \"\"\"\n        Sets the resolution of the mapping in the x and y direction\n        using the stored distances\n        \"\"\"\n        try: x_um, y_um = self._get_resolution_um()\n        except ValueError as e: return\n\n\n        try: x1,y1,x2,y2,_ = self._get_startendz_coor_mm()\n        except ValueError as e:\n            self._ent_xres.setPlaceholderText('Set coordinates first')\n            self._ent_yres.setPlaceholderText('Set coordinates first')\n            return\n\n        distx = x2 - x1\n        disty = y2 - y1\n\n        resx_pt = ceil((distx*1000)/x_um)\n        resy_pt = ceil((disty*1000)/y_um)\n\n        self._ent_xres.setText('{}'.format(resx_pt))\n        self._ent_yres.setText('{}'.format(resy_pt))\n\n    @Slot()\n    def _update_resolution_field_um(self):\n        \"\"\"\n        Sets the resolution of the mapping in the x and y direction\n        using the stored distances\n        \"\"\"\n        try: x_pts, y_pts = self._get_resolution_points()\n        except ValueError as e: return\n\n\n        try: x1,y1,x2,y2,_ = self._get_startendz_coor_mm()\n        except ValueError as e:\n            self._ent_xres.setPlaceholderText('Set coordinates first')\n            self._ent_yres.setPlaceholderText('Set coordinates first')\n            return\n\n        distx = x2 - x1\n        disty = y2 - y1\n\n        resx_um = (distx/x_pts)*1000\n        resy_um = (disty/y_pts)*1000\n\n        self._widget.ent_res_um_x.setText('{:.2f}'.format(resx_um))\n        self._widget.ent_res_um_y.setText('{:.2f}'.format(resy_um))\n\n    def _grab_z(self):\n        \"\"\"\n        Gets the current stage coordinate and store it as the initial position\n        \"\"\"\n        _,_,z = self._motion_controller.get_coordinates_closest_mm()\n        if z is None: qw.QMessageBox.warning(None,'Warning','Unable to get current Z coordinate from the stage'); return\n\n        self._ent_z_um.setText('{:.2f}'.format(z*1e3))\n\n    def _grab_endxy(self):\n        \"\"\"\n        Gets the current stage coordinate and store it as the initial position\n        \"\"\"\n        x,y,_ = self._motion_controller.get_coordinates_closest_mm()\n        if x is None or y is None: qw.QMessageBox.warning(None,'Warning','Unable to get current XY coordinates from the stage'); return\n\n        self._ent_endx_um.setText('{:.2f}'.format(x*1e3))\n        self._ent_endy_um.setText('{:.2f}'.format(y*1e3))\n\n    def _grab_startxy(self):\n        \"\"\"\n        Gets the current stage coordinate and store it as the initial position\n        \"\"\"\n        x,y,_ = self._motion_controller.get_coordinates_closest_mm()\n        if x is None or y is None: qw.QMessageBox.warning(None,'Warning','Unable to get current XY coordinates from the stage'); return\n\n        self._ent_startx_um.setText('{:.2f}'.format(x*1e3))\n        self._ent_starty_um.setText('{:.2f}'.format(y*1e3))\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.Wdg_Rect_StartEnd.__init__","title":"<code>__init__(parent, motion_controller, *args, **kwargs)</code>","text":"<p>Initializes the mapping method</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The frame to place the mapping method</p> required <code>motion_controller</code> <code>Wdg_MotionController</code> <p>The motion controller to control the stage</p> required Source code in <code>iris/gui/submodules/meaCoor_generator/rectangle_endToEnd.py</code> <pre><code>def __init__(self,parent,motion_controller:Wdg_MotionController,*args, **kwargs) -&gt; None:\n    \"\"\"Initializes the mapping method\n\n    Args:\n        parent (qw.QWidget): The frame to place the mapping method\n        motion_controller (Wdg_MotionController): The motion controller to control the stage\n    \"\"\"\n    # Place itself in the given master frame (container)\n    super().__init__(parent)\n\n    # Initialise the main widget\n    self._widget = Rect_EndToEnd(self)\n    wdg = self._widget\n\n    self._main_layout = qw.QHBoxLayout(self)\n    self._main_layout.addWidget(self._widget)\n\n    # Sets up the other controllers\n    self._motion_controller = motion_controller\n\n    # Mapping parameters\n    self._coor_xy1_mm = [None,None]     # Stores the start coordinates for the mapping. Required for movement boundary setting. Type: float\n    self._coor_xy2_mm = [None,None]     # Stores the end coordinates for the mapping. Required for movement boundary setting. Type: float\n    self._coor_z_mm = None              # Stores the start z-coordinate for the mapping. Required for movement boundary setting. Type: float\n    self._m1_pointsx = None             # Stores the mapping resolution in the x-direction\n    self._m1_pointsy = None             # Stores the mapping resolution in the y-direction\n    self._m1_resx_um = None             # Stores the mapping resolution in the x-direction\n    self._m1_resy_um = None             # Stores the mapping resolution in the y-direction\n    self._mapping_coordinates = None # Stores the mapping coordinates in a (x,y,z) list\n\n    # Make the widgets to store the coordinates\n    self._ent_startx_um = wdg.ent_startx_um\n    self._ent_starty_um = wdg.ent_starty_um\n    self._btn_storexy_start = wdg.btn_curr_start_xy\n\n    self._ent_endx_um = wdg.ent_endx_um\n    self._ent_endy_um = wdg.ent_endy_um\n    self._btn_storexy_end = wdg.btn_curr_end_xy\n\n    self._ent_z_um = wdg.ent_z_um\n    self._btn_storez = wdg.btn_curr_z\n\n    # Make the widgets to manage the rest of the mapping parameters\n    self._ent_xres = wdg.ent_res_pt_x\n    self._ent_yres = wdg.ent_res_pt_y\n\n    # Bind return to the set_coor buttons\n    self._ent_startx_um.textChanged.connect(self._update_resolution_field_um)\n    self._ent_starty_um.textChanged.connect(self._update_resolution_field_um)\n    self._ent_startx_um.returnPressed.connect(self._update_resolution_field_um)\n    self._ent_starty_um.returnPressed.connect(self._update_resolution_field_um)\n\n    self._ent_endx_um.textChanged.connect(self._update_resolution_field_um)\n    self._ent_endy_um.textChanged.connect(self._update_resolution_field_um)\n    self._ent_endx_um.returnPressed.connect(self._update_resolution_field_um)\n    self._ent_endy_um.returnPressed.connect(self._update_resolution_field_um)\n\n    self._ent_xres.textChanged.connect(self._update_resolution_field_um)\n    self._ent_yres.textChanged.connect(self._update_resolution_field_um)\n    self._ent_xres.returnPressed.connect(self._update_resolution_field_um)\n    self._ent_yres.returnPressed.connect(self._update_resolution_field_um)\n\n    self._widget.ent_res_um_x.textChanged.connect(self._update_resolution_field_points)\n    self._widget.ent_res_um_y.textChanged.connect(self._update_resolution_field_points)\n    self._widget.ent_res_um_x.returnPressed.connect(self._update_resolution_field_points)\n    self._widget.ent_res_um_y.returnPressed.connect(self._update_resolution_field_points)\n\n    self._btn_storexy_start.clicked.connect(self._grab_startxy)\n    self._btn_storexy_end.clicked.connect(self._grab_endxy)\n    self._btn_storez.clicked.connect(self._grab_z)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.Wdg_Rect_StartEnd.get_mapping_coordinates_mm","title":"<code>get_mapping_coordinates_mm()</code>","text":"<p>Returns the mapping coordinates</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[float, float, float]]</code> <p>List of tuple (x,y,z) coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_generator/rectangle_endToEnd.py</code> <pre><code>def get_mapping_coordinates_mm(self) -&gt; list[tuple[float,float,float]]:\n    \"\"\" \n    Returns the mapping coordinates\n\n    Returns:\n        list: List of tuple (x,y,z) coordinates\n    \"\"\"\n    # Make sure to keep the generated coordinates up to date\n    self._generate_mapping_coordinates()\n    assert isinstance(self._mapping_coordinates,list)\n    assert all([isinstance(coor,tuple) and len(coor)==3 for coor in self._mapping_coordinates])\n    assert all([all([isinstance(val,float) for val in coor]) for coor in self._mapping_coordinates])\n    return self._mapping_coordinates\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_endToEnd/#iris.gui.submodules.meaCoor_generator.rectangle_endToEnd.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/","title":"rectangle_image","text":"<p>An instance that manages a basic mapping method in tkinter. This is similar to that of the mapping_method_rectxy_scan_constz mapping method but this one can set it using an image (with an objective calibration file/params) instead.</p>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.CanvasUpdater_Worker","title":"<code>CanvasUpdater_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A worker class to automatically update the video feed canvas with the image unit and the clicked coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_generator/rectangle_image.py</code> <pre><code>class CanvasUpdater_Worker(QObject):\n    \"\"\"\n    A worker class to automatically update the video feed canvas\n    with the image unit and the clicked coordinates\n    \"\"\"\n    sig_error = Signal(str)\n\n    sig_img_stageCoor_mm = Signal(tuple)\n\n    sig_updateImage = Signal(Image)\n    sig_annotateRectangle = Signal(tuple,tuple,bool)\n\n    sig_finished = Signal() # To indicate that the canvas update is finished\n\n    def __init__(self, canvas_image:Canvas_Image_Annotations, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._canvas_image = canvas_image\n        self.sig_updateImage.connect(self._canvas_image.set_image)\n        self.sig_annotateRectangle.connect(self._canvas_image.draw_rectangle_canvas)\n\n    @Slot(MeaImg_Unit,bool)\n    def _update_image_shown(self, imgUnit:MeaImg_Unit, low_resolution:bool) -&gt; None:\n        \"\"\"\n        Updates the image shown on the canvas\n        \"\"\"\n        img, stage_coor_mm, _ = imgUnit.get_image_all_stitched(low_res=low_resolution)\n        self.sig_updateImage.emit(img)\n        self.sig_img_stageCoor_mm.emit(stage_coor_mm)\n        self.sig_finished.emit()\n\n    @Slot(MeaImg_Unit,bool,list)\n    def _update_image_annotation_rectangle(self, imgUnit:MeaImg_Unit, low_resolution:bool,\n        list_rect_meaCoors_mm:list[tuple[float,float]]):\n        \"\"\"\n        Automatically updates the image shown on the canvas with the rectangle annotations\n\n        Args:\n            imgUnit (MeaImg_Unit): The image measurement unit\n            low_resolution (bool): Whether to use low resolution image\n            list_rect_meaCoors_mm (list[tuple[float,float]]): The rectangle coordinates in mm\n        \"\"\"\n        assert isinstance(imgUnit,MeaImg_Unit), 'imgUnit must be an instance of MeaImg_Unit'\n        assert isinstance(list_rect_meaCoors_mm,list), 'list_rect_meaCoors_mm must be a list'\n        assert all(isinstance(coor,(tuple,list)) and len(coor)&gt;=2 for coor in list_rect_meaCoors_mm), \\\n            'list_rect_meaCoors_mm must be a list of tuples of length 2'\n\n        # Clear the click coordinates and the annotations\n        self._canvas_image.clear_all_annotations()\n\n        _, stage_coor_mm, _ = imgUnit.get_image_all_stitched(low_res=True)\n\n        # Draw the rectangle coordinatesf\n        if len(list_rect_meaCoors_mm) == 2:\n            # Convert the measurement coor back to stage coor\n            try:\n                coor_pxl_min = imgUnit.convert_stg2imgpt(coor_stage_mm=stage_coor_mm,\\\n                    coor_point_mm=list_rect_meaCoors_mm[0],correct_rot=True,low_res=low_resolution)\n                coor_pxl_max = imgUnit.convert_stg2imgpt(coor_stage_mm=stage_coor_mm,\\\n                    coor_point_mm=list_rect_meaCoors_mm[1],correct_rot=True,low_res=low_resolution)\n\n                # print(f'Annotating rectangle at pixel coords: {coor_pxl_min} to {coor_pxl_max}')\n\n                self._canvas_image.stop_recordClicks()\n                self.sig_annotateRectangle.emit(coor_pxl_min,coor_pxl_max,True)\n                self.sig_finished.emit()\n            except Exception as e: self.sig_error.emit(f'Error updating rectangle annotation: {e}')\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.Rect_Image","title":"<code>Rect_Image</code>","text":"<p>               Bases: <code>Ui_Rect_Image</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_generator/rectangle_image.py</code> <pre><code>class Rect_Image(Ui_Rect_Image, qw.QWidget):\n\n    sig_updateImageCombobox = Signal()\n    sig_updateResPt = Signal()\n    sig_updateResUm = Signal()\n\n    sig_resetStoredCoors = Signal() # To reset the stored coordinates\n\n    sig_updateCanvasRectangle = Signal(MeaImg_Unit,bool,list)\n    sig_updateCanvasImage = Signal(MeaImg_Unit,bool)\n\n    def __init__(\n        self,\n        parent: qw.QWidget,\n        motion_controller:Wdg_MotionController,\n        dataHub_img:Wdg_DataHub_Image,\n        *args, **kwargs\n        ):\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n    # &gt;&gt;&gt; General setup &lt;&lt;&lt;\n        self._motion_controller = motion_controller\n        self._dataHub_img = dataHub_img\n\n        video_feed_size = AppPlotEnum.MAP_METHOD_IMAGE_VIDEO_SIZE.value\n\n        # Parameters\n        self._imgUnit:MeaImg_Unit|None = None    # The image unit object\n        self._img:Image|None = None                  # The image shown on the canvas\n        self._img_coor_stage_mm:tuple|None = None    # The stage coordinates corresponding to the self._img camera frame of reference\n\n    # &gt;&gt;&gt; Video feed setup &lt;&lt;&lt;\n        # Parameters\n        self._list_imgunit_names:list[str] = []\n\n        # Canvas setup\n        self._canvas_image = Canvas_Image_Annotations(self,size_pixel=video_feed_size)\n        self.lyt_canvas.addWidget(self._canvas_image)\n        self._canvas_image.start_recordClicks()\n\n        self.combo_image.activated.connect(self._update_image_shown)\n\n        # Params\n        self._list_clickMeaCoor_mm = []     # The list of clicked coordinates in mm\n        self._list_rect_meaCoors_mm = []    # The rectangle coordinates for the scan area in mm\n\n    # &gt; Z-coordinate setup widgets &lt;\n        self.btn_storeZ.clicked.connect(self._store_current_coorz)\n\n    # &gt;&gt;&gt; Worker and signals setup &lt;&lt;&lt;\n        self._init_signals()\n        self._init_workers()\n\n    def _init_signals(self):\n        \"\"\"\n        Initialises the signals and slots for the GUI\n        \"\"\"\n        # Set scan area button\n        self.btn_defineROI.clicked.connect(self._set_scan_area)\n        self.btn_instruction.clicked.connect(self._show_instructions)\n\n        # Image unit combobox\n        self.combo_image.setEnabled(False)\n        self._dataHub_img.get_ImageMeasurement_Hub().add_observer(self.sig_updateImageCombobox.emit)\n        self.sig_updateImageCombobox.connect(self._update_combobox_imageUnits)\n        self.sig_updateImageCombobox.emit()\n\n        # Resolution spinbox signals\n        self.sig_updateResPt.connect(self._update_resolution_pt)\n        self.sig_updateResUm.connect(self._update_resolution_um)\n\n        self.spin_resXPt.editingFinished.connect(self.sig_updateResUm.emit)\n        self.spin_resYPt.editingFinished.connect(self.sig_updateResUm.emit)\n        self.spin_resXum.editingFinished.connect(self.sig_updateResPt.emit)\n        self.spin_resYum.editingFinished.connect(self.sig_updateResPt.emit)\n\n        # Canvas clear annotations observer\n        self._canvas_image.add_observer_rightclick(self.sig_resetStoredCoors.emit)\n        self.sig_resetStoredCoors.connect(self._reset_click_coors)\n\n        # Resolution checkbox\n        self.chk_lres.stateChanged.connect(self._update_image_shown)\n\n    def _init_workers(self):\n        \"\"\"\n        Initialises the worker threads for automatic image updating\n        \"\"\"\n        # Worker thread for automatic image updating\n        self._thread_canvas = QThread()\n        self._worker_canvas = CanvasUpdater_Worker(self._canvas_image)\n        self._worker_canvas.moveToThread(self._thread_canvas)\n\n        # Connect signals\n        self.sig_updateCanvasImage.connect(self._worker_canvas._update_image_shown)\n        self.sig_updateCanvasRectangle.connect(self._worker_canvas._update_image_annotation_rectangle)\n\n        self._worker_canvas.sig_error.connect(lambda msg: qw.QMessageBox.warning(self, 'Error', msg))\n        self._worker_canvas.sig_img_stageCoor_mm.connect(self._update_img_stageCoor_mm)\n        self._thread_canvas.start()\n\n    @Slot()\n    def _show_instructions(self):\n        \"\"\"\n        Shows the instructions for using the rectangle image mapping method\n        \"\"\"\n        instructions = (\n            \"Instructions:\\n\"\n            \"1. Select an image to display\\n\"\n            \"2. Left-click on the image to include points in the ROI\\n\"\n            \"3. Right-click on the image to reset the selected points.\\n\"\n            \"4. Click the 'Define ROI' button to finalise the setup.\"\n        )\n        qw.QMessageBox.information(self, 'Instructions - Rectangle Image Mapping Method', instructions)\n\n    @Slot(tuple)\n    def _update_img_stageCoor_mm(self,coor_mm:tuple):\n        \"\"\"\n        Updates the image stage coordinates\n\n        Args:\n            coor_mm (tuple): The stage coordinates in mm\n        \"\"\"\n        assert isinstance(coor_mm,tuple), 'coor_mm must be a tuple'\n        assert all(isinstance(c,float) for c in coor_mm), 'coor_mm must be a tuple of floats'\n        self._img_coor_stage_mm = coor_mm\n\n    def _block_signals_resolution(self,block:bool):\n        \"\"\"\n        Blocks or unblocks the resolution spinbox signals\n\n        Args:\n            block (bool): True to block, False to unblock\n        \"\"\"\n        self.spin_resXPt.blockSignals(block)\n        self.spin_resYPt.blockSignals(block)\n        self.spin_resXum.blockSignals(block)\n        self.spin_resYum.blockSignals(block)\n\n    @Slot()\n    def _update_resolution_pt(self):\n        \"\"\"\n        Sets the point resolution of the mapping method\n        \"\"\"\n        self.blockSignals(True)\n        resUm_x = self.spin_resXum.value()\n        resUm_y = self.spin_resYum.value()\n\n        if len(self._list_rect_meaCoors_mm) &lt; 2:\n            self.blockSignals(False)\n            return\n\n        dist_x = abs(self._list_rect_meaCoors_mm[1][0] - self._list_rect_meaCoors_mm[0][0])\n        dist_y = abs(self._list_rect_meaCoors_mm[1][1] - self._list_rect_meaCoors_mm[0][1])\n\n        points_x = int(dist_x/resUm_x)+1 if resUm_x&gt;0 else 1\n        points_y = int(dist_y/resUm_y)+1 if resUm_y&gt;0 else 1\n\n        self.spin_resXPt.setValue(points_x)\n        self.spin_resYPt.setValue(points_y)\n\n        self.blockSignals(False)\n\n    @Slot()\n    def _update_resolution_um(self):\n        \"\"\"\n        Sets the resolution of the mapping method\n        \"\"\"\n        self.blockSignals(True)\n        res_x_pt = self.spin_resXPt.value()\n        res_y_pt = self.spin_resYPt.value()\n\n        if len(self._list_rect_meaCoors_mm) &lt; 2:\n            self.blockSignals(False)\n            return\n\n        dist_x = abs(self._list_rect_meaCoors_mm[1][0] - self._list_rect_meaCoors_mm[0][0])\n        dist_y = abs(self._list_rect_meaCoors_mm[1][1] - self._list_rect_meaCoors_mm[0][1])\n\n        resUm_x = dist_x/(res_x_pt-1) if res_x_pt&gt;1 else 0\n        resUm_y = dist_y/(res_y_pt-1) if res_y_pt&gt;1 else 0\n\n        self.spin_resXum.setValue(resUm_x)\n        self.spin_resYum.setValue(resUm_y)\n\n        self.blockSignals(False)\n\n    @Slot()\n    def _store_current_coorz(self):\n        \"\"\"\n        Gets the current stage coordinate and store it as the initial position\n        \"\"\"\n        try:\n            coor_z_mm = self._motion_controller.get_coordinates_closest_mm()[2]\n            if not isinstance(coor_z_mm,float): raise ValueError('Z coordinate is not a float')\n        except Exception as e:\n            print(e)\n            qw.QMessageBox.warning(self, 'Error', str(e))\n            return\n\n        self.spin_z.setValue(coor_z_mm*1e3)\n\n    @Slot()\n    def _set_scan_area(self):\n        \"\"\"\n        Sets the scan area by taking the (x_min,y_min) and (x_max,y_max)\n        from the list of clicked coordinates\n        \"\"\"\n        imgUnit = self._get_selected_ImageUnit()\n        if not isinstance(imgUnit,MeaImg_Unit):\n            qw.QMessageBox.warning(self, 'Error', 'No image unit selected')\n            return\n\n        # Get the calibration area\n        list_clickCoor_pxl = self._canvas_image.get_clickCoordinates()\n\n        # Convert to mm\n        list_clickCoor_mm = []\n        stage_coor_mm = self._img_coor_stage_mm\n\n        if stage_coor_mm is None:\n            qw.QMessageBox.warning(self, 'Error', 'Image stage coordinates not available')\n            return\n\n        list_clickCoor_mm = [\n            imgUnit.convert_imgpt2stg(\n                frame_coor_mm=stage_coor_mm,\n                coor_pixel=coor_pxl,\n                correct_rot=True,\n                low_res=self.chk_lres.isChecked()\n            ) for coor_pxl in list_clickCoor_pxl]\n\n        # Get the min and max coordinates\n        list_x = [coor[0] for coor in list_clickCoor_mm]\n        list_y = [coor[1] for coor in list_clickCoor_mm]\n\n        x_min = min(list_x)\n        x_max = max(list_x)\n        y_min = min(list_y)\n        y_max = max(list_y)\n\n        coor_min = (x_min,y_min)\n        coor_max = (x_max,y_max)\n\n        stagecoor_min = imgUnit.convert_mea2stg(coor_min)\n        stagecoor_max = imgUnit.convert_mea2stg(coor_max)\n\n        self._stagecoor_init_xy_mm = stagecoor_min\n        self._stagecoor_final_xy_mm = stagecoor_max\n\n        # self.lbl_scanEdges.setText('({:.1f}, {:.1f}) to ({:.1f}, {:.1f}) \u03bcm'.format(\n        #     x_min*1e3,y_min*1e3,x_max*1e3,y_max*1e3))\n        self.lbl_scanEdges.setText('({:.1f}, {:.1f}) to ({:.1f}, {:.1f}) \u03bcm'.format(\n            stagecoor_min[0]*1e3,stagecoor_min[1]*1e3,\n            stagecoor_max[0]*1e3,stagecoor_max[1]*1e3))\n\n        try:    # Clear the click coordinates and the annotations except the scan area\n            self._list_rect_meaCoors_mm = [coor_min,coor_max]\n\n            imgUnit = self._get_selected_ImageUnit()\n            if imgUnit is None: raise ValueError('No image unit selected')\n\n            self.sig_updateCanvasRectangle.emit(\n                imgUnit,\n                self.chk_lres.isChecked(),\n                self._list_rect_meaCoors_mm)\n\n            self.sig_updateResPt.emit()\n\n        except Exception as e:\n            qw.QMessageBox.warning(self, 'Error', f'Error setting scan area: {e}')\n\n    @Slot()\n    def _reset_click_coors(self):\n        \"\"\"\n        Resets the click coordinates\n        \"\"\"\n        self._list_clickMeaCoor_mm.clear()\n        self._list_rect_meaCoors_mm.clear()\n        self.lbl_scanEdges.setText('None')\n\n        self._canvas_image.clear_all_annotations()\n        self._canvas_image.start_recordClicks()\n\n    @Slot()\n    def _update_combobox_imageUnits(self):\n        \"\"\"\n        Automatically updates the combobox with the image units\n        \"\"\"\n        self.combo_image.setEnabled(False)\n        hub = self._dataHub_img.get_ImageMeasurement_Hub()\n        list_unit_ids = hub.get_list_ImageUnit_ids()\n        dict_idToName = hub.get_dict_IDtoName()\n        list_unit_names = [dict_idToName[unit_id] for unit_id in list_unit_ids]\n\n        # Only updates when necessary\n        if list_unit_names == self._list_imgunit_names: return\n\n        self._list_imgunit_names = list_unit_names.copy()\n        name = self.combo_image.currentText()\n        self.combo_image.clear()\n        self.combo_image.addItems(self._list_imgunit_names)\n\n        if name in self._list_imgunit_names:\n            self.combo_image.setCurrentText(name)\n        elif len(self._list_imgunit_names) &gt; 0:\n            self.combo_image.setCurrentIndex(0)\n\n        self.combo_image.setEnabled(len(self._list_imgunit_names) &gt; 0)\n\n    def _get_selected_ImageUnit(self) -&gt; MeaImg_Unit|None:\n        \"\"\"\n        Returns the selected image unit in the combobox\n\n        Returns:\n            ImageMeasurement_Unit|None: The selected image unit or None\n        \"\"\"\n        unit_name = self.combo_image.currentText()\n        hub = self._dataHub_img.get_ImageMeasurement_Hub()\n        ret = None\n        try: ret = hub.get_ImageMeasurementUnit(unit_name=unit_name)\n        except Exception as e:\n            print(f'Error getting selected ImageUnit: {e}')\n        return ret\n\n    @Slot()\n    def _update_image_shown(self) -&gt; None:\n        \"\"\"\n        Updates the image shown on the canvas\n        \"\"\"\n        img = self._get_selected_ImageUnit()\n        if img is None:\n            print('No image unit selected')\n            return\n        # print(f'Updating image shown: {img.get_IdName()}')\n\n        self._reset_click_coors()\n\n        self.sig_updateCanvasImage.emit(\n            img,\n            self.chk_lres.isChecked()\n        )\n\n    def get_mapping_coordinates_mm(self):\n        if self._stagecoor_init_xy_mm == None or self._stagecoor_final_xy_mm == None:\n            qw.QMessageBox.warning(self, 'Error', 'Scan area not defined')\n            return\n\n        # Generate the mapping coordinates\n        x_min = self._stagecoor_init_xy_mm[0]\n        y_min = self._stagecoor_init_xy_mm[1]\n        x_max = self._stagecoor_final_xy_mm[0]\n        y_max = self._stagecoor_final_xy_mm[1]\n        coor_z_mm = self.spin_z.value()/1e3\n\n        res_x = self.spin_resXPt.value()\n        res_y = self.spin_resYPt.value()\n\n        x = np.linspace(x_min,x_max,res_x)\n        y = np.linspace(y_min,y_max,res_y)\n\n        return [(x_val,y_val,coor_z_mm) for x_val in x for y_val in y]\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_image/#iris.gui.submodules.meaCoor_generator.rectangle_image.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/","title":"rectangle_video","text":"<p>An instance that manages a basic mapping method in tkinter. This is similar to that of the mapping_method_rectxy_scan_constz mapping method but this one can set it using an image (with an objective calibration file/params) instead.</p>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.CanvasUpdater_Worker","title":"<code>CanvasUpdater_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A worker class to automatically update the video feed canvas with the image unit and the clicked coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_generator/rectangle_video.py</code> <pre><code>class CanvasUpdater_Worker(QObject):\n    \"\"\"\n    A worker class to automatically update the video feed canvas\n    with the image unit and the clicked coordinates\n    \"\"\"\n    sig_error = Signal(str)\n\n    _sig_updateImageCalibration = Signal()\n\n    sig_updateImage = Signal(Image)\n    sig_annotateRectangle = Signal(tuple,tuple,bool)\n    sig_annotateMultiPoints = Signal(list,bool,bool)\n\n    def __init__(self, canvas_image:Canvas_Image_Annotations, motion_controller:Wdg_MotionController,\n                 *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._canvas_image = canvas_image\n        self._motion_controller = motion_controller\n\n        self.sig_updateImage.connect(self._canvas_image.set_image)\n        self.sig_annotateRectangle.connect(self._canvas_image.draw_rectangle_canvas)\n        self.sig_annotateMultiPoints.connect(self._canvas_image.annotate_canvas_multi)\n\n    @Slot(list)\n    def _update_image_annotation_points(self, list_clickCoor_pixel:list[tuple[float,float]]) -&gt; None:\n        \"\"\"\n        Updates the image shown on the canvas\n        \"\"\"\n        # print(f'{get_timestamp_us_str()}: Updating canvas image with {len(list_clickCoor_pixel)} points')\n        img = self._motion_controller.get_current_image()\n\n        self.sig_updateImage.emit(img)\n        self.sig_annotateMultiPoints.emit(list_clickCoor_pixel,True,True)\n\n    @Slot(list)\n    def _update_image_annotation_rectangle(self, list_rect_meaCoors_pixel:list[tuple[float,float]]):\n        \"\"\"\n        Automatically updates the image shown on the canvas with the rectangle annotations\n\n        Args:\n            list_rect_meaCoors_mm (list[tuple[float,float]]): The rectangle coordinates in mm\n        \"\"\"\n        assert isinstance(list_rect_meaCoors_pixel,list), 'list_rect_meaCoors_mm must be a list'\n        assert len(list_rect_meaCoors_pixel) == 2, 'list_rect_meaCoors_mm must have 2 coordinates'\n\n        # print(f'{get_timestamp_us_str()}: Updating canvas rectangle annotation with coordinates {list_rect_meaCoors_pixel}')\n\n        img = self._motion_controller.get_current_image()\n        self.sig_updateImage.emit(img)\n        self._canvas_image.stop_recordClicks()\n        self.sig_annotateRectangle.emit(list_rect_meaCoors_pixel[0],list_rect_meaCoors_pixel[1],True)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.Rect_Video","title":"<code>Rect_Video</code>","text":"<p>               Bases: <code>Ui_Rect_Video</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_generator/rectangle_video.py</code> <pre><code>class Rect_Video(Ui_Rect_Video, qw.QWidget):\n\n    sig_updateResPt = Signal()\n    sig_updateResUm = Signal()\n\n    sig_resetStoredCoors = Signal()     # To reset the stored coordinates\n    sig_updateCalibration = Signal()    # To update the calibration parameters\n\n    sig_updateCanvasRectangle = Signal(list)\n    sig_updateCanvasImage = Signal(list)\n\n    def __init__(\n        self,\n        parent: qw.QWidget,\n        motion_controller:Wdg_MotionController,\n        dataHub_img:Wdg_DataHub_Image,\n        dataHub_imgCal:Wdg_DataHub_ImgCal,\n        *args, **kwargs\n        ):\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n    # &gt;&gt;&gt; General setup &lt;&lt;&lt;\n        self._motion_controller = motion_controller\n        self._dataHub_img = dataHub_img\n        self._dataHub_imgCal = dataHub_imgCal\n\n        video_feed_size = AppPlotEnum.MAP_METHOD_IMAGE_VIDEO_SIZE.value\n\n        # Parameters\n        self._imgUnit:MeaImg_Unit|None = None       # The image measurement unit used\n        self._img:Image|None = None                  # The image shown on the canvas\n        self._flg_mode:Literal['point','rectangle'] = 'point'   # The current mode of the coordinate generator\n\n    # &gt;&gt;&gt; Video feed setup &lt;&lt;&lt;\n        # Parameters\n        self._list_imgunit_names:list[str] = []\n\n        # Canvas setup\n        self._canvas_video = Canvas_Image_Annotations(self,size_pixel=video_feed_size)\n        self.lyt_canvas.addWidget(self._canvas_video)\n        self._canvas_video.start_recordClicks()\n\n        # Params\n        self._list_clickMeaCoor_mm = []     # The list of clicked coordinates in mm\n        self._list_rect_meaCoors_mm = []    # The rectangle coordinates for the scan area in mm\n\n    # &gt; Z-coordinate setup widgets &lt;\n        self.btn_storeZ.clicked.connect(self._store_current_coorz)\n\n    # &gt;&gt;&gt; Worker and signals setup &lt;&lt;&lt;\n        self._init_signals()\n        self._init_workers()\n\n    # &gt;&gt;&gt; Initial update &lt;&lt;&lt;\n        try: self._update_calibration()\n        except Exception as e: print(e)\n\n    def _init_signals(self):\n        \"\"\"\n        Initialises the signals and slots for the GUI\n        \"\"\"\n        # Set scan area button\n        self.btn_defineROI.clicked.connect(self._set_scan_area)\n\n        # Resolution spinbox signals\n        self.sig_updateResPt.connect(self._update_resolution_pt)\n        self.sig_updateResUm.connect(self._update_resolution_um)\n\n        self.spin_resXPt.editingFinished.connect(self.sig_updateResUm.emit)\n        self.spin_resYPt.editingFinished.connect(self.sig_updateResUm.emit)\n        self.spin_resXum.editingFinished.connect(self.sig_updateResPt.emit)\n        self.spin_resYum.editingFinished.connect(self.sig_updateResPt.emit)\n\n        # Canvas clear annotations observer\n        self._canvas_video.add_observer_rightclick(self.sig_resetStoredCoors.emit)\n        self.sig_resetStoredCoors.connect(self._reset_click_coors)\n        self._canvas_video.sig_leftclick.connect(self._append_clickCoor_mm)\n\n        # Calibration update\n        self._dataHub_imgCal.add_observer_calibrationChange(self.sig_updateCalibration.emit)\n        self.sig_updateCalibration.connect(self._update_calibration)\n\n    def _init_workers(self):\n        \"\"\"\n        Initialises the worker threads for automatic image updating\n        \"\"\"\n        # Worker thread for automatic image updating\n        self._thread_canvas = QThread()\n        self._worker_canvas = CanvasUpdater_Worker(self._canvas_video,self._motion_controller)\n        self._worker_canvas.moveToThread(self._thread_canvas)\n\n        # Connect signals\n        self.sig_updateCanvasImage.connect(self._worker_canvas._update_image_annotation_points)\n        self.sig_updateCanvasRectangle.connect(self._worker_canvas._update_image_annotation_rectangle)\n\n        self._worker_canvas.sig_error.connect(lambda msg: qw.QMessageBox.warning(self, 'Error', msg))\n        self._thread_canvas.start()\n\n        # Set a timer to automatically update the image shown\n        freq = 25  # in Hz\n        self._timer_updateCanvas = QTimer()\n        self._timer_updateCanvas.setInterval(int(1000/freq))\n        self._timer_updateCanvas.timeout.connect(self._update_canvas)\n        self.destroyed.connect(self._timer_updateCanvas.stop)\n        self._timer_updateCanvas.start()\n\n    def _block_signals_resolution(self,block:bool):\n        \"\"\"\n        Blocks or unblocks the resolution spinbox signals\n\n        Args:\n            block (bool): True to block, False to unblock\n        \"\"\"\n        self.spin_resXPt.blockSignals(block)\n        self.spin_resYPt.blockSignals(block)\n        self.spin_resXum.blockSignals(block)\n        self.spin_resYum.blockSignals(block)\n\n    @Slot()\n    def _update_resolution_pt(self):\n        \"\"\"\n        Sets the point resolution of the mapping method\n        \"\"\"\n        self.blockSignals(True)\n        resUm_x = self.spin_resXum.value()\n        resUm_y = self.spin_resYum.value()\n\n        if len(self._list_rect_meaCoors_mm) &lt; 2:\n            self.blockSignals(False)\n            return\n\n        dist_x = abs(self._list_rect_meaCoors_mm[1][0] - self._list_rect_meaCoors_mm[0][0])\n        dist_y = abs(self._list_rect_meaCoors_mm[1][1] - self._list_rect_meaCoors_mm[0][1])\n\n        points_x = int(dist_x/resUm_x)+1 if resUm_x&gt;0 else 1\n        points_y = int(dist_y/resUm_y)+1 if resUm_y&gt;0 else 1\n\n        self.spin_resXPt.setValue(points_x)\n        self.spin_resYPt.setValue(points_y)\n\n        self.blockSignals(False)\n\n    @Slot()\n    def _update_resolution_um(self):\n        \"\"\"\n        Sets the resolution of the mapping method\n        \"\"\"\n        self.blockSignals(True)\n        res_x_pt = self.spin_resXPt.value()\n        res_y_pt = self.spin_resYPt.value()\n\n        if len(self._list_rect_meaCoors_mm) &lt; 2:\n            self.blockSignals(False)\n            return\n\n        dist_x = abs(self._list_rect_meaCoors_mm[1][0] - self._list_rect_meaCoors_mm[0][0])\n        dist_y = abs(self._list_rect_meaCoors_mm[1][1] - self._list_rect_meaCoors_mm[0][1])\n\n        resUm_x = dist_x/(res_x_pt-1) if res_x_pt&gt;1 else 0\n        resUm_y = dist_y/(res_y_pt-1) if res_y_pt&gt;1 else 0\n\n        self.spin_resXum.setValue(resUm_x)\n        self.spin_resYum.setValue(resUm_y)\n\n        self.blockSignals(False)\n\n    @Slot()\n    def _store_current_coorz(self):\n        \"\"\"\n        Gets the current stage coordinate and store it as the initial position\n        \"\"\"\n        try:\n            coor_z_mm = self._motion_controller.get_coordinates_closest_mm()[2]\n            if not isinstance(coor_z_mm,float): raise ValueError('Z coordinate is not a float')\n        except Exception as e:\n            print(e)\n            qw.QMessageBox.warning(self, 'Error', str(e))\n            return\n\n        self.spin_z.setValue(coor_z_mm*1e3)\n\n    @Slot()\n    def _update_calibration(self):\n        \"\"\"\n        Updates the calibration parameters\n        \"\"\"\n        # print(f'{get_timestamp_us_str()}: Updating calibration for rectangle video mapping method')\n        new_calibration = self._dataHub_imgCal.get_selected_calibration()\n        self._imgUnit = MeaImg_Unit(\n            unit_name=f'ImgUnit_{uuid4()}',\n            calibration=new_calibration\n        )\n        # print(f'{get_timestamp_us_str()}: Updated calibration to {new_calibration.id}')\n\n    @Slot(tuple)\n    def _append_clickCoor_mm(self, coor_pixel:tuple):\n        \"\"\"\n        Appends the clicked coordinate in mm to the list\n\n        Args:\n            coor_pixel (tuple): The clicked coordinate in pixels\n        \"\"\"\n        # print(f'{get_timestamp_us_str()}: Clicked coordinate in pixels: {coor_pixel}')\n        stage_coor_mm = self._motion_controller.get_coordinates_closest_mm()\n\n        if not all(isinstance(c,float) for c in stage_coor_mm):\n            qw.QMessageBox.warning(self, 'Error', 'Image stage coordinates not available')\n            return\n        if self._imgUnit is None:\n            qw.QMessageBox.warning(self, 'Error', 'No image unit selected')\n            return\n\n        clickCoor_mm = self._imgUnit.convert_imgpt2stg(\n                            frame_coor_mm=stage_coor_mm, # pyright: ignore[reportArgumentType] ; Checked above\n                            coor_pixel=coor_pixel,\n                            correct_rot=False,\n                            low_res=False\n                        )\n        self._list_clickMeaCoor_mm.append(clickCoor_mm)\n\n    @Slot()\n    def _set_scan_area(self):\n        \"\"\"\n        Sets the scan area by taking the (x_min,y_min) and (x_max,y_max)\n        from the list of clicked coordinates\n        \"\"\"\n        if not isinstance(self._imgUnit,MeaImg_Unit) or not self._imgUnit.check_calibration_exist():\n            try:\n                self._update_calibration()\n            except Exception as e:\n                print(e)\n                qw.QMessageBox.warning(self, 'Error', 'Please select an objective first')\n            return\n\n        if len(self._list_clickMeaCoor_mm) &lt; 2:\n            qw.QMessageBox.warning(self, 'Error', 'Please click at least 2 coordinates to define the scan area')\n            return\n\n        # Get the min and max coordinates\n        list_x = [coor[0] for coor in self._list_clickMeaCoor_mm]\n        list_y = [coor[1] for coor in self._list_clickMeaCoor_mm]\n\n        x_min = min(list_x)\n        x_max = max(list_x)\n        y_min = min(list_y)\n        y_max = max(list_y)\n\n        coor_min = (x_min,y_min)\n        coor_max = (x_max,y_max)\n\n        # Convert to stage coordinates and store it\n        stagecoor_min = self._imgUnit.convert_mea2stg(coor_min)\n        stagecoor_max = self._imgUnit.convert_mea2stg(coor_max)\n\n        self._stagecoor_init_xy_mm = stagecoor_min\n        self._stagecoor_final_xy_mm = stagecoor_max\n\n        # Update the scan edges label\n        self.lbl_scanEdges.setText('({:.1f}, {:.1f}) to ({:.1f}, {:.1f}) \u03bcm'.format(\n            stagecoor_min[0]*1e3,stagecoor_min[1]*1e3,\n            stagecoor_max[0]*1e3,stagecoor_max[1]*1e3))\n\n        # Store the rectangle coordinates\n        self._list_rect_meaCoors_mm = [coor_min,coor_max]\n        self._list_clickMeaCoor_mm.clear()\n        self._list_clickMeaCoor_mm.extend([coor_min,coor_max])\n\n        # Switch to rectangle mode (to commit the selected ROI) and emit signal to update resolution\n        self._flg_mode = 'rectangle'\n        self.sig_updateResPt.emit()\n\n    @Slot()\n    def _reset_click_coors(self):\n        \"\"\"\n        Resets the click coordinates\n        \"\"\"\n        self._list_clickMeaCoor_mm.clear()\n        self._list_rect_meaCoors_mm.clear()\n        self.lbl_scanEdges.setText('None')\n        self._flg_mode = 'point'\n\n        self._canvas_video.clear_all_annotations()\n        self._canvas_video.start_recordClicks()\n\n    @Slot()\n    def _update_canvas(self) -&gt; None:\n        \"\"\"\n        Updates the image shown on the canvas\n        \"\"\"\n        if not self.isVisible():\n            print('Canvas not visible, skipping update')\n            return  # Do not update if the widget is not visible\n\n        if not isinstance(self._imgUnit,MeaImg_Unit) or not self._imgUnit.check_calibration_exist(): return\n\n        stagecoor_mm = self._motion_controller.get_coordinates_closest_mm()\n\n        if not isinstance(stagecoor_mm,tuple): return\n        if not all(isinstance(c,float) for c in stagecoor_mm): return\n\n        self._canvas_video.clear_all_annotations()\n        if self._flg_mode == 'point':\n            list_clickCoor_pixel = [self._imgUnit.convert_stg2imgpt(\n                coor_stage_mm=stagecoor_mm, # pyright: ignore[reportArgumentType] ; Checked above\n                coor_point_mm=coor_mm,\n                correct_rot=False,\n                low_res=False\n                )\n                for coor_mm in self._list_clickMeaCoor_mm\n            ]\n            self.sig_updateCanvasImage.emit(list_clickCoor_pixel)\n\n        elif self._flg_mode == 'rectangle':\n            list_clickCoor_pixel = [self._imgUnit.convert_stg2imgpt(\n                coor_stage_mm=stagecoor_mm, # pyright: ignore[reportArgumentType] ; Checked above\n                coor_point_mm=coor_mm,\n                correct_rot=False,\n                low_res=False\n                )\n                for coor_mm in self._list_rect_meaCoors_mm\n            ]\n            self.sig_updateCanvasRectangle.emit(list_clickCoor_pixel)\n\n    def get_mapping_coordinates_mm(self):\n        if self._stagecoor_init_xy_mm == None or self._stagecoor_final_xy_mm == None:\n            qw.QMessageBox.warning(self, 'Error', 'Scan area not defined')\n            return\n\n        # Generate the mapping coordinates\n        x_min = self._stagecoor_init_xy_mm[0]\n        y_min = self._stagecoor_init_xy_mm[1]\n        x_max = self._stagecoor_final_xy_mm[0]\n        y_max = self._stagecoor_final_xy_mm[1]\n        coor_z_mm = self.spin_z.value()/1e3\n\n        res_x = self.spin_resXPt.value()\n        res_y = self.spin_resYPt.value()\n\n        x = np.linspace(x_min,x_max,res_x)\n        y = np.linspace(y_min,y_max,res_y)\n\n        return [(x_val,y_val,coor_z_mm) for x_val in x for y_val in y]\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/rectangle_video/#iris.gui.submodules.meaCoor_generator.rectangle_video.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/","title":"singlePoint_zScan","text":"<p>An instance that manages a basic mapping method in tkinter</p>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.singlePoint_zScan","title":"<code>singlePoint_zScan</code>","text":"<p>               Bases: <code>Ui_singlePointZScan</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_generator/singlePoint_zScan.py</code> <pre><code>class singlePoint_zScan(Ui_singlePointZScan, qw.QWidget):\n    sig_request_currentCoorXY = Signal()\n    sig_request_currentCoorZStart = Signal()\n    sig_request_currentCoorZEnd = Signal()\n\n    sig_updateResPt = Signal()\n    sig_updateResUm = Signal()\n\n    def __init__(self,parent,motion_controller:Wdg_MotionController,\n                 *args, **kwargs) -&gt; None:\n        \"\"\"Initializes the mapping method\n\n        Args:\n            parent (qw.QWidget): The widget to place the mapping method\n            motion_controller (Frm_MotionController): The motion controller to control the stage\n            status_bar (tk.Label, optional): The status bar to show the status of the mapping method. Defaults to None.\n        \"\"\"\n        # Place itself in the given master widget (container)\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        # Sets up the other controllers\n        self._motion_controller = motion_controller\n\n        # Make the widgets to store the coordinates\n        self.btn_storeXY.clicked.connect(self.sig_request_currentCoorXY.emit)\n        self.btn_storeZStart.clicked.connect(self.sig_request_currentCoorZStart.emit)\n        self.btn_storeZEnd.clicked.connect(self.sig_request_currentCoorZEnd.emit)\n\n        self._init_workers()\n        self._init_signals()\n\n    def _init_workers(self) -&gt; None:\n        \"\"\"\n        Initialises the worker threads for communication with the motion controller\n        \"\"\"\n        self._thread = QThread()\n        self._worker = MotionControllerComm_Worker(self._motion_controller)\n        self._worker.moveToThread(self._thread)\n\n        self._worker.sig_currentCoorX_mm.connect(lambda x: self.spin_coorx.setValue(x*1e3))\n        self._worker.sig_currentCoorY_mm.connect(lambda y: self.spin_coory.setValue(y*1e3))\n        self._worker.sig_currentCoorZStart_mm.connect(lambda z: self.spin_coorZStart.setValue(z*1e3))\n        self._worker.sig_currentCoorZEnd_mm.connect(lambda z: self.spin_coorZEnd.setValue(z*1e3))\n        self._worker.sig_error.connect(lambda msg: qw.QMessageBox.warning(self,'Error',msg))\n\n        self.sig_request_currentCoorXY.connect(self._worker.get_current_coor_xy)\n        self.sig_request_currentCoorZStart.connect(self._worker.get_current_coor_zStart)\n        self.sig_request_currentCoorZEnd.connect(self._worker.get_current_coor_zEnd)\n\n        self._thread.start()\n\n    def _init_signals(self) -&gt; None:\n        \"\"\"\n        Initialises the signals for the widgets\n        \"\"\"\n        self.spin_resPt.valueChanged.connect(self._update_resolution_um)\n        self.spin_resUm.valueChanged.connect(self._update_resolution_points)\n\n        self.spin_coorZStart.valueChanged.connect(self._update_resolution_points)\n        self.spin_coorZEnd.valueChanged.connect(self._update_resolution_points)\n\n    def _block_signals_resolution(self,block:bool):\n        \"\"\"\n        Blocks the signals for the resolution widgets\n\n        Args:\n            block (bool): Whether to block the signals\n        \"\"\"\n        self.spin_resPt.blockSignals(block)\n        self.spin_resUm.blockSignals(block)\n\n    @Slot()\n    def _update_resolution_points(self):\n        \"\"\"\n        Updates the resolution in points based on the resolution in micrometers\n        \"\"\"\n        self._block_signals_resolution(True)\n\n        coor_z1_um = self.spin_coorZStart.value()\n        coor_z2_um = self.spin_coorZEnd.value()\n        res_um = self.spin_resUm.value()\n\n        num_points = int(abs(coor_z2_um - coor_z1_um) / res_um) + 1 if res_um != 0 else 1\n        self.spin_resPt.setValue(num_points)\n\n        self._block_signals_resolution(False)\n\n    @Slot()\n    def _update_resolution_um(self):\n        \"\"\"\n        Updates the resolution in micrometers based on the resolution in points\n        \"\"\"\n        self._block_signals_resolution(True)\n\n        coor_z1_um = self.spin_coorZStart.value()\n        coor_z2_um = self.spin_coorZEnd.value()\n        res_pt = self.spin_resPt.value()\n\n        if res_pt &gt; 1:\n            res_um = abs(coor_z2_um - coor_z1_um) / (res_pt - 1)\n        else:\n            res_um = abs(coor_z2_um - coor_z1_um)\n\n        self.spin_resUm.setValue(res_um)\n\n        self._block_signals_resolution(False)\n\n    def get_mapping_coordinates_mm(self):\n        \"\"\" \n        Returns the mapping coordinates\n\n        Returns:\n            list: List of tuple (x,y,z) coordinates\n        \"\"\"\n        coor_xy_um = self.spin_coorx.value(), self.spin_coory.value()\n        coor_z1_um = self.spin_coorZStart.value()\n        coor_z2_um = self.spin_coorZEnd.value()\n        res_z_um = self.spin_resPt.value()\n\n        # Generate the mapping coordinates\n        list_z_um = np.linspace(coor_z1_um,coor_z2_um,num=int(abs(coor_z2_um-coor_z1_um)/res_z_um)+1)\n        list_mapping_coor_mm = [(coor_xy_um[0]/1e3,coor_xy_um[1]/1e3,z/1e3) for z in list_z_um]\n\n        return list_mapping_coor_mm\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.singlePoint_zScan.__init__","title":"<code>__init__(parent, motion_controller, *args, **kwargs)</code>","text":"<p>Initializes the mapping method</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The widget to place the mapping method</p> required <code>motion_controller</code> <code>Frm_MotionController</code> <p>The motion controller to control the stage</p> required <code>status_bar</code> <code>Label</code> <p>The status bar to show the status of the mapping method. Defaults to None.</p> required Source code in <code>iris/gui/submodules/meaCoor_generator/singlePoint_zScan.py</code> <pre><code>def __init__(self,parent,motion_controller:Wdg_MotionController,\n             *args, **kwargs) -&gt; None:\n    \"\"\"Initializes the mapping method\n\n    Args:\n        parent (qw.QWidget): The widget to place the mapping method\n        motion_controller (Frm_MotionController): The motion controller to control the stage\n        status_bar (tk.Label, optional): The status bar to show the status of the mapping method. Defaults to None.\n    \"\"\"\n    # Place itself in the given master widget (container)\n    super().__init__(parent)\n    self.setupUi(self)\n    self.setLayout(self.main_layout)\n\n    # Sets up the other controllers\n    self._motion_controller = motion_controller\n\n    # Make the widgets to store the coordinates\n    self.btn_storeXY.clicked.connect(self.sig_request_currentCoorXY.emit)\n    self.btn_storeZStart.clicked.connect(self.sig_request_currentCoorZStart.emit)\n    self.btn_storeZEnd.clicked.connect(self.sig_request_currentCoorZEnd.emit)\n\n    self._init_workers()\n    self._init_signals()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.singlePoint_zScan.get_mapping_coordinates_mm","title":"<code>get_mapping_coordinates_mm()</code>","text":"<p>Returns the mapping coordinates</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of tuple (x,y,z) coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_generator/singlePoint_zScan.py</code> <pre><code>def get_mapping_coordinates_mm(self):\n    \"\"\" \n    Returns the mapping coordinates\n\n    Returns:\n        list: List of tuple (x,y,z) coordinates\n    \"\"\"\n    coor_xy_um = self.spin_coorx.value(), self.spin_coory.value()\n    coor_z1_um = self.spin_coorZStart.value()\n    coor_z2_um = self.spin_coorZEnd.value()\n    res_z_um = self.spin_resPt.value()\n\n    # Generate the mapping coordinates\n    list_z_um = np.linspace(coor_z1_um,coor_z2_um,num=int(abs(coor_z2_um-coor_z1_um)/res_z_um)+1)\n    list_mapping_coor_mm = [(coor_xy_um[0]/1e3,coor_xy_um[1]/1e3,z/1e3) for z in list_z_um]\n\n    return list_mapping_coor_mm\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/singlePoint_zScan/#iris.gui.submodules.meaCoor_generator.singlePoint_zScan.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/","title":"ssfrm_tilemthd1_rect_around","text":""},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.tiling_method_rectxy_scan_constz_around_a_point","title":"<code>tiling_method_rectxy_scan_constz_around_a_point</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A basic class that manage a mapping method</p> <p>Parameters:</p> Name Type Description Default <code>tk</code> <code>tkinter</code> <p>tkinter library</p> required Source code in <code>iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around.py</code> <pre><code>class tiling_method_rectxy_scan_constz_around_a_point(qw.QWidget):\n    \"\"\"\n    A basic class that manage a mapping method\n\n    Args:\n        tk (tkinter): tkinter library\n    \"\"\"\n    sig_store_currZ = Signal()  # Signal to store the current Z coordinate\n\n    def __init__(\n        self,\n        parent:qw.QWidget,\n        motion_controller:Wdg_MotionController,\n        tree_coor:Wdg_Treeview_MappingCoordinates,\n        getter_cal:Callable[[],ImgMea_Cal],\n        *args, **kwargs) -&gt; None:\n        # Place itself in the given master frame (container)\n        super().__init__(parent)\n\n        # Sets up the other controllers\n        self._motion_controller = motion_controller\n        self._getter_imgCal = getter_cal    # Function to get the image calibration\n\n    # &gt;&gt;&gt; Main widget setup &lt;&lt;&lt;\n        self._widget = TilingMethodControl_Design(self)\n        lyt = qw.QVBoxLayout(self)\n        lyt.addWidget(self._widget)\n        self.setLayout(lyt)\n        wdg = self._widget\n\n    # &gt;&gt;&gt; Top level frames &lt;&lt;&lt;\n        self._frm_tv_mapCoor = tree_coor\n\n    # &gt;&gt;&gt; Widgets &lt;&lt;&lt;\n        # Make the widgets to store the coordinates\n        self._chk_overrideZ = wdg.chk_ZOverride\n        self._entry_coorz = wdg.ent_zcoor\n        btn_coorz_set = wdg.btn_currZCoor\n        btn_coorz_set.clicked.connect(self.sig_store_currZ.emit)\n\n        self._spin_cropx = wdg.spin_cropx\n        self._spin_cropy = wdg.spin_cropy\n\n    # &gt;&gt;&gt; Signals &lt;&lt;&lt;\n        self._worker = worker_zcoor_getter(self._motion_controller)\n        self._thread = QThread()\n        self._worker.moveToThread(self._thread)\n        self._thread.start()\n        self.destroyed.connect(self._thread.quit)\n        self._thread.finished.connect(self._worker.deleteLater)\n\n        self.sig_store_currZ.connect(self._worker.get_current_zcoor)\n        self._worker.sig_return_zcoor.connect(lambda z: self._entry_coorz.setText(str(float(z*1e3))))\n\n    def get_tiling_coordinates_mm_and_cropFactors_rel(self) -&gt; tuple[list[MeaCoor_mm],float,float]|None:\n        \"\"\"\n        Returns the mapping coordinates and the cropping factors\n\n        Returns:\n            tuple[list[MeaCoor_mm], float, float]|None: The mapping coordinates (list of MeaCoor_mm objects), crop factor x, and crop factor y\n        \"\"\"\n        # Make sure to keep the generated coordinates up to date\n        list_meaCoor_mm = self._generate_tiling_coordinates()\n\n        if list_meaCoor_mm is None:\n            qw.QMessageBox.warning(self,'Error','No mapping coordinates generated. Please generate the coordinates first.')\n            return None\n        else:\n            cropx_reduction, cropy_reduction = self._get_crop_factors()\n            return (list_meaCoor_mm,cropx_reduction,cropy_reduction)\n\n    def _get_xy_scales_mmPerPixel(self) -&gt; tuple[float,float]:\n        \"\"\"\n        Gets the pixel to um conversion factor for the x and y direction \n\n        Returns:\n            tuple: The pixel to um conversion factor for the x and y direction [mm/pixel]\n        \"\"\"\n        img_cal:ImgMea_Cal = self._getter_imgCal()\n        scl_x = 1/img_cal.scale_x_pixelPerMm\n        scl_y = 1/img_cal.scale_y_pixelPerMm\n        return (abs(scl_x),abs(scl_y))\n\n    def _get_crop_factors(self) -&gt; tuple[float,float]:\n        \"\"\"\n        Gets the cropping factors for the x and y direction. (Between 0 and 1)\n\n        Returns:\n            tuple: The cropping factors for the x and y direction\n        \"\"\"\n        try:\n            cropx_reduction = self._spin_cropx.value()/100\n            cropy_reduction = self._spin_cropy.value()/100\n            assert 0 &lt;= cropx_reduction &lt; 1 and 0 &lt;= cropy_reduction &lt; 1, 'Cropping factors must be between 0 and 1'\n            return (cropx_reduction,cropy_reduction)\n        except Exception as e:\n            qw.QMessageBox.warning(self,'Error',f'{e}\\nUsing the default cropping factors (0.0, 0.0) instead')\n            return (0.0,0.0)\n\n    def _generate_tiling_coordinates(self) -&gt; list[MeaCoor_mm]|None:\n        \"\"\"\n        Generates the mapping coordinates. Also stores them in its own variable and the main\n        operation variable.\n\n        Returns:\n            list[MeaCoor_mm]|None: The mapping coordinates (list of (x,y,z) tuples) or None if an error occurs\n        \"\"\"\n        list_meaCoor_mm = self._frm_tv_mapCoor.get_selected_mappingCoor()\n        if len(list_meaCoor_mm) &lt; 1:\n            qw.QMessageBox.warning(self,'Error','Please select at least one mapping coordinate')\n            return\n\n        cropx_reduction, cropy_reduction = self._get_crop_factors()\n\n        image_size = self._motion_controller.get_image_shape()\n        if image_size is None:\n            qw.QMessageBox.warning(self,'Error','No image received from the motion controller')\n            return\n\n        cal = self._getter_imgCal()\n        if not isinstance(cal,ImgMea_Cal):\n            qw.QMessageBox.warning(self,'Error','No objective calibration selected. Please set the objective calibration first.')\n            return\n\n        # Define the grid boundaries\n        list_ret_MeaCoor_mm = [self._calculate_tiling_coordinates(meaCoor_mm, cropx_reduction, cropy_reduction, image_size, cal) for meaCoor_mm in list_meaCoor_mm]\n        list_ret_MeaCoor_mm = [meaCoor_mm for meaCoor_mm in list_ret_MeaCoor_mm if len(meaCoor_mm.mapping_coordinates) &gt; 0]\n        if len(list_ret_MeaCoor_mm) == 0:\n            qw.QMessageBox.warning(self,'Error','No valid mapping coordinates generated. Please check the input parameters.')\n            return None\n\n        return list_ret_MeaCoor_mm\n\n    def _calculate_tiling_coordinates(self, meaCoor_mm: MeaCoor_mm, cropx_reduction: float,\n        cropy_reduction: float, image_size: tuple[int, int], cal: ImgMea_Cal) -&gt; MeaCoor_mm:\n        \"\"\"\n        Calculates the tiling coordinates based on the input parameters.\n\n        Args:\n            meaCoor_mm (MeaCoor_mm): The mapping coordinates to tile.\n            cropx_reduction (float): The cropping factor for the x direction.\n            cropy_reduction (float): The cropping factor for the y direction.\n            image_size (tuple[int, int]): The size of an example image to be used for the size calculation. (Typically this would be\\\n                an image from the video camera)\n            cal (ImgMea_Cal): The objective calibration object.\n\n        Returns:\n            MeaCoor_mm: The calculated mapping coordinates with the original MeaCoor_mm mapping unit name.\n        \"\"\"\n        list_coor_mm = meaCoor_mm.mapping_coordinates\n        x_min = min([coor[0] for coor in list_coor_mm])\n        x_max = max([coor[0] for coor in list_coor_mm])\n        y_min = min([coor[1] for coor in list_coor_mm])\n        y_max = max([coor[1] for coor in list_coor_mm])\n        list_coor_xy_mm = [(coor[0], coor[1]) for coor in list_coor_mm]\n        list_coor_z_mm = [coor[2] for coor in list_coor_mm]\n\n        # Calculate the resolution required\n        x_scale, y_scale = self._get_xy_scales_mmPerPixel()\n        img_size_x, img_size_y = image_size\n        x_size_mm = img_size_x * x_scale\n        y_size_mm = img_size_y * y_scale\n\n        # Take into account the crop and the overlap\n        x_size_mm *= (1 - cropx_reduction)    # Taking into account the: Crop\n        y_size_mm *= (1 - cropy_reduction)\n        x_size_mm_temp, y_size_mm_temp = x_size_mm, y_size_mm\n        x_size_mm -= y_size_mm_temp * abs(np.sin(cal.rotation_rad)) # Taking into account the: Rotation\n        y_size_mm -= x_size_mm_temp * abs(np.sin(cal.rotation_rad))\n        x_size_mm *= (1 - OVERLAP)  # Taking into account the: Overlap\n        y_size_mm *= (1 - OVERLAP)\n\n        # Calculate the number of points required\n        num_x = ceil((x_max - x_min) / x_size_mm) + 1 # +1 to include the last point\n        num_y = ceil((y_max - y_min) / y_size_mm) + 1 # +1 to include the last point\n\n        m1_pointsx = num_x\n        m1_pointsy = num_y\n\n        # Generate linearly spaced points along each axis\n        x_points_mm = np.linspace(x_min, x_max, m1_pointsx)\n        y_points_mm = np.linspace(y_min, y_max, m1_pointsy)\n\n        list_xy_mm = [(x, y) for x in x_points_mm for y in y_points_mm]\n\n        # Interpolate the z-coordinates using griddata\n        list_z_mm = griddata(\n            points=list_coor_xy_mm,\n            values=list_coor_z_mm,\n            xi=list_xy_mm,\n            method='linear',\n            fill_value=np.nan\n        )\n\n        if self._chk_overrideZ.isChecked():\n            try:\n                z_override = float(self._entry_coorz.text()) * 1e-3\n                list_z_mm = [z_override for _ in list_z_mm]\n            except Exception as e:\n                qw.QMessageBox.warning(self,'Error',f'Invalid Z-coordinate override: {e}\\nUsing the interpolated Z-coordinates instead.')\n\n        list_xyz_mm = [(x, y, z) for (x, y), z in zip(list_xy_mm, list_z_mm) if not np.isnan(z)]\n        ret_mapCoor_mm = MeaCoor_mm(\n            mappingUnit_name=meaCoor_mm.mappingUnit_name,\n            mapping_coordinates=list_xyz_mm,\n        )\n        return ret_mapCoor_mm\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.tiling_method_rectxy_scan_constz_around_a_point.get_tiling_coordinates_mm_and_cropFactors_rel","title":"<code>get_tiling_coordinates_mm_and_cropFactors_rel()</code>","text":"<p>Returns the mapping coordinates and the cropping factors</p> <p>Returns:</p> Type Description <code>tuple[list[MeaCoor_mm], float, float] | None</code> <p>tuple[list[MeaCoor_mm], float, float]|None: The mapping coordinates (list of MeaCoor_mm objects), crop factor x, and crop factor y</p> Source code in <code>iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around.py</code> <pre><code>def get_tiling_coordinates_mm_and_cropFactors_rel(self) -&gt; tuple[list[MeaCoor_mm],float,float]|None:\n    \"\"\"\n    Returns the mapping coordinates and the cropping factors\n\n    Returns:\n        tuple[list[MeaCoor_mm], float, float]|None: The mapping coordinates (list of MeaCoor_mm objects), crop factor x, and crop factor y\n    \"\"\"\n    # Make sure to keep the generated coordinates up to date\n    list_meaCoor_mm = self._generate_tiling_coordinates()\n\n    if list_meaCoor_mm is None:\n        qw.QMessageBox.warning(self,'Error','No mapping coordinates generated. Please generate the coordinates first.')\n        return None\n    else:\n        cropx_reduction, cropy_reduction = self._get_crop_factors()\n        return (list_meaCoor_mm,cropx_reduction,cropy_reduction)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.worker_zcoor_getter","title":"<code>worker_zcoor_getter</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A worker class to get the current Z coordinate in a separate thread</p> Source code in <code>iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around.py</code> <pre><code>class worker_zcoor_getter(QObject):\n    \"\"\"\n    A worker class to get the current Z coordinate in a separate thread\n    \"\"\"\n    sig_return_zcoor = Signal(float)  # Signal to return the Z coordinate\n\n    def __init__(self, motion_controller:Wdg_MotionController):\n        super().__init__()\n        self._motion_controller = motion_controller\n\n    @Slot()\n    def get_current_zcoor(self):\n        \"\"\"Gets the current Z coordinate from the motion controller and emits it\n        \"\"\"\n        try:\n            z_mm = self._motion_controller.get_coordinates_closest_mm()[2]\n            self.sig_return_zcoor.emit(z_mm)\n        except Exception as e:\n            print('worker_zcoor_getter &gt;&gt; Error getting current Z coordinate:',e)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.worker_zcoor_getter.get_current_zcoor","title":"<code>get_current_zcoor()</code>","text":"<p>Gets the current Z coordinate from the motion controller and emits it</p> Source code in <code>iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around.py</code> <pre><code>@Slot()\ndef get_current_zcoor(self):\n    \"\"\"Gets the current Z coordinate from the motion controller and emits it\n    \"\"\"\n    try:\n        z_mm = self._motion_controller.get_coordinates_closest_mm()[2]\n        self.sig_return_zcoor.emit(z_mm)\n    except Exception as e:\n        print('worker_zcoor_getter &gt;&gt; Error getting current Z coordinate:',e)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_generator/ssfrm_tilemthd1_rect_around/#iris.gui.submodules.meaCoor_generator.ssfrm_tilemthd1_rect_around.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/","title":"every_z","text":"<p>A GUI module to modify the z-coordinates of a mapping coordinates list.</p>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.EveryZ","title":"<code>EveryZ</code>","text":"<p>               Bases: <code>Ui_every_z</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/every_z.py</code> <pre><code>class EveryZ(Ui_every_z, qw.QWidget):\n    msg_instructions = (\n        \"This module allows you to modify the z-coordinates of a mapping coordinates list.\\n\"\n        \"1. Select a mapping unit from the dropdown menu.\\n\"\n        \"2. Click 'Start modification' to start the modification process.\\n\"\n        \"3. For each coordinate, the current z-coordinate will be displayed.\\n\"\n        \"4. You can either enter a new z-coordinate manually or click 'Insert current Z-coor'.\\n\"\n        \"5. Move to the next coordinate by either enabling the 'Automove' checkbos or clicking 'Next coordinate'.\\n\"\n        \"6. You can cancel the modification process at any time by clicking 'Cancel modification'.\\n\"\n        \"7. After all coordinates have been modified or after pressing 'Finish and save modification',\"\n        \"you will be prompted to enter a name for the new mapping unit.\\n\")\n\n    sig_updateCombo_mappingUnits = Signal()\n    sig_perform_zModification = Signal(MeaCoor_mm)\n\n    sig_gotonext_coordinate = Signal(Option_NextZ)\n    sig_store_coorZ_mm = Signal(float)\n\n    def __init__(\n        self,\n        parent,\n        mappingCoorHub: List_MeaCoor_Hub,\n        motion_controller:Wdg_MotionController,\n        *args, **kwargs) -&gt; None:\n        \"\"\"Initializes the mapping method\n\n        Args:\n            parent (qw.QWidget): The parent widget to place this widget in\n            MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n            getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n            motion_controller (Frm_MotionController): The motion controller to use for the mapping\n        \"\"\"\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        self._coorHub = mappingCoorHub\n        self._motion_controller = motion_controller\n\n        # Button setup\n        self.btn_showInstructions.clicked.connect(lambda: qw.QMessageBox.information(self, \"Instructions\", self.msg_instructions))\n        self.btn_start.clicked.connect(self._start_modify_z_coordinates)\n        self._set_enabled_modifier(enabled=False)\n\n        # Params\n        self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n        # Initialize the worker thread for motion controller communication\n        self._init_worker()\n        self._init_signals()\n        self.sig_updateCombo_mappingUnits.emit()\n\n    def _init_worker(self):\n        # Initialize the worker thread for z-coordinate modification\n        self._thread_modifier = QThread()\n        self._worker_modifier = EveryZModifier_Worker(self._motion_controller)\n        self._worker_modifier.moveToThread(self._thread_modifier)\n\n        self._worker_modifier.sig_finish.connect(self._handle_finish)\n        self._worker_modifier.sig_saveModification.connect(self._handle_save_modification)\n        self._worker_modifier.sig_error.connect(self._handle_error)\n\n        self._worker_modifier.sig_current_coordinate_index.connect(lambda idx_str: self.lbl_coorLeft.setText(idx_str))\n        self._worker_modifier.sig_current_coordinate_z_mm.connect(lambda z_mm: self.spin_newZUm.setValue(z_mm*1e3))\n        self._worker_modifier.sig_original_coordinate_z_mm.connect(lambda z_str: self.lbl_prevZ.setText(z_str))\n\n        self.sig_perform_zModification.connect(self._worker_modifier._set_mapping_coordinates)\n        self.sig_gotonext_coordinate.connect(self._worker_modifier._go_to_next_coordinate)\n        self.sig_store_coorZ_mm.connect(self._worker_modifier._set_newZCoor_mm)\n\n        self.btn_goToNext.clicked.connect(self._go_to_next_coordinate)\n        self.btn_goToPrev.clicked.connect(self._worker_modifier._go_to_prev_coordinate)\n        self.btn_storeZ.clicked.connect(self._store_current_z_coordinate)\n\n        self.btn_cancel.clicked.connect(self._worker_modifier._cancel_modification)\n        self.btn_finishAndSave.clicked.connect(self._worker_modifier._finish_modification)\n\n        self._thread_modifier.start()\n\n    def _init_signals(self):\n        self.sig_updateCombo_mappingUnits.connect(self._update_list_units)\n        self._coorHub.add_observer(self.sig_updateCombo_mappingUnits.emit)\n\n    @Slot()\n    def _update_list_units(self):\n        \"\"\"Updates the list of mapping units in the combobox\"\"\"\n        self._dict_mapUnit.clear()  # Clear the existing dictionary\n        self._dict_mapUnit = {unit.mappingUnit_name: unit for unit in self._coorHub}\n\n        self.combo_mappingCoor.clear()\n        self.combo_mappingCoor.addItems(list(self._dict_mapUnit.keys()))\n\n    @Slot(str)\n    def _handle_error(self, msg:str):\n        \"\"\"Handles errors from the modifier worker\"\"\"\n        qw.QMessageBox.critical(self, \"Error\", msg)\n\n    @Slot(str)\n    def _handle_finish(self, msg:str):\n        \"\"\"Handles the finishing of the modification process\"\"\"\n        self._set_enabled_modifier(False)\n        self._set_enabled_selector(True)\n\n        if msg.startswith(self._worker_modifier.msg_error_finish):\n            qw.QMessageBox.critical(self, \"Error\", msg)\n        elif msg.startswith(self._worker_modifier.msg_success_finish):\n            qw.QMessageBox.information(self, \"Success\", msg)\n        elif msg.startswith(self._worker_modifier.msg_cancelled_finish):\n            qw.QMessageBox.information(self, \"Cancelled\", msg)\n\n    @Slot(MeaCoor_mm)\n    def _handle_save_modification(self, mapping_coor:MeaCoor_mm):\n        \"\"\"Handles saving the modified mapping coordinates\n\n        Args:\n            mapping_coor (MeaCoor_mm): The modified mapping coordinates\n        \"\"\"\n        new_name = messagebox_request_input(\n            self,\n            title=\"New Mapping Unit Name\",\n            message=\"Enter a name for the new mapping unit:\",\n            default=mapping_coor.mappingUnit_name + \"_modified\",\n            validator=self._coorHub.validator_new_name,\n            invalid_msg=\"The name is already in use. Please enter a different name.\",\n            loop_until_valid=True\n        )\n\n        if new_name is None:\n            qw.QMessageBox.warning(self, \"Warning\", \"Modification cancelled: No name provided for new mapping unit.\")\n            return\n\n        # Add the new mapping coordinates to the hub\n        new_mapping_coor = MeaCoor_mm(new_name, mapping_coor.mapping_coordinates)\n        try: self._coorHub.append(new_mapping_coor)\n        except Exception as e:\n            qw.QMessageBox.critical(self, \"Error\", f\"Failed to add new mapping coordinates: {e}\")\n            return\n\n    def _set_enabled_selector(self, enabled:bool):\n        \"\"\"Resets the widgets in the mapping coordinates selection frame to the given state\n        Args:\n            enabled (bool): The state to set the widgets to enabled or disabled. True for enabled, False for disabled.\n        \"\"\"\n        list_widgets = get_all_widgets_from_layout(self.lyt_selector)\n\n        for widget in list_widgets:\n            if isinstance(widget, (qw.QPushButton, qw.QComboBox)):\n                widget.setEnabled(enabled)\n\n    def _set_enabled_modifier(self, enabled:bool):\n        \"\"\"Resets the widgets in the z-coordinates modification frame to the given state\n        Args:\n            enabled (bool): The state to set the widgets to enabled or disabled. True for enabled, False for disabled.\n        \"\"\"\n        list_widgets = get_all_widgets_from_layout(self.lyt_modifications)\n\n        for widget in list_widgets:\n            if isinstance(widget, (qw.QPushButton, qw.QLineEdit, qw.QCheckBox, qw.QRadioButton)):\n                widget.setEnabled(enabled)\n\n    def _get_mapping_coordinates(self) -&gt; MeaCoor_mm|None:\n        \"\"\"Retrieves the selected mapping coordinates from the combobox\n\n        Returns:\n            MeaCoor_mm|None: The selected mapping coordinates, or None if not found\n        \"\"\"\n        selected_unit_name = self.combo_mappingCoor.currentText()\n        if not selected_unit_name:\n            qw.QMessageBox.warning(self, \"Warning\", \"Please select a mapping unit to modify.\")\n            return None\n\n        if selected_unit_name not in self._dict_mapUnit:\n            qw.QMessageBox.critical(self, \"Error\", f\"Mapping unit '{selected_unit_name}' not found.\")\n            return None\n\n        mapping_coordinates = self._dict_mapUnit[selected_unit_name]\n\n        if not isinstance(mapping_coordinates, MeaCoor_mm):\n            qw.QMessageBox.critical(self, \"Error\", \"Invalid mapping coordinates type.\")\n            return None\n\n        return mapping_coordinates\n\n    @Slot()\n    def _start_modify_z_coordinates(self):\n        \"\"\"\n        Runs the modification of the z-coordinates of the selected mapping coordinates\n        \"\"\"\n        mapping_coordinate = self._get_mapping_coordinates()\n        if mapping_coordinate is None: return\n\n        self.sig_perform_zModification.emit(mapping_coordinate)\n        self._set_enabled_modifier(True)\n        self._set_enabled_selector(False)\n\n    @Slot()\n    def _go_to_next_coordinate(self):\n        \"\"\"\n        Moves to the next coordinate using the modifier worker\n        \"\"\"\n        self.sig_gotonext_coordinate.emit(self._get_nextZ_option())\n\n    def _get_nextZ_option(self) -&gt; Option_NextZ:\n        \"\"\"Retrieves the next Z-coordinate option from the radio buttons\n\n        Returns:\n            Option_NextZ: The selected next Z-coordinate option\n        \"\"\"\n        return Option_NextZ.ORIGINAL if self.rad_originalZ.isChecked() else Option_NextZ.LAST\n\n    @Slot()\n    def _store_current_z_coordinate(self):\n        \"\"\"\n        Stores the current z-coordinate from the motion controller into the modifier worker\n        \"\"\"\n        new_z_mm = self._motion_controller.get_coordinates_closest_mm()[2]\n        if not isinstance(new_z_mm, (int,float)):\n            qw.QMessageBox.warning(self, \"Error\", \"Could not retrieve current Z coordinate from motion controller.\")\n            return\n\n        self.spin_newZUm.setValue(new_z_mm*1e3)\n        self.sig_store_coorZ_mm.emit(new_z_mm)\n\n        if self.chk_autoNextCoor.isChecked():\n            self.sig_gotonext_coordinate.emit(self._get_nextZ_option())\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.EveryZ.__init__","title":"<code>__init__(parent, mappingCoorHub, motion_controller, *args, **kwargs)</code>","text":"<p>Initializes the mapping method</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget to place this widget in</p> required <code>MappingCoorHub</code> <code>MappingCoordinatesHub</code> <p>The hub to store the resulting mapping coordinates in</p> required <code>getter_MappingCoor</code> <code>Callable[[], MappingCoordinates_mm]</code> <p>A function to get the mapping coordinates to modify</p> required <code>motion_controller</code> <code>Frm_MotionController</code> <p>The motion controller to use for the mapping</p> required Source code in <code>iris/gui/submodules/meaCoor_modifier/every_z.py</code> <pre><code>def __init__(\n    self,\n    parent,\n    mappingCoorHub: List_MeaCoor_Hub,\n    motion_controller:Wdg_MotionController,\n    *args, **kwargs) -&gt; None:\n    \"\"\"Initializes the mapping method\n\n    Args:\n        parent (qw.QWidget): The parent widget to place this widget in\n        MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n        getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n        motion_controller (Frm_MotionController): The motion controller to use for the mapping\n    \"\"\"\n    super().__init__(parent)\n    self.setupUi(self)\n    self.setLayout(self.main_layout)\n\n    self._coorHub = mappingCoorHub\n    self._motion_controller = motion_controller\n\n    # Button setup\n    self.btn_showInstructions.clicked.connect(lambda: qw.QMessageBox.information(self, \"Instructions\", self.msg_instructions))\n    self.btn_start.clicked.connect(self._start_modify_z_coordinates)\n    self._set_enabled_modifier(enabled=False)\n\n    # Params\n    self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n    # Initialize the worker thread for motion controller communication\n    self._init_worker()\n    self._init_signals()\n    self.sig_updateCombo_mappingUnits.emit()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.EveryZModifier_Worker","title":"<code>EveryZModifier_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/every_z.py</code> <pre><code>class EveryZModifier_Worker(QObject):\n    sig_error = Signal(str)\n    sig_finish = Signal(str)\n    sig_saveModification = Signal(MeaCoor_mm)\n    sig_current_coordinate_index = Signal(str)\n    sig_current_coordinate_z_mm = Signal(float)\n    sig_original_coordinate_z_mm = Signal(str)\n\n    msg_error_finish = \"Error in modifying z-coordinates:\"\n    msg_error_inprogress = \"Error in modifying z-coordinates (in progress):\"\n    msg_success_finish = \"Successfully modified z-coordinates.\"\n    msg_cancelled_finish = \"Z-coordinates modification cancelled by user.\"\n\n    _sig_gotocoor = Signal(tuple,threading.Event)\n\n    def __init__(self, motion_controller:Wdg_MotionController):\n        super().__init__()\n        self._motion_controller = motion_controller\n        self._mappingCoor:MeaCoor_mm|None = None\n        self._index:int = 0\n        self._last_z_mm:float|None = None\n\n        self._gotoworker = self._motion_controller.get_goto_worker()\n        self._sig_gotocoor.connect(self._gotoworker.work)\n\n    def _emit_current_coordinate(self):\n        \"\"\"Emits the current coordinate index as a string\"\"\"\n        if self._mappingCoor is None:\n            self.sig_current_coordinate_index.emit('N/A')\n            return\n\n        total = len(self._mappingCoor.mapping_coordinates)\n        current = self._index + 1  # 1-based index for user display\n        self.sig_current_coordinate_index.emit(f'{current} of {total}')\n        self.sig_original_coordinate_z_mm.emit(\n            f\"{self._mappingCoor.mapping_coordinates[self._index][2]*1e3:.2f} \u00b5m\"\n        )\n\n    @Slot(MeaCoor_mm)\n    def _set_mapping_coordinates(self, mapping_coordinates:MeaCoor_mm):\n        \"\"\"\n        Runs the modification of the z-coordinates of the selected mapping coordinates\n        \"\"\"\n        self._mappingCoor = mapping_coordinates.copy()\n        self.sig_current_coordinate_z_mm.emit(self._mappingCoor.mapping_coordinates[self._index][2])\n        self._emit_current_coordinate()\n\n    @Slot(float)\n    def _set_newZCoor_mm(self, new_z_mm:float):\n        \"\"\"Sets the last known z-coordinate\n        \"\"\"\n        if self._mappingCoor is None:\n            self.sig_error.emit(f\"{self.msg_error_inprogress} No mapping coordinates set.\")\n            return\n\n        new_coor_mm = self._mappingCoor.mapping_coordinates[self._index]\n        new_coor_mm = (\n            new_coor_mm[0],\n            new_coor_mm[1],\n            new_z_mm,\n        )\n        self._mappingCoor.mapping_coordinates[self._index] = new_coor_mm\n        self._last_z_mm = new_z_mm\n\n    @Slot(Option_NextZ)\n    def _go_to_next_coordinate(self, option_nextZ:Option_NextZ):\n        \"\"\"Moves the motion controller to the next coordinate\n\n        Args:\n            target_coor_mm (tuple): The target coordinate to move to\n        \"\"\"\n        self._index += 1\n\n        if self._mappingCoor is None:\n            self.sig_error.emit(f\"{self.msg_error_inprogress} No mapping coordinates set.\")\n            return\n\n        if self._index &gt;= len(self._mappingCoor.mapping_coordinates):\n            self._index = len(self._mappingCoor.mapping_coordinates) - 1\n            self.sig_error.emit(f\"{self.msg_error_inprogress} Already at the last coordinate.\")\n            return\n\n        target_coor_mm = self._mappingCoor.mapping_coordinates[self._index]\n        nextZ = target_coor_mm[2]\n        if option_nextZ == Option_NextZ.LAST and isinstance(self._last_z_mm, (int,float)):\n            target_coor_mm = (\n                target_coor_mm[0],\n                target_coor_mm[1],\n                self._last_z_mm,\n            )\n            nextZ = self._last_z_mm\n\n        try:\n            reached = threading.Event()\n            self._sig_gotocoor.emit(target_coor_mm, reached)\n            reached.wait(10)\n            if not reached.is_set(): raise TimeoutError(\"Motion controller did not reach target coordinate in time.\")\n        except Exception as e:\n            self.sig_error.emit(f\"{self.msg_error_inprogress} Failed to move to next coordinate: {e}\")\n            return\n\n        self._emit_current_coordinate()\n        self.sig_current_coordinate_z_mm.emit(nextZ)\n\n    @Slot()\n    def _go_to_prev_coordinate(self):\n        if self._mappingCoor is None:\n            self.sig_error.emit(f\"{self.msg_error_inprogress} No mapping coordinates set.\")\n            return\n\n        self._index -= 1\n        if self._index &lt; 0:\n            self._index = 0\n            self.sig_error.emit(f\"{self.msg_error_inprogress} Already at the first coordinate.\")\n            return\n\n        target_coor_mm = self._mappingCoor.mapping_coordinates[self._index]\n        try:\n            reached = threading.Event()\n            self._sig_gotocoor.emit(target_coor_mm, reached)\n            reached.wait(10)\n            if not reached.is_set(): raise TimeoutError(\"Motion controller did not reach target coordinate in time.\")\n        except Exception as e:\n            self.sig_error.emit(f\"{self.msg_error_inprogress} Failed to move to previous coordinate: {e}\")\n            return\n\n        self.sig_current_coordinate_z_mm.emit(self._mappingCoor.mapping_coordinates[self._index][2])\n\n    @Slot()\n    def _cancel_modification(self):\n        \"\"\"Cancels the modification process\n        \"\"\"\n        self._mappingCoor = None\n        self._index = 0\n        self._last_z_mm = None\n        self.sig_finish.emit(self.msg_cancelled_finish)\n\n    @Slot()\n    def _finish_modification(self):\n        \"\"\"Finishes the modification process and emits the modified mapping coordinates\n        \"\"\"\n        if self._mappingCoor is None:\n            self.sig_error.emit(f\"{self.msg_error_finish} No mapping coordinates set.\")\n            return\n\n        modified_mappingCoor = self._mappingCoor\n        self._mappingCoor = None\n        self._index = 0\n        self._last_z_mm = None\n\n        self.sig_saveModification.emit(modified_mappingCoor)\n        self.sig_finish.emit(self.msg_success_finish)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/every_z/#iris.gui.submodules.meaCoor_modifier.every_z.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/","title":"gridify","text":"<p>A GUI module to modify a mapping coordinates list by translating  the coordinates in the X, Y and Z direction.</p>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Enums_NamingScheme","title":"<code>Enums_NamingScheme</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for the naming scheme of the gridified coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>class Enums_NamingScheme(Enum):\n    \"\"\"Enumeration for the naming scheme of the gridified coordinates\"\"\"\n    row_col = \"Row, Column\"\n    col_row = \"Column, Row\"\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Enums_RefCornerDict","title":"<code>Enums_RefCornerDict</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for the dict keys of the reference four corners</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>class Enums_RefCornerDict(Enum):\n    \"\"\"Enum for the dict keys of the reference four corners\"\"\"\n    x = 'x'\n    y = 'y'\n    z = 'z'\n    loc_xy = 'location_xy'\n    loc_z = 'location_z'\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Enums_RefFourCorners","title":"<code>Enums_RefFourCorners</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for the reference four corners of the mapping coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>class Enums_RefFourCorners(Enum):\n    \"\"\"Enumeration for the reference four corners of the mapping coordinates\"\"\"\n    top_left = 'Top left'\n    top_right = 'Top right'\n    bottom_left = 'Bottom left'\n    bottom_right = 'Bottom right'\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Enums_RefXY","title":"<code>Enums_RefXY</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for the reference location of the mapping coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>class Enums_RefXY(Enum):\n    \"\"\"Enumeration for the reference location of the mapping coordinates\"\"\"\n    top_left = 'Top left'\n    top_center = 'Top center'\n    top_right = 'Top right'\n    center_left = 'Center left'\n    center_center = 'Center center'\n    center_right = 'Center right'\n    bottom_left = 'Bottom left'\n    bottom_center = 'Bottom center'\n    bottom_right = 'Bottom right'\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Enums_RefZ","title":"<code>Enums_RefZ</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for the reference Z-coordinate of the mapping coordinates</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>class Enums_RefZ(Enum):\n    \"\"\"Enumeration for the reference Z-coordinate of the mapping coordinates\"\"\"\n    top = 'Top Z'\n    center = 'Center Z'\n    bottom = 'Bottom Z'\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Gridify","title":"<code>Gridify</code>","text":"<p>               Bases: <code>Ui_gridify_setup</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>class Gridify(Ui_gridify_setup, qw.QWidget):\n    def __init__(\n        self,\n        parent,\n        mappingCoorHub: List_MeaCoor_Hub,\n        motion_controller:Wdg_MotionController,\n        *args, **kwargs) -&gt; None:\n        \"\"\"Initializes the mapping method\n\n        Args:\n            parent (tk.Frame): The parent frame to place this widget in\n            MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n            getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n            motion_controller (Frm_MotionController): The motion controller to use for the mapping\n        \"\"\"\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        self._coorHub = mappingCoorHub\n        self._motion_controller = motion_controller\n\n    # &gt;&gt;&gt; Information widget &lt;&lt;&lt;\n        self.btn_instructions.clicked.connect(self._show_instructions)\n\n    # &gt;&gt;&gt; Reference coordinates widget &lt;&lt;&lt;\n        # Parameters setup\n        self._dict_refFourCorners = {\n            Enums_RefFourCorners.top_left: dict(),\n            Enums_RefFourCorners.top_right: dict(),\n            Enums_RefFourCorners.bottom_left: dict(),\n            Enums_RefFourCorners.bottom_right: dict(),\n        }\n        self._init_refFourCorners_widgets()\n\n    # &gt;&gt;&gt; Options frame &lt;&lt;&lt;\n        self.btn_finalise.clicked.connect(self._run_gridSetup)\n\n    # &gt;&gt;&gt; Parameters for the mapping coordinates modification &lt;&lt;&lt;\n        self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n    # &gt;&gt;&gt; Others &lt;&lt;&lt;\n        self._coorHub.add_observer(self._update_list_units)\n        self._update_list_units()\n\n    def _init_refFourCorners_widgets(self):\n        \"\"\"Initializes the reference four corners for the mapping coordinates\"\"\"\n        # &gt;&gt; Setup the widgets &lt;&lt;\n        list_combo_xy = [self.combo_tl_xy, self.combo_tr_xy, self.combo_bl_xy, self.combo_br_xy]\n        list_combo_z = [self.combo_tl_z, self.combo_tr_z, self.combo_bl_z, self.combo_br_z]\n\n        [combo_xy.addItems([e.value for e in Enums_RefXY]) for combo_xy in list_combo_xy]\n        [combo_z.addItems([e.value for e in Enums_RefZ]) for combo_z in list_combo_z]\n\n        [combo_xy.setCurrentText(Enums_RefXY.center_center.value) for combo_xy in list_combo_xy]\n        [combo_z.setCurrentText(Enums_RefZ.bottom.value) for combo_z in list_combo_z]\n\n        self.btn_currcoor_tl.clicked.connect(lambda: self._insert_current_coordinate(self.spin_tl_x, self.spin_tl_y, self.spin_tl_z))\n        self.btn_currcoor_tr.clicked.connect(lambda: self._insert_current_coordinate(self.spin_tr_x, self.spin_tr_y, self.spin_tr_z))\n        self.btn_currcoor_bl.clicked.connect(lambda: self._insert_current_coordinate(self.spin_bl_x, self.spin_bl_y, self.spin_bl_z))\n        self.btn_currcoor_br.clicked.connect(lambda: self._insert_current_coordinate(self.spin_br_x, self.spin_br_y, self.spin_br_z))\n\n        # &gt;&gt; Setup the dictionary &lt;&lt;\n        self._dict_refFourCorners[Enums_RefFourCorners.top_left] = {\n            Enums_RefCornerDict.x: self.spin_tl_x,\n            Enums_RefCornerDict.y: self.spin_tl_y,\n            Enums_RefCornerDict.z: self.spin_tl_z,\n            Enums_RefCornerDict.loc_xy: self.combo_tl_xy,\n            Enums_RefCornerDict.loc_z: self.combo_tl_z,\n        }\n        self._dict_refFourCorners[Enums_RefFourCorners.top_right] = {\n            Enums_RefCornerDict.x: self.spin_tr_x,\n            Enums_RefCornerDict.y: self.spin_tr_y,\n            Enums_RefCornerDict.z: self.spin_tr_z,\n            Enums_RefCornerDict.loc_xy: self.combo_tr_xy,\n            Enums_RefCornerDict.loc_z: self.combo_tr_z,\n        }\n        self._dict_refFourCorners[Enums_RefFourCorners.bottom_left] = {\n            Enums_RefCornerDict.x: self.spin_bl_x,\n            Enums_RefCornerDict.y: self.spin_bl_y,\n            Enums_RefCornerDict.z: self.spin_bl_z,\n            Enums_RefCornerDict.loc_xy: self.combo_bl_xy,\n            Enums_RefCornerDict.loc_z: self.combo_bl_z,\n        }\n        self._dict_refFourCorners[Enums_RefFourCorners.bottom_right] = {\n            Enums_RefCornerDict.x: self.spin_br_x,\n            Enums_RefCornerDict.y: self.spin_br_y,\n            Enums_RefCornerDict.z: self.spin_br_z,\n            Enums_RefCornerDict.loc_xy: self.combo_br_xy,\n            Enums_RefCornerDict.loc_z: self.combo_br_z,\n        }\n\n    def _insert_current_coordinate(self, ent_x:qw.QDoubleSpinBox, ent_y:qw.QDoubleSpinBox, ent_z:qw.QDoubleSpinBox):\n        \"\"\"\n        Inserts the current coordinates from the motion controller into the reference coordinates\n\n        Args:\n            ent_x (QDoubleSpinBox): The spinbox for the X coordinate\n            ent_y (QDoubleSpinBox): The spinbox for the Y coordinate\n            ent_z (QDoubleSpinBox): The spinbox for the Z coordinate\n        \"\"\"\n        coor = self._motion_controller.get_coordinates_closest_mm()\n        if any(c is None for c in coor):\n            qw.QMessageBox.warning(self, \"Warning\", \"Failed to get current coordinates from the motion controller.\")\n            return\n\n        coorx_um = coor[0] * 1e3    # pyright: ignore[reportOptionalOperand] ; coor is checked for None above\n        coory_um = coor[1] * 1e3    # pyright: ignore[reportOptionalOperand] ; coor is checked for None above\n        coorz_um = coor[2] * 1e3    # pyright: ignore[reportOptionalOperand] ; coor is checked for None above\n\n        ent_x.setValue(coorx_um)\n        ent_y.setValue(coory_um)\n        ent_z.setValue(coorz_um)\n\n    @Slot()\n    def _show_instructions(self):\n        instructions = (\n            \"This module takes an existing mapping coordinates list and creates a grid layout based on the specified parameters.\\n\"\n            \"NOTE: Make sure that the XY stage coordinate increases when the XY stage physically moves to the left and bottom.\\n\"\n            \"And the Z coordinate increases when the objective's stage moves closer to the sample.\"\n        )\n        qw.QMessageBox.information(self, \"Instructions\", instructions)\n\n    def _update_list_units(self):\n        \"\"\"Updates the list of mapping units in the combobox\"\"\"\n        self._dict_mapUnit.clear()  # Clear the existing dictionary\n        self._dict_mapUnit = {unit.mappingUnit_name: unit for unit in self._coorHub}\n\n        selection = self.combo_roi.currentText()\n        self.combo_roi.clear()\n        list_roi_names = list(self._dict_mapUnit.keys())\n        self.combo_roi.addItems(list_roi_names)\n\n        if selection in list_roi_names: self.combo_roi.setCurrentText(selection)\n\n    @Slot()\n    def reset_and_handle_cancellation(self):\n        \"\"\"\n        Resets the finalise button to enabled state\n        \"\"\"\n        self.btn_finalise.setEnabled(True)\n\n    @Slot()\n    def _run_gridSetup(self):\n        \"\"\"\n        Runs the modification of the z-coordinates of the selected mapping coordinates\n        \"\"\"\n        self.btn_finalise.setEnabled(False)\n\n    # &gt; Retrieve the selected mapping unit from the combobox and check it &lt;\n        selected_unit_name = self.combo_roi.currentText()\n        if not selected_unit_name:\n            qw.QMessageBox.warning(self, \"Warning\", \"Please select a mapping unit to modify.\")\n            self.reset_and_handle_cancellation()\n            return\n\n        if selected_unit_name not in self._dict_mapUnit:\n            qw.QMessageBox.warning(self, \"Error\", f\"Mapping unit '{selected_unit_name}' not found.\")\n            self.reset_and_handle_cancellation()\n            return\n\n        # Get the current mapping coordinates\n        mapping_coordinates = self._dict_mapUnit[selected_unit_name]\n\n        if not isinstance(mapping_coordinates, MeaCoor_mm):\n            qw.QMessageBox.warning(self, \"Error\", \"Invalid mapping coordinates type.\")\n            self.reset_and_handle_cancellation()\n            return\n\n    # &gt; Calculate the center of the four corners coordinates &lt;\n        corner_coords = []\n        for corner in self._dict_refFourCorners:\n            x_mm = float(self._dict_refFourCorners[corner][Enums_RefCornerDict.x].value())/1e3\n            y_mm = float(self._dict_refFourCorners[corner][Enums_RefCornerDict.y].value())/1e3\n            z_mm = float(self._dict_refFourCorners[corner][Enums_RefCornerDict.z].value())/1e3\n            ctr_x, ctr_y, ctr_z = calculate_coordinatesCenter(\n                ref_coor=np.array([x_mm, y_mm, z_mm]),\n                mappingCoor=mapping_coordinates,\n                loc_xy=Enums_RefXY(self._dict_refFourCorners[corner][Enums_RefCornerDict.loc_xy].currentText()),\n                loc_z=Enums_RefZ(self._dict_refFourCorners[corner][Enums_RefCornerDict.loc_z].currentText())\n            )\n            corner_coords.append(np.array([ctr_x, ctr_y, ctr_z]))\n\n    # &gt; Get the number of rows and columns from the entry fields &lt;\n        try:\n            num_rows = self.spin_row.value()\n            num_cols = self.spin_col.value()\n            if num_rows &lt; 2 or num_cols &lt; 2:\n                raise ValueError(\"Number of rows and columns must be at least 2.\")\n        except ValueError as e:\n            qw.QMessageBox.critical(self, \"Error\", f\"Invalid input: {e}\")\n            self.reset_and_handle_cancellation()\n            return\n\n        mapping_coor = mapping_coordinates.copy()\n\n    # &gt; Open the grid setup dialog &lt;\n        self._mw_naming = Gridify_NamingSetup(\n            gridify_main=self,\n            corner_coords=corner_coords,\n            num_rows=num_rows,\n            num_cols=num_cols,\n            mapping_coor=mapping_coor,\n            ctrl_motion_video=self._motion_controller,\n        )\n        self._mw_naming.show()\n\n    def initialise_Gridify_Finetune(self, list_mapping_coor:list[MeaCoor_mm],\n        list_loc:list[tuple[int,int]]) -&gt; None:\n        \"\"\"\n        Initialises the fine-tune gridify window.\n\n        Args:\n            list_mapping_coor (list[MeaCoor_mm]): List of mapping coordinates to fine-tune\n            list_loc (list[tuple[int,int]]): List of (row, column) locations for each mapping coordinate\n        \"\"\"\n        self._mw_finetune = Gridify_Finetune(\n            gridify_main=self,\n            list_mapping_coor=list_mapping_coor,\n            list_loc=list_loc,\n            ctrl_motion_video=self._motion_controller,\n        )\n        self._mw_finetune.show()\n\n    @Slot(list)\n    def handle_gridify_completion(self, res:list[MeaCoor_mm]):\n        list_newMapCoor = []\n        for mapcoor in res:\n            mapcoor:MeaCoor_mm\n            list_coor = [(float(coor[0]), float(coor[1]), float(coor[2])) for coor in mapcoor.mapping_coordinates.copy()]\n            new_mapcoor = MeaCoor_mm(\n                mappingUnit_name=mapcoor.mappingUnit_name,\n                mapping_coordinates=list_coor\n            )\n            list_newMapCoor.append(new_mapcoor)\n\n        if len(list_newMapCoor) &gt; 0:\n            self._coorHub.extend(list_newMapCoor)\n        self.reset_and_handle_cancellation()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Gridify.__init__","title":"<code>__init__(parent, mappingCoorHub, motion_controller, *args, **kwargs)</code>","text":"<p>Initializes the mapping method</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Frame</code> <p>The parent frame to place this widget in</p> required <code>MappingCoorHub</code> <code>MappingCoordinatesHub</code> <p>The hub to store the resulting mapping coordinates in</p> required <code>getter_MappingCoor</code> <code>Callable[[], MappingCoordinates_mm]</code> <p>A function to get the mapping coordinates to modify</p> required <code>motion_controller</code> <code>Frm_MotionController</code> <p>The motion controller to use for the mapping</p> required Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>def __init__(\n    self,\n    parent,\n    mappingCoorHub: List_MeaCoor_Hub,\n    motion_controller:Wdg_MotionController,\n    *args, **kwargs) -&gt; None:\n    \"\"\"Initializes the mapping method\n\n    Args:\n        parent (tk.Frame): The parent frame to place this widget in\n        MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n        getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n        motion_controller (Frm_MotionController): The motion controller to use for the mapping\n    \"\"\"\n    super().__init__(parent)\n    self.setupUi(self)\n    self.setLayout(self.main_layout)\n\n    self._coorHub = mappingCoorHub\n    self._motion_controller = motion_controller\n\n# &gt;&gt;&gt; Information widget &lt;&lt;&lt;\n    self.btn_instructions.clicked.connect(self._show_instructions)\n\n# &gt;&gt;&gt; Reference coordinates widget &lt;&lt;&lt;\n    # Parameters setup\n    self._dict_refFourCorners = {\n        Enums_RefFourCorners.top_left: dict(),\n        Enums_RefFourCorners.top_right: dict(),\n        Enums_RefFourCorners.bottom_left: dict(),\n        Enums_RefFourCorners.bottom_right: dict(),\n    }\n    self._init_refFourCorners_widgets()\n\n# &gt;&gt;&gt; Options frame &lt;&lt;&lt;\n    self.btn_finalise.clicked.connect(self._run_gridSetup)\n\n# &gt;&gt;&gt; Parameters for the mapping coordinates modification &lt;&lt;&lt;\n    self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n# &gt;&gt;&gt; Others &lt;&lt;&lt;\n    self._coorHub.add_observer(self._update_list_units)\n    self._update_list_units()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Gridify.initialise_Gridify_Finetune","title":"<code>initialise_Gridify_Finetune(list_mapping_coor, list_loc)</code>","text":"<p>Initialises the fine-tune gridify window.</p> <p>Parameters:</p> Name Type Description Default <code>list_mapping_coor</code> <code>list[MeaCoor_mm]</code> <p>List of mapping coordinates to fine-tune</p> required <code>list_loc</code> <code>list[tuple[int, int]]</code> <p>List of (row, column) locations for each mapping coordinate</p> required Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>def initialise_Gridify_Finetune(self, list_mapping_coor:list[MeaCoor_mm],\n    list_loc:list[tuple[int,int]]) -&gt; None:\n    \"\"\"\n    Initialises the fine-tune gridify window.\n\n    Args:\n        list_mapping_coor (list[MeaCoor_mm]): List of mapping coordinates to fine-tune\n        list_loc (list[tuple[int,int]]): List of (row, column) locations for each mapping coordinate\n    \"\"\"\n    self._mw_finetune = Gridify_Finetune(\n        gridify_main=self,\n        list_mapping_coor=list_mapping_coor,\n        list_loc=list_loc,\n        ctrl_motion_video=self._motion_controller,\n    )\n    self._mw_finetune.show()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Gridify.reset_and_handle_cancellation","title":"<code>reset_and_handle_cancellation()</code>","text":"<p>Resets the finalise button to enabled state</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>@Slot()\ndef reset_and_handle_cancellation(self):\n    \"\"\"\n    Resets the finalise button to enabled state\n    \"\"\"\n    self.btn_finalise.setEnabled(True)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Gridify_Finetune","title":"<code>Gridify_Finetune</code>","text":"<p>               Bases: <code>Ui_gridify_setup_finetuning</code>, <code>QMainWindow</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>class Gridify_Finetune(Ui_gridify_setup_finetuning, qw.QMainWindow):\n    sig_gotocoor = Signal(tuple, threading.Event)\n    sig_list_modified_ROI = Signal(list)\n    sig_cancelled = Signal()\n\n    def __init__(self, gridify_main:Gridify, list_mapping_coor:list[MeaCoor_mm],\n                 list_loc:list[tuple[int, int]], ctrl_motion_video:Wdg_MotionController,\n                 *args, **kwargs):\n        \"\"\"\n        Initializes the fine-tune gridify window.\n\n        Args:\n            parent (tk.Tk): The parent window.\n            list_mapping_coor (list[MappingCoordinates_mm]): The list of mapping coordinates.\n            list_loc (list[tuple[int, int]]): The list of (row, column) locations.\n            ctrl_motion_video (Frm_MotionController): The motion controller for the video feed.\n        \"\"\"\n        super().__init__(gridify_main, *args, **kwargs)\n        self.setupUi(self)\n\n    # &gt;&gt;&gt; Store the parameters &lt;&lt;&lt;\n        self._gridify_main = gridify_main\n        self._list_mapping_coor = list_mapping_coor\n        self._list_loc = list_loc\n        self._ctrl_motion_video = ctrl_motion_video\n\n    # &gt;&gt; Connect signals &lt;&lt;&lt;\n        self.sig_gotocoor.connect(self._ctrl_motion_video.get_goto_worker().work)\n        self.sig_list_modified_ROI.connect(self._gridify_main.handle_gridify_completion)\n        self.sig_cancelled.connect(self._gridify_main.reset_and_handle_cancellation)\n\n    # &gt;&gt;&gt; Initialise the parameters &lt;&lt;&lt;\n        self._list_mod = [False] * len(self._list_mapping_coor)  # List to track modified coordinates\n\n    # &gt;&gt;&gt; Layout setup &lt;&lt;&lt;\n        self._init_finetune_widgets()\n\n    # &gt;&gt;&gt; Initialize the video feed parameters &lt;&lt;&lt;\n        self._flg_video_feed = threading.Event()\n\n        self._lbl_vid = ResizableQLabel(min_height=1)\n        self.lyt_video.addWidget(self._lbl_vid)\n\n    # &gt;&gt;&gt; Start a qtimer to update the video feed &lt;&lt;&lt;\n        self._timer = QTimer(self)\n        self._timer.timeout.connect(self._auto_video_updater)\n        self._timer.start(20)  # Update every 20 ms\n        self._flg_video_feed.set()  # Set the flag to start the video feed\n        self._last_imgqt = None\n        QTimer.singleShot(0, self._auto_video_updater)  # Initial call to start the video feed immediately\n\n    # &gt;&gt;&gt; Others &lt;&lt;&lt;\n        self._programmatic_close = False\n\n    @Slot()\n    def _auto_video_updater(self):\n        \"\"\"Automatically updates the video feed\"\"\"\n        if not self._flg_video_feed.is_set():\n            self._timer.stop()\n            return\n        try:\n            new_img = self._ctrl_motion_video.get_current_image()\n            if new_img is None: return\n            new_imgqt = ImageQt.toqpixmap(new_img)\n            if new_imgqt != self._last_imgqt:\n                self._lbl_vid.setPixmap(new_imgqt)\n                self._last_imgqt = new_imgqt\n        except Exception as e:\n            print(f\"Error updating video feed: {e}\")\n\n    def _init_finetune_widgets(self):\n        \"\"\"Initializes the fine-tune widgets for the gridified coordinates\"\"\"\n        # &gt;&gt;&gt; Create a treeview widget to display the gridified coordinates &lt;&lt;&lt;\n        self.tree_roi.setColumnCount(5)\n        self.tree_roi.setHeaderLabels(['Row', 'Col', 'Name', 'Center coor [\u03bcm]', 'Modified'])\n\n        # Bind double-click event to the treeview\n        self.tree_roi.doubleClicked.connect(self._on_treeview_double_click)\n\n        self._update_treeview()\n        item = self.tree_roi.topLevelItem(0)\n        if item is not None: self.tree_roi.setCurrentItem(item)\n\n    # &gt;&gt;&gt; Setup the parameters widget &lt;&lt;&lt;\n        self.combo_xy.addItems([e.value for e in Enums_RefXY])\n        self.combo_z.addItems([e.value for e in Enums_RefZ])\n\n        self.combo_xy.setCurrentText(Enums_RefXY.center_center.value)\n        self.combo_z.setCurrentText(Enums_RefZ.bottom.value)\n\n        self.btn_set_currcoor.clicked.connect(self._update_coordinate_withCurrentCoor)\n        self.btn_nextROI.clicked.connect(self._go_to_nextMappingCoor)\n        self.btn_finish.clicked.connect(self._finalise_editing)\n        self.btn_cancel.clicked.connect(self.close)\n\n    @Slot()\n    def _update_treeview(self) -&gt; None:\n        \"\"\"Updates the treeview with the gridified coordinates\"\"\"\n        # Store the current selection\n        sel = self._get_selected_mappingCoor(suppress_warning=True)\n        idx = sel[0] if sel else None\n\n        self.tree_roi.clear()\n        for i, mapping_coor in enumerate(self._list_mapping_coor):\n            center_coor = np.mean(mapping_coor.mapping_coordinates, axis=0)\n            center_coor_str = f\"({center_coor[0]*1e3:.1f}, {center_coor[1]*1e3:.1f}, {center_coor[2]*1e3:.1f})\"\n            row, col = self._list_loc[i]\n            name = mapping_coor.mappingUnit_name\n            modified = 'Yes' if self._list_mod[i] else 'No'\n            item = qw.QTreeWidgetItem([str(row+1), str(col+1), name, center_coor_str, modified])\n            self.tree_roi.addTopLevelItem(item)\n\n        # Restore the selection\n        if idx is not None and idx &lt; len(self._list_mapping_coor):\n            iid = self.tree_roi.topLevelItem(idx)\n            if iid is None: return\n            self.tree_roi.setCurrentItem(iid)\n            self.tree_roi.scrollToItem(iid)\n\n    def _calculate_target_coordinate(self, mapping_coor:MeaCoor_mm) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the target coordinate based on the selected reference coordinates and the mapping coordinates.\n\n        Args:\n            mapping_coor (MappingCoordinates_mm): The mapping coordinates from which to select the coordinate\n\n        Returns:\n            np.ndarray: The selected coordinate in the form of a numpy array [x, y, z]\n        \"\"\"\n        loc_xy = Enums_RefXY(self.combo_xy.currentText())\n        loc_z = Enums_RefZ(self.combo_z.currentText())\n\n        if loc_xy == Enums_RefXY.top_left:\n            x = np.min([coor[0] for coor in mapping_coor.mapping_coordinates])\n            y = np.max([coor[1] for coor in mapping_coor.mapping_coordinates])\n        elif loc_xy == Enums_RefXY.top_center:\n            x = np.mean([coor[0] for coor in mapping_coor.mapping_coordinates])\n            y = np.max([coor[1] for coor in mapping_coor.mapping_coordinates])\n        elif loc_xy == Enums_RefXY.top_right:\n            x = np.max([coor[0] for coor in mapping_coor.mapping_coordinates])\n            y = np.max([coor[1] for coor in mapping_coor.mapping_coordinates])\n        elif loc_xy == Enums_RefXY.center_left:\n            x = np.min([coor[0] for coor in mapping_coor.mapping_coordinates])\n            y = np.mean([coor[1] for coor in mapping_coor.mapping_coordinates])\n        elif loc_xy == Enums_RefXY.center_center:\n            x = np.mean([coor[0] for coor in mapping_coor.mapping_coordinates])\n            y = np.mean([coor[1] for coor in mapping_coor.mapping_coordinates])\n        elif loc_xy == Enums_RefXY.center_right:\n            x = np.max([coor[0] for coor in mapping_coor.mapping_coordinates])\n            y = np.mean([coor[1] for coor in mapping_coor.mapping_coordinates])\n        elif loc_xy == Enums_RefXY.bottom_left:\n            x = np.min([coor[0] for coor in mapping_coor.mapping_coordinates])\n            y = np.min([coor[1] for coor in mapping_coor.mapping_coordinates])\n        elif loc_xy == Enums_RefXY.bottom_center:\n            x = np.mean([coor[0] for coor in mapping_coor.mapping_coordinates])\n            y = np.min([coor[1] for coor in mapping_coor.mapping_coordinates])\n        elif loc_xy == Enums_RefXY.bottom_right:\n            x = np.max([coor[0] for coor in mapping_coor.mapping_coordinates])\n            y = np.min([coor[1] for coor in mapping_coor.mapping_coordinates])\n        else: raise ValueError(f\"Invalid loc_xy value: {loc_xy}\")\n\n        if loc_z == Enums_RefZ.top:\n            z = np.max([coor[2] for coor in mapping_coor.mapping_coordinates])\n        elif loc_z == Enums_RefZ.center:\n            z = np.mean([coor[2] for coor in mapping_coor.mapping_coordinates])\n        elif loc_z == Enums_RefZ.bottom:\n            z = np.min([coor[2] for coor in mapping_coor.mapping_coordinates])\n        else: raise ValueError(f\"Invalid loc_z value: {loc_z}\")\n\n        return np.array([x, y, z])\n\n    def _update_coordinate_withCurrentCoor(self) -&gt; None:\n        \"\"\"Updates the selected coordinate with the current position of the motion controller\"\"\"\n        result = self._get_selected_mappingCoor()\n        if not result: return\n\n        idx, mapping_coor = result\n\n        current_coor = np.array(self._ctrl_motion_video.get_coordinates_closest_mm())\n\n        new_center_coor = calculate_coordinatesCenter(\n            ref_coor=current_coor,\n            mappingCoor=mapping_coor,\n            loc_xy=Enums_RefXY(self.combo_xy.currentText()),\n            loc_z=Enums_RefZ(self.combo_z.currentText())\n        )\n\n        # Update the mapping coordinates by translating them to the new center coordinates\n        translated_coor = np.array(mapping_coor.mapping_coordinates) + (new_center_coor - np.mean(mapping_coor.mapping_coordinates, axis=0))\n        translated_coor_tup = [tuple(coor) for coor in translated_coor]\n        new_mapping_coor = MeaCoor_mm(\n            mappingUnit_name=mapping_coor.mappingUnit_name,\n            mapping_coordinates=translated_coor_tup\n        )\n\n        # Update the mapping coordinates in the list\n        self._list_mapping_coor[idx] = new_mapping_coor\n        self._list_mod[idx] = True  # Mark the coordinate as modified\n        self._update_treeview()\n\n        return\n\n    def _go_to_nextMappingCoor(self) -&gt; None:\n        \"\"\"Updates the next coordinate with the current position of the motion controller\n        and moves the motion controller to the next coordinate\"\"\"\n        # Select the next coordinate in the treeview\n        result = self._get_selected_mappingCoor()\n        if not result: return None\n        idx, _ = result\n        if idx == len(self._list_mapping_coor) - 1:\n            qw.QMessageBox.information(self, \"Info\", \"You have reached the last coordinate.\")\n            return\n\n        item = self.tree_roi.topLevelItem(idx + 1)\n        if item is not None: self.tree_roi.setCurrentItem(item)\n\n        # Move to the next coordinate\n        self._go_to_selectedMappingCoor()\n\n    def _get_selected_mappingCoor(self, suppress_warning: bool = False) -&gt; tuple[int,MeaCoor_mm]|None:\n        \"\"\"Returns the currently selected mapping coordinates from the treeview\n\n        Args:\n            suppress_warning (bool): If True, suppresses the warning message if no item is selected.\n\n        Returns:\n            tuple: A tuple containing the index of the selected mapping coordinates and the mapping coordinates object\n        \"\"\"\n        selected_item = self.tree_roi.currentItem()\n        if not selected_item and not suppress_warning:\n            qw.QMessageBox.warning(self, \"Warning\", \"Please select a mapping coordinate to modify.\")\n            return None\n\n        idx = self.tree_roi.indexOfTopLevelItem(selected_item)\n        return idx, self._list_mapping_coor[idx]\n\n    @Slot()\n    def _go_to_selectedMappingCoor(self) -&gt; None:\n        \"\"\"\n        Moves the motion controller to the selected mapping coordinates\n        \"\"\"\n        result = self._get_selected_mappingCoor()\n        if not result: return\n\n        _, mapping_coor = result\n        target_coor = self._calculate_target_coordinate(mapping_coor)\n        target_coor = target_coor.astype(float)\n        target_coor = (target_coor[0], target_coor[1], target_coor[2])\n\n        try:\n            self.sig_gotocoor.emit(target_coor, threading.Event())\n        except Exception as e:\n            qw.QMessageBox.critical(self, \"Error\", f\"Failed to move to coordinates: {e}\")\n            return\n\n    @Slot()\n    def _on_treeview_double_click(self, index: QModelIndex) -&gt; None:\n        self._go_to_selectedMappingCoor()\n\n    @Slot()\n    def _finalise_editing(self):\n        \"\"\"Finalises the editing of the gridified coordinates and returns the modified coordinates\"\"\"\n        self.btn_cancel.setEnabled(False)\n        self.btn_finish.setEnabled(False)\n\n        confirmation = qw.QMessageBox.question(self, \"Confirm\", \"Are you sure you want to finish editing?\\n\"\n            \"This will save all changes made to the mapping coordinates.\",\n            qw.QMessageBox.Yes | qw.QMessageBox.No, # pyright: ignore[reportAttributeAccessIssue]\n            qw.QMessageBox.No # pyright: ignore[reportAttributeAccessIssue]\n        )\n        if confirmation != qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue]\n            self.btn_cancel.setEnabled(True)\n            self.btn_finish.setEnabled(True)\n            return\n\n        # Return the modified mapping coordinates\n        self.sig_list_modified_ROI.emit(self._list_mapping_coor)\n        self._flg_video_feed.clear()\n\n        self._programmatic_close = True\n        self.close()\n\n    def closeEvent(self, event: QCloseEvent) -&gt; None:\n        \"\"\"\n        Terminates the video feed and closes the window\n        \"\"\"\n        if self._programmatic_close:\n            event.accept()\n            return super().closeEvent(event)\n\n        self.btn_cancel.setEnabled(False)\n        self.btn_finish.setEnabled(False)\n\n        confirmation = qw.QMessageBox.question(self, \"Confirm\", \"Are you sure you want to cancel all modifications?\\n\"\n            \"This will discard all changes made to the mapping coordinates.\\n\"\n            \"There is no way to undo this action.\",\n            qw.QMessageBox.Yes | qw.QMessageBox.No, # pyright: ignore[reportAttributeAccessIssue]\n            qw.QMessageBox.No # pyright: ignore[reportAttributeAccessIssue]\n        )\n        if confirmation != qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue]\n            self.btn_cancel.setEnabled(True)\n            self.btn_finish.setEnabled(True)\n            return\n\n        self._flg_video_feed.clear()\n        self.sig_cancelled.emit()\n\n        return super().closeEvent(event)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Gridify_Finetune.__init__","title":"<code>__init__(gridify_main, list_mapping_coor, list_loc, ctrl_motion_video, *args, **kwargs)</code>","text":"<p>Initializes the fine-tune gridify window.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Tk</code> <p>The parent window.</p> required <code>list_mapping_coor</code> <code>list[MappingCoordinates_mm]</code> <p>The list of mapping coordinates.</p> required <code>list_loc</code> <code>list[tuple[int, int]]</code> <p>The list of (row, column) locations.</p> required <code>ctrl_motion_video</code> <code>Frm_MotionController</code> <p>The motion controller for the video feed.</p> required Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>def __init__(self, gridify_main:Gridify, list_mapping_coor:list[MeaCoor_mm],\n             list_loc:list[tuple[int, int]], ctrl_motion_video:Wdg_MotionController,\n             *args, **kwargs):\n    \"\"\"\n    Initializes the fine-tune gridify window.\n\n    Args:\n        parent (tk.Tk): The parent window.\n        list_mapping_coor (list[MappingCoordinates_mm]): The list of mapping coordinates.\n        list_loc (list[tuple[int, int]]): The list of (row, column) locations.\n        ctrl_motion_video (Frm_MotionController): The motion controller for the video feed.\n    \"\"\"\n    super().__init__(gridify_main, *args, **kwargs)\n    self.setupUi(self)\n\n# &gt;&gt;&gt; Store the parameters &lt;&lt;&lt;\n    self._gridify_main = gridify_main\n    self._list_mapping_coor = list_mapping_coor\n    self._list_loc = list_loc\n    self._ctrl_motion_video = ctrl_motion_video\n\n# &gt;&gt; Connect signals &lt;&lt;&lt;\n    self.sig_gotocoor.connect(self._ctrl_motion_video.get_goto_worker().work)\n    self.sig_list_modified_ROI.connect(self._gridify_main.handle_gridify_completion)\n    self.sig_cancelled.connect(self._gridify_main.reset_and_handle_cancellation)\n\n# &gt;&gt;&gt; Initialise the parameters &lt;&lt;&lt;\n    self._list_mod = [False] * len(self._list_mapping_coor)  # List to track modified coordinates\n\n# &gt;&gt;&gt; Layout setup &lt;&lt;&lt;\n    self._init_finetune_widgets()\n\n# &gt;&gt;&gt; Initialize the video feed parameters &lt;&lt;&lt;\n    self._flg_video_feed = threading.Event()\n\n    self._lbl_vid = ResizableQLabel(min_height=1)\n    self.lyt_video.addWidget(self._lbl_vid)\n\n# &gt;&gt;&gt; Start a qtimer to update the video feed &lt;&lt;&lt;\n    self._timer = QTimer(self)\n    self._timer.timeout.connect(self._auto_video_updater)\n    self._timer.start(20)  # Update every 20 ms\n    self._flg_video_feed.set()  # Set the flag to start the video feed\n    self._last_imgqt = None\n    QTimer.singleShot(0, self._auto_video_updater)  # Initial call to start the video feed immediately\n\n# &gt;&gt;&gt; Others &lt;&lt;&lt;\n    self._programmatic_close = False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Gridify_Finetune.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Terminates the video feed and closes the window</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>def closeEvent(self, event: QCloseEvent) -&gt; None:\n    \"\"\"\n    Terminates the video feed and closes the window\n    \"\"\"\n    if self._programmatic_close:\n        event.accept()\n        return super().closeEvent(event)\n\n    self.btn_cancel.setEnabled(False)\n    self.btn_finish.setEnabled(False)\n\n    confirmation = qw.QMessageBox.question(self, \"Confirm\", \"Are you sure you want to cancel all modifications?\\n\"\n        \"This will discard all changes made to the mapping coordinates.\\n\"\n        \"There is no way to undo this action.\",\n        qw.QMessageBox.Yes | qw.QMessageBox.No, # pyright: ignore[reportAttributeAccessIssue]\n        qw.QMessageBox.No # pyright: ignore[reportAttributeAccessIssue]\n    )\n    if confirmation != qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue]\n        self.btn_cancel.setEnabled(True)\n        self.btn_finish.setEnabled(True)\n        return\n\n    self._flg_video_feed.clear()\n    self.sig_cancelled.emit()\n\n    return super().closeEvent(event)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.Gridify_NamingSetup","title":"<code>Gridify_NamingSetup</code>","text":"<p>               Bases: <code>Ui_gridify_setup_naming</code>, <code>QMainWindow</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>class Gridify_NamingSetup(Ui_gridify_setup_naming, qw.QMainWindow):\n    sig_cancelled = Signal()\n\n    def __init__(self, gridify_main:Gridify, corner_coords: list[np.ndarray],\n                 num_rows: int, num_cols: int, mapping_coor: MeaCoor_mm,\n                 ctrl_motion_video: Wdg_MotionController, *args, **kwargs):\n        super().__init__(gridify_main, *args, **kwargs)\n        self.setupUi(self)\n\n    # &gt;&gt;&gt; Store the parameters &lt;&lt;&lt;\n        self._gridify_main = gridify_main\n        self._corner_coords = corner_coords\n        self._num_rows = num_rows\n        self._num_cols = num_cols\n        self._mapping_coor = mapping_coor\n        self._ctrl_motion_video = ctrl_motion_video\n\n    # &gt;&gt;&gt; Create the gridify interface &lt;&lt;&lt;\n        # Parameters setup\n        self._list_rowNames:list[qw.QLineEdit] = []\n        self._list_colNames:list[qw.QLineEdit] = []\n        self._init_rowColSetup_widgets()\n        self._init_namingScheme_widgets()\n\n    # &gt;&gt;&gt; Finalise button &lt;&lt;&lt;\n        self.btn_finalise.clicked.connect(self._run_gridFinetune)\n        self.btn_cancel.clicked.connect(self.close)\n\n    # &gt;&gt; Signals &lt;&lt;&lt;\n        self._programmatic_close = False\n        self.sig_cancelled.connect(self._gridify_main.reset_and_handle_cancellation)\n\n    def closeEvent(self, event: QCloseEvent) -&gt; None:\n        if self._programmatic_close:\n            event.accept()\n            return\n\n        cancel = qw.QMessageBox.question(\n            self,\n            \"Confirm Close\",\n            \"Are you sure you want to close the gridify naming setup? This will cancel the operation.\",\n            qw.QMessageBox.Yes | qw.QMessageBox.No, # pyright: ignore[reportAttributeAccessIssue]\n            qw.QMessageBox.No # pyright: ignore[reportAttributeAccessIssue]\n        )\n        if cancel == qw.QMessageBox.Yes: # pyright: ignore[reportAttributeAccessIssue]\n            self.sig_cancelled.emit()\n            event.accept()\n        else:\n            event.ignore()\n\n    def _init_rowColSetup_widgets(self):\n        \"\"\"Initializes the row and column setup widgets\"\"\"\n        for i in range(self._num_rows):\n            lbl_row = qw.QLabel(f'Row {i+1}:')\n            entry_row = qw.QLineEdit(f'Row {i+1}')\n            self.lyt_row.addRow(lbl_row, entry_row)\n            self._list_rowNames.append(entry_row)\n\n        for j in range(self._num_cols):\n            lbl_col = qw.QLabel(f'Col {j+1}:')\n            entry_col = qw.QLineEdit(f'Col {j+1}')\n            self.lyt_col.addRow(lbl_col, entry_col)\n            self._list_colNames.append(entry_col)\n\n    def _init_namingScheme_widgets(self):\n        \"\"\"Initializes the naming scheme setup widgets\"\"\"\n        # Create radio buttons for naming scheme selection\n        self.btn_example.clicked.connect(self._show_example_names)\n\n    def _show_example_names(self):\n        qw.QMessageBox.information(self, \"Example\", f\"Example naming: {self._generate_names()[0][:5] if self._generate_names() else 'No names could be generated'}\")\n\n    def _generate_names(self) -&gt; tuple[list[str], list[tuple[int, int]]]:\n        \"\"\"\n        Generates the names for the gridified coordinates based on the row and column names.\n\n        Returns:\n            tuple: A tuple containing two lists:\n            list: of names generated based on the naming scheme and row/column names in \n                the order of rows first then columns (u then v, e.g., (row1,col1),(row2,col1),...,(row1,col2),...)\n                the order of columns first then rows (u then v, e.g., (col1,row1),(col1,row2),...,(col2,row1),...)\n            list: of tuples containing the (row, column) indices for each name.\n                \"\"\"\n        separator = self.ent_separator.text()\n\n        list_name = []\n        list_loc = []\n        # Generate the rows in the reverse order\n        for j in range(self._num_cols):\n            for i in reversed(range(self._num_rows)):\n                if self.rad_rowcol.isChecked():\n                    name = f\"{self._list_rowNames[i].text()}{separator}{self._list_colNames[j].text()}\"\n                else:\n                    name = f\"{self._list_colNames[j].text()}{separator}{self._list_rowNames[i].text()}\"\n\n                list_name.append(name)\n                list_loc.append((i, j))\n        return list_name, list_loc\n\n    def _generate_coordinates(self):\n        \"\"\"Generates the coordinates for the gridified mapping coordinates\"\"\"\n        corner_coords = np.array(self._corner_coords)\n        num_rows = self._num_rows\n        num_cols = self._num_cols\n\n        # Generate the gridified coordinates\n        result = generate_warped_grid(\n            p00=corner_coords[2],\n            p01=corner_coords[3],\n            p10=corner_coords[0],\n            p11=corner_coords[1],\n            num_u_lines=num_rows,\n            num_v_lines=num_cols,\n        )\n\n        # flatten the result and convert to lists\n        list_x = result[0].flatten().tolist()\n        list_y = result[1].flatten().tolist()\n        list_z = result[2].flatten().tolist()\n\n        list_coor = [(x,y,z) for x,y,z in zip(list_x, list_y, list_z)]\n        return list_coor\n\n    def _translate_mappingCoor(self, mappingCoor:MeaCoor_mm, new_center_coor:np.ndarray) -&gt; MeaCoor_mm:\n        \"\"\"Translates the mapping coordinates to the new center coordinates\n\n        Args:\n            mappingCoor (MappingCoordinates_mm): The mapping coordinates to translate\n            new_center_coor (np.ndarray): The new center coordinates in the form of a numpy array\n\n        Returns:\n            MappingCoordinates_mm: The translated mapping coordinates\n        \"\"\"\n        assert isinstance(mappingCoor, MeaCoor_mm), \"mappingCoor must be an instance of MappingCoordinates_mm\"\n        assert isinstance(new_center_coor, np.ndarray), \"new_center_coor must be a numpy array\"\n        assert new_center_coor.shape == (3,), \"new_center_coor must be a 3-element numpy array\"\n        assert mappingCoor.mapping_coordinates, \"mappingCoor must contain coordinates to translate\"\n\n        current_center = np.mean(mappingCoor.mapping_coordinates, axis=0)\n        translation_vector = new_center_coor - current_center\n        translated_coordinates = mappingCoor.mapping_coordinates + translation_vector\n\n        mappingCoor.mapping_coordinates = translated_coordinates\n\n        return mappingCoor\n\n    @Slot()\n    def _run_gridFinetune(self):\n        \"\"\"\n        Performs the gridify operation by generating the mapping coordinates based on the specified parameters.\n        \"\"\"\n        self.btn_finalise.setEnabled(False)\n        self.btn_cancel.setEnabled(False)\n\n        list_names, list_loc = self._generate_names()\n        coordinates = self._generate_coordinates()\n\n        list_mapping_coor = []\n        for i, name in enumerate(list_names):\n            mapping_coor = self._mapping_coor.copy()\n            mapping_coor.mappingUnit_name = name\n            mapping_coor = self._translate_mappingCoor(\n                mappingCoor=mapping_coor,\n                new_center_coor=np.array(coordinates[i]))\n\n            list_mapping_coor.append(mapping_coor)\n\n        # Make sure that all the names are unique\n        unique_names = set(list_names)\n        if len(unique_names) &lt; len(list_names):\n            qw.QMessageBox.warning(self, \"Warning\", \"Duplicate names found in the generated mapping coordinates. Please ensure unique names.\")\n            self.btn_finalise.setEnabled(True)\n            self.btn_cancel.setEnabled(True)\n            return\n\n        self._gridify_main.initialise_Gridify_Finetune(\n            list_mapping_coor=list_mapping_coor,\n            list_loc=list_loc,\n        )\n\n        self._programmatic_close = True\n        self.close()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.calculate_coordinatesCenter","title":"<code>calculate_coordinatesCenter(ref_coor, mappingCoor, loc_xy, loc_z)</code>","text":"<p>Calculates the center coordinates based on the corner coordinates and specified locations</p> <p>Parameters:</p> Name Type Description Default <code>ref_coor</code> <code>ndarray</code> <p>The reference coordinates in the form of a numpy array</p> required <code>mappingCoor</code> <code>MappingCoordinates_mm</code> <p>The mapping coordinates object</p> required <code>loc_xy</code> <code>Enums_RefXY</code> <p>The location in the XY plane</p> required <code>loc_z</code> <code>Enums_RefZ</code> <p>The location in the Z direction</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list containing the calculated center coordinates in the form [x, y, z]</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/gridify.py</code> <pre><code>def calculate_coordinatesCenter(ref_coor:np.ndarray, mappingCoor:MeaCoor_mm,\n                                    loc_xy: Enums_RefXY, loc_z: Enums_RefZ) -&gt; list:\n    \"\"\"\n    Calculates the center coordinates based on the corner coordinates and specified locations\n\n    Args:\n        ref_coor (np.ndarray): The reference coordinates in the form of a numpy array\n        mappingCoor (MappingCoordinates_mm): The mapping coordinates object\n        loc_xy (Enums_RefXY): The location in the XY plane\n        loc_z (Enums_RefZ): The location in the Z direction\n\n    Returns:\n        list: A list containing the calculated center coordinates in the form [x, y, z]\n    \"\"\"\n    list_coors = mappingCoor.mapping_coordinates\n\n    list_x = [coor[0] for coor in list_coors]\n    list_y = [coor[1] for coor in list_coors]\n    list_z = [coor[2] for coor in list_coors]\n\n    wid_x = abs(max(list_x) - min(list_x))\n    wid_y = abs(max(list_y) - min(list_y))\n    wid_z = abs(max(list_z) - min(list_z))\n\n    x_ref = ref_coor[0]\n    y_ref = ref_coor[1]\n    z_ref = ref_coor[2]\n\n    if loc_xy == Enums_RefXY.top_left:\n        x_final = x_ref + wid_x / 2\n        y_final = y_ref - wid_y / 2\n    elif loc_xy == Enums_RefXY.top_center:\n        x_final = x_ref\n        y_final = y_ref - wid_y / 2\n    elif loc_xy == Enums_RefXY.top_right:\n        x_final = x_ref - wid_x / 2\n        y_final = y_ref - wid_y / 2\n    elif loc_xy == Enums_RefXY.center_left:\n        x_final = x_ref + wid_x / 2\n        y_final = y_ref\n    elif loc_xy == Enums_RefXY.center_center:\n        x_final = x_ref\n        y_final = y_ref\n    elif loc_xy == Enums_RefXY.center_right:\n        x_final = x_ref - wid_x / 2\n        y_final = y_ref\n    elif loc_xy == Enums_RefXY.bottom_left:\n        x_final = x_ref + wid_x / 2\n        y_final = y_ref + wid_y / 2\n    elif loc_xy == Enums_RefXY.bottom_center:\n        x_final = x_ref\n        y_final = y_ref + wid_y / 2\n    elif loc_xy == Enums_RefXY.bottom_right:\n        x_final = x_ref - wid_x / 2\n        y_final = y_ref + wid_y / 2\n\n    if loc_z == Enums_RefZ.top:\n        z_final = z_ref - wid_z / 2\n    elif loc_z == Enums_RefZ.center:\n        z_final = z_ref\n    elif loc_z == Enums_RefZ.bottom:\n        z_final = z_ref + wid_z / 2\n\n    return [x_final, y_final, z_final]\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/gridify/#iris.gui.submodules.meaCoor_modifier.gridify.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/","title":"topology_visualiser","text":"<p>A GUI to visualize the topology of a mapping coordinates</p>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.TopologyVisualiser","title":"<code>TopologyVisualiser</code>","text":"<p>               Bases: <code>Ui_topology_visualiser</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/topology_visualiser.py</code> <pre><code>class TopologyVisualiser(Ui_topology_visualiser, qw.QWidget):\n    msg_instructions = (\n        \"This module allows you to visualise the topology of mapping coordinates stored in the MeaCoor Hub.\\n\"\n        \"To use this module:\\n\"\n        \"1. Select the mapping coordinates unit from the dropdown menu.\\n\"\n        \"2. Adjust the plot parameters as desired (e.g., show/hide edges).\\n\"\n        \"3. The topology will be displayed in the plot area.\\n\\n\"\n        \"Note: The colour of the plot represents the Z-coordinate values of the mapping coordinates.\"\n    )\n\n    sig_updateListUnits = Signal()\n    sig_req_plotTopo = Signal(MeaCoor_mm, bool) # Signal to request topology plotting\n\n    def __init__(\n        self,\n        parent,\n        mappingCoorHub: List_MeaCoor_Hub,\n        *args, **kwargs) -&gt; None:\n        \"\"\"Initializes the mapping method\n\n        Args:\n            parent (tk.Frame): The parent frame to place this widget in\n            MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n            getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n        \"\"\"\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        self._coorHub = mappingCoorHub\n\n    # &gt;&gt;&gt; Information widget &lt;&lt;&lt;\n        self.btn_instructions.clicked.connect(lambda: qw.QMessageBox.information(\n            self,\n            \"Instructions\",\n            self.msg_instructions\n        ))\n\n    # &gt;&gt;&gt; Plotting parameters and widget &lt;&lt;&lt;\n        self._figsize_pxl = AppPlotEnum.PLT_MAP_SIZE_PIXEL.value\n        self._dpi = plt.rcParams['figure.dpi']\n        self._figsize_in = (self._figsize_pxl[1]/self._dpi,self._figsize_pxl[0]/self._dpi)\n        self._fig, self._ax = plt.subplots(figsize=self._figsize_in)\n\n        self._plt_canvas = FigureCanvas(figure=self._fig)\n        self.lyt_plot.addWidget(self._plt_canvas)\n        self._plt_canvas.draw()\n\n        # Typehinting\n        self._fig: Figure\n        self._ax: Axes\n        self._cbar: Colorbar|None = None\n\n    # &gt;&gt;&gt; Selection widget &lt;&lt;&lt;\n        self.combo_meaCoor.activated.connect(self._show_topology)\n        self.chk_edges.clicked.connect(self._show_topology)\n\n    # &gt;&gt;&gt; Parameters for the mapping coordinates modification &lt;&lt;&lt;\n        self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n    # &gt;&gt;&gt; Others &lt;&lt;&lt;\n        self.sig_updateListUnits.connect(self._update_list_units)\n        self._coorHub.add_observer(self.sig_updateListUnits.emit)\n        self.sig_updateListUnits.emit()\n\n        self._init_worker()\n\n    def _init_worker(self):\n        \"\"\"\n        Initialises the worker thread for plotting the topology\n        \"\"\"\n        self._thread_plotter = QThread()\n\n        self._worker_plotter = MeaCoorTopologyPlotter_Worker(\n            fig=self._fig,\n            ax=self._ax,\n            cbar=self._cbar,\n        )\n        self._worker_plotter.moveToThread(self._thread_plotter)\n\n        self.sig_updateListUnits.connect(self._update_list_units)\n        self.sig_updateListUnits.emit()\n\n        self.sig_req_plotTopo.connect(self._worker_plotter.plot)\n        self._worker_plotter.sig_draw.connect(self._plt_canvas.draw)\n\n        self.destroyed.connect(self._worker_plotter.deleteLater)\n        self.destroyed.connect(self._thread_plotter.quit)\n\n        self._thread_plotter.start()\n\n    @Slot()\n    def _update_list_units(self):\n        \"\"\"Updates the list of mapping units in the combobox\"\"\"\n        self._dict_mapUnit.clear()  # Clear the existing dictionary\n        self._dict_mapUnit = {unit.mappingUnit_name: unit for unit in self._coorHub}\n\n        self.combo_meaCoor.clear()\n        self.combo_meaCoor.addItems(list(self._dict_mapUnit.keys()))\n\n    @Slot()\n    def _show_topology(self):\n        \"\"\"Shows the topology of the selected mapping coordinates\"\"\"\n        selected_unit_name = self.combo_meaCoor.currentText()\n\n        if not selected_unit_name or selected_unit_name not in self._dict_mapUnit:\n            qw.QMessageBox.warning(self, \"Warning\", \"No mapping unit selected or unit not found.\")\n            return\n\n        selected_unit = self._dict_mapUnit.get(selected_unit_name)\n        if not selected_unit:\n            qw.QMessageBox.warning(self, \"Warning\", f\"Mapping unit '{selected_unit_name}' not found.\")\n            return\n\n        if len(selected_unit.mapping_coordinates) &lt; 2:\n            qw.QMessageBox.warning(self, \"Warning\", \"Not enough coordinates to plot topology. Please select a unit with at least 2 coordinates.\")\n            return\n\n        show_edges = self.chk_edges.isChecked()\n        self.sig_req_plotTopo.emit(selected_unit, show_edges)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.TopologyVisualiser.__init__","title":"<code>__init__(parent, mappingCoorHub, *args, **kwargs)</code>","text":"<p>Initializes the mapping method</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Frame</code> <p>The parent frame to place this widget in</p> required <code>MappingCoorHub</code> <code>MappingCoordinatesHub</code> <p>The hub to store the resulting mapping coordinates in</p> required <code>getter_MappingCoor</code> <code>Callable[[], MappingCoordinates_mm]</code> <p>A function to get the mapping coordinates to modify</p> required Source code in <code>iris/gui/submodules/meaCoor_modifier/topology_visualiser.py</code> <pre><code>def __init__(\n    self,\n    parent,\n    mappingCoorHub: List_MeaCoor_Hub,\n    *args, **kwargs) -&gt; None:\n    \"\"\"Initializes the mapping method\n\n    Args:\n        parent (tk.Frame): The parent frame to place this widget in\n        MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n        getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n    \"\"\"\n    super().__init__(parent)\n    self.setupUi(self)\n    self.setLayout(self.main_layout)\n\n    self._coorHub = mappingCoorHub\n\n# &gt;&gt;&gt; Information widget &lt;&lt;&lt;\n    self.btn_instructions.clicked.connect(lambda: qw.QMessageBox.information(\n        self,\n        \"Instructions\",\n        self.msg_instructions\n    ))\n\n# &gt;&gt;&gt; Plotting parameters and widget &lt;&lt;&lt;\n    self._figsize_pxl = AppPlotEnum.PLT_MAP_SIZE_PIXEL.value\n    self._dpi = plt.rcParams['figure.dpi']\n    self._figsize_in = (self._figsize_pxl[1]/self._dpi,self._figsize_pxl[0]/self._dpi)\n    self._fig, self._ax = plt.subplots(figsize=self._figsize_in)\n\n    self._plt_canvas = FigureCanvas(figure=self._fig)\n    self.lyt_plot.addWidget(self._plt_canvas)\n    self._plt_canvas.draw()\n\n    # Typehinting\n    self._fig: Figure\n    self._ax: Axes\n    self._cbar: Colorbar|None = None\n\n# &gt;&gt;&gt; Selection widget &lt;&lt;&lt;\n    self.combo_meaCoor.activated.connect(self._show_topology)\n    self.chk_edges.clicked.connect(self._show_topology)\n\n# &gt;&gt;&gt; Parameters for the mapping coordinates modification &lt;&lt;&lt;\n    self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n# &gt;&gt;&gt; Others &lt;&lt;&lt;\n    self.sig_updateListUnits.connect(self._update_list_units)\n    self._coorHub.add_observer(self.sig_updateListUnits.emit)\n    self.sig_updateListUnits.emit()\n\n    self._init_worker()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/topology_visualiser/#iris.gui.submodules.meaCoor_modifier.topology_visualiser.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/","title":"translateXYZ","text":"<p>A GUI module to modify a mapping coordinates list by translating  the coordinates in the X, Y and Z direction.</p>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.TranslateXYZ","title":"<code>TranslateXYZ</code>","text":"<p>               Bases: <code>Ui_translator_xyz</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/translateXYZ.py</code> <pre><code>class TranslateXYZ(Ui_translator_xyz, qw.QWidget):\n    msg_instructions = (\n        \"The Translate XYZ module allows you to translate the coordinates of a selected mapping unit, \"\n        \"essentially moving it to another location while maintaining its points distribution.\\n\\n\"\n        \"To use the module:\\n\"\n        \"1. Select the mapping unit you wish to modify from the dropdown menu.\\n\"\n        \"2. Choose the reference location for the translation using the radio buttons. \"\n        \"e.g., top left (XY) means that the coordinates' top-left most coordinate will be moved to the newly specified coordinate.\\n\"\n        \"3. The current reference coordinate will be displayed next to 'Reference coordinate [\u03bcm]'.\\n\"\n        \"4. Enter the new desired coordinate for the reference location in the 'New coordinate [\u03bcm]' fields.\\n\"\n        \"5. You can click 'Insert current coordinate (X,Y,Z)' to automatically fill in the current position of the motion controller.\\n\"\n        \"6. Click 'Commit modification' to apply the translation to the selected mapping unit.\\n\\n\"\n        \"Options:\\n\"\n        \"- 'Auto-select last modified mapping unit': Automatically selects the newly created mapping unit after modification.\\n\"\n        \"- 'Auto-move the stage using the last coordinate shift': Moves the motion controller to the new reference coordinate after modification.\\n\"\n    )\n\n    sig_updateListUnits = Signal()\n    sig_update_prevCoor = Signal(MeaCoor_mm, RadioOptionXY, RadioOptionZ)\n    sig_performTranslation = Signal(MeaCoor_mm, RadioOptionXY, RadioOptionZ, tuple, bool)\n    sig_goto_nextMeaCoor_ref = Signal(MeaCoor_mm, MeaCoor_mm, RadioOptionXY, RadioOptionZ)\n\n    def __init__(\n        self,\n        parent,\n        mappingCoorHub: List_MeaCoor_Hub,\n        motion_controller:Wdg_MotionController,\n        *args, **kwargs) -&gt; None:\n        \"\"\"Initializes the mapping method\n\n        Args:\n            parent (tk.Frame): The parent frame to place this widget in\n            MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n            getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n            motion_controller (Frm_MotionController): The motion controller to use for the mapping\n        \"\"\"\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        self._coorHub = mappingCoorHub\n        self._motion_controller = motion_controller\n\n    # &gt;&gt;&gt; Information widget &lt;&lt;&lt;\n        self.btn_instructions.clicked.connect(lambda: qw.QMessageBox.information(\n            self,\n            \"Instructions\",\n            self.msg_instructions\n        ))\n\n    # &gt;&gt;&gt; Parameters for the mapping coordinates modification &lt;&lt;&lt;\n        self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n        self._init_worker_and_signals()\n\n    def _init_worker_and_signals(self):\n        \"\"\"\n        Initialises the worker thread for communication with the motion controller\n        \"\"\"\n        # Create the worker thread\n        self._thread_worker = QThread()\n\n        self._worker_translator = TranslatorXYZ_Worker(\n            motion_controller=self._motion_controller)\n        self._worker_translator.moveToThread(self._thread_worker)\n\n        # Signal: Store current stage coordinate\n        self.btn_storeCoor.clicked.connect(self._worker_translator.get_current_coordinate)\n        self._worker_translator.sig_currentCoor_mm.connect(self._update_current_coordinate)\n\n        # Signal: Update reference coordinate\n        self.sig_update_prevCoor.connect(self._worker_translator.get_reference_coordinate)\n        self._worker_translator.sig_updatePrevCoor_mm.connect(lambda text: self.lbl_prevCoor.setText(text))\n\n        # Signal: Perform translation\n        self.sig_performTranslation.connect(self._worker_translator._perform_translation)\n\n        # Signal: Handle saving modified coordinates\n        self._worker_translator.sig_saveModifiedCoor.connect(self._handle_save_modified_coor)\n\n        # Signal: Move to next mapping coordinate reference\n        self.sig_goto_nextMeaCoor_ref.connect(self._worker_translator._move_to_next_meaCoor_ref)\n\n        self.destroyed.connect(self._worker_translator.deleteLater)\n        self.destroyed.connect(self._thread_worker.quit)\n\n        self._thread_worker.start()\n\n        # &gt;&gt;&gt; Others &lt;&lt;&lt;\n        self.sig_updateListUnits.connect(self._update_list_units)\n        self._coorHub.add_observer(self.sig_updateListUnits.emit)\n        self.sig_updateListUnits.emit()\n\n        # Commit button\n        self.btn_commit.clicked.connect(self._perform_translation)\n\n    @Slot(tuple)\n    def _update_current_coordinate(self, coor:tuple):\n        \"\"\"\n        Updates the current coordinate displayed in the entry fields\n        \"\"\"\n        coorx_um = coor[0] * 1e3\n        coory_um = coor[1] * 1e3\n        coorz_um = coor[2] * 1e3\n\n        self.spin_coorXUm.setValue(coorx_um)\n        self.spin_coorYUm.setValue(coory_um)\n        self.spin_coorZUm.setValue(coorz_um)\n\n    def _get_reference_location(self) -&gt; tuple[RadioOptionXY, RadioOptionZ]:\n        \"\"\"Gets the selected reference location from the radio buttons\n\n        Returns:\n            tuple[RadioOptionXY, RadioOptionZ]: The selected reference locations for XY and Z\n        \"\"\"\n        # Get XY location\n        if self.btn_xy_topleft.isChecked():         xyLoc = RadioOptionXY.TOP_LEFT\n        elif self.btn_xy_topcentre.isChecked():     xyLoc = RadioOptionXY.TOP_CENTER\n        elif self.btn_xy_topright.isChecked():      xyLoc = RadioOptionXY.TOP_RIGHT\n        elif self.btn_xy_centreleft.isChecked():    xyLoc = RadioOptionXY.CENTER_LEFT\n        elif self.btn_xy_centrecentre.isChecked():  xyLoc = RadioOptionXY.CENTER_CENTER\n        elif self.btn_xy_centreright.isChecked():   xyLoc = RadioOptionXY.CENTER_RIGHT\n        elif self.btn_xy_bottomleft.isChecked():    xyLoc = RadioOptionXY.BOTTOM_LEFT\n        elif self.btn_xy_bottomcentre.isChecked():  xyLoc = RadioOptionXY.BOTTOM_CENTER\n        elif self.btn_xy_bottomright.isChecked():   xyLoc = RadioOptionXY.BOTTOM_RIGHT\n        else: raise ValueError(\"No reference location selected\")\n\n        # Get Z location\n        if self.btn_z_top.isChecked():      zLoc = RadioOptionZ.TOP\n        elif self.btn_z_centre.isChecked():    zLoc = RadioOptionZ.CENTER\n        elif self.btn_z_bottom.isChecked():    zLoc = RadioOptionZ.BOTTOM\n        else: raise ValueError(\"No reference Z-coordinate selected\")\n\n        return (xyLoc, zLoc)\n\n    @Slot()\n    def _update_list_units(self):\n        \"\"\"Updates the list of mapping units in the combobox\"\"\"\n        self._dict_mapUnit.clear()  # Clear the existing dictionary\n        self._dict_mapUnit = {unit.mappingUnit_name: unit for unit in self._coorHub}\n\n        self.combo_meaCoor.clear()\n        self.combo_meaCoor.addItems(list(self._dict_mapUnit.keys()))\n\n    @thread_assign\n    def _perform_translation(self):\n        \"\"\"\n        Runs the modification of the z-coordinates of the selected mapping coordinates\n        \"\"\"\n    # &gt; Retrieve the selected mapping unit from the combobox and check it &lt;\n        selected_unit_name = self.combo_meaCoor.currentText()\n        if not selected_unit_name:\n            qw.QMessageBox.warning(self, \"Warning\", \"Please select a mapping unit to modify.\")\n            return\n\n        if selected_unit_name not in self._dict_mapUnit:\n            qw.QMessageBox.warning(self, \"Warning\", f\"Mapping unit '{selected_unit_name}' not found.\")\n            return\n\n        # Get the current mapping coordinates\n        mapping_coordinates = self._dict_mapUnit[selected_unit_name]\n\n        if not isinstance(mapping_coordinates, MeaCoor_mm):\n            qw.QMessageBox.warning(self, \"Warning\", \"Invalid mapping coordinates type.\")\n            return\n\n        new_coor_mm = (self.spin_coorXUm.value()/1e3,\n                    self.spin_coorYUm.value()/1e3,\n                    self.spin_coorZUm.value()/1e3)\n\n        print('Check if the \"*\" delivery works')\n        self.sig_performTranslation.emit(\n            mapping_coordinates,\n            *self._get_reference_location(),\n            new_coor_mm,\n            self.chk_automove_xyonly.isChecked()\n        )\n\n    @Slot(MeaCoor_mm, MeaCoor_mm)\n    def _handle_save_modified_coor(self, prev_meaCoor:MeaCoor_mm, modified_meaCoor:MeaCoor_mm):\n        new_name = messagebox_request_input(\n            parent=self,\n            title=\"New Mapping Unit Name\",\n            message=\"Please enter a new name for the modified mapping coordinates:\",\n            default=f\"{modified_meaCoor.mappingUnit_name}\",\n            validator=self._coorHub.validator_new_name,\n            invalid_msg=\"Mapping unit name already exists. Please choose a different name.\",\n            loop_until_valid=True,\n        )\n\n        if new_name is None:\n            qw.QMessageBox.warning(self, \"Warning\", \"Modification cancelled. No new mapping unit name provided.\")\n            return\n\n        new_mappingCoor = MeaCoor_mm(\n            mappingUnit_name=new_name,\n            mapping_coordinates=modified_meaCoor.mapping_coordinates\n        )\n\n        try: self._coorHub.append(new_mappingCoor)\n        except Exception as e:\n            qw.QMessageBox.warning(self, \"Warning\", f\"Could not save modified mapping coordinates: {e}\")\n            return\n\n        if self.chk_autoSelect.isChecked():\n            self._update_list_units()\n            self.combo_meaCoor.setCurrentText(new_name)\n            self.sig_update_prevCoor.emit(new_mappingCoor, *self._get_reference_location())\n\n        if self.chk_autoSelect.isChecked() and self.chk_autoMove.isChecked():\n            self.sig_goto_nextMeaCoor_ref.emit(\n                prev_meaCoor,\n                new_mappingCoor,\n                *self._get_reference_location()\n            )\n\n        print(f'Newly saved coordinates: {new_mappingCoor.mapping_coordinates}')\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.TranslateXYZ.__init__","title":"<code>__init__(parent, mappingCoorHub, motion_controller, *args, **kwargs)</code>","text":"<p>Initializes the mapping method</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Frame</code> <p>The parent frame to place this widget in</p> required <code>MappingCoorHub</code> <code>MappingCoordinatesHub</code> <p>The hub to store the resulting mapping coordinates in</p> required <code>getter_MappingCoor</code> <code>Callable[[], MappingCoordinates_mm]</code> <p>A function to get the mapping coordinates to modify</p> required <code>motion_controller</code> <code>Frm_MotionController</code> <p>The motion controller to use for the mapping</p> required Source code in <code>iris/gui/submodules/meaCoor_modifier/translateXYZ.py</code> <pre><code>def __init__(\n    self,\n    parent,\n    mappingCoorHub: List_MeaCoor_Hub,\n    motion_controller:Wdg_MotionController,\n    *args, **kwargs) -&gt; None:\n    \"\"\"Initializes the mapping method\n\n    Args:\n        parent (tk.Frame): The parent frame to place this widget in\n        MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n        getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n        motion_controller (Frm_MotionController): The motion controller to use for the mapping\n    \"\"\"\n    super().__init__(parent)\n    self.setupUi(self)\n    self.setLayout(self.main_layout)\n\n    self._coorHub = mappingCoorHub\n    self._motion_controller = motion_controller\n\n# &gt;&gt;&gt; Information widget &lt;&lt;&lt;\n    self.btn_instructions.clicked.connect(lambda: qw.QMessageBox.information(\n        self,\n        \"Instructions\",\n        self.msg_instructions\n    ))\n\n# &gt;&gt;&gt; Parameters for the mapping coordinates modification &lt;&lt;&lt;\n    self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n    self._init_worker_and_signals()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.TranslatorXYZ_Worker","title":"<code>TranslatorXYZ_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/translateXYZ.py</code> <pre><code>class TranslatorXYZ_Worker(QObject):\n\n    sig_updatePrevCoor_mm = Signal(str)\n    sig_currentCoor_mm = Signal(tuple)\n\n    sig_finished = Signal(str)\n    sig_error = Signal(str)\n    sig_saveModifiedCoor = Signal(MeaCoor_mm, MeaCoor_mm)\n\n    msg_error = \"Error during translation: \"\n    msg_success = \"Translation completed successfully.\"\n\n    _sig_gotocoor = Signal(tuple,threading.Event)\n\n    def __init__(self, motion_controller:Wdg_MotionController):\n        super().__init__()\n        self._motion_controller = motion_controller\n\n        self._sig_gotocoor.connect(self._motion_controller.get_goto_worker().work)\n\n    def _get_reference_coordinate(self, mappingCoor:MeaCoor_mm, xyLoc:RadioOptionXY, zLoc:RadioOptionZ)\\\n        -&gt; tuple[float, float, float]:\n        \"\"\"\n        Updates the label showing the current reference coordinates\n        \"\"\"\n        assert isinstance(mappingCoor, MeaCoor_mm), \"Invalid mapping coordinates type\"\n\n        x_min = min(coor[0] for coor in mappingCoor.mapping_coordinates)\n        x_max = max(coor[0] for coor in mappingCoor.mapping_coordinates)\n        y_min = min(coor[1] for coor in mappingCoor.mapping_coordinates)\n        y_max = max(coor[1] for coor in mappingCoor.mapping_coordinates)\n        x_ctr = (x_min + x_max) / 2\n        y_ctr = (y_min + y_max) / 2\n\n        if xyLoc == RadioOptionXY.TOP_LEFT:         coor_xy = (x_min, y_max)\n        elif xyLoc == RadioOptionXY.TOP_CENTER:     coor_xy = (x_ctr, y_max)\n        elif xyLoc == RadioOptionXY.TOP_RIGHT:      coor_xy = (x_max, y_max)\n        elif xyLoc == RadioOptionXY.CENTER_LEFT:    coor_xy = (x_min, y_ctr)\n        elif xyLoc == RadioOptionXY.CENTER_CENTER:  coor_xy = (x_ctr, y_ctr)\n        elif xyLoc == RadioOptionXY.CENTER_RIGHT:   coor_xy = (x_max, y_ctr)\n        elif xyLoc == RadioOptionXY.BOTTOM_LEFT:    coor_xy = (x_min, y_min)\n        elif xyLoc == RadioOptionXY.BOTTOM_CENTER:  coor_xy = (x_ctr, y_min)\n        elif xyLoc == RadioOptionXY.BOTTOM_RIGHT:   coor_xy = (x_max, y_min)\n        else: raise ValueError(\"No reference location selected\")\n\n        z_min = min(coor[2] for coor in mappingCoor.mapping_coordinates)\n        z_max = max(coor[2] for coor in mappingCoor.mapping_coordinates)\n        z_ctr = (z_min + z_max) / 2\n\n        if zLoc == RadioOptionZ.TOP:    coor_z = z_max\n        elif zLoc == RadioOptionZ.CENTER:  coor_z = z_ctr\n        elif zLoc == RadioOptionZ.BOTTOM:  coor_z = z_min\n        else: raise ValueError(\"No reference Z-coordinate selected\")\n\n        return (coor_xy[0], coor_xy[1], coor_z)\n\n    @Slot(MeaCoor_mm, RadioOptionXY, RadioOptionZ)\n    def get_reference_coordinate(self, mappingCoor:MeaCoor_mm, xyLoc:RadioOptionXY, zLoc:RadioOptionZ):\n        \"\"\"\n        Emits the reference coordinate signal\n        \"\"\"\n        coor = self._get_reference_coordinate(mappingCoor, xyLoc, zLoc)\n        self.sig_updatePrevCoor_mm.emit(f'{coor[0]*1e3:.0f}, {coor[1]*1e3:.0f}, {coor[2]*1e3:.0f} (\u03bcm)')\n\n    @Slot()\n    def get_current_coordinate(self):\n        \"\"\"\n        Emits the current coordinate from the motion controller\n        \"\"\"\n        coor = self._motion_controller.get_coordinates_closest_mm()\n        if not all(isinstance(c, (int,float)) for c in coor):\n            self.sig_error.emit('Could not retrieve current coordinates from motion controller.')\n            return\n\n        self.sig_currentCoor_mm.emit(coor)\n\n\n    @Slot(MeaCoor_mm, RadioOptionXY, RadioOptionZ, tuple)\n    def _perform_translation(self,mappingCoor:MeaCoor_mm, loc_xy:RadioOptionXY, loc_z:RadioOptionZ,\n                             new_coor:tuple[float,float,float]):\n        \"\"\"\n        Runs the modification of the z-coordinates of the selected mapping coordinates\n\n        Args:\n            mappingCoor (MeaCoor_mm): The mapping coordinates to modify\n            loc_xy (RadioOptionXY): The reference location in XY\n            loc_z (RadioOptionZ): The reference location in Z\n            new_coor (tuple[float,float,float]): The new coordinate to move the reference location to\n        \"\"\"\n    # &gt; Modify the coordinates &lt;\n        try:\n            ref_coor = self._get_reference_coordinate(mappingCoor, loc_xy, loc_z)\n        except ValueError as e:\n            self.sig_finished.emit(f\"{self.msg_error} Invalid input: {e}\")\n            return\n\n        # Translate the coordinates\n        shiftx = new_coor[0] - ref_coor[0]\n        shifty = new_coor[1] - ref_coor[1]\n        shiftz = new_coor[2] - ref_coor[2]\n\n        list_new_coor = []\n        for x, y, z in mappingCoor.mapping_coordinates:\n            new_x = x + shiftx\n            new_y = y + shifty\n            new_z = z + shiftz\n            list_new_coor.append((new_x, new_y, new_z))\n\n        self.sig_saveModifiedCoor.emit(mappingCoor, MeaCoor_mm(\n            mappingUnit_name=mappingCoor.mappingUnit_name+'_translated',\n            mapping_coordinates=list_new_coor\n        ))\n\n    @Slot(MeaCoor_mm, MeaCoor_mm, RadioOptionXY, RadioOptionZ, bool)\n    def _move_to_next_meaCoor_ref(self, prev_meaCoor:MeaCoor_mm, current_meaCoor:MeaCoor_mm,\n                                  loc_xy:RadioOptionXY, loc_z:RadioOptionZ, xy_only:bool):\n        \"\"\"\n        Moves the stage to the new reference coordinate of the modified mapping coordinates\n        \"\"\"\n        prev_coor = self._get_reference_coordinate(prev_meaCoor, loc_xy, loc_z)\n        curr_coor = self._get_reference_coordinate(current_meaCoor, loc_xy, loc_z)\n\n        new_x = curr_coor[0] + (curr_coor[0] - prev_coor[0])\n        new_y = curr_coor[1] + (curr_coor[1] - prev_coor[1])\n\n        if xy_only: new_z = curr_coor[2]\n        else: new_z = curr_coor[2] + (curr_coor[2] - prev_coor[2])\n\n        evt_moveDone = threading.Event()\n        self._sig_gotocoor.emit((new_x, new_y, new_z), evt_moveDone)\n        evt_moveDone.wait()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.TranslatorXYZ_Worker.get_current_coordinate","title":"<code>get_current_coordinate()</code>","text":"<p>Emits the current coordinate from the motion controller</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/translateXYZ.py</code> <pre><code>@Slot()\ndef get_current_coordinate(self):\n    \"\"\"\n    Emits the current coordinate from the motion controller\n    \"\"\"\n    coor = self._motion_controller.get_coordinates_closest_mm()\n    if not all(isinstance(c, (int,float)) for c in coor):\n        self.sig_error.emit('Could not retrieve current coordinates from motion controller.')\n        return\n\n    self.sig_currentCoor_mm.emit(coor)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.TranslatorXYZ_Worker.get_reference_coordinate","title":"<code>get_reference_coordinate(mappingCoor, xyLoc, zLoc)</code>","text":"<p>Emits the reference coordinate signal</p> Source code in <code>iris/gui/submodules/meaCoor_modifier/translateXYZ.py</code> <pre><code>@Slot(MeaCoor_mm, RadioOptionXY, RadioOptionZ)\ndef get_reference_coordinate(self, mappingCoor:MeaCoor_mm, xyLoc:RadioOptionXY, zLoc:RadioOptionZ):\n    \"\"\"\n    Emits the reference coordinate signal\n    \"\"\"\n    coor = self._get_reference_coordinate(mappingCoor, xyLoc, zLoc)\n    self.sig_updatePrevCoor_mm.emit(f'{coor[0]*1e3:.0f}, {coor[1]*1e3:.0f}, {coor[2]*1e3:.0f} (\u03bcm)')\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/translateXYZ/#iris.gui.submodules.meaCoor_modifier.translateXYZ.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/","title":"zInterpolate","text":"<p>A GUI module to modify the z-coordinates of a mapping coordinates list.</p>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.Interpolator_Worker","title":"<code>Interpolator_Worker</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/zInterpolate.py</code> <pre><code>class Interpolator_Worker(QObject):\n    sig_finished = Signal(str)\n    sig_saveModification = Signal(MeaCoor_mm)\n\n    msg_error = 'Error during interpolation: \\n'\n    msg_success = 'Z-coordinate interpolation and modification completed successfully.'\n    msg_partial_success = 'Z-coordinate interpolation completed with some warnings: \\n'\n\n    def __init__(self):\n        super().__init__()\n\n    def _interpolate_z_values(self,list_coor:list,list_ref:list,method:Option_InterpolationMethod,\n                              skip_nan:bool=True) -&gt; list[tuple[float, float, float]]:\n        \"\"\"\n        Interpolates the z-values of the given coordinates based on the reference coordinates.\n\n        Args:\n            list_coor (list): List of coordinates to interpolate, each coordinate is a list of [X, Y].\n            list_ref (list): List of reference coordinates, each coordinate is a list of [X, Y, Z].\n            method (Option_InterpolationMethod): Interpolation method to use.\n            skip_nan (bool): If True, skips NaN values in the interpolation result.\n\n        Returns:\n            list: List of interpolated coordinates with z-values, each coordinate is a list of [X, Y, Z].\n        \"\"\"\n        points = np.array(list_ref)[:, :2]  # X, Y coordinates from list_ref\n        values = np.array(list_ref)[:, 2]   # Z values from list_ref\n        xi = np.array(list_coor)[:, :2]     # X, Y coordinates for which to interpolate\n\n        interpolated_z = griddata(points, values, xi, method=method.value)\n\n        list_coor_interpolated = []\n        for i in range(len(list_coor)):\n            if np.isnan(interpolated_z[i]) and skip_nan:\n                print(f\"Warning: Interpolated z-value for {list_coor[i]} is NaN, skipping.\")\n                continue\n            list_coor_interpolated.append((list_coor[i][0], list_coor[i][1], interpolated_z[i]))\n\n        return list_coor_interpolated\n\n    @Slot(MeaCoor_mm, MeaCoor_mm, Option_InterpolationMethod)\n    def _run_modify_z_coordinates(self, meaCoorTarget:MeaCoor_mm, meaCoorRef:MeaCoor_mm,\n                                  method:Option_InterpolationMethod):\n        \"\"\"\n        Runs the modification of the z-coordinates of the selected mapping coordinates\n\n        Args:\n            meaCoorTarget (MeaCoor_mm): The mapping coordinates to modify\n            meaCoorRef (MeaCoor_mm): The reference mapping coordinates\n            method (Option_InterpolationMethod): The interpolation method to use\n        \"\"\"\n    # &gt; Modify the z-coordinates &lt;\n        list_coor_tgt = meaCoorTarget.mapping_coordinates.copy()\n        list_coor_ref = meaCoorRef.mapping_coordinates.copy()\n\n        # try:\n        list_coor_interp = self._interpolate_z_values(\n            list_coor=list_coor_tgt,\n            list_ref=list_coor_ref,\n            method=method,\n            skip_nan=True\n        )\n\n        modified_coor = MeaCoor_mm(meaCoorTarget.mappingUnit_name + \"_zInterpolated\", list_coor_interp)\n\n        if len(list_coor_interp) == 0:\n            self.sig_finished.emit(self.msg_error + \"No valid coordinates were interpolated. Please check the reference coordinates.\")\n        if len(list_coor_interp) != len(list_coor_tgt):\n            self.sig_finished.emit(self.msg_partial_success + \n                                   \"Some coordinates could not be calculated due to them being outside the reference range.\\n\"\n                                   \"Only the valid coordinates have been modified.\")\n            self.sig_saveModification.emit(modified_coor)\n        else:\n            self.sig_finished.emit(self.msg_success)\n            self.sig_saveModification.emit(modified_coor)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.ZInterpolate","title":"<code>ZInterpolate</code>","text":"<p>               Bases: <code>Ui_zInterpolate</code>, <code>QWidget</code></p> Source code in <code>iris/gui/submodules/meaCoor_modifier/zInterpolate.py</code> <pre><code>class ZInterpolate(Ui_zInterpolate, qw.QWidget):\n\n    msg_instructions = (\n        \"The Z-Coordinate Interpolation Modifier allows you to modify the z-coordinates of a selected mapping coordinates unit \"\n        \"based on the z-coordinates of a reference mapping coordinates unit using interpolation methods.\\n\\n\"\n        \"Instructions:\\n\"\n        \"1. Select the mapping coordinates unit you want to modify from the 'Select the mapping coordinates to modify' dropdown.\\n\"\n        \"2. Select the reference mapping coordinates unit from the 'Select the mapping coordinates reference' dropdown.\\n\"\n        \"3. Choose the interpolation method (linear, nearest, or cubic) from the 'Interpolation method' dropdown.\\n\"\n        \"4. Click the 'Modify Z-coordinates' button to perform the interpolation and modify the z-coordinates.\\n\"\n        \"5. You will be prompted to enter a new name for the modified mapping coordinates unit. Enter a unique name and click OK.\\n\"\n        \"6. The modified mapping coordinates unit will be added to the hub with the new name.\\n\\n\"\n        \"Note: Ensure that the reference mapping coordinates unit has valid z-coordinates for accurate interpolation.\"\n    )\n\n    sig_updateListUnits = Signal()\n    sig_performInterpolation = Signal(MeaCoor_mm, MeaCoor_mm, Option_InterpolationMethod)\n\n    def __init__(\n        self,\n        parent,\n        mappingCoorHub: List_MeaCoor_Hub,\n        *args, **kwargs) -&gt; None:\n        \"\"\"Initializes the mapping method\n\n        Args:\n            parent (tk.Frame): The parent frame to place this widget in\n            MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n            getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n        \"\"\"\n        super().__init__(parent)\n        self.setupUi(self)\n        self.setLayout(self.main_layout)\n\n        self._coorHub = mappingCoorHub\n\n        self.btn_instruction.clicked.connect(lambda: qw.QMessageBox.information(\n            self,\n            \"Z-Coordinate Interpolation Modifier Instructions\",\n            self.msg_instructions\n        ))\n\n        self.btn_performInterp.clicked.connect(self._run_modify_z_coordinates)\n\n    # &gt;&gt;&gt; Parameter widgets &lt;&lt;&lt;\n        self.combo_interpMethod.addItems([method.value for method in Option_InterpolationMethod])\n\n    # &gt;&gt;&gt; Parameters for the mapping coordinates modification &lt;&lt;&lt;\n        self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n    # &gt;&gt;&gt; Others &lt;&lt;&lt;\n        self._init_worker_and_signals()\n\n    def _init_worker_and_signals(self):\n        self.sig_updateListUnits.connect(self._update_list_units)\n        self._coorHub.add_observer(self.sig_updateListUnits.emit)\n        self.sig_updateListUnits.emit()\n\n        # Signal to perform the interpolation\n        self._thread_interp = QThread()\n        self._worker_interp = Interpolator_Worker()\n        self._worker_interp.moveToThread(self._thread_interp)\n\n        self._worker_interp.sig_finished.connect(self._handle_finished_interpolation)\n        self._worker_interp.sig_saveModification.connect(self._handle_store_modification)\n\n        self.sig_performInterpolation.connect(self._worker_interp._run_modify_z_coordinates)\n\n        self.destroyed.connect(self._thread_interp.quit)\n        self.destroyed.connect(self._worker_interp.deleteLater)\n        self.destroyed.connect(self._thread_interp.deleteLater)\n        self._thread_interp.start()\n\n    @Slot()\n    def _update_list_units(self):\n        \"\"\"Updates the list of mapping units in the combobox\"\"\"\n        self._dict_mapUnit.clear()  # Clear the existing dictionary\n        self._dict_mapUnit = {unit.mappingUnit_name: unit for unit in self._coorHub}\n\n        self.combo_target.clear()\n        self.combo_reference.clear()\n\n        self.combo_target.addItems(list(self._dict_mapUnit.keys()))\n        self.combo_reference.addItems(list(self._dict_mapUnit.keys()))\n\n    @Slot(MeaCoor_mm)\n    def _handle_store_modification(self, mapping_coor:MeaCoor_mm):\n        \"\"\"Handles the saving of the modified mapping coordinates\n\n        Args:\n            mapping_coor (MeaCoor_mm): The modified mapping coordinates\n        \"\"\"\n        # Prompt for new name\n        new_name = messagebox_request_input(\n            self,\n            title=\"New Mapping Unit Name\",\n            message=\"Enter a name for the new mapping unit:\",\n            default=mapping_coor.mappingUnit_name,\n            validator=self._coorHub.validator_new_name,\n            invalid_msg=\"The name is already in use. Please enter a different name.\",\n            loop_until_valid=True\n        )\n\n        if not new_name:\n            qw.QMessageBox.warning(self, \"Warning\", \"Modification cancelled: No name provided for new mapping unit.\")\n            return\n\n        # Add the new mapping coordinates to the hub\n        new_mapping_coor = MeaCoor_mm(new_name, mapping_coor.mapping_coordinates)\n        try: self._coorHub.append(new_mapping_coor)\n        except ValueError as e:\n            qw.QMessageBox.critical(self, \"Error\", str(e))\n\n        # print(f'Modified mapping coordinates saved as \"{new_name}\".')\n        # print(f'Number of coordinates: {len(new_mapping_coor.mapping_coordinates)}')\n        # print(f'First 5 coordinates: {new_mapping_coor.mapping_coordinates[:5]}')\n\n    @Slot(str)\n    def _handle_finished_interpolation(self,msg:str):\n        \"\"\"Handles the finished signal from the interpolation worker\n\n        Args:\n            msg (str): The message to display\n        \"\"\"\n        if msg.startswith(self._worker_interp.msg_error):\n            qw.QMessageBox.warning(self, \"Interpolation Error\", msg)\n        elif msg.startswith(self._worker_interp.msg_partial_success):\n            qw.QMessageBox.warning(self, \"Interpolation Partial Success\", msg)\n        else:\n            qw.QMessageBox.information(self, \"Interpolation Success\", msg)\n\n        self.btn_performInterp.setEnabled(True)\n\n    def _interpolate_z_values(self,list_coor:list,list_ref:list,method:Literal['linear','nearest','cubic'],\n                              skip_nan:bool=True) -&gt; list[tuple[float, float, float]]:\n        \"\"\"\n        Interpolates the z-values of the given coordinates based on the reference coordinates.\n\n        Args:\n            list_coor (list): List of coordinates to interpolate, each coordinate is a list of [X, Y].\n            list_ref (list): List of reference coordinates, each coordinate is a list of [X, Y, Z].\n            method (Literal['linear','nearest','cubic']): Interpolation method to use.\n            skip_nan (bool): If True, skips NaN values in the interpolation result.\n\n        Returns:\n            list: List of interpolated coordinates with z-values, each coordinate is a list of [X, Y, Z].\n        \"\"\"\n        points = np.array(list_ref)[:, :2]  # X, Y coordinates from list_ref\n        values = np.array(list_ref)[:, 2]   # Z values from list_ref\n        xi = np.array(list_coor)[:, :2]     # X, Y coordinates for which to interpolate\n\n        interpolated_z = griddata(points, values, xi, method=method)\n\n        list_coor_interpolated = []\n        for i in range(len(list_coor)):\n            if np.isnan(interpolated_z[i]) and skip_nan:\n                print(f\"Warning: Interpolated z-value for {list_coor[i]} is NaN, skipping.\")\n                continue\n            list_coor_interpolated.append((list_coor[i][0], list_coor[i][1], interpolated_z[i]))\n\n        return list_coor_interpolated\n\n    @Slot()\n    def _run_modify_z_coordinates(self):\n        \"\"\"\n        Runs the modification of the z-coordinates of the selected mapping coordinates\n        \"\"\"\n    # &gt; Retrieve the selected mapping unit from the combobox and check it &lt;\n        sel_unitName_tgt = self.combo_target.currentText()\n        sel_unitName_ref = self.combo_reference.currentText()\n\n        if not sel_unitName_tgt or not sel_unitName_ref:\n            qw.QMessageBox.warning(self, \"Warning\", \"Please select both target and reference mapping units.\")\n            return\n\n        if sel_unitName_ref == sel_unitName_tgt:\n            qw.QMessageBox.warning(self, \"Warning\", \"Target and reference mapping units must be different.\")\n            return\n\n        if sel_unitName_tgt not in self._dict_mapUnit or sel_unitName_ref not in self._dict_mapUnit:\n            qw.QMessageBox.warning(self, \"Error\", f\"Mapping unit '{sel_unitName_tgt}' not found.\")\n            return\n\n        # Get the current mapping coordinates\n        mapCoor_source = self._dict_mapUnit[sel_unitName_tgt]\n        mapCoor_ref = self._dict_mapUnit[sel_unitName_ref]\n\n        if not isinstance(mapCoor_source, MeaCoor_mm) or not isinstance(mapCoor_ref, MeaCoor_mm):\n            qw.QMessageBox.critical(self, \"Error\", \"Invalid mapping coordinates type.\")\n            return\n\n        approx_method = Option_InterpolationMethod(self.combo_interpMethod.currentText())\n\n        self.btn_performInterp.setEnabled(False)\n        self.sig_performInterpolation.emit(mapCoor_source, mapCoor_ref, approx_method)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.ZInterpolate.__init__","title":"<code>__init__(parent, mappingCoorHub, *args, **kwargs)</code>","text":"<p>Initializes the mapping method</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Frame</code> <p>The parent frame to place this widget in</p> required <code>MappingCoorHub</code> <code>MappingCoordinatesHub</code> <p>The hub to store the resulting mapping coordinates in</p> required <code>getter_MappingCoor</code> <code>Callable[[], MappingCoordinates_mm]</code> <p>A function to get the mapping coordinates to modify</p> required Source code in <code>iris/gui/submodules/meaCoor_modifier/zInterpolate.py</code> <pre><code>def __init__(\n    self,\n    parent,\n    mappingCoorHub: List_MeaCoor_Hub,\n    *args, **kwargs) -&gt; None:\n    \"\"\"Initializes the mapping method\n\n    Args:\n        parent (tk.Frame): The parent frame to place this widget in\n        MappingCoorHub (MappingCoordinatesHub): The hub to store the resulting mapping coordinates in\n        getter_MappingCoor (Callable[[], MappingCoordinates_mm]): A function to get the mapping coordinates to modify\n    \"\"\"\n    super().__init__(parent)\n    self.setupUi(self)\n    self.setLayout(self.main_layout)\n\n    self._coorHub = mappingCoorHub\n\n    self.btn_instruction.clicked.connect(lambda: qw.QMessageBox.information(\n        self,\n        \"Z-Coordinate Interpolation Modifier Instructions\",\n        self.msg_instructions\n    ))\n\n    self.btn_performInterp.clicked.connect(self._run_modify_z_coordinates)\n\n# &gt;&gt;&gt; Parameter widgets &lt;&lt;&lt;\n    self.combo_interpMethod.addItems([method.value for method in Option_InterpolationMethod])\n\n# &gt;&gt;&gt; Parameters for the mapping coordinates modification &lt;&lt;&lt;\n    self._dict_mapUnit = {}  # Dictionary to store mapping units\n\n# &gt;&gt;&gt; Others &lt;&lt;&lt;\n    self._init_worker_and_signals()\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/gui/submodules/meaCoor_modifier/zInterpolate/#iris.gui.submodules.meaCoor_modifier.zInterpolate.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/multiprocessing/basemanager/","title":"basemanager","text":""},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/","title":"dataStreamer_Raman","text":"<p>A hub that stores the measurement from the spectrometer. The hub is a multiprocessing process that runs in the background and is responsible for collecting the coordinates from  the stage controllers and storing them in a dictionary. The hub also provides a method to retrieve the coordinates based on the timestamp.</p> Idea <ul> <li>The hub will constantly run in the background, collecting the measurement and timestamp from the spectrometer.</li> <li>When required, e.g., for the mapping measurements, the hub can be queried for the measurements based on the timestamp.</li> </ul> Note <ul> <li>The timestamp is in [us] integer format. See library/general_functions.py for the timestamp conversion functions.</li> </ul> Usage <ol> <li>Create a central base manager using the MyManager class from the basemanager.py file.</li> <li>Register the classes and the dictionary with the manager using the initialise_manager() function.</li> <li>Register any other classes and dictionary from other hubs/use cases.</li> <li>Start the manager.</li> <li>Create the proxies for the controllers and the dictionary using the initialise_proxy() function.</li> <li>Add any other proxies from other hubs/use cases.</li> <li>Pass the proxies into the hubs/other classes that require them.</li> </ol> <p>!!! Note that the manager.start() has to be called after the all the manager initialisations (register()) and before the proxies are created.</p> <p>Techinical notes (for myself):     - The controllers passed into the hub have to be proxies from the multiprocessing manager.     - The multithreading has to be run within the hub's run() method.     - The dictionary also has to be a proxy from the multiprocessing manager.     - There can only be 1 manager for the entire program. The manager has to be started before the any other instances is created.     - Note on the order of the initialisation:         1. The manager has to be registered with the classes and the dictionary before the proxies are created and only after the proxy creations can the manager be started.         2. The hub has to be started after the proxies are created.</p>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman","title":"<code>DataStreamer_Raman</code>","text":"<p>               Bases: <code>Process</code></p> <p>A class to automatically run scans and store the results and its timestamps. Designed to be opearted with raman_measurement_hub_processor.</p> Note <p>!!! This class operates with timestamps that are stored is in the format of get_timestamp_us(), which is in integer format of microseconds (instead of the default %y%m%d_%H%M%S_%f) !!!</p> <p>Merged from another class: A class to run the measurements and store then in the raman_measurement_hub.</p> VERY IMPORTANT NOTES <ul> <li>Only 1 instance of this class should be running at a time.</li> <li>Once terminated, the instance cannot be restarted.</li> <li>This class should be initialised first before any multithreading/multiprocessing methods/functions.</li> </ul> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>class DataStreamer_Raman(mp.Process):\n    \"\"\"\n    A class to automatically run scans and store the results and its timestamps.\n    Designed to be opearted with raman_measurement_hub_processor.\n\n    Note:\n        !!! This class operates with timestamps that are stored is in the format of get_timestamp_us(),\n        which is in integer format of microseconds (instead of the default %y%m%d_%H%M%S_%f) !!!\n\n    Merged from another class: A class to run the measurements and store then in the raman_measurement_hub.\n\n    VERY IMPORTANT NOTES:\n        - Only 1 instance of this class should be running at a time.\n        - Once terminated, the instance cannot be restarted.\n        - This class should be initialised first before any multithreading/multiprocessing methods/functions.\n\n    \"\"\"\n\n    def __init__(self,controller:Controller_Spectrometer,dict_measurements:mpm.DictProxy):\n        \"\"\"\n        Args:\n            controller (raman_spectrometer_controller): The controller for the spectrometer\n            dict_measurements (mpm.DictProxy): A dictionary to store the measurements\n            pipe_cal_update (mpc.Connection): A pipe to update the calibration\n        \"\"\"\n        super().__init__()\n        self._controller = controller\n\n    # &gt;&gt;&gt; Calibrator setup &lt;&lt;&lt;\n        self._pipe_cal_update_front,self._pipe_cal_update_back = mp.Pipe()\n        self._pipe_cal_mea_front,self._pipe_cal_mea_back = mp.Pipe()\n        self._calibrator: SpectrometerCalibrator = None\n\n    # &gt;&gt;&gt; Storage setup &lt;&lt;&lt;\n        # Labels for the measurements\n        self._lbl_ts = 'timestamp_us_int'\n        self._lbl_mea = 'raw_spectrum'\n        self._lbl_inttime = 'integration_time_ms'\n        self._lbl_flg_retrieved = 'flg_retrieved'\n\n        # Measurement parameters\n        self._max_measurement = MPMeaHubEnum.RAMANHUB_MAXSTORAGE.value     # Maximum number of measurements stored\n        self._list_measurements_updater = []            # A list to store the measuremets\n        self._q_SelfUpdate:mp.Queue = mp.Queue()        # A queue to update self\n\n        # Flags\n        self._flg_process_updater = mp.Event()          # A flag to control the updater\n        self._flg_pause_updater = mp.Event()            # A flag to pause the updater\n        self._flg_pause_updater.clear()\n        self._flg_PauseMeasurement = None     # A flag to autorestart the measurements \n                                                        # (will be set up automatically by the processor)\n        self._flg_ListReady = mp.Event()                # A flag to indicate that the list is ready for access.\n                                                        # This prevents the list from being accessed when it's still being updated.\n        self._flg_ListReady.set()\n\n        # Stores the measurements\n        assert type(self._max_measurement) == int and self._max_measurement &gt; 0,\\\n            \"The maximum number of measurements has to be an integer greater than 0\"\n\n        self._list_timestamps:list = dict_measurements[self._lbl_ts]\n        self._list_measurements:list = dict_measurements[self._lbl_mea]\n        self._list_integrationtime:list = dict_measurements[self._lbl_inttime]\n        self._list_flg_retrieved:list = dict_measurements[self._lbl_flg_retrieved]\n\n        # Other parameters\n        self._pause_interval_updater = 10   # The interval between checks for new measurements [ms]\n\n    # &gt;&gt;&gt; Processor setup &lt;&lt;&lt;\n        # Flags\n        self._flg_process_measurement = mp.Event()              # A flag to control the continuous measurement. set() to stop\n        self._flg_pause_measurement = mp.Event()                # A flag to pause the continuous measurement. set() to pause, clear() to resume\n        self._flg_pause_measurement.set()\n\n        self._pause_interval_measurement = 10   # The pause interval the continuous measurement [ms] (if the pause flag is raised)\n\n        # Locks\n        self._lock_meaCal_pipe = mp.Lock() # A lock for the pipe to calibrate a measurement\n\n    def get_calibrator_pipe(self) -&gt; mpc.Connection:\n        \"\"\"\n        Returns the pipe to update the calibrator\n\n        Returns:\n            mpc.Connection: The pipe to update the calibrator\n        \"\"\"\n        return self._pipe_cal_update_front\n\n    def run(self):\n        \"\"\"\n        Runs the continuous measurement\n        \"\"\"\n        self._calibrator = SpectrometerCalibrator(pipe_update=self._pipe_cal_update_back,pipe_measurement=self._pipe_cal_mea_back)\n        threading.Thread(target=self._auto_update_measurements).start()\n        threading.Thread(target=self._auto_collect_measurement).start()\n\n    def _auto_update_measurements(self):\n        \"\"\"\n        Sets the measurements from the continuous measurements of the \n        raman_measurement_hub_processor\n        \"\"\"\n        try:\n            self._flg_process_updater.set()\n            while self._flg_process_updater.is_set():\n                if self._flg_pause_updater.is_set():\n                    time.sleep(self._pause_interval_updater/1000)\n                    self._flg_ListReady.set()\n                    continue\n                try:\n                    self._flg_ListReady.clear()\n                    package = self._list_measurements_updater.pop(0)\n                    self._set_measurement_childProc(*package)\n                except IndexError:\n                # except queue.Empty:\n                    time.sleep(self._pause_interval_updater/1000)\n                except Exception as e:\n                    print('update_continuous_measurements_package:')\n                    print(e)\n        finally:\n            self._flg_process_updater.set()\n\n    def _pause_updater(self):\n        \"\"\"\n        Pauses the updater. Automatically waits for the list to be ready for access.\n        !!! Note that if the process is paused, the list will wait indefinitely for the process to resume.\n        \"\"\"\n        self._flg_pause_updater.set()\n        if not self._flg_pause_measurement.is_set():\n            self._flg_ListReady.wait()\n\n    def _resume_updater(self):\n        \"\"\"\n        Resumes the updater\n        \"\"\"\n        self._flg_pause_updater.clear()\n\n    def wait_MeasurementUpdate(self):\n        \"\"\"\n        Waits for a new measurement to be stored. Automatically restarts the measurement.\n        \"\"\"\n        timestamp_initial = self._list_timestamps.__getitem__(-1) if len(self._list_timestamps) &gt; 0 else 0\n\n        self.resume_auto_measurement()\n        while len(self._list_timestamps) == 0 or timestamp_initial == self._list_timestamps.__getitem__(-1):\n            time.sleep(self._pause_interval_updater/1000)\n\n    def _get_measurement_idx(self,timestamp:int) -&gt; int:\n        \"\"\"\n        Returns the measurement based on the closest timestamp.\n        Scans from the latest to the oldest for speed.\n\n        Args:\n            timestamp (int): The timestamp to be searched for [us] in integer format\n\n        Returns:\n            int: index of the measurement in the list.\n        \"\"\"\n        idx_min = 0\n        length = len(self._list_timestamps)\n        for i in range(length):\n            # Check for a smaller timestamp, scans from the latest to the oldest\n            idx_check = i+1\n            comparator = self._list_timestamps.__getitem__(-idx_check)\n            if comparator &lt; timestamp:\n            # if self._list_timestamps.__getitem__(-idx_check) &lt; timestamp:\n                idx_min=length-(idx_check)\n                break\n\n        if idx_min == length-1:\n            return idx_min\n        else:\n            return idx_min+1\n\n    def get_measurement(self,timestamp_start:int,timestamp_end:int=None,WaitForMeasurement:bool=True,\n                        getNewOnly:bool=False)\\\n        -&gt; tuple[list,list,list]:\n        \"\"\"\n        Returns the measurements based on the range of timestamps. Automatically pauses the updater.\n\n        Args:\n            timestamp_start (int): The start timestamp [us] in integer format\n            timestamp_end (int, optional): The end timestamp [us] in integer format. If None, returns the measurement based on the start timestamp\n            WaitForMeasurement (bool, optional): If True, waits for a new measurement to be stored\n            getNewOnly (bool, optional): If True, only returns the new measurements (not retrieved yet)\n\n        Returns:\n            tuple: (timestamp_list (int), raw_spectrum_list (df), integration_time_ms_list (int))\n\n        Note:\n            - The returned timestamp is in the integer format of [us]\n            - The getNewOnly is ONLY OPTIMISED FOR SINGLE MEASUREMENT RETRIEVAL. For multiple measurement retrievals, it's better to use the normal method.\n\n        \"\"\"\n        assert all([type(timestamp_start) == int, type(timestamp_end) == int or timestamp_end == None]),\\\n            \"The timestamps have to be in integer format\"\n\n        # Waits for a new measurement to be stored if requested or if there are no measurements\n        if WaitForMeasurement or len(self._list_timestamps)==0: self.wait_MeasurementUpdate()\n\n        self._pause_updater() # Pauses the updater to prevent index change during the process\n\n        # Get lock on the lists\n\n    # &gt;&gt;&gt; If the end timestamp is not provided, returns the measurement based on the start timestamp\n        if timestamp_end == timestamp_start or timestamp_end == None:\n            mea_idx = self._get_measurement_idx(timestamp=timestamp_start)\n            if getNewOnly and self._list_flg_retrieved.__getitem__(mea_idx):\n                self._resume_updater()\n                self.wait_MeasurementUpdate()\n                self._pause_updater()\n                mea_idx = self._get_measurement_idx(timestamp=timestamp_start)\n            timestamp = self._list_timestamps.__getitem__(mea_idx)\n            raw_spectrum = self._list_measurements.__getitem__(mea_idx)\n            integration_time_ms = self._list_integrationtime.__getitem__(mea_idx)\n            self._list_flg_retrieved.__setitem__(mea_idx,True)\n            self._resume_updater()\n            return ([timestamp],[raw_spectrum],[integration_time_ms])\n\n        # Makes sure that the start timestamp is before the end timestamp\n        assert timestamp_start &lt; timestamp_end, \"The start timestamp has to be before the end timestamp\"\n\n        idx_start = self._get_measurement_idx(timestamp=timestamp_start)\n        idx_end = self._get_measurement_idx(timestamp=timestamp_end)\n\n        if not getNewOnly:\n            # Returns the measurements based on the range\n            sliceobj = slice(idx_start,idx_end)\n            ts_list:list = self._list_timestamps.__getitem__(sliceobj)\n            mea_list:list = self._list_measurements.__getitem__(sliceobj)\n            inttime_list:list = self._list_integrationtime.__getitem__(sliceobj)\n        else:\n            print('getNewOnly')\n            num_measurements = len([self._list_flg_retrieved.__getitem__(i) for i in range(idx_start,idx_end) if not self._list_flg_retrieved.__getitem__(i)])\n            if num_measurements == 0:\n                print('waiting getNewOnly')\n                self._resume_updater()\n                self.wait_MeasurementUpdate()\n                self._pause_updater()\n            ts_list = [self._list_timestamps.__getitem__(i) for i in range(idx_start,idx_end) if not self._list_flg_retrieved.__getitem__(i)]\n            mea_list = [self._list_measurements.__getitem__(i) for i in range(idx_start,idx_end) if not self._list_flg_retrieved.__getitem__(i)]\n            inttime_list = [self._list_integrationtime.__getitem__(i) for i in range(idx_start,idx_end) if not self._list_flg_retrieved.__getitem__(i)]\n\n        # Flag the measurements as retrieved\n        [self._list_flg_retrieved.__setitem__(i,True) for i in range(idx_start,idx_end)]\n\n        result = (ts_list,mea_list,inttime_list)\n\n        if idx_start &lt; int(0.1*len(self._list_timestamps)):\n            print('\\n!!!!! Warning !!!!!\\n&gt;&gt;&gt;&gt;&gt; raman_measurement_hub: Running out of measurement reserve. Increase self._max_measurements. &lt;&lt;&lt;&lt;&lt;\\n!!!!! Warning !!!!!\\n')\n\n        self._resume_updater()\n        return result\n\n    def _set_measurement_childProc(self,timestamp:int,raw_spectrum:pd.DataFrame,integration_time_ms:int):\n        \"\"\"\n        Sets a measurement based on the timestamp. Designed to be used in the child process.\n        If not used in the child process, the calibration won't work properly.\n\n        Args:\n            timestamp (int): The timestamp in the format of get_timestamp_us()\n            raw_spectrum (pd.DataFrame): The raw spectrum\n            integration_time_ms (int): The integration time in [ms]\n\n        Note:\n            - The timestamp has to be in the format of get_timestamp_us()\n            (defaults to %y%m%d_%H%M%S_%f)\n        \"\"\"\n        # Calibrate the measurements\n        cal_spectrum = self._calibrator.calibrate_measurement(raw_spectrum)\n\n        # # &gt;&lt;&gt;&lt; Debugging part starts here &gt;&lt;&gt;&lt;\n        # print('Calibrated spectrum:')\n        # print(cal_spectrum.head(5))\n\n        # print('Raw spectrum:')\n        # print(raw_spectrum.head(5))\n        # # &gt;&lt;&gt;&lt; Debugging part ends here &gt;&lt;&gt;&lt;\n\n        self._list_timestamps.append(timestamp)\n        self._list_measurements.append(cal_spectrum)\n        self._list_integrationtime.append(integration_time_ms)\n        self._list_flg_retrieved.append(False)\n\n        # Removes the oldest measurement if the maximum number of measurements is reached\n        if len(self._list_timestamps) &gt; self._max_measurement:\n            self._list_timestamps.pop(0)\n            self._list_measurements.pop(0)\n            self._list_integrationtime.pop(0)\n            self._list_flg_retrieved.pop(0)\n\n    def terminate_process(self):\n        \"\"\"\n        Stops the continuous measurement\n        \"\"\"\n        self._flg_process_measurement.clear()\n        self._flg_process_updater.clear()\n\n    def pause_auto_measurement(self):\n        \"\"\"\n        Pauses the continuous measurement\n        \"\"\"\n        self._flg_pause_measurement.set()\n\n    def resume_auto_measurement(self):\n        \"\"\"\n        Resumes the continuous measurement\n        \"\"\"\n        self._flg_pause_measurement.clear()\n\n    def isrunning_auto_measurement(self) -&gt; bool:\n        \"\"\"\n        Returns the status of the auto measurement (continuous)\n\n        Returns:\n            bool: True if the auto measurement is running\n        \"\"\"\n        return not self._flg_pause_measurement.is_set()\n\n    def get_single_measurement(self) -&gt; tuple[int,pd.DataFrame,int]|None:\n        \"\"\"\n        Performs a single measurement and returns the results. Designed to be used\n        manually, separate from the auto measurement. For this, the auto measurement\n        has to be off (or use the get_measurement() instead).\n\n        Returns:\n            tuple: (timestamp (int), raw_spectrum (pd.DataFrame), integration_time_ms (int))\n        \"\"\"\n        assert self._flg_pause_measurement.is_set(), \"The continuous measurement is running. Use get_measurement() instead.\"\n\n        # Performs a measurement\n        result = self._controller.measure_spectrum()\n        raw_spectrum, ts_us_int, int_time_us = result\n\n        # Calibrate the measurements\n        with self._lock_meaCal_pipe:\n            self._pipe_cal_mea_front.send(raw_spectrum)\n            cal_spectrum = self._pipe_cal_mea_front.recv()\n\n        int_time_ms = int_time_us/1000\n\n        # Stores the measurement\n        if isinstance(cal_spectrum,pd.DataFrame): measurements = ts_us_int, cal_spectrum, int_time_ms\n        else: measurements = None\n\n        return measurements\n\n    def _auto_collect_measurement(self):\n        \"\"\"\n        Performs a continuous measurement. Designed to be used in a separate \n        multiprocessing physical core/thread.\n\n        Note:\n            !!! The timestamp stored is in the format of get_timestamp_us(), which is\n            in integer format of microseconds (instead of the default %y%m%d_%H%M%S_%f) !!!\n        \"\"\"\n        try:\n            self._flg_process_measurement.set()\n            list_timestamps_debug = []\n            while self._flg_process_measurement.is_set():\n                try:\n                    # Pauses the continuous measurement\n                    if self._flg_pause_measurement.is_set(): # Prevents deadlocks\n                        time.sleep(self._pause_interval_measurement/1000)\n                        continue\n\n                    # Performs a measurement\n                    # ts_start = get_timestamp_us_int()\n                    result = self._controller.measure_spectrum()\n                    raw_spectrum, ts_mea, int_time_us = result\n                    int_time_ms = int_time_us/1000\n                    # ts_end = get_timestamp_us_int()\n                    # ts_mea = (int((ts_start+ts_end)/2))\n                    # ts_mea = ts_start\n\n                    # Stores the measurement\n                    measurements = ts_mea, raw_spectrum, int_time_ms\n                    self._list_measurements_updater.append(measurements)\n\n                    # ## &gt;&lt;&gt;&lt; Debugging part starts here &gt;&lt;&gt;&lt;\n                    # list_timestamps_debug.append(ts_avg_us_int)\n                    # if len(list_timestamps_debug) &gt; 3:\n                    #     gap_current = list_timestamps_debug[-1]-list_timestamps_debug[-2]\n                    #     gap_previous = list_timestamps_debug[-2]-list_timestamps_debug[-3]\n                    #     if gap_current &gt; gap_previous*1.75:\n                    #         print('Gap: {}, Previous gap: {}'.format(gap_current,gap_previous))\n                    # list_timestamps_debug.pop(0)\n                    # ## &gt;&lt;&gt;&lt; Debugging part ends here &gt;&lt;&gt;&lt;\n                except Exception as e:\n                    print('_auto_collect_measurement: ',e)\n        finally:\n            self._flg_process_measurement.set()\n\n    def join(self, timeout:float|None=None):\n        \"\"\"\n        Joins the process\n        \"\"\"\n        self.terminate_process()\n        self._flg_process_updater.wait(timeout)\n        self._flg_process_measurement.wait(timeout)\n        # self._calibrator.terminate()\n        super().join(timeout)\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.__init__","title":"<code>__init__(controller, dict_measurements)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>controller</code> <code>raman_spectrometer_controller</code> <p>The controller for the spectrometer</p> required <code>dict_measurements</code> <code>DictProxy</code> <p>A dictionary to store the measurements</p> required <code>pipe_cal_update</code> <code>Connection</code> <p>A pipe to update the calibration</p> required Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def __init__(self,controller:Controller_Spectrometer,dict_measurements:mpm.DictProxy):\n    \"\"\"\n    Args:\n        controller (raman_spectrometer_controller): The controller for the spectrometer\n        dict_measurements (mpm.DictProxy): A dictionary to store the measurements\n        pipe_cal_update (mpc.Connection): A pipe to update the calibration\n    \"\"\"\n    super().__init__()\n    self._controller = controller\n\n# &gt;&gt;&gt; Calibrator setup &lt;&lt;&lt;\n    self._pipe_cal_update_front,self._pipe_cal_update_back = mp.Pipe()\n    self._pipe_cal_mea_front,self._pipe_cal_mea_back = mp.Pipe()\n    self._calibrator: SpectrometerCalibrator = None\n\n# &gt;&gt;&gt; Storage setup &lt;&lt;&lt;\n    # Labels for the measurements\n    self._lbl_ts = 'timestamp_us_int'\n    self._lbl_mea = 'raw_spectrum'\n    self._lbl_inttime = 'integration_time_ms'\n    self._lbl_flg_retrieved = 'flg_retrieved'\n\n    # Measurement parameters\n    self._max_measurement = MPMeaHubEnum.RAMANHUB_MAXSTORAGE.value     # Maximum number of measurements stored\n    self._list_measurements_updater = []            # A list to store the measuremets\n    self._q_SelfUpdate:mp.Queue = mp.Queue()        # A queue to update self\n\n    # Flags\n    self._flg_process_updater = mp.Event()          # A flag to control the updater\n    self._flg_pause_updater = mp.Event()            # A flag to pause the updater\n    self._flg_pause_updater.clear()\n    self._flg_PauseMeasurement = None     # A flag to autorestart the measurements \n                                                    # (will be set up automatically by the processor)\n    self._flg_ListReady = mp.Event()                # A flag to indicate that the list is ready for access.\n                                                    # This prevents the list from being accessed when it's still being updated.\n    self._flg_ListReady.set()\n\n    # Stores the measurements\n    assert type(self._max_measurement) == int and self._max_measurement &gt; 0,\\\n        \"The maximum number of measurements has to be an integer greater than 0\"\n\n    self._list_timestamps:list = dict_measurements[self._lbl_ts]\n    self._list_measurements:list = dict_measurements[self._lbl_mea]\n    self._list_integrationtime:list = dict_measurements[self._lbl_inttime]\n    self._list_flg_retrieved:list = dict_measurements[self._lbl_flg_retrieved]\n\n    # Other parameters\n    self._pause_interval_updater = 10   # The interval between checks for new measurements [ms]\n\n# &gt;&gt;&gt; Processor setup &lt;&lt;&lt;\n    # Flags\n    self._flg_process_measurement = mp.Event()              # A flag to control the continuous measurement. set() to stop\n    self._flg_pause_measurement = mp.Event()                # A flag to pause the continuous measurement. set() to pause, clear() to resume\n    self._flg_pause_measurement.set()\n\n    self._pause_interval_measurement = 10   # The pause interval the continuous measurement [ms] (if the pause flag is raised)\n\n    # Locks\n    self._lock_meaCal_pipe = mp.Lock() # A lock for the pipe to calibrate a measurement\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.get_calibrator_pipe","title":"<code>get_calibrator_pipe()</code>","text":"<p>Returns the pipe to update the calibrator</p> <p>Returns:</p> Type Description <code>Connection</code> <p>mpc.Connection: The pipe to update the calibrator</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def get_calibrator_pipe(self) -&gt; mpc.Connection:\n    \"\"\"\n    Returns the pipe to update the calibrator\n\n    Returns:\n        mpc.Connection: The pipe to update the calibrator\n    \"\"\"\n    return self._pipe_cal_update_front\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.get_measurement","title":"<code>get_measurement(timestamp_start, timestamp_end=None, WaitForMeasurement=True, getNewOnly=False)</code>","text":"<p>Returns the measurements based on the range of timestamps. Automatically pauses the updater.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp_start</code> <code>int</code> <p>The start timestamp [us] in integer format</p> required <code>timestamp_end</code> <code>int</code> <p>The end timestamp [us] in integer format. If None, returns the measurement based on the start timestamp</p> <code>None</code> <code>WaitForMeasurement</code> <code>bool</code> <p>If True, waits for a new measurement to be stored</p> <code>True</code> <code>getNewOnly</code> <code>bool</code> <p>If True, only returns the new measurements (not retrieved yet)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[list, list, list]</code> <p>(timestamp_list (int), raw_spectrum_list (df), integration_time_ms_list (int))</p> Note <ul> <li>The returned timestamp is in the integer format of [us]</li> <li>The getNewOnly is ONLY OPTIMISED FOR SINGLE MEASUREMENT RETRIEVAL. For multiple measurement retrievals, it's better to use the normal method.</li> </ul> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def get_measurement(self,timestamp_start:int,timestamp_end:int=None,WaitForMeasurement:bool=True,\n                    getNewOnly:bool=False)\\\n    -&gt; tuple[list,list,list]:\n    \"\"\"\n    Returns the measurements based on the range of timestamps. Automatically pauses the updater.\n\n    Args:\n        timestamp_start (int): The start timestamp [us] in integer format\n        timestamp_end (int, optional): The end timestamp [us] in integer format. If None, returns the measurement based on the start timestamp\n        WaitForMeasurement (bool, optional): If True, waits for a new measurement to be stored\n        getNewOnly (bool, optional): If True, only returns the new measurements (not retrieved yet)\n\n    Returns:\n        tuple: (timestamp_list (int), raw_spectrum_list (df), integration_time_ms_list (int))\n\n    Note:\n        - The returned timestamp is in the integer format of [us]\n        - The getNewOnly is ONLY OPTIMISED FOR SINGLE MEASUREMENT RETRIEVAL. For multiple measurement retrievals, it's better to use the normal method.\n\n    \"\"\"\n    assert all([type(timestamp_start) == int, type(timestamp_end) == int or timestamp_end == None]),\\\n        \"The timestamps have to be in integer format\"\n\n    # Waits for a new measurement to be stored if requested or if there are no measurements\n    if WaitForMeasurement or len(self._list_timestamps)==0: self.wait_MeasurementUpdate()\n\n    self._pause_updater() # Pauses the updater to prevent index change during the process\n\n    # Get lock on the lists\n\n# &gt;&gt;&gt; If the end timestamp is not provided, returns the measurement based on the start timestamp\n    if timestamp_end == timestamp_start or timestamp_end == None:\n        mea_idx = self._get_measurement_idx(timestamp=timestamp_start)\n        if getNewOnly and self._list_flg_retrieved.__getitem__(mea_idx):\n            self._resume_updater()\n            self.wait_MeasurementUpdate()\n            self._pause_updater()\n            mea_idx = self._get_measurement_idx(timestamp=timestamp_start)\n        timestamp = self._list_timestamps.__getitem__(mea_idx)\n        raw_spectrum = self._list_measurements.__getitem__(mea_idx)\n        integration_time_ms = self._list_integrationtime.__getitem__(mea_idx)\n        self._list_flg_retrieved.__setitem__(mea_idx,True)\n        self._resume_updater()\n        return ([timestamp],[raw_spectrum],[integration_time_ms])\n\n    # Makes sure that the start timestamp is before the end timestamp\n    assert timestamp_start &lt; timestamp_end, \"The start timestamp has to be before the end timestamp\"\n\n    idx_start = self._get_measurement_idx(timestamp=timestamp_start)\n    idx_end = self._get_measurement_idx(timestamp=timestamp_end)\n\n    if not getNewOnly:\n        # Returns the measurements based on the range\n        sliceobj = slice(idx_start,idx_end)\n        ts_list:list = self._list_timestamps.__getitem__(sliceobj)\n        mea_list:list = self._list_measurements.__getitem__(sliceobj)\n        inttime_list:list = self._list_integrationtime.__getitem__(sliceobj)\n    else:\n        print('getNewOnly')\n        num_measurements = len([self._list_flg_retrieved.__getitem__(i) for i in range(idx_start,idx_end) if not self._list_flg_retrieved.__getitem__(i)])\n        if num_measurements == 0:\n            print('waiting getNewOnly')\n            self._resume_updater()\n            self.wait_MeasurementUpdate()\n            self._pause_updater()\n        ts_list = [self._list_timestamps.__getitem__(i) for i in range(idx_start,idx_end) if not self._list_flg_retrieved.__getitem__(i)]\n        mea_list = [self._list_measurements.__getitem__(i) for i in range(idx_start,idx_end) if not self._list_flg_retrieved.__getitem__(i)]\n        inttime_list = [self._list_integrationtime.__getitem__(i) for i in range(idx_start,idx_end) if not self._list_flg_retrieved.__getitem__(i)]\n\n    # Flag the measurements as retrieved\n    [self._list_flg_retrieved.__setitem__(i,True) for i in range(idx_start,idx_end)]\n\n    result = (ts_list,mea_list,inttime_list)\n\n    if idx_start &lt; int(0.1*len(self._list_timestamps)):\n        print('\\n!!!!! Warning !!!!!\\n&gt;&gt;&gt;&gt;&gt; raman_measurement_hub: Running out of measurement reserve. Increase self._max_measurements. &lt;&lt;&lt;&lt;&lt;\\n!!!!! Warning !!!!!\\n')\n\n    self._resume_updater()\n    return result\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.get_single_measurement","title":"<code>get_single_measurement()</code>","text":"<p>Performs a single measurement and returns the results. Designed to be used manually, separate from the auto measurement. For this, the auto measurement has to be off (or use the get_measurement() instead).</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[int, DataFrame, int] | None</code> <p>(timestamp (int), raw_spectrum (pd.DataFrame), integration_time_ms (int))</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def get_single_measurement(self) -&gt; tuple[int,pd.DataFrame,int]|None:\n    \"\"\"\n    Performs a single measurement and returns the results. Designed to be used\n    manually, separate from the auto measurement. For this, the auto measurement\n    has to be off (or use the get_measurement() instead).\n\n    Returns:\n        tuple: (timestamp (int), raw_spectrum (pd.DataFrame), integration_time_ms (int))\n    \"\"\"\n    assert self._flg_pause_measurement.is_set(), \"The continuous measurement is running. Use get_measurement() instead.\"\n\n    # Performs a measurement\n    result = self._controller.measure_spectrum()\n    raw_spectrum, ts_us_int, int_time_us = result\n\n    # Calibrate the measurements\n    with self._lock_meaCal_pipe:\n        self._pipe_cal_mea_front.send(raw_spectrum)\n        cal_spectrum = self._pipe_cal_mea_front.recv()\n\n    int_time_ms = int_time_us/1000\n\n    # Stores the measurement\n    if isinstance(cal_spectrum,pd.DataFrame): measurements = ts_us_int, cal_spectrum, int_time_ms\n    else: measurements = None\n\n    return measurements\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.isrunning_auto_measurement","title":"<code>isrunning_auto_measurement()</code>","text":"<p>Returns the status of the auto measurement (continuous)</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the auto measurement is running</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def isrunning_auto_measurement(self) -&gt; bool:\n    \"\"\"\n    Returns the status of the auto measurement (continuous)\n\n    Returns:\n        bool: True if the auto measurement is running\n    \"\"\"\n    return not self._flg_pause_measurement.is_set()\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.join","title":"<code>join(timeout=None)</code>","text":"<p>Joins the process</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def join(self, timeout:float|None=None):\n    \"\"\"\n    Joins the process\n    \"\"\"\n    self.terminate_process()\n    self._flg_process_updater.wait(timeout)\n    self._flg_process_measurement.wait(timeout)\n    # self._calibrator.terminate()\n    super().join(timeout)\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.pause_auto_measurement","title":"<code>pause_auto_measurement()</code>","text":"<p>Pauses the continuous measurement</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def pause_auto_measurement(self):\n    \"\"\"\n    Pauses the continuous measurement\n    \"\"\"\n    self._flg_pause_measurement.set()\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.resume_auto_measurement","title":"<code>resume_auto_measurement()</code>","text":"<p>Resumes the continuous measurement</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def resume_auto_measurement(self):\n    \"\"\"\n    Resumes the continuous measurement\n    \"\"\"\n    self._flg_pause_measurement.clear()\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.run","title":"<code>run()</code>","text":"<p>Runs the continuous measurement</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def run(self):\n    \"\"\"\n    Runs the continuous measurement\n    \"\"\"\n    self._calibrator = SpectrometerCalibrator(pipe_update=self._pipe_cal_update_back,pipe_measurement=self._pipe_cal_mea_back)\n    threading.Thread(target=self._auto_update_measurements).start()\n    threading.Thread(target=self._auto_collect_measurement).start()\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.terminate_process","title":"<code>terminate_process()</code>","text":"<p>Stops the continuous measurement</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def terminate_process(self):\n    \"\"\"\n    Stops the continuous measurement\n    \"\"\"\n    self._flg_process_measurement.clear()\n    self._flg_process_updater.clear()\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.DataStreamer_Raman.wait_MeasurementUpdate","title":"<code>wait_MeasurementUpdate()</code>","text":"<p>Waits for a new measurement to be stored. Automatically restarts the measurement.</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def wait_MeasurementUpdate(self):\n    \"\"\"\n    Waits for a new measurement to be stored. Automatically restarts the measurement.\n    \"\"\"\n    timestamp_initial = self._list_timestamps.__getitem__(-1) if len(self._list_timestamps) &gt; 0 else 0\n\n    self.resume_auto_measurement()\n    while len(self._list_timestamps) == 0 or timestamp_initial == self._list_timestamps.__getitem__(-1):\n        time.sleep(self._pause_interval_updater/1000)\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.initialise_manager_raman","title":"<code>initialise_manager_raman(manager)</code>","text":"<p>Registers the classes and the dictionary with the manager.</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def initialise_manager_raman(manager:MyManager|SyncManager):\n    \"\"\"\n    Registers the classes and the dictionary with the manager.\n    \"\"\"\n    manager.register('raman_controller_proxy',callable=Controller_Spectrometer)\n    manager.register('dict_raman_proxy',callable=dict,proxytype=mpm.DictProxy)\n    manager.register('list_raman_timestamp_proxy',callable=list,proxytype=mpm.ListProxy)\n    manager.register('list_raman_measurement_proxy',callable=list,proxytype=mpm.ListProxy)\n    manager.register('list_raman_integrationtime_proxy',callable=list,proxytype=mpm.ListProxy)\n    manager.register('list_raman_flg_retrieved_proxy',callable=list,proxytype=mpm.ListProxy)\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.initialise_proxy_raman","title":"<code>initialise_proxy_raman(manager)</code>","text":"<p>Initialises the proxies for the controllers and the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>MyManager</code> <p>The central base manager</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(raman_ctrl_proxy,dict_raman_proxy)</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def initialise_proxy_raman(manager:MyManager|SyncManager):\n    \"\"\"\n    Initialises the proxies for the controllers and the dictionary.\n\n    Args:\n        manager (MyManager): The central base manager\n\n    Returns:\n        tuple: (raman_ctrl_proxy,dict_raman_proxy)\n    \"\"\"\n    raman_ctrl_proxy = manager.raman_controller_proxy()\n    dict_raman_proxy = manager.dict_raman_proxy()\n\n    list_raman_timestamp_proxy = manager.list_raman_timestamp_proxy()               # Proxy list for the timestamps\n    list_raman_measurement_proxy = manager.list_raman_measurement_proxy()           # Proxy list for the measurements\n    list_raman_integrationtime_proxy = manager.list_raman_integrationtime_proxy()   # Proxy list for the integration times\n    list_raman_flg_retrieved_proxy = manager.list_raman_flg_retrieved_proxy()       # Proxy list for the flags (True if the measurement is retrieved)\n\n    dict_raman_proxy.update({\n        'timestamp_us_int':list_raman_timestamp_proxy,\n        'raw_spectrum':list_raman_measurement_proxy,\n        'integration_time_ms':list_raman_integrationtime_proxy,\n        'flg_retrieved':list_raman_flg_retrieved_proxy,\n    })\n    return raman_ctrl_proxy,dict_raman_proxy\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.test_initialise_cal_hub","title":"<code>test_initialise_cal_hub()</code>","text":"<p>Initialisation of the calibrator GUI and the RamanMeasurementHub for other tests.</p> Note <p>The hub has to be started (hub.start()) and the app has to be run (app.mainloop())</p> Source code in <code>iris/multiprocessing/dataStreamer_Raman.py</code> <pre><code>def test_initialise_cal_hub():\n    \"\"\"\n    Initialisation of the calibrator GUI and the RamanMeasurementHub\n    for other tests.\n\n    Note:\n        The hub has to be started (hub.start()) and the app has to be run\n        (app.mainloop())\n    \"\"\"\n    # Manager setups\n    manager:MyManager = get_my_manager()\n    initialise_manager_raman(manager)\n    manager.start()\n\n    raman_ctrl_proxy,dict_raman_proxy=initialise_proxy_raman(manager)\n\n    hub = DataStreamer_Raman(controller=raman_ctrl_proxy,\n                              dict_measurements=dict_raman_proxy)\n    pipe_front = hub.get_calibrator_pipe()\n\n    # Calibrator setup\n    app = tk.Tk()\n    calibrator_gui = Wdg_SpectrometerCalibrationGenerator(app,pipe_front)\n    calibrator_gui.pack()\n\n    return hub,app\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_Raman/#iris.multiprocessing.dataStreamer_Raman.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/","title":"dataStreamer_StageCam","text":"<p>A hub that stores the coordinates from the stage controllers. The hub is a multiprocessing process that runs in the background and is responsible for collecting the coordinates from  the stage controllers and storing them in a dictionary. The hub also provides a method to retrieve the coordinates based on the timestamp.</p> <p>Idea: - The hub will constantly run in the background, collecting the coordinates from the stage controllers. - When required, e.g., for the mapping coordinate reference, the hub can be queried for the coordinates based on the timestamp.</p> <p>Note: - The timestamp is in [us] integer format. See library/general_functions.py for the timestamp conversion functions.</p> <p>Usage: 1. Create a central base manager using the MyManager class from the basemanager.py file. 2. Register the classes and the dictionary with the manager using the initialise_manager() function. 3. Register any other classes and dictionary from other hubs/use cases. 4. Start the manager. 5. Create the proxies for the controllers and the dictionary using the initialise_proxy() function. 6. Add any other proxies from other hubs/use cases. 7. Pass the proxies into the hubs/other classes that require them.</p> <p>!!! Note that the manager.start() has to be called after the all the manager initialisations (register()) and before the proxies are created.</p> <p>Techinical notes (for myself): - The controllers passed into the hub have to be proxies from the multiprocessing manager. - The multithreading has to be run within the hub's run() method. - The dictionary also has to be a proxy from the multiprocessing manager. - There can only be 1 manager for the entire program. The manager has to be started before the any other instances is created. - Note on the order of the initialisation: 1. The manager has to be registered with the classes and the dictionary before the proxies are created and only after the proxy creations can the manager be started. 2. The hub has to be started after the proxies are created.</p>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam","title":"<code>DataStreamer_StageCam</code>","text":"<p>               Bases: <code>Process</code></p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>class DataStreamer_StageCam(mp.Process):\n    def __init__(self, xy_controller: Controller_XY, z_controller: Controller_Z,\n                 cam_controller: CameraController, namespace:StageNamespace):\n        \"\"\"\n        A hub that manages the storage and retrieval of coordinates from the stage controllers.\n\n        Args:\n            xy_controller (XYController): XY stage controller\n            z_controller (ZController): Z stage controller\n            cam_controller (CameraController): Camera controller\n            namespace (StageNamespace): Namespace for the stage hub\n        \"\"\"\n        super().__init__()\n        self.xy_controller = xy_controller\n        self.z_controller = z_controller\n        self.cam_controller = cam_controller\n        self._namespace = namespace\n        self._coor_pipe_main, self._coor_pipe_child = mp.Pipe(duplex=True)\n        self._cam_pipe_main, self._cam_pipe_child = mp.Pipe(duplex=True)\n\n        # &gt; Operation parameters &lt;\n        self._flg_selfrunning = mp.Event()\n\n        # &gt; Constants &lt;\n        self._pause_interval_sec = MPMeaHubEnum.STAGEHUB_REQUEST_INTERVAL.value / 1000.0  # Convert to seconds\n        self._stage_offset_ms = MPMeaHubEnum.STAGEHUB_TIME_OFFSET_MS.value\n\n        # &gt; Locks &lt;\n        self._lock_pipe = mp.Lock()  # Lock for the pipe\n\n    class Enum_CoorType(Enum):\n        \"\"\"\n        An enumeration for the type of coordinate retrieval\n        \"\"\"\n        CLOSEST = 1\n        INTERPOLATE = 2\n\n    class _child_CoorProc():\n        \"\"\"\n        A coordinate storage and processor for the stage hub, to be run \n        in a separate process.\n        \"\"\"\n        def __init__(self,pipe:mpc.Connection):\n            \"\"\"\n            Stores and interpolates the coordinates from the stage controllers.\n\n            Args:\n                pipe (mpc.Connection): _description_\n            \"\"\"\n            self._pipe = pipe   # Pipe for communication with the main process\n\n            # &gt; Operation parameters &lt;\n            self._list_timestamp = []   # List of timestamps for the child process\n            self._list_coordinates = [] # List of coordinates for the child process\n\n            # &gt; Locks &lt;\n            self._flg_selfrunning = threading.Event()   # Event flag for the child process running\n            self._flg_data_added = threading.Event()   # Event flag for data added\n            self._lock = mp.Lock()   # Threading lock for the list because it's only going to be accessed by the child process\n\n            # &gt; Constants &lt;\n            self._max_measurement = MPMeaHubEnum.STAGEHUB_MAXSTORAGE.value # Maximum number of coordinates stored\n\n            # &gt; Thread &lt;\n            self._thread:threading.Thread = threading.Thread()\n\n        def append_coordinate(self,timestamp:int,coordinate:tuple[float,float,float]):\n            \"\"\"\n            Add the coordinates to the list\n\n            Args:\n                timestamp (int): Timestamp in [us]\n                coordinate (tuple[float,float,float]): Coordinates (x,y,z)\n            \"\"\"\n            with self._lock:\n                self._list_timestamp.append(timestamp)\n                self._list_coordinates.append(coordinate)\n\n                if len(self._list_timestamp) &gt; self._max_measurement:\n                    self._list_timestamp.pop(0)\n                    self._list_coordinates.pop(0)\n            self._flg_data_added.set()\n\n        def get_closest_coordinate(self,timestamp:int) -&gt; tuple[int,tuple[float,float,float]]|None:\n            \"\"\"\n            Get the closest coordinate based on the timestamp\n\n            Args:\n                timestamp (int): Timestamp in [us]\n\n            Returns:\n                tuple|None: timestamp, coordinate tuple[x,y,z] or None if no coordinates are found\n            \"\"\"\n            try:\n                if len(self._list_timestamp) == 0:\n                    return None\n\n                while True:\n                    with self._lock: idx = bisect.bisect_left(self._list_timestamp,timestamp)\n                    if idx+1 &gt; len(self._list_timestamp):\n                        self.wait_coordinate()\n                    else: break\n\n                coor = self._list_coordinates[idx]\n            except Exception as e:\n                print('Error in get_closest_coordinate:',e)\n                coor = None\n\n            return coor\n\n        def wait_coordinate(self,timeout_sec:float|None=None) -&gt; None:\n            \"\"\"\n            Waits for a coordinate to be added into the list\n\n            Args:\n                timeout_sec (float): Timeout in seconds. If None, wait indefinitely\n            \"\"\"\n            self._flg_data_added.clear()\n            self._flg_data_added.wait(timeout_sec)\n\n        def get_interpolated_coordinate(self,timestamp:int) -&gt; tuple[float,float,float]|None:\n            \"\"\"\n            Get the interpolated coordinate based on the timestamp\n\n            Args:\n                timestamp (int): Timestamp in [us]\n\n            Returns:\n                tuple[int,tuple[float,float,float]]: timestamp, coordinate\n            \"\"\"\n            try:\n                while True:\n                    with self._lock: idx = bisect.bisect_left(self._list_timestamp,timestamp)\n                    if idx + 2 &gt;= len(self._list_timestamp):\n                        self.wait_coordinate()\n                    else: break\n\n                with self._lock:\n                    idx = bisect.bisect_left(self._list_timestamp,timestamp)\n                    ts1,coor1 = self._list_timestamp[idx],self._list_coordinates[idx]\n                    ts2,coor2 = self._list_timestamp[idx+1],self._list_coordinates[idx+1]\n\n                # Interpolate the coordinates\n                coor1 = np.array(coor1)\n                coor2 = np.array(coor2)\n                coor = coor1 + (coor2-coor1) * (timestamp-ts1)/(ts2 - ts1)\n                coor = tuple(coor)\n            except Exception as e:\n                print('Error in get_interpolated_coordinate:',e)\n                print(f'Requested index: {idx} and {idx+1}')\n                print(f'Available indices: {len(self._list_timestamp)} and {len(self._list_coordinates)}')\n                coor = None\n\n            return coor\n\n        def _assign_and_send_coordinates(self):\n            \"\"\"\n            Assign the coordinates to the timestamp and send it back to the main process.\n            \"\"\"\n            self._flg_selfrunning.set()\n            while self._flg_selfrunning.is_set():\n                flg_data = self._pipe.poll(timeout=0.5)\n                if not flg_data: continue\n\n                try:\n                    coor = None\n                    req_type,timestamp = self._pipe.recv()\n                    if req_type == DataStreamer_StageCam.Enum_CoorType.CLOSEST:\n                        coor = self.get_closest_coordinate(timestamp)\n                    elif req_type == DataStreamer_StageCam.Enum_CoorType.INTERPOLATE:\n                        coor = self.get_interpolated_coordinate(timestamp)\n                    else:\n                        raise ValueError('Invalid request type')\n                except Exception as e:\n                    print(f'Error in child process: {e}')\n                    print(f'Received data: {req_type},{timestamp}')\n                finally:\n                    self._pipe.send(coor)\n            self._pipe.close()\n\n        def run(self):\n            \"\"\"\n            Run the child process\n            \"\"\"\n            self._thread = threading.Thread(target=self._assign_and_send_coordinates,daemon=False)\n            self._thread.start()\n\n        def join(self,timeout:float|None=None):\n            self._flg_selfrunning.clear()\n            self._thread.join(timeout)\n\n    class Enum_CamCorrectionType(Enum):\n        \"\"\"\n        Enumeration for the type of camera image request\n        \"\"\"\n        RAW = 'raw'\n        FLATFIELD = 'flatfield'\n        BACKGROUND_SUBTRACTION = 'background_subtraction'\n\n    class Enum_CommandType(Enum):\n        \"\"\"\n        Enumeration for the type of command\n        \"\"\"\n        FLATFIELD_REF = 'flatfield_ref'\n        SAVE_FLATFIELD_REF = 'save_flatfield_ref'\n        LOAD_FLATFIELD_REF = 'load_flatfield_ref'\n        SET_FLATFIELD_GAIN = 'set_flatfield_gain'\n        GET_FLATFIELD_GAIN = 'get_flatfield_gain'\n\n    class _child_CamProc():\n        \"\"\"\n        Child process to acquire the camera images, correct them, and send them to the main process\n        \"\"\"\n        def __init__(self,pipe:mpc.Connection, cam_controller:CameraController):\n            \"\"\"\n            Initialise the child process.\n\n            Args:\n                pipe (mpc.Connection): Pipe for communication with the main process\n                cam_controller (CameraController): Camera controller\n\n            Usage:\n                Whenever a request is received (Any type), the child process will acquire the image, correct it, and send it back to the main process.\n                If an image of the same dimension is received, the child process will take it as a correction image.\n            \"\"\"\n            self._pipe = pipe\n            self._cam_controller = cam_controller\n\n            # &gt; Image processing parameters &lt;\n            self._ff_arr_correction:np.ndarray|None = None\n            self._ff_gain:float = 1.0  # Gain for flatfield correction\n\n            # &gt; Operation parameters &lt;\n            self._flg_selfrunning = threading.Event()\n\n            # &gt; Thread &lt;\n            self._thread:threading.Thread = threading.Thread()\n\n        def _calculate_reference_flatfield(self,reference:np.ndarray) -&gt; None:\n            \"\"\"\n            Calculates the reference normalisation array for flatfield correction\n\n            Args:\n                ref_img (np.ndarray): _description_\n            \"\"\"\n            num_channels = reference.shape[2]\n            reference_float = reference.astype(np.float32)\n\n            # Turn into a grayscale image\n            reference_float = np.mean(reference_float,axis=2)\n\n            # Normalize the reference image (important!)\n            self._ff_arr_correction = reference_float / np.mean(reference_float)  # Or another suitable normalization\n\n            assert self._ff_arr_correction is not None, \"Reference image has not been set.\"\n            # Normalize the reference image to (1,inf)\n            self._ff_arr_correction = self._ff_arr_correction / np.min(self._ff_arr_correction + 1e-7)  # Prevent division by zero\n\n            # Expand the image back to the original number of channels\n            self._ff_arr_correction = np.stack([self._ff_arr_correction]*num_channels,axis=2)\n\n        def _correct_arr_flatfield(self,img:np.ndarray) -&gt; np.ndarray:\n            \"\"\"\n            Corrects the image using the flatfield correction\n\n            Args:\n                img (np.ndarray): Image to be corrected\n\n            Returns:\n                np.ndarray: Corrected image\n            \"\"\"\n            try:\n                assert isinstance(self._ff_arr_correction,np.ndarray), \"Reference image has not been set.\"\n                assert img.shape == self._ff_arr_correction.shape, \"Image and reference image must have the same dimensions.\"\n            except AssertionError as e:\n                print(f'Error in _correct_image_flatfield: {e}')\n                return img\n\n            # Convert to float for division\n            img_float = img.astype(np.float32)\n\n            # Correct the image\n            corrected_img = img_float / (self._ff_arr_correction + 1e-7)  # Prevent division by zero\n\n            # Apply the gain\n            corrected_img = corrected_img * self._ff_gain\n\n            # Scale and convert back to uint8\n            corrected_img = np.clip(corrected_img, 0, 255).astype(np.uint8)\n\n            return corrected_img\n\n        def _correct_backgroundSubtraction_1channel(self, img:np.ndarray):  # Adjust kernel_size\n            \"\"\"Corrects uneven lighting using background subtraction.\"\"\"\n            kernel_size = IMAGECAL_KERNELSIZE\n\n            # 1. Estimate the background illumination:\n            #    - Gaussian blur is often used for this.  Adjust kernel_size as needed.\n            background = cv2.GaussianBlur(img, (kernel_size, kernel_size), 0)\n\n            # 2. Divide the original image by the background (normalization):\n            #    - Convert to float for division\n            img_float = img.astype(np.float32)\n            background_float = background.astype(np.float32)\n\n            # Normalize the background image to (1,inf)\n            background_float = background_float / np.min(background_float)\n\n            # Avoid division by zero: Add a small epsilon\n            epsilon = 1e-7  # Or a slightly larger value if needed\n            corrected_img = img_float / (background_float + epsilon)\n\n            # 3. Scale back to the original range (0-255) and convert to uint8\n            corrected_img = np.clip(corrected_img, 0, 255).astype(np.uint8)\n\n            return corrected_img\n\n        def _correct_backgroundSubtraction_3channel(self,img:np.ndarray) -&gt; np.ndarray:\n            \"\"\"Corrects uneven lighting in a color image using background subtraction.\"\"\"\n            # Split the image into color channels\n            b, g, r = cv2.split(img)\n\n            # Apply background subtraction to each channel\n            corrected_b = self._correct_backgroundSubtraction_1channel(b)\n            corrected_g = self._correct_backgroundSubtraction_1channel(g)\n            corrected_r = self._correct_backgroundSubtraction_1channel(r)\n\n            # Merge the corrected channels back into a color image\n            corrected_img = cv2.merge((corrected_b, corrected_g, corrected_r))\n\n            return corrected_img\n\n        def _convert_arr2img(self,arr:np.ndarray) -&gt; Image.Image:\n            \"\"\"\n            Convert the numpy array to an image\n\n            Args:\n                arr (np.ndarray): Numpy array\n\n            Returns:\n                Image.Image: Image\n            \"\"\"\n            img = Image.fromarray(arr)\n            return img\n\n        def run(self):\n            \"\"\"\n            Run the child process\n            \"\"\"\n            self._thread = threading.Thread(target=self._handle_image_requests,daemon=False)\n            self._thread.start()\n\n        def _handle_image_requests(self):\n            \"\"\"\n            Collect the image from the camera controller and puts it back into the pipe\n            based on the user request.\n            \"\"\"\n            self._flg_selfrunning.set()\n            while self._flg_selfrunning.is_set():\n                flg_data = self._pipe.poll(timeout=0.5)\n                if not flg_data: continue\n                try:\n                    return_pkg = None # Placeholder for the processed image\n                    request = self._pipe.recv()\n                    img = self._cam_controller.img_capture()\n                    arr_img = np.array(img)\n\n                    if request == DataStreamer_StageCam.Enum_CamCorrectionType.RAW:\n                        proc_img = arr_img\n                    elif request == DataStreamer_StageCam.Enum_CamCorrectionType.FLATFIELD:\n                        proc_img = self._correct_arr_flatfield(arr_img)\n                    elif request == DataStreamer_StageCam.Enum_CamCorrectionType.BACKGROUND_SUBTRACTION:\n                        proc_img = self._correct_backgroundSubtraction_3channel(arr_img)\n                    else:\n                        return_pkg = self._handle_other_requests(request)\n\n                    if request in DataStreamer_StageCam.Enum_CamCorrectionType.__members__.values():\n                        return_pkg = self._convert_arr2img(proc_img)\n\n                except Exception as e:\n                    print(f'Error in child process: {e}')\n                    print(f'Received data: {request}')\n                finally:\n                    self._pipe.send(return_pkg)\n            self._pipe.close()\n\n        def _handle_other_requests(self,request:tuple[Any]) -&gt; Any:\n            \"\"\"\n            Handle other commands from the main process\n\n            Args:\n                request (tuple): Request tuple\n\n            Returns:\n                Any: Return package depending on the request, otherwise None\n\n            Raises:\n                ValueError: If the request is invalid\n            \"\"\"\n            if not isinstance(request,tuple): raise ValueError('Invalid request type, not a tuple')\n            if len(request) != 2: raise ValueError('Invalid request type, not enough arguments')\n\n            return_pkg = None\n            if request[0] == DataStreamer_StageCam.Enum_CommandType.SET_FLATFIELD_GAIN:\n                if not isinstance(request[1],float): raise ValueError('Invalid request type, gain is not a float')\n                self._ff_gain = request[1]\n\n            elif request[0] == DataStreamer_StageCam.Enum_CommandType.GET_FLATFIELD_GAIN:\n                return_pkg = self._ff_gain\n\n            elif request[0] == DataStreamer_StageCam.Enum_CommandType.FLATFIELD_REF:\n                if not isinstance(request[1],np.ndarray): raise ValueError('Invalid request type, reference image is not a numpy array')\n                self._calculate_reference_flatfield(request[1])\n\n            elif request[0] == DataStreamer_StageCam.Enum_CommandType.SAVE_FLATFIELD_REF:\n                if not isinstance(request[1],str): raise ValueError('Invalid request type, reference image is not a string')\n                if self._ff_arr_correction is None: raise ValueError('Reference image has not been set.')\n\n                # Dump the reference image to a file\n                np.save(request[1],self._ff_arr_correction)\n\n            elif request[0] == DataStreamer_StageCam.Enum_CommandType.LOAD_FLATFIELD_REF:\n                if not isinstance(request[1],str): raise ValueError('Invalid request type, reference image is not a string')\n                if not os.path.exists(request[1]): raise ValueError('File does not exist')\n\n                # Load the reference image from a file\n                self._ff_arr_correction = np.load(request[1])\n\n            else:\n                raise ValueError('Invalid request type, not in Enum_CommandType')\n\n            return return_pkg\n\n\n        def join(self,timeout:float|None=None):\n            self._flg_selfrunning.clear()\n            self._thread.join(timeout)\n\n    def save_flatfield_reference(self,filename:str) -&gt; None:\n        \"\"\"\n        Save the reference image for flatfield correction\n\n        Args:\n            filename (str): Filename to save the reference image\n        \"\"\"\n        assert isinstance(filename,str), 'Filename is not a string'\n        with self._lock_pipe:\n            self._cam_pipe_main.send((self.Enum_CommandType.SAVE_FLATFIELD_REF,filename))\n            self._cam_pipe_main.recv()\n\n    def load_flatfield_reference(self,filename:str) -&gt; None:\n        \"\"\"\n        Load the reference image for flatfield correction\n\n        Args:\n            filename (str): Filename to load the reference image\n        \"\"\"\n        assert isinstance(filename,str), 'Filename is not a string'\n        with self._lock_pipe:\n            self._cam_pipe_main.send((self.Enum_CommandType.LOAD_FLATFIELD_REF,filename))\n            self._cam_pipe_main.recv()\n\n    def set_flatfield_reference(self,ref_img:np.ndarray) -&gt; None:\n        \"\"\"\n        Set the reference image for flatfield correction\n\n        Args:\n            ref_img (np.ndarray): Reference image\n        \"\"\"\n        assert isinstance(ref_img,np.ndarray), 'Reference image is not a numpy array'\n        with self._lock_pipe:\n            self._cam_pipe_main.send((self.Enum_CommandType.FLATFIELD_REF,ref_img))\n            self._cam_pipe_main.recv()\n\n    def get_flatfield_gain(self) -&gt; float:\n        \"\"\"\n        Get the flatfield gain\n\n        Returns:\n            float: Flatfield gain\n        \"\"\"\n        with self._lock_pipe:\n            self._cam_pipe_main.send((self.Enum_CommandType.GET_FLATFIELD_GAIN,0))\n            gain = self._cam_pipe_main.recv()\n        return gain\n\n    def set_flatfield_gain(self,gain:float) -&gt; None:\n        \"\"\"\n        Set the flatfield gain\n\n        Args:\n            gain (float): Flatfield gain\n        \"\"\"\n        assert isinstance(gain,float), 'Gain is not a float'\n        with self._lock_pipe:\n            self._cam_pipe_main.send((self.Enum_CommandType.SET_FLATFIELD_GAIN,gain))\n            self._cam_pipe_main.recv()\n\n    def get_image(self, request:Enum_CamCorrectionType) -&gt; Image.Image:\n        \"\"\"\n        Get the image from the camera controller\n\n        Args:\n            request (Enum_CamType): Request type\n\n        Returns:\n            np.ndarray: Image\n        \"\"\"\n        assert isinstance(request,self.Enum_CamCorrectionType), 'Invalid request type'\n        with self._lock_pipe:\n            self._cam_pipe_main.send(request)\n            img = self._cam_pipe_main.recv()\n        return img\n\n    def get_camera_controller(self) -&gt; CameraController:\n        \"\"\"\n        Return the camera controller\n        \"\"\"\n        return self.cam_controller\n\n    def get_measurement_offset_ms(self) -&gt; float:\n        \"\"\"\n        Return the measurement offset in ms\n        \"\"\"\n        return self._namespace.stage_offset_ms\n\n    def set_measurement_offset_ms(self,offset_ms:float) -&gt; None:\n        \"\"\"\n        Set the measurement offset in ms\n\n        Args:\n            offset_ms (float): Offset in ms\n        \"\"\"\n        self._namespace.stage_offset_ms = offset_ms\n\n    def run(self):\n        print('&gt;&gt;&gt;&gt;&gt;&gt; Stage hub is running &lt;&lt;&lt;&lt;&lt;&lt;')\n        self._collect_coordinateAndImage()\n\n\n    def _collect_coordinateAndImage(self):\n        self._flg_selfrunning.set()\n        child_proc_coor = self._child_CoorProc(self._coor_pipe_child)\n        child_proc_coor.run()\n        child_proc_cam = self._child_CamProc(self._cam_pipe_child,self.cam_controller)\n        child_proc_cam.run()\n        while self._flg_selfrunning.is_set():\n            try:\n                timestamp = int(get_timestamp_us_int() + self._namespace.stage_offset_ms * 1e3)\n                coorx, coory = self.xy_controller.get_coordinates()\n                coorz = self.z_controller.get_coordinates()\n                coor = (coorx, coory, coorz)\n\n                child_proc_coor.append_coordinate(timestamp,coor)\n\n                time.sleep(self._pause_interval_sec)\n            except Exception as e:\n                print('Error in stage hub:',e)\n                time.sleep(0.5)\n        child_proc_coor.join()\n        child_proc_cam.join()\n\n    def join(self, timeout: float | None = None) -&gt; None:\n        self._flg_selfrunning.clear()\n        super().join(timeout)\n\n    def get_coordinates_interpolate(self,timestamp:int) -&gt; tuple[float,float,float]|None:\n        \"\"\"\n        Get the coordinates by interpolating the coordinates between the timestamps (linear)\n\n        Args:\n            timestamp (int): Timestamp in us\n\n        Returns:\n            tuple|None: Coordinates in [x,y,z] or None if no coordinates are found\n        \"\"\"\n        with self._lock_pipe:\n            self._coor_pipe_main.send((self.Enum_CoorType.INTERPOLATE,timestamp))\n            coor = self._coor_pipe_main.recv()\n        return coor\n\n    def get_coordinates_closest(self,timestamp:int) -&gt; tuple[float,float,float]|None:\n        \"\"\"\n        Get the closest coordinates to the timestamp\n\n        Args:\n            timestamp (int): Timestamp in us\n\n        Returns:\n            tuple: Coordinates in [x,y,z] or None if no coordinates are found\n        \"\"\"\n        with self._lock_pipe:\n            self._coor_pipe_main.send((self.Enum_CoorType.CLOSEST,timestamp))\n            coor = self._coor_pipe_main.recv()\n        return coor\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.Enum_CamCorrectionType","title":"<code>Enum_CamCorrectionType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for the type of camera image request</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>class Enum_CamCorrectionType(Enum):\n    \"\"\"\n    Enumeration for the type of camera image request\n    \"\"\"\n    RAW = 'raw'\n    FLATFIELD = 'flatfield'\n    BACKGROUND_SUBTRACTION = 'background_subtraction'\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.Enum_CommandType","title":"<code>Enum_CommandType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for the type of command</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>class Enum_CommandType(Enum):\n    \"\"\"\n    Enumeration for the type of command\n    \"\"\"\n    FLATFIELD_REF = 'flatfield_ref'\n    SAVE_FLATFIELD_REF = 'save_flatfield_ref'\n    LOAD_FLATFIELD_REF = 'load_flatfield_ref'\n    SET_FLATFIELD_GAIN = 'set_flatfield_gain'\n    GET_FLATFIELD_GAIN = 'get_flatfield_gain'\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.Enum_CoorType","title":"<code>Enum_CoorType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration for the type of coordinate retrieval</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>class Enum_CoorType(Enum):\n    \"\"\"\n    An enumeration for the type of coordinate retrieval\n    \"\"\"\n    CLOSEST = 1\n    INTERPOLATE = 2\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.__init__","title":"<code>__init__(xy_controller, z_controller, cam_controller, namespace)</code>","text":"<p>A hub that manages the storage and retrieval of coordinates from the stage controllers.</p> <p>Parameters:</p> Name Type Description Default <code>xy_controller</code> <code>XYController</code> <p>XY stage controller</p> required <code>z_controller</code> <code>ZController</code> <p>Z stage controller</p> required <code>cam_controller</code> <code>CameraController</code> <p>Camera controller</p> required <code>namespace</code> <code>StageNamespace</code> <p>Namespace for the stage hub</p> required Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def __init__(self, xy_controller: Controller_XY, z_controller: Controller_Z,\n             cam_controller: CameraController, namespace:StageNamespace):\n    \"\"\"\n    A hub that manages the storage and retrieval of coordinates from the stage controllers.\n\n    Args:\n        xy_controller (XYController): XY stage controller\n        z_controller (ZController): Z stage controller\n        cam_controller (CameraController): Camera controller\n        namespace (StageNamespace): Namespace for the stage hub\n    \"\"\"\n    super().__init__()\n    self.xy_controller = xy_controller\n    self.z_controller = z_controller\n    self.cam_controller = cam_controller\n    self._namespace = namespace\n    self._coor_pipe_main, self._coor_pipe_child = mp.Pipe(duplex=True)\n    self._cam_pipe_main, self._cam_pipe_child = mp.Pipe(duplex=True)\n\n    # &gt; Operation parameters &lt;\n    self._flg_selfrunning = mp.Event()\n\n    # &gt; Constants &lt;\n    self._pause_interval_sec = MPMeaHubEnum.STAGEHUB_REQUEST_INTERVAL.value / 1000.0  # Convert to seconds\n    self._stage_offset_ms = MPMeaHubEnum.STAGEHUB_TIME_OFFSET_MS.value\n\n    # &gt; Locks &lt;\n    self._lock_pipe = mp.Lock()  # Lock for the pipe\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.get_camera_controller","title":"<code>get_camera_controller()</code>","text":"<p>Return the camera controller</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def get_camera_controller(self) -&gt; CameraController:\n    \"\"\"\n    Return the camera controller\n    \"\"\"\n    return self.cam_controller\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.get_coordinates_closest","title":"<code>get_coordinates_closest(timestamp)</code>","text":"<p>Get the closest coordinates to the timestamp</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[float, float, float] | None</code> <p>Coordinates in [x,y,z] or None if no coordinates are found</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def get_coordinates_closest(self,timestamp:int) -&gt; tuple[float,float,float]|None:\n    \"\"\"\n    Get the closest coordinates to the timestamp\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        tuple: Coordinates in [x,y,z] or None if no coordinates are found\n    \"\"\"\n    with self._lock_pipe:\n        self._coor_pipe_main.send((self.Enum_CoorType.CLOSEST,timestamp))\n        coor = self._coor_pipe_main.recv()\n    return coor\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.get_coordinates_interpolate","title":"<code>get_coordinates_interpolate(timestamp)</code>","text":"<p>Get the coordinates by interpolating the coordinates between the timestamps (linear)</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float] | None</code> <p>tuple|None: Coordinates in [x,y,z] or None if no coordinates are found</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def get_coordinates_interpolate(self,timestamp:int) -&gt; tuple[float,float,float]|None:\n    \"\"\"\n    Get the coordinates by interpolating the coordinates between the timestamps (linear)\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        tuple|None: Coordinates in [x,y,z] or None if no coordinates are found\n    \"\"\"\n    with self._lock_pipe:\n        self._coor_pipe_main.send((self.Enum_CoorType.INTERPOLATE,timestamp))\n        coor = self._coor_pipe_main.recv()\n    return coor\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.get_flatfield_gain","title":"<code>get_flatfield_gain()</code>","text":"<p>Get the flatfield gain</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Flatfield gain</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def get_flatfield_gain(self) -&gt; float:\n    \"\"\"\n    Get the flatfield gain\n\n    Returns:\n        float: Flatfield gain\n    \"\"\"\n    with self._lock_pipe:\n        self._cam_pipe_main.send((self.Enum_CommandType.GET_FLATFIELD_GAIN,0))\n        gain = self._cam_pipe_main.recv()\n    return gain\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.get_image","title":"<code>get_image(request)</code>","text":"<p>Get the image from the camera controller</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Enum_CamType</code> <p>Request type</p> required <p>Returns:</p> Type Description <code>Image</code> <p>np.ndarray: Image</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def get_image(self, request:Enum_CamCorrectionType) -&gt; Image.Image:\n    \"\"\"\n    Get the image from the camera controller\n\n    Args:\n        request (Enum_CamType): Request type\n\n    Returns:\n        np.ndarray: Image\n    \"\"\"\n    assert isinstance(request,self.Enum_CamCorrectionType), 'Invalid request type'\n    with self._lock_pipe:\n        self._cam_pipe_main.send(request)\n        img = self._cam_pipe_main.recv()\n    return img\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.get_measurement_offset_ms","title":"<code>get_measurement_offset_ms()</code>","text":"<p>Return the measurement offset in ms</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def get_measurement_offset_ms(self) -&gt; float:\n    \"\"\"\n    Return the measurement offset in ms\n    \"\"\"\n    return self._namespace.stage_offset_ms\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.load_flatfield_reference","title":"<code>load_flatfield_reference(filename)</code>","text":"<p>Load the reference image for flatfield correction</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filename to load the reference image</p> required Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def load_flatfield_reference(self,filename:str) -&gt; None:\n    \"\"\"\n    Load the reference image for flatfield correction\n\n    Args:\n        filename (str): Filename to load the reference image\n    \"\"\"\n    assert isinstance(filename,str), 'Filename is not a string'\n    with self._lock_pipe:\n        self._cam_pipe_main.send((self.Enum_CommandType.LOAD_FLATFIELD_REF,filename))\n        self._cam_pipe_main.recv()\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.save_flatfield_reference","title":"<code>save_flatfield_reference(filename)</code>","text":"<p>Save the reference image for flatfield correction</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filename to save the reference image</p> required Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def save_flatfield_reference(self,filename:str) -&gt; None:\n    \"\"\"\n    Save the reference image for flatfield correction\n\n    Args:\n        filename (str): Filename to save the reference image\n    \"\"\"\n    assert isinstance(filename,str), 'Filename is not a string'\n    with self._lock_pipe:\n        self._cam_pipe_main.send((self.Enum_CommandType.SAVE_FLATFIELD_REF,filename))\n        self._cam_pipe_main.recv()\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.set_flatfield_gain","title":"<code>set_flatfield_gain(gain)</code>","text":"<p>Set the flatfield gain</p> <p>Parameters:</p> Name Type Description Default <code>gain</code> <code>float</code> <p>Flatfield gain</p> required Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def set_flatfield_gain(self,gain:float) -&gt; None:\n    \"\"\"\n    Set the flatfield gain\n\n    Args:\n        gain (float): Flatfield gain\n    \"\"\"\n    assert isinstance(gain,float), 'Gain is not a float'\n    with self._lock_pipe:\n        self._cam_pipe_main.send((self.Enum_CommandType.SET_FLATFIELD_GAIN,gain))\n        self._cam_pipe_main.recv()\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.set_flatfield_reference","title":"<code>set_flatfield_reference(ref_img)</code>","text":"<p>Set the reference image for flatfield correction</p> <p>Parameters:</p> Name Type Description Default <code>ref_img</code> <code>ndarray</code> <p>Reference image</p> required Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def set_flatfield_reference(self,ref_img:np.ndarray) -&gt; None:\n    \"\"\"\n    Set the reference image for flatfield correction\n\n    Args:\n        ref_img (np.ndarray): Reference image\n    \"\"\"\n    assert isinstance(ref_img,np.ndarray), 'Reference image is not a numpy array'\n    with self._lock_pipe:\n        self._cam_pipe_main.send((self.Enum_CommandType.FLATFIELD_REF,ref_img))\n        self._cam_pipe_main.recv()\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.DataStreamer_StageCam.set_measurement_offset_ms","title":"<code>set_measurement_offset_ms(offset_ms)</code>","text":"<p>Set the measurement offset in ms</p> <p>Parameters:</p> Name Type Description Default <code>offset_ms</code> <code>float</code> <p>Offset in ms</p> required Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def set_measurement_offset_ms(self,offset_ms:float) -&gt; None:\n    \"\"\"\n    Set the measurement offset in ms\n\n    Args:\n        offset_ms (float): Offset in ms\n    \"\"\"\n    self._namespace.stage_offset_ms = offset_ms\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.generate_dummy_stageHub","title":"<code>generate_dummy_stageHub()</code>","text":"<p>Get a dummy stage hub for testing purposes.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[DataStreamer_StageCam, Controller_XY, Controller_Z, CameraController, StageNamespace]</code> <p>stage hub, xy controller, z controller, camera controller, namespace</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def generate_dummy_stageHub() -&gt; tuple[DataStreamer_StageCam,Controller_XY,Controller_Z,CameraController,StageNamespace]:\n    \"\"\"\n    Get a dummy stage hub for testing purposes.\n\n    Returns:\n        tuple: stage hub, xy controller, z controller, camera controller, namespace\n    \"\"\"\n    manager_base:mpm.SyncManager = get_my_manager()\n    initialise_manager_stage(manager_base)\n    manager_base.start()\n    xyproxy,zproxy,camproxy,stage_namespace = initialise_proxy_stage(manager_base)\n\n    stagehub = DataStreamer_StageCam(\n        xy_controller=xyproxy,\n        z_controller=zproxy,\n        cam_controller=camproxy,\n        namespace=stage_namespace\n    )\n\n    return stagehub, xyproxy, zproxy, camproxy, stage_namespace\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.initialise_manager_stage","title":"<code>initialise_manager_stage(manager)</code>","text":"<p>Register the classes and the dictionary with the manager</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>MyManager</code> <p>The central base manager</p> required Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def initialise_manager_stage(manager:mpm.SyncManager):\n    \"\"\"\n    Register the classes and the dictionary with the manager\n\n    Args:\n        manager (MyManager): The central base manager\n    \"\"\"\n    manager.register('xyctrl',callable=Controller_XY)\n    manager.register('zctrl',callable=Controller_Z)\n    manager.register('camctrl',callable=CameraController)\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.initialise_proxy_stage","title":"<code>initialise_proxy_stage(manager)</code>","text":"<p>Initialise the proxies for the stage controllers and the dictionary</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>MyManager</code> <p>Manager instance</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Controller_XY, Controller_Z, CameraController, StageNamespace]</code> <p>xyproxy, zproxy, camproxy, namespace</p> Source code in <code>iris/multiprocessing/dataStreamer_StageCam.py</code> <pre><code>def initialise_proxy_stage(manager:mpm.SyncManager) -&gt; tuple[Controller_XY,Controller_Z,CameraController,StageNamespace]:\n    \"\"\"\n    Initialise the proxies for the stage controllers and the dictionary\n\n    Args:\n        manager (MyManager): Manager instance\n\n    Returns:\n        tuple: xyproxy, zproxy, camproxy, namespace\n    \"\"\"\n    # Initialise all the controllers\n    zproxy:Controller_Z = manager.zctrl(sim=ControllerConfigEnum.SIMULATION_MODE.value)\n    xyproxy:Controller_XY = manager.xyctrl(sim=ControllerConfigEnum.SIMULATION_MODE.value)\n    camproxy:CameraController = manager.camctrl()\n\n    stg_namespace:StageNamespace = manager.Namespace()\n    stg_namespace.stage_offset_ms = MPMeaHubEnum.STAGEHUB_TIME_OFFSET_MS.value\n\n    return xyproxy,zproxy,camproxy,stg_namespace\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/multiprocessing/dataStreamer_StageCam/#iris.multiprocessing.dataStreamer_StageCam.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/resources/dataHubPlus_Raman_ui/","title":"dataHubPlus_Raman_ui","text":""},{"location":"reference/iris/resources/dataHub_Raman_ui/","title":"dataHub_Raman_ui","text":""},{"location":"reference/iris/resources/dataHub_coor_ui/","title":"dataHub_coor_ui","text":""},{"location":"reference/iris/resources/dataHub_image_ui/","title":"dataHub_image_ui","text":""},{"location":"reference/iris/resources/heatmap_plotter_overlay_ui/","title":"heatmap_plotter_overlay_ui","text":""},{"location":"reference/iris/resources/heatmap_plotter_ui/","title":"heatmap_plotter_ui","text":""},{"location":"reference/iris/resources/hilvl_Raman_ui/","title":"hilvl_Raman_ui","text":""},{"location":"reference/iris/resources/hilvl_brightfield_ui/","title":"hilvl_brightfield_ui","text":""},{"location":"reference/iris/resources/hilvl_coorGen_coorMod_ui/","title":"hilvl_coorGen_coorMod_ui","text":""},{"location":"reference/iris/resources/hilvl_coorGen_ui/","title":"hilvl_coorGen_ui","text":""},{"location":"reference/iris/resources/main_analyser_ui/","title":"main_analyser_ui","text":""},{"location":"reference/iris/resources/main_controller_ui/","title":"main_controller_ui","text":""},{"location":"reference/iris/resources/objective_calibration_controls_ui/","title":"objective_calibration_controls_ui","text":""},{"location":"reference/iris/resources/objective_calibration_main_ui/","title":"objective_calibration_main_ui","text":""},{"location":"reference/iris/resources/objectives_ui/","title":"objectives_ui","text":""},{"location":"reference/iris/resources/raman_ui/","title":"raman_ui","text":""},{"location":"reference/iris/resources/spectra_peak_finder_ui/","title":"spectra_peak_finder_ui","text":""},{"location":"reference/iris/resources/spectrometer_calibration_ui/","title":"spectrometer_calibration_ui","text":""},{"location":"reference/iris/resources/tiling_method_control_ui/","title":"tiling_method_control_ui","text":""},{"location":"reference/iris/resources/tiling_method_ui/","title":"tiling_method_ui","text":""},{"location":"reference/iris/resources/coordinate_generators/convert_2Dto3D_ui/","title":"convert_2Dto3D_ui","text":""},{"location":"reference/iris/resources/coordinate_generators/point_image_ui/","title":"point_image_ui","text":""},{"location":"reference/iris/resources/coordinate_generators/point_zScanLinear_ui/","title":"point_zScanLinear_ui","text":""},{"location":"reference/iris/resources/coordinate_generators/rect_aroundcentre_ui/","title":"rect_aroundcentre_ui","text":""},{"location":"reference/iris/resources/coordinate_generators/rect_image_ui/","title":"rect_image_ui","text":""},{"location":"reference/iris/resources/coordinate_generators/rect_startend_ui/","title":"rect_startend_ui","text":""},{"location":"reference/iris/resources/coordinate_generators/rect_video_ui/","title":"rect_video_ui","text":""},{"location":"reference/iris/resources/coordinate_modifiers/every_z_ui/","title":"every_z_ui","text":""},{"location":"reference/iris/resources/coordinate_modifiers/gridify_setup_finetuning_ui/","title":"gridify_setup_finetuning_ui","text":""},{"location":"reference/iris/resources/coordinate_modifiers/gridify_setup_naming_ui/","title":"gridify_setup_naming_ui","text":""},{"location":"reference/iris/resources/coordinate_modifiers/gridify_setup_ui/","title":"gridify_setup_ui","text":""},{"location":"reference/iris/resources/coordinate_modifiers/topology_visuliser_ui/","title":"topology_visuliser_ui","text":""},{"location":"reference/iris/resources/coordinate_modifiers/translator_xyz_ui/","title":"translator_xyz_ui","text":""},{"location":"reference/iris/resources/coordinate_modifiers/zInterpolate_ui/","title":"zInterpolate_ui","text":""},{"location":"reference/iris/resources/motion_video/brightfieldcontrol_ui/","title":"brightfieldcontrol_ui","text":""},{"location":"reference/iris/resources/motion_video/stagecontrol_ui/","title":"stagecontrol_ui","text":""},{"location":"reference/iris/utils/general/","title":"general","text":"<p>All the general functions used in most of the programs</p> <p>Made on: 14 March 2024 By: Kevin Uning For: The Thomas Group, Biochemical Engineering Dept., UCL</p>"},{"location":"reference/iris/utils/general/#iris.utils.general.check_and_create_config_file","title":"<code>check_and_create_config_file(config_file_path='config.ini')</code>","text":"<p>Generate a default config file if it does not exist</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'</p> required Source code in <code>iris/utils/general.py</code> <pre><code>def check_and_create_config_file(config_file_path:str='config.ini'):\n    \"\"\"\n    Generate a default config file if it does not exist\n\n    Args:\n        config_file (str): Path to the config file. Defaults to 'config.ini'\n    \"\"\"\n    # Generate a default config file if it does not exist\n    updater = ConfigUpdater(allow_no_value=True)\n    if not os.path.isfile(config_file_path):\n        with open(config_file_path, 'w') as configfile: updater.write(configfile)\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.convert_ramanshift_to_wavelength","title":"<code>convert_ramanshift_to_wavelength(raman_shift, excitation_wavelength)</code>","text":"<p>Converts Raman shift to wavelength</p> <p>Parameters:</p> Name Type Description Default <code>raman_shift</code> <code>float | ndarray</code> <p>Raman shift in cm^-1</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Wavelength in nm</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_ramanshift_to_wavelength(raman_shift:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts Raman shift to wavelength\n\n    Args:\n        raman_shift (float|np.ndarray): Raman shift in cm^-1\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Wavelength in nm\n    \"\"\"\n    wavelength = 1/(1/excitation_wavelength - raman_shift/1e7)\n    return wavelength\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.convert_timestamp_us_int_to_str","title":"<code>convert_timestamp_us_int_to_str(timestamp)</code>","text":"<p>Converts timestamp integer to string</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>Timestamp in us</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp as string in the format %y%m%d_%H%M%S_%f</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_int_to_str(timestamp:int) -&gt; str:\n    \"\"\"\n    Converts timestamp integer to string\n\n    Args:\n        timestamp (int): Timestamp in us\n\n    Returns:\n        str: Timestamp as string in the format %y%m%d_%H%M%S_%f\n    \"\"\"\n    timestamp_str = dt.datetime.fromtimestamp(timestamp*1e-6).strftime(\"%y%m%d_%H%M%S_%f\")\n    return timestamp_str\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.convert_timestamp_us_str_to_int","title":"<code>convert_timestamp_us_str_to_int(timestamp)</code>","text":"<p>Converts timestamp string to integer</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>str</code> <p>Timestamp, has to be in the format %y%m%d_%H%M%S_%f</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp as integer in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_timestamp_us_str_to_int(timestamp:str) -&gt; int:\n    \"\"\"\n    Converts timestamp string to integer\n\n    Args:\n        timestamp (str): Timestamp, has to be in the format %y%m%d_%H%M%S_%f\n\n    Returns:\n        int: Timestamp as integer in us\n    \"\"\"\n    timestamp_int = int(dt.datetime.strptime(timestamp, \"%y%m%d_%H%M%S_%f\").timestamp()*1e6)\n    return timestamp_int\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.convert_wavelength_to_ramanshift","title":"<code>convert_wavelength_to_ramanshift(wavelength, excitation_wavelength)</code>","text":"<p>Converts wavelength to Raman shift</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float | ndarray</code> <p>Wavelength in nm</p> required <code>excitation_wavelength</code> <code>float</code> <p>Excitation laser wavelength in nm</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>float|np.ndarray: Raman shift in cm^-1</p> Source code in <code>iris/utils/general.py</code> <pre><code>def convert_wavelength_to_ramanshift(wavelength:float|np.ndarray,excitation_wavelength:float) -&gt; float|np.ndarray:\n    \"\"\"\n    Converts wavelength to Raman shift\n\n    Args:\n        wavelength (float|np.ndarray): Wavelength in nm\n        excitation_wavelength (float): Excitation laser wavelength in nm\n\n    Returns:\n        float|np.ndarray: Raman shift in cm^-1\n    \"\"\"\n    if isinstance(wavelength, float) and wavelength == 0: wavelength = 0.0001\n    else: wavelength = np.where(wavelength == 0, 0.0001, wavelength)\n    raman_shift = 1e7*(1/excitation_wavelength - 1/wavelength)\n    return raman_shift\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.generate_test_app","title":"<code>generate_test_app(lyt)</code>","text":"<p>Generates a test QApplication and QVBoxLayout for testing purposes</p> <p>Returns:</p> Type Description <code>tuple[QApplication, QWidget]</code> <p>tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances</p> Source code in <code>iris/utils/general.py</code> <pre><code>def generate_test_app(lyt:qw.QVBoxLayout|qw.QHBoxLayout) -&gt; tuple[qw.QApplication,qw.QWidget]:\n    \"\"\"\n    Generates a test QApplication and QVBoxLayout for testing purposes\n\n    Returns:\n        tuple[qw.QApplication, qw.QWidget]: The QApplication and QWidget instances\n    \"\"\"\n    app = qw.QApplication([])\n    main_window = qw.QMainWindow()\n    main_window.show()\n    wdg = qw.QWidget()\n    main_window.setCentralWidget(wdg)\n    wdg.setLayout(lyt)\n    return app, wdg\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.get_all_widgets","title":"<code>get_all_widgets(parent_widget, get_all=True)</code>","text":"<p>A function that returns all widgets in a frame and optionally, its subframes (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Widget which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-widgets as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the widget</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets(parent_widget:qw.QWidget,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a frame and optionally, its subframes (all levels)\n\n    Args:\n        parent_widget (qw.QWidget): Widget which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-widgets as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the widget\n    \"\"\"\n    if get_all:\n        return parent_widget.findChildren(qw.QWidget)   # The default findChildren() is already recursive\n    else:\n        # findChildren() with a search option that limits depth\n        # For a single level, findChildren(type, options) is useful\n        # We find widgets that are immediate children of the parent.\n        return parent_widget.findChildren(qw.QWidget, qc.Qt.FindChildOption.FindDirectChildrenOnly) # type: ignore\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.get_all_widgets_from_layout","title":"<code>get_all_widgets_from_layout(parent_layout, get_all=True)</code>","text":"<p>A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)</p> <p>Parameters:</p> Name Type Description Default <code>parent_layout</code> <code>QLayout</code> <p>Layout which children need to be listed</p> required <code>get_all</code> <code>bool</code> <p>If True it will get the widgets in the sub-layouts as well</p> <code>True</code> <p>Returns:</p> Type Description <code>list[QWidget]</code> <p>list[qw.QWidget]: List of all widgets in the layout</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_all_widgets_from_layout(parent_layout:qw.QLayout,get_all=True) -&gt; list[qw.QWidget]:\n    \"\"\"\n    A function that returns all widgets in a layout and optionally, its sub-layouts (all levels)\n\n    Args:\n        parent_layout (qw.QLayout): Layout which children need to be listed\n        get_all (bool, optional): If True it will get the widgets in the sub-layouts as well\n\n    Returns:\n        list[qw.QWidget]: List of all widgets in the layout\n    \"\"\"\n    list_widget = []\n    for i in range(parent_layout.count()):\n        item = parent_layout.itemAt(i)\n        if item.widget():\n            list_widget.append(item.widget())\n            if get_all and isinstance(item.widget(), qw.QWidget):\n                child_widgets = get_all_widgets(item.widget(), get_all=True)\n                list_widget.extend(child_widgets)\n        elif item.layout() and get_all:\n            child_widgets = get_all_widgets_from_layout(item.layout(), get_all=True)\n            list_widget.extend(child_widgets)\n    return list_widget\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.get_timestamp_day","title":"<code>get_timestamp_day()</code>","text":"<p>Gets the current timestamp in days</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp without time: yymmdd</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_day() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in days\n\n    Returns:\n        str: Timestamp without time: yymmdd\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d\")\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.get_timestamp_sec","title":"<code>get_timestamp_sec()</code>","text":"<p>Gets the current timestamp in seconds</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time: yymmdd_hhmmss</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_sec() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in seconds\n\n    Returns:\n        str: Timestamp with time: yymmdd_hhmmss\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S\")\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.get_timestamp_us_int","title":"<code>get_timestamp_us_int()</code>","text":"<p>Gets the current timestamp in us as integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Timestamp in us</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_int() -&gt; int:\n    \"\"\"\n    Gets the current timestamp in us as integer\n\n    Returns:\n        int: Timestamp in us\n    \"\"\"\n    return int(dt.datetime.now().timestamp()*1e6)\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.get_timestamp_us_str","title":"<code>get_timestamp_us_str()</code>","text":"<p>Gets the current timestamp in us as string</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)</p> Source code in <code>iris/utils/general.py</code> <pre><code>def get_timestamp_us_str() -&gt; str:\n    \"\"\"\n    Gets the current timestamp in us as string\n\n    Returns:\n        str: Timestamp with time and milliseconds: yymmdd_hhmmss_us(6 digits)\n    \"\"\"\n    return dt.datetime.now().strftime(\"%y%m%d_%H%M%S_%f\")\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.messagebox_request_input","title":"<code>messagebox_request_input(parent, title, message, default='', validator=None, invalid_msg='The entered value is invalid. Please try again.', loop_until_valid=False)</code>","text":"<p>A function that creates a QInputDialog to request input with optional validation.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the dialog (recommended).</p> required <code>title</code> <code>str</code> <p>Title of the dialog box.</p> required <code>message</code> <code>str</code> <p>Message/label to be displayed for the input field.</p> required <code>default</code> <code>str</code> <p>Default value of the input.</p> <code>''</code> <code>validator</code> <code>Callable[[str], bool] | None</code> <p>A function that takes the  input string and returns True if valid, False otherwise.</p> <code>None</code> <code>invalid_msg</code> <code>str</code> <p>Message to show if validation fails.</p> <code>'The entered value is invalid. Please try again.'</code> <code>loop_until_valid</code> <code>bool</code> <p>If True, keeps asking until the input is valid  or the user presses Cancel.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: User input string if OK was pressed and validation passed,          otherwise None (if Cancel was pressed).</p> Source code in <code>iris/utils/general.py</code> <pre><code>def messagebox_request_input(\n        parent: qw.QWidget, \n        title: str, \n        message: str, \n        default: str = '',\n        validator: Callable[[str], bool]|None = None,\n        invalid_msg: str = \"The entered value is invalid. Please try again.\",\n        loop_until_valid: bool = False\n    ) -&gt; str | None:\n    \"\"\"\n    A function that creates a QInputDialog to request input with optional validation.\n\n    Args:\n        parent (qw.QWidget): The parent widget for the dialog (recommended).\n        title (str): Title of the dialog box.\n        message (str): Message/label to be displayed for the input field.\n        default (str, optional): Default value of the input.\n        validator (Callable[[str], bool]|None, optional): A function that takes the \n            input string and returns True if valid, False otherwise.\n        invalid_msg (str): Message to show if validation fails.\n        loop_until_valid (bool): If True, keeps asking until the input is valid \n            or the user presses Cancel.\n\n    Returns:\n        str | None: User input string if OK was pressed and validation passed, \n                    otherwise None (if Cancel was pressed).\n    \"\"\"\n    current_default = default\n\n    while True:\n        # 1. Show the input dialog\n        user_input, ok = qw.QInputDialog.getText(\n            parent,\n            title,\n            message,\n            qw.QLineEdit.Normal, # pyright: ignore[reportAttributeAccessIssue]\n            current_default\n        )\n\n        if not ok: return None  # User pressed Cancel\n\n        is_valid = True\n        if validator is not None: is_valid = validator(user_input)\n        if is_valid: return user_input\n\n        if not loop_until_valid: return None\n        else:\n            qw.QMessageBox.warning(parent, \"Invalid Input\", invalid_msg)\n            current_default = user_input\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.read_update_config_file_section","title":"<code>read_update_config_file_section(dict_controllers_default, dict_controllers_comments, section, config_file='config.ini')</code>","text":"<p>Read the config file and automatically add an entry if it does not exist based on the given default values (dict form) and returns the read values after the update. Additionally, it will also automatically append comments given by the comments dictionary at the end of each respective key's value in the config file. If the values are already present, it will just read the values. If the config file is not present, it will automatically try to create one.</p> <p>Parameters:</p> Name Type Description Default <code>dict_controllers_default</code> <code>dict</code> <p>Dictionary of the default values</p> required <code>dict_controllers_comments</code> <code>dict</code> <p>Dictionary of the comments for each key in the default values</p> required <code>section</code> <code>str</code> <p>Section name in the config file</p> required <code>config_file</code> <code>str</code> <p>Path to the config file. Defaults to 'config.ini'.</p> <code>'config.ini'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion of the default value type is not implemented</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the read values (after the update) in the correct format given by the default values dictionary</p> Source code in <code>iris/utils/general.py</code> <pre><code>def read_update_config_file_section(dict_controllers_default:dict, dict_controllers_comments:dict,\n    section:str, config_file:str='config.ini') -&gt; dict:\n    \"\"\"\n    Read the config file and automatically add an entry if it does not exist\n    based on the given default values (dict form) and returns the read values\n    after the update. Additionally, it will also automatically append comments\n    given by the comments dictionary at the end of each respective key's value\n    in the config file. If the values are already present, it will just read the values.\n    If the config file is not present, it will automatically try to create one.\n\n    Args:\n        dict_controllers_default (dict): Dictionary of the default values\n        dict_controllers_comments (dict): Dictionary of the comments for each key in the default values\n        section (str): Section name in the config file\n        config_file (str, optional): Path to the config file. Defaults to 'config.ini'.\n\n    Raises:\n        NotImplementedError: If the conversion of the default value type is not implemented\n\n    Returns:\n        dict: Dictionary of the read values (after the update) in the correct format\n            given by the default values dictionary\n    \"\"\"\n    check_and_create_config_file(config_file)\n\n    # Read the config file and automatically add an entry if it does not exist \n    # (along with its comments)\n    updater = ConfigUpdater(allow_no_value=True)\n    updater.read(config_file)\n\n    splitter = '\\t'\n    commenter = '; '\n    list_splitters = [splitter, commenter]\n\n    if not updater.has_section(section):\n        updater.add_section(section)\n        with open(config_file, 'w') as f:\n            updater.write(f)\n\n    for key in dict_controllers_default.keys():\n        if not updater.has_option(section, key):\n            if type(dict_controllers_default[key]) != str:\n                updater.set(\n                    section=section,\n                    option=key,\n                    value=str(dict_controllers_default[key]) + splitter + commenter + dict_controllers_comments[key],\n                )\n            else:   # Add quotes to the string values\n                updater.set(\n                    section=section,\n                    option=key,\n                    value='\"' + str(dict_controllers_default[key]) + '\"' + splitter + commenter + dict_controllers_comments[key],\n                )\n            with open(config_file, 'w') as f: updater.write(f)\n\n    dict_controllers_read = {}\n    updater.read(config_file)\n    for key,value in updater.items(section):\n        if key not in dict_controllers_default.keys(): continue\n        def_val_type = type(dict_controllers_default[key])\n\n        # Process different types of values separately\n        # note that the splits are to remove the comments\n        if def_val_type == bool:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            val = read_line.lower()\n            if val != 'true' and val != 'false':\n                raise ValueError(f\"Error: {val} is not a boolean value.\")\n            dict_controllers_read[key] = read_line.lower() == 'true'\n        elif def_val_type in [int, float]:\n            read_line:str = value.value\n            for splitter in list_splitters:\n                read_line = read_line.split(splitter)[0]\n            conv_val = type(dict_controllers_default[key])(read_line)\n            dict_controllers_read[key] = conv_val\n        elif def_val_type == str:\n            if '\"' in value.value:\n                conv_val = value.value.split('\"')[1]\n            else:\n                conv_val:str = value.value\n                for splitter in list_splitters:\n                    conv_val = conv_val.split(splitter)[0]\n            dict_controllers_read[key] = conv_val\n        else: raise NotImplementedError(f\"Error: {def_val_type} conversion is not implemented.\")\n\n    return dict_controllers_read\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.run_with_timeout","title":"<code>run_with_timeout(func, args=(), kwargs={}, timeout=5)</code>","text":"<p>Runs a function with a timeout.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to execute.</p> required <code>args</code> <p>Tuple of positional arguments for the function.</p> <code>()</code> <code>kwargs</code> <p>Dictionary of keyword arguments for the function.</p> <code>{}</code> <code>timeout</code> <p>The timeout in seconds.</p> <code>5</code> <p>Returns:</p> Type Description <p>The result of the function if it completes within the timeout.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the function does not complete within the timeout.</p> Source code in <code>iris/utils/general.py</code> <pre><code>def run_with_timeout(func, args=(), kwargs={}, timeout=5):\n    \"\"\"\n    Runs a function with a timeout.\n\n    Args:\n        func: The function to execute.\n        args: Tuple of positional arguments for the function.\n        kwargs: Dictionary of keyword arguments for the function.\n        timeout: The timeout in seconds.\n\n    Returns:\n        The result of the function if it completes within the timeout.\n\n    Raises:\n        TimeoutError: If the function does not complete within the timeout.\n    \"\"\"\n    result = None\n    exception = None\n    finished = threading.Event()\n\n    def target():\n        nonlocal result, exception\n        try: result = func(*args, **kwargs)\n        except Exception as e: exception = e\n        finally: finished.set()\n\n    timer = threading.Timer(timeout, lambda: finished.set())\n    thread = threading.Thread(target=target)\n\n    timer.start()\n    thread.start()\n\n    finished.wait()\n    timer.cancel()\n\n    if thread.is_alive():\n        raise TimeoutError(\"Function execution timed out\")\n\n    if exception:\n        raise exception\n\n    return result\n</code></pre>"},{"location":"reference/iris/utils/general/#iris.utils.general.validator_float_greaterThanZero","title":"<code>validator_float_greaterThanZero(input_str)</code>","text":"<p>A validator function that checks if the input string can be converted to a non-negative float</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>iris/utils/general.py</code> <pre><code>def validator_float_greaterThanZero(input_str: str) -&gt; bool:\n    \"\"\"\n    A validator function that checks if the input string can be converted to a non-negative float\n\n    Args:\n        input_str (str): Input string to validate\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    try:\n        val = float(input_str)\n        return val &gt;= 0.0\n    except:\n        return False\n</code></pre>"},{"location":"reference/iris/utils/gridify/","title":"gridify","text":""},{"location":"reference/iris/utils/gridify/#iris.utils.gridify.generate_warped_grid","title":"<code>generate_warped_grid(p00, p10, p01, p11, num_u_lines, num_v_lines)</code>","text":"<p>Generates a 2D grid within a 3D plane defined by four corner points using bilinear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>p00</code> <code>array</code> <p>XYZ coordinates of the corner corresponding to (u=0, v=0).</p> required <code>p10</code> <code>array</code> <p>XYZ coordinates of the corner corresponding to (u=1, v=0).</p> required <code>p01</code> <code>array</code> <p>XYZ coordinates of the corner corresponding to (u=0, v=1).</p> required <code>p11</code> <code>array</code> <p>XYZ coordinates of the corner corresponding to (u=1, v=1).</p> required <code>num_u_lines</code> <code>int</code> <p>Number of grid lines along the 'u' direction (columns).</p> required <code>num_v_lines</code> <code>int</code> <p>Number of grid lines along the 'v' direction (rows).</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(grid_points_x, grid_points_y, grid_points_z, u_lines_3d, v_lines_3d)    - grid_points_x/y/z: 2D arrays (num_u_lines, num_v_lines) of XYZ points      forming the full mesh.    - u_lines_3d: List of arrays, each representing a 'column' line in 3D.    - v_lines_3d: List of arrays, each representing a 'row' line in 3D.</p> Source code in <code>iris/utils/gridify.py</code> <pre><code>def generate_warped_grid(p00, p10, p01, p11, num_u_lines, num_v_lines):\n    \"\"\"\n    Generates a 2D grid within a 3D plane defined by four corner points\n    using bilinear interpolation.\n\n    Args:\n        p00 (np.array): XYZ coordinates of the corner corresponding to (u=0, v=0).\n        p10 (np.array): XYZ coordinates of the corner corresponding to (u=1, v=0).\n        p01 (np.array): XYZ coordinates of the corner corresponding to (u=0, v=1).\n        p11 (np.array): XYZ coordinates of the corner corresponding to (u=1, v=1).\n        num_u_lines (int): Number of grid lines along the 'u' direction (columns).\n        num_v_lines (int): Number of grid lines along the 'v' direction (rows).\n\n    Returns:\n        tuple: (grid_points_x, grid_points_y, grid_points_z, u_lines_3d, v_lines_3d)\n               - grid_points_x/y/z: 2D arrays (num_u_lines, num_v_lines) of XYZ points\n                 forming the full mesh.\n               - u_lines_3d: List of arrays, each representing a 'column' line in 3D.\n               - v_lines_3d: List of arrays, each representing a 'row' line in 3D.\n    \"\"\"\n    # Convert input points to numpy arrays if they aren't already\n    p00 = np.array(p00)\n    p10 = np.array(p10)\n    p01 = np.array(p01)\n    p11 = np.array(p11)\n\n    # Generate parametric coordinates (u, v)\n    u_coords = np.linspace(0, 1, num_u_lines)\n    v_coords = np.linspace(0, 1, num_v_lines)\n\n    # Use meshgrid to create a grid of (u,v) pairs\n    U, V = np.meshgrid(u_coords, v_coords)\n\n    # Apply bilinear interpolation to get the 3D coordinates for each (u,v) point\n    grid_points_x = (1 - U) * (1 - V) * p00[0] + U * (1 - V) * p10[0] + (1 - U) * V * p01[0] + U * V * p11[0]\n    grid_points_y = (1 - U) * (1 - V) * p00[1] + U * (1 - V) * p10[1] + (1 - U) * V * p01[1] + U * V * p11[1]\n    grid_points_z = (1 - U) * (1 - V) * p00[2] + U * (1 - V) * p10[2] + (1 - U) * V * p01[2] + U * V * p11[2]\n\n    # --- Extract grid lines for plotting ---\n    # The shape of grid_points_x is (len(v_coords), len(u_coords)) or (num_v_lines, num_u_lines)\n    # So, the first dimension is associated with V (rows), and the second with U (columns)\n\n    u_lines_3d = [] # These are lines where 'u' is constant (vertical lines in the image)\n    # Iterate over the number of 'columns' (num_u_lines)\n    for i in range(num_u_lines):\n        # A 'column' line is where u is constant, and v varies (across rows of the array)\n        # We need to extract the i-th column from grid_points_x,y,z\n        line = np.array([grid_points_x[:, i], grid_points_y[:, i], grid_points_z[:, i]]).T\n        u_lines_3d.append(line)\n\n    v_lines_3d = [] # These are lines where 'v' is constant (horizontal lines in the image)\n    # Iterate over the number of 'rows' (num_v_lines)\n    for j in range(num_v_lines):\n        # A 'row' line is where v is constant, and u varies (across columns of the array)\n        # We need to extract the j-th row from grid_points_x,y,z\n        line = np.array([grid_points_x[j, :], grid_points_y[j, :], grid_points_z[j, :]]).T\n        v_lines_3d.append(line)\n\n    return grid_points_x, grid_points_y, grid_points_z, u_lines_3d, v_lines_3d\n</code></pre>"}]}